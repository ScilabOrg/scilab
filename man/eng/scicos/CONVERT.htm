<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<!--Converted with LaTeX2HTML 2002-2-1 (1.71)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>CONVERT</TITLE>
<META NAME="description" CONTENT="CONVERT">
<META NAME="keywords" CONTENT="CONVERT">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META NAME="Generator" CONTENT="LaTeX2HTML v2002-2-1">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="CONVERT.css">

</HEAD>

<BODY bgcolor="#FFFFFF">

<P>
<DIV ALIGN="CENTER">
Scicos Block
<BR><A NAME="tex2html1"
  HREF="../../fr/scicos/CONVERT.htm">fr</A> - <A NAME="tex2html2"
  HREF="./CONVERT.htm">eng</A>

</DIV>
<H2><A NAME="SECTION00010000000000000000"></A><A NAME="CONVERT"></A><BR>
CONVERT Data Type Conversion
</H2>
<DIV ALIGN="CENTER">
<!-- MATH
 $\epsfig{file=CONVERT.eps,width=90.00pt}$
 -->
<IMG
 WIDTH="143" HEIGHT="101" ALIGN="BOTTOM" BORDER="0"
 SRC="../../images/scicos/CONVERT_blk.gif"
 ALT="\epsfig{file=CONVERT.eps,width=90.00pt}">

</DIV>
<BR>

<H3><font color="blue"><A NAME="SECTION00020000000000000000">
Contents</A>
</font></H3>
<!--Table of Contents-->

<UL CLASS="TofC">
<LI><A NAME="tex2html5"
  HREF="CONVERT.htm#SECTION00010000000000000000">CONVERT Data Type Conversion</A>
<UL>
<LI><A NAME="tex2html6"
  HREF="CONVERT.htm#SECTION00021000000000000000">Palette</A>
<LI><A NAME="tex2html7"
  HREF="CONVERT.htm#SECTION00022000000000000000">Description</A>
<LI><A NAME="tex2html8"
  HREF="CONVERT.htm#SECTION00023000000000000000">Dialog box</A>
<LI><A NAME="tex2html9"
  HREF="CONVERT.htm#SECTION00024000000000000000">Default properties</A>
<LI><A NAME="tex2html10"
  HREF="CONVERT.htm#SECTION00025000000000000000">Interfacing function</A>
<LI><A NAME="tex2html11"
  HREF="CONVERT.htm#SECTION00026000000000000000">Computational function (type 4)</A>
<LI><A NAME="tex2html12"
  HREF="CONVERT.htm#SECTION00027000000000000000">Used functions</A>
<LI><A NAME="tex2html13"
  HREF="CONVERT.htm#SECTION00028000000000000000">See also</A>
<LI><A NAME="tex2html14"
  HREF="CONVERT.htm#SECTION00029000000000000000">Authors</A>
<LI><A NAME="tex2html15"
  HREF="CONVERT.htm#SECTION00030000000000000000">Bibliography</A>
</UL>
</UL><BR>
<!--End of Table of Contents-->
<H3><font color="blue"><A NAME="SECTION00021000000000000000">
Palette</A>
</font></H3>

<UL>
<LI><A NAME="tex2html3"
  HREF="Integer_pal.htm">Integer - Integer palette</A>
</LI>
</UL>
<H3><font color="blue"><A NAME="SECTION00022000000000000000">
Description</A>
</font></H3>

<P>
  This block converts an input signal of any data type to a specified data type. The input can be real, complex or integer. When the output is an integer and when overflow occurs the block three different forms of results: 
<BR>1- A normal non saturated result. 
<BR>2- A saturated result. 
<BR>3- An error message warning the user about the overflow.. 
<BR>The user can select one of these three forms by setting the "DO ON OVERFLOW" field to 0,1 or 2. 
<BR>
<H3><font color="blue"><A NAME="SECTION00023000000000000000">
Dialog box</A>
</font></H3>

<DIV ALIGN="CENTER">
<IMG
 WIDTH="477" HEIGHT="116" BORDER="0"
 SRC="../../images/scicos/CONVERT_gui.gif"
 ALT="\begin{figure}\begin{center}
\epsfig{file=CONVERT_gui.eps,width=300pt}
\end{center}\end{figure}">
</DIV>

<P>

<UL>
<LI><b>input type (1= double 3=int32  4=int16 5=int8 ...)</b>
<BR>   : Type 'vec' of size 1. It indicates the input data type, it can be a double or an integer.
</LI>
<LI><b>output type (1= double 3=int32  4=int16 5=int8 ...)</b>
<BR>   : Type 'vec' of size 1. It indicates the output data type, it can be a double or an integer.
</LI>
<LI><b>Do on Overflow(0=Nothing 1=Saturate 2=Error)</b>
<BR>   : Type 'vec' of size 1. When this parameter is set to zero the result is similar to a normal multiplication of two integer matrix. When it is set to 1, on overflow the block saturate the result. When it is set to 2, on overflow an error message box appears.
</LI>
</UL>

<H3><font color="blue"><A NAME="SECTION00024000000000000000">
Default properties</A>
</font></H3>

<UL>
<LI><b>always active:</b> no
</LI>
<LI><b>direct-feedthrough:</b> yes
</LI>
<LI><b>zero-crossing:</b> no
</LI>
<LI><b>mode:</b> no
</LI>
<LI><b>number/sizes of inputs:</b> 1 / -1
</LI>
<LI><b>number/sizes of outputs:</b> 1 / -1
</LI>
<LI><b>number/sizes of activation inputs:</b> 0 / 
</LI>
<LI><b>number/sizes of activation outputs:</b> 0 / 
</LI>
<LI><b>continuous-time state:</b> no
</LI>
<LI><b>discrete-time state:</b> no
</LI>
<LI><b>name of computational function:</b> <EM>convert</EM>
</LI>
</UL>

<H3><font color="blue"><A NAME="SECTION00025000000000000000">
Interfacing function</A>
</font></H3>
<TT>CONVERT.sci</TT>

<H3><font color="blue"><A NAME="SECTION00026000000000000000">
Computational function (type 4)</A>
</font></H3>
 <SMALL CLASS="TINY">  </SMALL><BR>
<PRE  CLASS="verbatim"># include "scicos_block4.h"
# include "../machine.h"
# include &lt;math.h&gt;
# include &lt;memory.h&gt;

void convert(scicos_block *block,int flag)
{
 int m,n,i;
 int *ipar;
 double v,w,k;
 
 m=GetInPortRows(block,1);
 n=GetInPortCols(block,1);
 ipar=GetIparPtrs(block);
 
 if ((flag==1)|(flag==6))
    {
     switch (*ipar){
	    case 1:{ 
		   void *u,*y;
		   int so;
		   so=GetSizeOfOut(block,1);
     	  	   u=GetInPortPtrs(block,1);
     	  	   y=GetOutPortPtrs(block,1);
     	  	   memcpy(y,u,m*n*so);
     	  	   break;}
	    case 2:{
		   double *u;
		   long *y;
	  	   u=GetRealInPortPtrs(block,1);
	           y=Getint32OutPortPtrs(block,1);
		   k=pow(2,32);
		   for (i=0;i&lt;m*n;i++) 
		        {v=(double)u[i];
		         w=v-(int)(v/k)*k;
		         if (abs(w)&gt;k/2-1)
			     {if (w&gt;=0) w=(-k/2+abs(w-((int)(w/(k/2)))*(k/2)));
			     else w=-(-(k/2)+abs(w-((int)(w/(k/2)))*(k/2)));
			     }
		         y[i]=(long)w;}
		   break;}
	    case 3:{
		   double *u;
		   short *y;
	  	   u=GetRealInPortPtrs(block,1);
	           y=Getint16OutPortPtrs(block,1);
		   k=pow(2,16);
		   for (i=0;i&lt;m*n;i++) 
		        {v=(double)u[i];
		         w=v-(int)(v/k)*k;
		         if (abs(w)&gt;k/2-1)
			     {if (w&gt;=0) w=(-k/2+abs(w-((int)(w/(k/2)))*(k/2)));
			     else w=-(-(k/2)+abs(w-((int)(w/(k/2)))*(k/2)));
			     }
		         y[i]=(short)w;}
		   break;}
	    case 4:{
		   double *u;
		   char *y;
	  	   u=GetRealInPortPtrs(block,1);
	           y=Getint8OutPortPtrs(block,1);
		   k=pow(2,8);
		   for (i=0;i&lt;m*n;i++) 
		        {v=(double)u[i];
		         w=v-(int)(v/k)*k;
		         if (abs(w)&gt;k/2-1)
			     {if (w&gt;=0) w=(-k/2+abs(w-((int)(w/(k/2)))*(k/2)));
			     else w=-(-(k/2)+abs(w-((int)(w/(k/2)))*(k/2)));
			     }
		         y[i]=(char)w;}
		   break;}
	    case 5:{
		   double *u;
		   unsigned long *y;
	  	   u=GetRealInPortPtrs(block,1);
	           y=Getuint32OutPortPtrs(block,1);
		   k=pow(2,32);
		   for (i=0;i&lt;m*n;i++) 
		        {v=(double)u[i];
		         w=v-(int)(v/k)*k;
		         y[i]=(unsigned long)w;}
		   break;}
	    case 6:{
		   double *u;
		   unsigned short *y;
	  	   u=GetRealInPortPtrs(block,1);
	           y=Getuint16OutPortPtrs(block,1);
		   k=pow(2,16);
		   for (i=0;i&lt;m*n;i++) 
		        {v=(double)u[i];
		         w=v-(int)(v/k)*k;
		         y[i]=(unsigned short)w;}
		   break;}
	    case 7:{
		   double *u;
		   unsigned char *y;
	  	   u=GetRealInPortPtrs(block,1);
	           y=Getuint8OutPortPtrs(block,1);
		   k=pow(2,8);
		   for (i=0;i&lt;m*n;i++) 
		        {v=(double)u[i];
		         w=v-(int)(v/k)*k;
		         y[i]=(unsigned char)w;}
		   break;}
	    case 8:{
		   long *u;
		   double *y;
		   u=Getint32InPortPtrs(block,1);
		   y=GetRealOutPortPtrs(block,1);
		   for (i=0;i&lt;m*n;i++) y[i]=(double) u[i];
		   break;}
	    case 9:{
		   long *u;
		   short *y;
	  	   u=Getint32InPortPtrs(block,1);
	           y=Getint16OutPortPtrs(block,1);
		   k=pow(2,16);
		   for (i=0;i&lt;m*n;i++) 
		        {v=(double)u[i];
		         w=v-(int)(v/k)*k;
		         if (abs(w)&gt;k/2-1)
			     {if (w&gt;=0) w=(-k/2+abs(w-((int)(w/(k/2)))*(k/2)));
			     else w=-(-(k/2)+abs(w-((int)(w/(k/2)))*(k/2)));
			     }
		         y[i]=(short)w;}
		   break;}
	    case 10:{
		   long *u;
		   char *y;
	  	   u=Getint32InPortPtrs(block,1);
	           y=Getint8OutPortPtrs(block,1);
		   k=pow(2,8);
		   for (i=0;i&lt;m*n;i++) 
		        {v=(double)u[i];
		         w=v-(int)(v/k)*k;
		         if (abs(w)&gt;k/2-1)
			     {if (w&gt;=0) w=(-k/2+abs(w-((int)(w/(k/2)))*(k/2)));
			     else w=-(-(k/2)+abs(w-((int)(w/(k/2)))*(k/2)));
			     }
		         y[i]=(char)w;}
		   break;}
	    case 11:{
		   long *u;
		   unsigned short *y;
	  	   u=Getint32InPortPtrs(block,1);
	           y=Getuint16OutPortPtrs(block,1);
		   k=pow(2,16);
		   for (i=0;i&lt;m*n;i++) 
		        {v=(double)u[i];
		         w=v-(int)(v/k)*k;
		         y[i]=(unsigned short)w;}
		   break;}
	    case 12:{
		   long *u;
		   unsigned char *y;
	  	   u=Getint32InPortPtrs(block,1);
	           y=Getuint8OutPortPtrs(block,1);
		   k=pow(2,8);
		   for (i=0;i&lt;m*n;i++) 
		        {v=(double)u[i];
		         w=v-(int)(v/k)*k;
		         y[i]=(unsigned char)w;}
		   break;}
	    case 13:{
		   short *u;
		   double *y;
		   u=Getint16InPortPtrs(block,1);
		   y=GetRealOutPortPtrs(block,1);
		   for (i=0;i&lt;m*n;i++) y[i]=(double) u[i];
		   break;}
	    case 14:{
		   short *u;
		   long *y;
	  	   u=Getint16InPortPtrs(block,1);
	           y=Getint32OutPortPtrs(block,1);
		   for (i=0;i&lt;m*n;i++) 
		        {y[i]=(long)u[i];}
		   break;}
	    case 15:{
		   short *u;
		   char *y;
	  	   u=Getint16InPortPtrs(block,1);
	           y=Getint8OutPortPtrs(block,1);
		   k=pow(2,8);
		   for (i=0;i&lt;m*n;i++) 
		        {v=(double)u[i];
		         w=v-(int)(v/k)*k;
		         if (abs(w)&gt;k/2-1)
			     {if (w&gt;=0) w=(-k/2+abs(w-((int)(w/(k/2)))*(k/2)));
			     else w=-(-(k/2)+abs(w-((int)(w/(k/2)))*(k/2)));
			     }
		         y[i]=(char)w;}
		   break;}
	    case 16:{
		   short *u;
		   unsigned long *y;
	  	   u=Getint16InPortPtrs(block,1);
	           y=Getuint32OutPortPtrs(block,1);
		   for (i=0;i&lt;m*n;i++) 
		        {y[i]=(unsigned long)u[i];}
		   break;}
	    case 17:{
		   short *u;
		   unsigned char *y;
	  	   u=Getint16InPortPtrs(block,1);
	           y=Getuint8OutPortPtrs(block,1);
		   k=pow(2,8);
		   for (i=0;i&lt;m*n;i++) 
		        {v=(double)u[i];
		         w=v-(int)(v/k)*k;
		         y[i]=(unsigned char)w;}
		   break;}
	    case 18:{
		   char *u;
		   double *y;
		   u=Getint8InPortPtrs(block,1);
		   y=GetRealOutPortPtrs(block,1);
		   for (i=0;i&lt;m*n;i++) y[i]=(double) u[i];
		   break;}
	    case 19:{
		   char *u;
		   long *y;
	  	   u=Getint8InPortPtrs(block,1);
	           y=Getint32OutPortPtrs(block,1);
		   for (i=0;i&lt;m*n;i++) 
		        {y[i]=(long)u[i];}
		   break;}
	    case 20:{
		   char *u;
		   short *y;
	  	   u=Getint8InPortPtrs(block,1);
	           y=Getint16OutPortPtrs(block,1);
		   for (i=0;i&lt;m*n;i++) 
		        {y[i]=(short)w;}
		   break;}
	    case 21:{
		   char *u;
		   unsigned long *y;
	  	   u=Getint8InPortPtrs(block,1);
	           y=Getuint32OutPortPtrs(block,1);
		   for (i=0;i&lt;m*n;i++) 
		        {y[i]=(unsigned long)u[i];}
		   break;}
	    case 22:{
		   char *u;
		   unsigned short *y;
	  	   u=Getint8InPortPtrs(block,1);
	           y=Getuint16OutPortPtrs(block,1);
		   for (i=0;i&lt;m*n;i++) 
		        {y[i]=(unsigned short)w;}
		   break;}
	    case 23:{
		   unsigned long *u;
		   double *y;
		   u=Getuint32InPortPtrs(block,1);
		   y=GetRealOutPortPtrs(block,1);
		   for (i=0;i&lt;m*n;i++) y[i]=(double) u[i];
		   break;}
	    case 24:{
		   unsigned long *u;
		   short *y;
	  	   u=Getuint32InPortPtrs(block,1);
	           y=Getint16OutPortPtrs(block,1);
		   k=pow(2,16);
		   for (i=0;i&lt;m*n;i++) 
		        {v=(double)u[i];
		         w=v-(int)(v/k)*k;
		         if ((w)&gt;k/2-1)
			     { w=(-k/2+abs(w-((int)(w/(k/2)))*(k/2)));
			     }
		         y[i]=(short)w;}
		   break;}
	    case 25:{
		   unsigned long *u;
		   char *y;
	  	   u=Getuint32InPortPtrs(block,1);
	           y=Getint8OutPortPtrs(block,1);
		   k=pow(2,8);
		   for (i=0;i&lt;m*n;i++) 
		        {v=(double)u[i];
		         w=v-(int)(v/k)*k;
		         if ((w)&gt;k/2-1)
			     {w=(-k/2+abs(w-((int)(w/(k/2)))*(k/2)));
			     }
		         y[i]=(char)w;}
		   break;}
	    case 26:{
		   unsigned long *u;
		   unsigned short *y;
	  	   u=Getuint32InPortPtrs(block,1);
	           y=Getuint16OutPortPtrs(block,1);
		   k=pow(2,16);
		   for (i=0;i&lt;m*n;i++) 
		        {v=(double)u[i];
		         w=v-(int)(v/k)*k;
		         y[i]=(unsigned short)w;}
		   break;}
	    case 27:{
		   unsigned long *u;
		   unsigned char *y;
	  	   u=Getuint32InPortPtrs(block,1);
	           y=Getuint8OutPortPtrs(block,1);
		   k=pow(2,8);
		   for (i=0;i&lt;m*n;i++) 
		        {v=(double)u[i];
		         w=v-(int)(v/k)*k;
		         y[i]=(unsigned char)w;}
		   break;}
	    case 28:{
		   unsigned short *u;
		   double *y;
		   u=Getuint16InPortPtrs(block,1);
		   y=GetRealOutPortPtrs(block,1);
		   for (i=0;i&lt;m*n;i++) y[i]=(double) u[i];
		   break;}
	    case 29:{
		   unsigned short *u;
		   long *y;
	  	   u=Getuint16InPortPtrs(block,1);
	           y=Getint32OutPortPtrs(block,1);
		   for (i=0;i&lt;m*n;i++) 
		        {y[i]=(long)u[i];}
		   break;}
	    case 30:{
		   unsigned short *u;
		   char *y;
	  	   u=Getuint16InPortPtrs(block,1);
	           y=Getint8OutPortPtrs(block,1);
		   k=pow(2,8);
		   for (i=0;i&lt;m*n;i++) 
		        {v=(double)u[i];
		         w=v-(int)(v/k)*k;
		         if (w&gt;k/2-1)
			     {w=(-k/2+abs(w-((int)(w/(k/2)))*(k/2)));
			     }
		         y[i]=(char)w;}
		   break;}
	    case 31:{
		   unsigned short *u;
		   unsigned long *y;
	  	   u=Getuint16InPortPtrs(block,1);
	           y=Getuint32OutPortPtrs(block,1);
		   for (i=0;i&lt;m*n;i++) 
		        {y[i]=(unsigned long)u[i];}
		   break;}
	    case 32:{
		   unsigned short *u;
		   unsigned char *y;
	  	   u=Getuint16InPortPtrs(block,1);
	           y=Getuint8OutPortPtrs(block,1);
		   k=pow(2,8);
		   for (i=0;i&lt;m*n;i++) 
		        {v=(double)u[i];
		         w=v-(int)(v/k)*k;
		         y[i]=(unsigned char)w;}
		   break;}
	    case 33:{
		   unsigned char *u;
		   double *y;
		   u=Getuint8InPortPtrs(block,1);
		   y=GetRealOutPortPtrs(block,1);
		   for (i=0;i&lt;m*n;i++) y[i]=(double) u[i];
		   break;}
	    case 34:{
		   unsigned char *u;
		   long *y;
	  	   u=Getuint8InPortPtrs(block,1);
	           y=Getint32OutPortPtrs(block,1);
		   for (i=0;i&lt;m*n;i++) 
		        {y[i]=(long)u[i];}
		   break;}
	    case 35:{
		   unsigned char *u;
		   short *y;
	  	   u=Getuint8InPortPtrs(block,1);
	           y=Getint16OutPortPtrs(block,1);
		   for (i=0;i&lt;m*n;i++) 
		        {y[i]=(short)w;}
		   break;}
	    case 36:{
		   unsigned char *u;
		   unsigned long *y;
	  	   u=Getuint8InPortPtrs(block,1);
	           y=Getuint32OutPortPtrs(block,1);
		   for (i=0;i&lt;m*n;i++) 
		        {y[i]=(unsigned long)u[i];}
		   break;}
	    case 37:{
		   unsigned char *u;
		   unsigned short *y;
	  	   u=Getuint8InPortPtrs(block,1);
	           y=Getuint16OutPortPtrs(block,1);
		   for (i=0;i&lt;m*n;i++) 
		        {y[i]=(unsigned short)w;}
		   break;}
	    case 38:{
		   double *u;
		   long *y;
	  	   u=GetRealInPortPtrs(block,1);
	           y=Getint32OutPortPtrs(block,1);
		   k=pow(2,32);
		   for (i=0;i&lt;m*n;i++)
		       {if (u[i]&gt;k/2-1)
		           {y[i]=k/2-1;}
		        else if (u[i]&lt;-(k/2))
			   {y[i]=-(k/2);}
		        else {y[i]=(long)(u[i]);}
		       }
		   break;}
	    case 39:{
		   double *u;
		   short *y;
	  	   u=GetRealInPortPtrs(block,1);
	           y=Getint16OutPortPtrs(block,1);
		   k=pow(2,16);
		   for (i=0;i&lt;m*n;i++) 
		        {if (u[i]&gt;k/2-1)
		           {y[i]=k/2-1;}
		        else if (u[i]&lt;-(k/2))
			   {y[i]=-(k/2);}
		        else {y[i]=(short)(u[i]);}
		       }
		   break;}
	    case 40:{
		   double *u;
		   char *y;
	  	   u=GetRealInPortPtrs(block,1);
	           y=Getint8OutPortPtrs(block,1);
		   k=pow(2,8);
		   for (i=0;i&lt;m*n;i++) 
		        {if (u[i]&gt;k/2-1)
		           {y[i]=k/2-1;}
		        else if (u[i]&lt;-(k/2))
			   {y[i]=-(k/2);}
		        else {y[i]=(char)(u[i]);}
		       }
		   break;}
	    case 41:{
		   double *u;
		   unsigned long *y;
	  	   u=GetRealInPortPtrs(block,1);
	           y=Getuint32OutPortPtrs(block,1);
		   k=pow(2,32);
		   for (i=0;i&lt;m*n;i++) 
		        {if (u[i]&gt;=k)
		       	     {y[i]=k-1;}
		   	else if (u[i]&lt;0)
			     {y[i]=0;}
		   	else {y[i]=(unsigned long)(u[i]);}
		   	}
		   break;}
	    case 42:{
		   double *u;
		   unsigned short *y;
	  	   u=GetRealInPortPtrs(block,1);
	           y=Getuint16OutPortPtrs(block,1);
		   k=pow(2,16);
		   for (i=0;i&lt;m*n;i++) 
		        {if (u[i]&gt;=k)
		       	     {y[i]=k-1;}
		   	else if (u[i]&lt;0)
			     {y[i]=0;}
		   	else {y[i]=(unsigned short)(u[i]);}
		   	}
		   break;}
	    case 43:{
		   double *u;
		   unsigned char *y;
	  	   u=GetRealInPortPtrs(block,1);
	           y=Getuint8OutPortPtrs(block,1);
		   k=pow(2,8);
		   for (i=0;i&lt;m*n;i++) 
		        {if (u[i]&gt;=k)
		       	     {y[i]=k-1;}
		   	else if (u[i]&lt;0)
			     {y[i]=0;}
		   	else {y[i]=(unsigned char)(u[i]);}
		   	}
		   break;}
	    case 44:{
		   long *u;
		   short *y;
	  	   u=Getint32InPortPtrs(block,1);
	           y=Getint16OutPortPtrs(block,1);
		   k=pow(2,16);
		   for (i=0;i&lt;m*n;i++) 
		        {if (u[i]&gt;k/2-1)
		           {y[i]=k/2-1;}
		        else if (u[i]&lt;-(k/2))
			   {y[i]=-(k/2);}
		        else {y[i]=(short)(u[i]);}
		       }
		   break;}
	    case 45:{
		   long *u;
		   char *y;
	  	   u=Getint32InPortPtrs(block,1);
	           y=Getint8OutPortPtrs(block,1);
		   k=pow(2,8);
		   for (i=0;i&lt;m*n;i++) 
		        {if (u[i]&gt;k/2-1)
		           {y[i]=k/2-1;}
		        else if (u[i]&lt;-(k/2))
			   {y[i]=-(k/2);}
		        else {y[i]=(char)(u[i]);}
		       }
		   break;}
	    case 46:{
		   long *u;
		   unsigned long *y;
	  	   u=Getint32InPortPtrs(block,1);
	           y=Getuint32OutPortPtrs(block,1);
		   for (i=0;i&lt;m*n;i++) 
		   	{if (u[i]&lt;0)
			     {y[i]=0;}
		   	else {y[i]=(unsigned long)(u[i]);}
		   	}
		   break;}
	    case 47:{
		   long *u;
		   unsigned short *y;
	  	   u=Getint32InPortPtrs(block,1);
	           y=Getuint16OutPortPtrs(block,1);
		   k=pow(2,16);
		   for (i=0;i&lt;m*n;i++) 
		        {if (u[i]&gt;=k)
		       	     {y[i]=k-1;}
		   	else if (u[i]&lt;0)
			     {y[i]=0;}
		   	else {y[i]=(unsigned short)(u[i]);}
		   	}
		   break;}
	    case 48:{
		   long *u;
		   unsigned char *y;
	  	   u=Getint32InPortPtrs(block,1);
	           y=Getuint8OutPortPtrs(block,1);
		   k=pow(2,8);
		   for (i=0;i&lt;m*n;i++) 
		        {if (u[i]&gt;=k)
		       	     {y[i]=k-1;}
		   	else if (u[i]&lt;0)
			     {y[i]=0;}
		   	else {y[i]=(unsigned char)(u[i]);}
		   	}
		   break;}
	    case 49:{
		   short *u;
		   char *y;
	  	   u=Getint16InPortPtrs(block,1);
	           y=Getint8OutPortPtrs(block,1);
		   k=pow(2,8);
		   for (i=0;i&lt;m*n;i++) 
		        {if (u[i]&gt;k/2-1)
		           {y[i]=k/2-1;}
		        else if (u[i]&lt;-(k/2))
			   {y[i]=-(k/2);}
		        else {y[i]=(char)(u[i]);}
		       }
		   break;}
	    case 50:{
		   short *u;
		   unsigned long *y;
	  	   u=Getint16InPortPtrs(block,1);
	           y=Getuint32OutPortPtrs(block,1);
		   for (i=0;i&lt;m*n;i++) 
		        {if (u[i]&lt;0)  y[i]=0;
			 else y[i]=(unsigned long)u[i];}
		   break;}
	    case 51:{
		   short *u;
		   unsigned short *y;
	  	   u=Getint16InPortPtrs(block,1);
	           y=Getuint16OutPortPtrs(block,1);
		   for (i=0;i&lt;m*n;i++) 
		   	{if (u[i]&lt;0)
			     {y[i]=0;}
		   	else {y[i]=(unsigned short)(u[i]);}
		   	}
		   break;}
	    case 52:{
		   short *u;
		   unsigned char *y;
	  	   u=Getint16InPortPtrs(block,1);
	           y=Getuint8OutPortPtrs(block,1);
		   k=pow(2,8);
		   for (i=0;i&lt;m*n;i++) 
		        {if (u[i]&gt;=k)
		       	     {y[i]=k-1;}
		   	else if (u[i]&lt;0)
			     {y[i]=0;}
		   	else {y[i]=(unsigned char)(u[i]);}
		   	}
		   break;}
	    case 53:{
		   char *u;
		   unsigned long *y;
	  	   u=Getint8InPortPtrs(block,1);
	           y=Getuint32OutPortPtrs(block,1);
		   for (i=0;i&lt;m*n;i++) 
			{if (u[i]&lt;0)  y[i]=0;
			 else y[i]=(unsigned long)u[i];}
		   break;}
	    case 54:{
		   char *u;
		   unsigned short *y;
	  	   u=Getint8InPortPtrs(block,1);
	           y=Getuint16OutPortPtrs(block,1);
		   for (i=0;i&lt;m*n;i++) 
		        {if (u[i]&lt;0)
			     {y[i]=0;}
		   	else {y[i]=(unsigned short)(u[i]);}
		   	}
		   break;}
	    case 55:{
		   char *u;
		   unsigned char *y;
	  	   u=Getint8InPortPtrs(block,1);
	           y=Getuint8OutPortPtrs(block,1);
		   for (i=0;i&lt;m*n;i++) 
		   	{if (u[i]&lt;0)
			     {y[i]=0;}
		   	else {y[i]=(unsigned char)(u[i]);}
		   	}
		   break;}
	    case 56:{
		   long *y;
		   unsigned long *u;
	  	   u=Getuint32InPortPtrs(block,1);
	           y=Getint32OutPortPtrs(block,1);
		   k=pow(2,32);
		   for (i=0;i&lt;m*n;i++) 
		   	{if (u[i]&gt;(k/2-1))
			     {y[i]=k/2-1;}
		   	else {y[i]=(long)(u[i]);}
		   	}
		   break;}
	    case 57:{
		   unsigned long *u;
		   short *y;
	  	   u=Getuint32InPortPtrs(block,1);
	           y=Getint16OutPortPtrs(block,1);
		   k=pow(2,16);
		   for (i=0;i&lt;m*n;i++) 
		        {if (u[i]&gt;(k/2-1))
			     {y[i]=k/2-1;}
		   	else {y[i]=(short)(u[i]);}
		   	}
		   break;}
	    case 58:{
		   unsigned long *u;
		   char *y;
	  	   u=Getuint32InPortPtrs(block,1);
	           y=Getint8OutPortPtrs(block,1);
		   k=pow(2,8);
		   for (i=0;i&lt;m*n;i++) 
		        {if (u[i]&gt;(k/2-1))
			     {y[i]=k/2-1;}
		   	else {y[i]=(char)(u[i]);}
		   	}
		   break;}
	    case 59:{
		   unsigned long *u;
		   unsigned short *y;
	  	   u=Getuint32InPortPtrs(block,1);
	           y=Getuint16OutPortPtrs(block,1);
		   k=pow(2,16);
		   for (i=0;i&lt;m*n;i++) 
		        {if (u[i]&gt;(k/2-1))
			     {y[i]=k/2-1;}
		   	else {y[i]=(unsigned short)(u[i]);}
		   	}
		   break;}
	    case 60:{
		   unsigned long *u;
		   unsigned char *y;
	  	   u=Getuint32InPortPtrs(block,1);
	           y=Getuint8OutPortPtrs(block,1);
		   k=pow(2,8);
		   for (i=0;i&lt;m*n;i++) 
		        {if (u[i]&gt;(k/2-1))
			     {y[i]=k/2-1;}
		   	else {y[i]=(unsigned char)(u[i]);}
		   	}
		   break;}
	    case 61:{
		   unsigned short *u;
		   short *y;
	  	   u=Getuint16InPortPtrs(block,1);
	           y=Getint16OutPortPtrs(block,1);
		   k=pow(2,16);
		   for (i=0;i&lt;m*n;i++) 
		        {if (u[i]&gt;(k/2-1))
			     {y[i]=k/2-1;}
		   	else {y[i]=(short)(u[i]);}
		   	}
		   break;}
	    case 62:{
		   unsigned short *u;
		   char *y;
	  	   u=Getuint16InPortPtrs(block,1);
	           y=Getint8OutPortPtrs(block,1);
		   k=pow(2,8);
		   for (i=0;i&lt;m*n;i++) 
		        {if (u[i]&gt;(k/2-1))
			     {y[i]=k/2-1;}
		   	else {y[i]=(char)(u[i]);}
		   	}
		   break;}
	    case 63:{
		   unsigned short *u;
		   unsigned char *y;
	  	   u=Getuint16InPortPtrs(block,1);
	           y=Getuint8OutPortPtrs(block,1);
		   k=pow(2,8);
		   for (i=0;i&lt;m*n;i++) 
		        {if (u[i]&gt;(k/2-1))
			     {y[i]=k/2-1;}
		   	else {y[i]=(unsigned char)(u[i]);}
		   	}
		   break;}
	    case 64:{
		   unsigned char *u;
		   char *y;
	  	   u=Getuint8InPortPtrs(block,1);
	           y=Getint8OutPortPtrs(block,1);
		   k=pow(2,8);
		   for (i=0;i&lt;m*n;i++) 
		        {if (u[i]&gt;(k/2-1))
			     {y[i]=k/2-1;}
		   	else {y[i]=(char)(u[i]);}
		   	}
		   break;}
	    case 65:{
		   double *u;
		   long *y;
	  	   u=GetRealInPortPtrs(block,1);
	           y=Getint32OutPortPtrs(block,1);
		   k=pow(2,32);
		   for (i=0;i&lt;m*n;i++)
		       {if ((u[i]&gt;k/2-1) | (u[i]&lt;-(k/2)))
		           {sciprint("overflow error");
			    set_block_error(-4);
			    return;}
		        else {y[i]=(long)(u[i]);}
		       }
		   break;}
	    case 66:{
		   double *u;
		   short *y;
	  	   u=GetRealInPortPtrs(block,1);
	           y=Getint16OutPortPtrs(block,1);
		   k=pow(2,16);
		   for (i=0;i&lt;m*n;i++) 
		        {if ((u[i]&gt;k/2-1) | (u[i]&lt;-(k/2)))
		           {sciprint("overflow error");
			    set_block_error(-4);
			    return;}
		        else {y[i]=(short)(u[i]);}
		       }
		   break;}
	    case 67:{
		   double *u;
		   char *y;
	  	   u=GetRealInPortPtrs(block,1);
	           y=Getint8OutPortPtrs(block,1);
		   k=pow(2,8);
		   for (i=0;i&lt;m*n;i++) 
		        {if ((u[i]&gt;k/2-1) | (u[i]&lt;-(k/2)))
		           {sciprint("overflow error");
			    set_block_error(-4);
			    return;}
		        else {y[i]=(char)(u[i]);}
		       }
		   break;}
	    case 68:{
		   double *u;
		   unsigned long *y;
	  	   u=GetRealInPortPtrs(block,1);
	           y=Getuint32OutPortPtrs(block,1);
		   k=pow(2,32);
		   for (i=0;i&lt;m*n;i++) 
		        {if ((u[i]&gt;=k) | (u[i]&lt;0))
		       	   {sciprint("overflow error");
			    set_block_error(-4);
			    return;}
		   	else {y[i]=(unsigned long)(u[i]);}
		   	}
		   break;}
	    case 69:{
		   double *u;
		   unsigned short *y;
	  	   u=GetRealInPortPtrs(block,1);
	           y=Getuint16OutPortPtrs(block,1);
		   k=pow(2,16);
		   for (i=0;i&lt;m*n;i++) 
		        {if ((u[i]&gt;=k) | (u[i]&lt;0))
		       	    {sciprint("overflow error");
			     set_block_error(-4);
			     return;}
		   	else {y[i]=(unsigned short)(u[i]);}
		   	}
		   break;}
	    case 70:{
		   double *u;
		   unsigned char *y;
	  	   u=GetRealInPortPtrs(block,1);
	           y=Getuint8OutPortPtrs(block,1);
		   k=pow(2,8);
		   for (i=0;i&lt;m*n;i++) 
		        {if ((u[i]&gt;=k) | (u[i]&lt;0))
		       	    {sciprint("overflow error");
			     set_block_error(-4);
			     return;}
		   	else {y[i]=(unsigned char)(u[i]);}
		   	}
		   break;}
	    case 71:{
		   long *u;
		   short *y;
	  	   u=Getint32InPortPtrs(block,1);
	           y=Getint16OutPortPtrs(block,1);
		   k=pow(2,16);
		   for (i=0;i&lt;m*n;i++) 
		        {if ((u[i]&gt;k/2-1) | (u[i]&lt;-(k/2)))
		            {sciprint("overflow error");
			     set_block_error(-4);
			     return;}
		        else {y[i]=(short)(u[i]);}
		       }
		   break;}
	    case 72:{
		   long *u;
		   char *y;
	  	   u=Getint32InPortPtrs(block,1);
	           y=Getint8OutPortPtrs(block,1);
		   k=pow(2,8);
		   for (i=0;i&lt;m*n;i++) 
		        {if ((u[i]&gt;k/2-1) | (u[i]&lt;-(k/2)))
		            {sciprint("overflow error");
			     set_block_error(-4);
			     return;}
		        else {y[i]=(char)(u[i]);}
		       }
		   break;}
	    case 73:{
		   long *u;
		   unsigned long *y;
	  	   u=Getint32InPortPtrs(block,1);
	           y=Getuint32OutPortPtrs(block,1);
		   for (i=0;i&lt;m*n;i++) 
		   	{if (u[i]&lt;0)
			    {sciprint("overflow error");
			     set_block_error(-4);
			     return;}
		   	else {y[i]=(unsigned long)(u[i]);}
		   	}
		   break;}
	    case 74:{
		   long *u;
		   unsigned short *y;
	  	   u=Getint32InPortPtrs(block,1);
	           y=Getuint16OutPortPtrs(block,1);
		   k=pow(2,16);
		   for (i=0;i&lt;m*n;i++) 
		        {if ((u[i]&gt;=k) | (u[i]&lt;0))
		       	    {sciprint("overflow error");
			     set_block_error(-4);
			     return;}
		   	else {y[i]=(unsigned short)(u[i]);}
		   	}
		   break;}
	    case 75:{
		   long *u;
		   unsigned char *y;
	  	   u=Getint32InPortPtrs(block,1);
	           y=Getuint8OutPortPtrs(block,1);
		   k=pow(2,8);
		   for (i=0;i&lt;m*n;i++) 
		        {if ((u[i]&gt;=k) | (u[i]&lt;0))
		       	    {sciprint("overflow error");
			     set_block_error(-4);
			     return;}
		   	else {y[i]=(unsigned char)(u[i]);}
		   	}
		   break;}
	    case 76:{
		   short *u;
		   char *y;
	  	   u=Getint16InPortPtrs(block,1);
	           y=Getint8OutPortPtrs(block,1);
		   k=pow(2,8);
		   for (i=0;i&lt;m*n;i++) 
		        {if ((u[i]&gt;k/2-1) | (u[i]&lt;-(k/2)))
		            {sciprint("overflow error");
			     set_block_error(-4);
			     return;}
		        else {y[i]=(char)(u[i]);}
		       }
		   break;}
	    case 77:{
		   short *u;
		   unsigned long *y;
	  	   u=Getint16InPortPtrs(block,1);
	           y=Getuint32OutPortPtrs(block,1);
		   for (i=0;i&lt;m*n;i++) 
		        {if (u[i]&lt;0)  
			    {sciprint("overflow error");
			     set_block_error(-4);
			     return;}
			 else y[i]=(unsigned long)u[i];}
		   break;}
	    case 78:{
		   short *u;
		   unsigned short *y;
	  	   u=Getint16InPortPtrs(block,1);
	           y=Getuint16OutPortPtrs(block,1);
		   for (i=0;i&lt;m*n;i++) 
		   	{if (u[i]&lt;0)
			    {sciprint("overflow error");
			     set_block_error(-4);
			     return;}
		   	else {y[i]=(unsigned short)(u[i]);}
		   	}
		   break;}
	    case 79:{
		   short *u;
		   unsigned char *y;
	  	   u=Getint16InPortPtrs(block,1);
	           y=Getuint8OutPortPtrs(block,1);
		   k=pow(2,8);
		   for (i=0;i&lt;m*n;i++) 
		        {if ((u[i]&gt;=k) | (u[i]&lt;0))
		       	    {sciprint("overflow error");
			     set_block_error(-4);
			     return;}
		   	else {y[i]=(unsigned char)(u[i]);}
		   	}
		   break;}
	    case 80:{
		   char *u;
		   unsigned long *y;
	  	   u=Getint8InPortPtrs(block,1);
	           y=Getuint32OutPortPtrs(block,1);
		   for (i=0;i&lt;m*n;i++) 
			{if (u[i]&lt;0)
			    {sciprint("overflow error");
			     set_block_error(-4);
			     return;}
			 else y[i]=(unsigned long)u[i];}
		   break;}
	    case 81:{
		   char *u;
		   unsigned short *y;
	  	   u=Getint8InPortPtrs(block,1);
	           y=Getuint16OutPortPtrs(block,1);
		   for (i=0;i&lt;m*n;i++) 
		        {if (u[i]&lt;0)
			    {sciprint("overflow error");
			     set_block_error(-4);
			     return;}
		   	else {y[i]=(unsigned short)(u[i]);}
		   	}
		   break;}
	    case 82:{
		   char *u;
		   unsigned char *y;
	  	   u=Getint8InPortPtrs(block,1);
	           y=Getuint8OutPortPtrs(block,1);
		   for (i=0;i&lt;m*n;i++) 
		   	{if (u[i]&lt;0)
			    {sciprint("overflow error");
			     set_block_error(-4);
			     return;}
		   	else {y[i]=(unsigned char)(u[i]);}
		   	}
		   break;}
	    case 83:{
		   long *y;
		   unsigned long *u;
	  	   u=Getuint32InPortPtrs(block,1);
	           y=Getint32OutPortPtrs(block,1);
		   k=pow(2,32);
		   for (i=0;i&lt;m*n;i++) 
		   	{if (u[i]&gt;(k/2-1))
			    {sciprint("overflow error");
			     set_block_error(-4);
			     return;}
		   	else {y[i]=(long)(u[i]);}
		   	}
		   break;}
	    case 84:{
		   unsigned long *u;
		   short *y;
	  	   u=Getuint32InPortPtrs(block,1);
	           y=Getint16OutPortPtrs(block,1);
		   k=pow(2,16);
		   for (i=0;i&lt;m*n;i++) 
		        {if (u[i]&gt;(k/2-1))
			    {sciprint("overflow error");
			     set_block_error(-4);
			     return;}
		   	else {y[i]=(short)(u[i]);}
		   	}
		   break;}
	    case 85:{
		   unsigned long *u;
		   char *y;
	  	   u=Getuint32InPortPtrs(block,1);
	           y=Getint8OutPortPtrs(block,1);
		   k=pow(2,8);
		   for (i=0;i&lt;m*n;i++) 
		        {if (u[i]&gt;(k/2-1))
			    {sciprint("overflow error");
			     set_block_error(-4);
			     return;}
		   	else {y[i]=(char)(u[i]);}
		   	}
		   break;}
	    case 86:{
		   unsigned long *u;
		   unsigned short *y;
	  	   u=Getuint32InPortPtrs(block,1);
	           y=Getuint16OutPortPtrs(block,1);
		   k=pow(2,16);
		   for (i=0;i&lt;m*n;i++) 
		        {if (u[i]&gt;(k/2-1))
			    {sciprint("overflow error");
			     set_block_error(-4);
			     return;}
		   	else {y[i]=(unsigned short)(u[i]);}
		   	}
		   break;}
	    case 87:{
		   unsigned long *u;
		   unsigned char *y;
	  	   u=Getuint32InPortPtrs(block,1);
	           y=Getuint8OutPortPtrs(block,1);
		   k=pow(2,8);
		   for (i=0;i&lt;m*n;i++) 
		        {if (u[i]&gt;(k/2-1))
			    {sciprint("overflow error");
			     set_block_error(-4);
			     return;}
		   	else {y[i]=(unsigned char)(u[i]);}
		   	}
		   break;}
	    case 88:{
		   unsigned short *u;
		   short *y;
	  	   u=Getuint16InPortPtrs(block,1);
	           y=Getint16OutPortPtrs(block,1);
		   k=pow(2,16);
		   for (i=0;i&lt;m*n;i++) 
		        {if (u[i]&gt;(k/2-1))
			    {sciprint("overflow error");
			     set_block_error(-4);
			     return;}
		   	else {y[i]=(short)(u[i]);}
		   	}
		   break;}
	    case 89:{
		   unsigned short *u;
		   char *y;
	  	   u=Getuint16InPortPtrs(block,1);
	           y=Getint8OutPortPtrs(block,1);
		   k=pow(2,8);
		   for (i=0;i&lt;m*n;i++) 
		        {if (u[i]&gt;(k/2-1))
			    {sciprint("overflow error");
			     set_block_error(-4);
			     return;}
		   	else {y[i]=(char)(u[i]);}
		   	}
		   break;}
	    case 90:{
		   unsigned short *u;
		   unsigned char *y;
	  	   u=Getuint16InPortPtrs(block,1);
	           y=Getuint8OutPortPtrs(block,1);
		   k=pow(2,8);
		   for (i=0;i&lt;m*n;i++) 
		        {if (u[i]&gt;(k/2-1))
			    {sciprint("overflow error");
			     set_block_error(-4);
			     return;}
		   	else {y[i]=(unsigned char)(u[i]);}
		   	}
		   break;}
	    case 91:{
		   unsigned char *u;
		   char *y;
	  	   u=Getuint8InPortPtrs(block,1);
	           y=Getint8OutPortPtrs(block,1);
		   k=pow(2,8);
		   for (i=0;i&lt;m*n;i++) 
		        {if (u[i]&gt;(k/2-1))
			    {sciprint("overflow error");
			     set_block_error(-4);
			     return;}
		   	else {y[i]=(char)(u[i]);}
		   	}
		   break;}
	   }
	}
 }
</PRE>

<H3><font color="blue"><A NAME="SECTION00027000000000000000">
Used functions</A>
</font></H3>
<b>convert</b>

<H3><font color="blue"><A NAME="SECTION00028000000000000000">
See also</A>
</font></H3>

<UL>
<LI><A NAME="tex2html4"
  HREF="add a key here.htm">add a key here</A>
</LI>
</UL>

<H3><font color="blue"><A NAME="SECTION00029000000000000000">
Authors</A>
</font></H3>
<b>Fady NASSIF</b> INRIA
 
<H3><font color="blue"><A NAME="SECTION00030000000000000000">
Bibliography</A>
</font></H3><DL COMPACT><DD>Add here the function bibliography if any
</DL>

<BR>




</BODY>
</HTML>
