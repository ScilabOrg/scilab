//Generate a modified standalone C-code file required for 20-sim 4C
//
//Author : Maarten Meijer
//
//
function ok=generateMain();

  //** Generate main C-code
  Code=makeMain();
 
  //Create <prefix>main.c
  ierr=execstr('mputl(Code,rpat+''/src/'+XX_VARPREFIX+'main.c'')','errcatch');
  if ierr<>0 then
    message(lasterror())
    ok=%f
  end
endfunction

//generates code of the standalone simulation procedure
//
//
// rmq : La fonction zdoit n'est pas utilisï¿½e pour le moment
// 2010-08-02 Modified by Maarten Meijer
function Code=makeMain()


  Code=[makeHeaderComment(XX_VARPREFIX+'main.c')
        ''
        '/* Code prototype for standalone use  */'
        '/*     Generated by a modified version of the Code_Generation toolbox of Scicos with '+ ..
        getversion()+' */'
        '/*     date : '+date()+' */'
        ''
        '/* This C-code is created by the 20-sim 4C macros added to Scilab */'
        ''
        '/* ---- Headers ---- */'
        '#include <stdio.h>'
        '#include <stdlib.h>'
        '#include <math.h>'
        '#include <string.h>'
        '#include <memory.h>'
        ''
		'/* Scilab includes*/'
		'#include '"'+XX_VARPREFIX+'model.h'"'
		''
		'/* 20-sim 4C includes */'
		'#include <float.h>'
		'#include <stdio.h>'
		''
		'#include '"xxtypes.h'"'
		'#include '"ivcipc.h'"'
		'#include '"ivcdebug.h'"'
		''
		'/* 20-sim 4C dynamic includes */'
		'%TC_INCLUDES%'
		''
		'/* 20-sim 4C globals */'
		'%TC_GLOBALS%'
        '']
  

  Code=[Code;
        '/* the main function */'
        'int main()'
        '{'
        '']


  //** Add 20-sim 4C initialization code
  Code=[Code
        ''
		'  /* Begin of 20-sim 4C initialization */'
		'    /* redirect the std output and std error to a log file */'
 		'    DFREOPEN('"'+rdnom+'.log'", '"w+'", stdout);'
 		'    DFREOPEN('"'+rdnom+'.log'", '"w+'", stderr);'
		''
		'    /* 20-sim 4C initialize the I/O devices */'
 		'    %TC_INIT%'
		'    '
		'    /* Initialize the platform */'
 		'    if ( ivcInitializePlatform('"'+rdnom+''") != 0 )'
		'    {'
 		'        DPRINTF('"Platform could not be initialized exiting.'");'
		'        return 1;'
		'    }'
		'    '
		'    /* Create the shared memory */'
		'    if ( '+XX_VARPREFIX+'OpenSharedMemory() != 0 )'
		'    {'
 		'        DPRINTF('"Shared memory could not be initialized exiting.'");'
		'        return 1;'
		'    }'
		'    '
		'    /* Initialize parameters and globals */'
		'    '+XX_VARPREFIX+'InitializeFromSharedMemory();'
		''
		'    /* Initialize task */'
 		'    if ( ivcInitializeTask('"'+rdnom+''", '+XX_VARPREFIX+'step_size) != 0)'
		'    {'
 		'        DPRINTF('"Task could not be initialized exiting.'");'
		'        return 1;'
		'    }'
		''
		'    /* Start task */'
 		'    if ( ivcStartTask('"'+rdnom+''") != 0)'
		'    {'
		'        DPRINTF('"Task could not be started exiting.'");'
		'        return 1;'
		'    }'
		'    /* end of 20-sim 4C initialization */'
		'']
		
  //** Add Scilab model initialization code
  Code=[Code
		'    /* initialize Scilab model */'
		'    '+XX_FUNCTIONPREFIX+'ModelInitialize();'
		''];
  
  //** begin input main loop on time
  Code=[Code;
        ''
        '    while ( ('+XX_VARPREFIX+'time <= '+XX_VARPREFIX+'finish_time) && ('+XX_VARPREFIX+'stop_simulation == XXFALSE) )'
		'        {';
        '        /* 20-sim 4C read & write functions */'
        '        %TC_READ_FUNCTION%'
        '        %TC_WRITE_FUNCTION%'
        ''
		'        /* Calculation of the model */'
		'        '+XX_FUNCTIONPREFIX+'Calculate();'
		''
        '        /* Copy the calculated values to the shared memory and retrieve parameters from the shared memory*/'
        '        '+XX_VARPREFIX+'SynchronizeSharedMemory();'
		''
        '        /* Wait for the timer period */'
        '        '+XX_VARPREFIX+'executionTime = ivcTaskWaitForPeriod();'
		''
		'        /* increment the simulation time */'
		'        sci_time = sci_time + sci_step_size;'
		'        }'
        '']



  //** Add 20-sim 4C termination code
  Code=[Code
  		'    /* Terminate model */'
		'    '+XX_FUNCTIONPREFIX+'ModelTerminate();'
		''
		'    /* Terminated the task */'
		'    ivcTerminateTask('"'+rdnom+''");'
		''
		'    /* clear the shared memory */'
		'    '+XX_VARPREFIX+'CloseSharedMemory();'
		''
		'    /* Terminated the platform */'
		'    ivcTerminatePlatform('"'+rdnom+''");'
		''
		'    /* 20-sim 4C close the I/O devices */'
		'    %TC_CLOSE%'
		'    '
		'    /* close the streams */'
		'    FCLOSE(stdout);'
		'    FCLOSE(stderr);'
		'']
  
  Code=[Code
        ''
        '  return 0;'
        '}'
        ''];

endfunction

//write_code_odoit : generate body of the code for
//                   ordering calls of blocks before
//                   continuous time integration
//
//input : flag : flag number for block's call
//
//output : txt for flag 0
//
//12/07/07 Alan Layec
function [txt]=write_code_odoit(flag)
  txt=[];

  for j=1:noord
    bk=oord(j,1);
    pt=oord(j,2);
    //** blk
    if funtyp(bk)>-1 then
      txt2=call_block42(bk,pt,flag);
      if txt2<>[] then
        txt=[txt;
             '    '+txt2
             ''];
      end
    //** ifthenelse blk
    elseif funtyp(bk)==-1 then
      ix=-1+inplnk(inpptr(bk));
      TYPE=mat2c_typ(outtb(ix+1)); //** scilab index start from 1
      thentxt=write_code_ozdoit(clkptr(bk),flag);
      elsetxt=write_code_ozdoit(clkptr(bk)+1,flag);
      if thentxt<>[] | elsetxt<>[] then
        txt=[txt;
             '    '+get_comment('ifthenelse_blk',list(bk));]
        //** C **//
        tmp_='*(('+TYPE+' *)'+XX_VARPREFIX+'outtbptr['+string(ix)+'])'
        txt=[txt;
             '    if ((block_'+rdnom+'['+string(bk-1)+'].nmode<0'+...
              ' && '+tmp_+'>0)'+...
              ' || \'
             '        (block_'+rdnom+'['+string(bk-1)+'].nmode>0'+...
              ' && block_'+rdnom+'['+string(bk-1)+'].mode[0]==1)) {']
        //*******//
        txt=[txt;
             Indent+thentxt]
        //** C **//
        txt=[txt;
             '    }'];
        //*******//
        if elsetxt<>[] then
          //** C **//
          txt=[txt;
               '    else if  ((block_'+rdnom+'['+string(bk-1)+'].nmode<0'+...
                ' && '+tmp_+'<=0)'+...
                ' || \'
               '              (block_'+rdnom+'['+string(bk-1)+'].nmode>0'+...
                ' && block_'+rdnom+'['+string(bk-1)+'].mode[0]==2)) {';]
          //*******//
          txt=[txt;
               Indent+elsetxt]
          //** C **//
          txt=[txt;
               '    }'];
          //*******//
        end
      end
    //** eventselect blk
    elseif funtyp(bk)==-2 then
      Noutport=clkptr(bk+1)-clkptr(bk);
      ix=-1+inplnk(inpptr(bk));
      TYPE=mat2c_typ(outtb(ix+1)); //** scilab index start from 1
      II=[];
      switchtxt=list()
      for i=1: Noutport
        switchtxt(i)=write_code_ozdoit(clkptr(bk)+i-1,flag);
        if switchtxt(i)<>[] then II=[II i];end
      end
      if II<>[] then
        txt=[txt;
             '    '+get_comment('evtselect_blk',list(bk));]
        //** C **//
        tmp_='*(('+TYPE+' *)'+XX_VARPREFIX+'outtbptr['+string(ix)+'])'
        txt=[txt;
             '    if (block_'+rdnom+'['+string(bk-1)+'].nmode<0) {';
             '      i=max(min((int) '+...
                tmp_+',block_'+rdnom+'['+string(bk-1)+'].evout),1);'
             '    }'
             '    else {'
             '      i=block_'+rdnom+'['+string(bk-1)+'].mode[0];'
             '    }']
        txt=[txt;
             '    switch(i)'
             '    {'];
        //*******//
        for i=II
          //** C **//
          txt=[txt;
               '     case '+string(i)+' :';]
          //*******//
          txt=[txt;
               BigIndent+write_code_ozdoit(clkptr(bk)+i-1,flag);]
          //** C **//
          txt=[txt;
               BigIndent+'break;']
          //*******//
        end
        //** C **//
        txt=[txt;
             '    }'];
        //*******//
      end
    //** Unknown block
    else
      error('Unknown block type '+string(bk));
    end
  end

endfunction


//write_code_idoit : generate body of the code for
//                   ordering calls of initial
//                   called blocks
//
//input : nothing (blocks are called with flag 1)
//
//output : txt for iord
//
//15/07/07 Alan Layec
function [txt]=write_code_idoit()
  txt=[];

  for j=1:niord
    bk=iord(j,1);
    pt=iord(j,2);
    //** blk
    if funtyp(bk)>-1 then
      if or(bk==act) then
        if stalone then
          txt2=call_block42(bk,pt,1);
          if txt2<>[] then
            txt=[txt;
                 '    '+txt2
                 ''];
          end
        end
      else
        txt2=call_block42(bk,pt,1);
        if txt2<>[] then
          txt=[txt;
               '    '+txt2
               ''];
        end
      end
    //** ifthenelse blk
    elseif funtyp(bk)==-1 then
      ix=-1+inplnk(inpptr(bk));
      TYPE=mat2c_typ(outtb(ix+1)); //** scilab index start from 1
      thentxt=write_code_doit(clkptr(bk),1);
      elsetxt=write_code_doit(clkptr(bk)+1,1);
      if thentxt<>[] | elsetxt<>[] then
        txt=[txt;
             '    '+get_comment('ifthenelse_blk',list(bk));]
        //** C **//
        tmp_ = '*(('+TYPE+' *)'+XX_VARPREFIX+'outtbptr['+string(ix)+'])'
        txt=[txt;
             '    if('+tmp_+'>0) {']
        //*******//
        txt=[txt;
             Indent+thentxt];
        if elsetxt<>[] then
           //** C **//
           txt=[txt;
                '    }';
                '    else {';]
           //*******//
           txt=[txt;
                Indent+elsetxt];
        end
        //** C **//
        txt=[txt;
             '    }']
        //*******//
      end
    //** eventselect blk
    elseif funtyp(bk)==-2 then
      Noutport=clkptr(bk+1)-clkptr(bk);
      ix=-1+inplnk(inpptr(bk));
      TYPE=mat2c_typ(outtb(ix+1)); //** scilab index start from 1
      II=[];
      switchtxt=list()
      for i=1: Noutport
        switchtxt(i)=write_code_doit(clkptr(bk)+i-1,1);
        if switchtxt(i)<>[] then II=[II i];end
      end
      if II<>[] then
        txt=[txt;
             '    '+get_comment('evtselect_blk',list(bk));]
        //** C **//
        tmp_='*(('+TYPE+' *)'+XX_VARPREFIX+'outtbptr['+string(ix)+'])'
        txt=[txt;
             '    i=max(min((int) '+...
              tmp_+',block_'+rdnom+'['+string(bk-1)+'].evout),1);']
        txt=[txt;
             '    switch(i)'
             '    {']
        //*******//
        for i=II
          //** C **//
          txt=[txt;
               '     case '+string(i)+' :';]
          //*******//
          txt=[txt;
               BigIndent+write_code_doit(clkptr(bk)+i-1,1);]
          //** C **//
          txt=[txt;
               BigIndent+'break;']
          //*******//
        end
        //** C **//
        txt=[txt;
             '    }'];
        //*******//
      end
    //** Unknown block
    else
      error('Unknown block type '+string(bk));
    end
  end

endfunction

//write_code_ozdoit : generate body of the code for both
//                    flag 0 & flag 9
//
//input: ev  : evt number for block's call
//      flag : flag number for block's call
//
//output : txt for flag 0 or flag 9
//
//12/07/07 Alan Layec
function [txt]=write_code_ozdoit(ev,flag)
  txt=[];

  for j=ordptr(ev):ordptr(ev+1)-1
    bk=ordclk(j,1);
    pt=ordclk(j,2);
    //** blk
    if funtyp(bk)>-1 then
      if (or(bk==act) | or(bk==cap)) & (flag==1) then
        if stalone then
          txt=[txt;
               '    '+call_block42(bk,pt,flag)
               ''];
        end
      else
        txt2=call_block42(bk,pt,flag);
        if txt2<>[] then
          txt=[txt;
               '    '+txt2
               ''];
        end
      end
    //** ifthenelse blk
    elseif funtyp(bk)==-1 then
      ix=-1+inplnk(inpptr(bk));
      TYPE=mat2c_typ(outtb(ix+1)); //** scilab index start from 1
      thentxt=write_code_ozdoit(clkptr(bk),flag);
      elsetxt=write_code_ozdoit(clkptr(bk)+1,flag);
      if thentxt<>[] | elsetxt<>[] then
        txt=[txt;
             '    '+get_comment('ifthenelse_blk',list(bk));]
        //** C **//
        tmp_ = '*(('+TYPE+' *)'+XX_VARPREFIX+'outtbptr['+string(ix)+'])'
        txt=[txt;
             '    if (((phase==1'+...
              ' || block_'+rdnom+'['+string(bk-1)+'].nmode==0)'+...
              ' && '+tmp_+'>0)'+...
              ' || \'
             '        ((phase!=1'+...
              ' && block_'+rdnom+'['+string(bk-1)+'].nmode!=0)'+...
              ' && block_'+rdnom+'['+string(bk-1)+'].mode[0]==1)) {']
        //*******//
        txt=[txt;
             Indent+thentxt]
        //** C **//
        txt=[txt;
             '    }'];
        //*******//
        if elsetxt<>[] then
           //** C **//
           txt=[txt;
                '      else if (((phase==1'+...
                 ' || block_'+rdnom+'['+string(bk-1)+'].nmode==0)'+...
                 ' && '+tmp_+'<=0)'+...
                 ' || \'
                '               ((phase!=1'+...
                 ' && block_'+rdnom+'['+string(bk-1)+'].nmode!=0)'+...
                 ' && block_'+rdnom+'['+string(bk-1)+'].mode[0]==2)) {';]
          //*******//
          txt=[txt;
               Indent+elsetxt]
          //** C **//
          txt=[txt;
                '    }'];
          //*******//
        end
      end
    //** eventselect blk
    elseif funtyp(bk)==-2 then
      Noutport=clkptr(bk+1)-clkptr(bk);
      ix=-1+inplnk(inpptr(bk));
      TYPE=mat2c_typ(outtb(ix+1)); //** scilab index start from 1
      II=[];
      switchtxt=list()
      for i=1: Noutport
        switchtxt(i)=write_code_ozdoit(clkptr(bk)+i-1,flag);
        if switchtxt(i)<>[] then II=[II i];end
      end
      if II<>[] then
        txt=[txt;
             '    '+get_comment('evtselect_blk',list(bk));]
        //** C **//
        tmp_='*(('+TYPE+' *)'+XX_VARPREFIX+'outtbptr['+string(ix)+'])'
        txt=[txt;
             '    if (phase==1 || block_'+rdnom+'['+string(bk-1)+'].nmode==0) {';
             '      i=max(min((int) '+...
              tmp_+',block_'+rdnom+'['+string(bk-1)+'].evout),1);'
             '    }'
             '    else {'
             '      i=block_'+rdnom+'['+string(bk-1)+'].mode[0];'
             '    }']
        txt=[txt;
             '    switch(i)'
             '    {'];
        //*******//
        for i=II
          //** C **//
          txt=[txt;
               '     case '+string(i)+' :';]
          //*******//
          txt=[txt;
               BigIndent+write_code_ozdoit(clkptr(bk)+i-1,flag);]
          //** C **//
          txt=[txt;
               BigIndent+'break;']
          //*******//
        end
        //** C **//
        txt=[txt;
             '    }'];
        //*******//
      end
    //** Unknown block
    else
      error('Unknown block type '+string(bk));
    end
  end

endfunction

//write_code_zdoit : generate body of the code for
//                   ordering calls of blocks before
//                   continuous time zero crossing
//                   detection
//
//input : noting
//
//output : txt for flag 9
//
//12/07/07 Alan Layec
function [txt]=write_code_zdoit()
  txt=[];

  //** first pass (flag 1)
  for j=1:nzord
    bk=zord(j,1);
    pt=zord(j,2);
    //** blk
    if funtyp(bk)>-1 then
      if or(bk==act) | or(bk==cap) then
        if stalone then
          txt=[txt;
               '    '+call_block42(bk,pt,1)
               ''];
        end
      else
        txt2=call_block42(bk,pt,1);
        if txt2<>[] then
          txt=[txt;
               '    '+txt2
               ''];
        end
      end
    //** ifthenelse blk
    elseif funtyp(bk)==-1 then
      ix=-1+inplnk(inpptr(bk));
      TYPE=mat2c_typ(outtb(ix+1)); //** scilab index start from 1
      thentxt=write_code_ozdoit(clkptr(bk),1);
      elsetxt=write_code_ozdoit(clkptr(bk)+1,1);
      if thentxt<>[] | elsetxt<>[] then
        txt=[txt;
             '    '+get_comment('ifthenelse_blk',list(bk));]
        //** C **//
        tmp_ = '*(('+TYPE+' *)'+XX_VARPREFIX+'outtbptr['+string(ix)+'])'
        txt=[txt;
             '    if (((phase==1'+...
              ' || block_'+rdnom+'['+string(bk-1)+'].nmode==0)'+...
              ' && '+tmp_+'>0)'+...
              ' || \'
             '        ((phase!=1'+...
              ' && block_'+rdnom+'['+string(bk-1)+'].nmode!=0)'+...
              ' && block_'+rdnom+'['+string(bk-1)+'].mode[0]==1)) {']
        //*******//
        txt=[txt;
             Indent+thentxt]
        //** C **//
        txt=[txt;
             '    }'];
        //*******//
        if elsetxt<>[] then
           //** C **//
           txt=[txt;
                '      else if (((phase==1'+...
                 ' || block_'+rdnom+'['+string(bk-1)+'].nmode==0)'+...
                 ' && '+tmp_+'<=0)'+...
                 ' || \'
                '               ((phase!=1'+...
                 ' && block_'+rdnom+'['+string(bk-1)+'].nmode!=0)'+...
                 ' && block_'+rdnom+'['+string(bk-1)+'].mode[0]==2)) {';]
          //*******//
          txt=[txt;
               Indent+elsetxt]
          //** C **//
          txt=[txt;
               '    }'];
          //*******//
        end
      end
    //** eventselect blk
    elseif funtyp(bk)==-2 then
      Noutport=clkptr(bk+1)-clkptr(bk);
      ix=-1+inplnk(inpptr(bk));
      TYPE=mat2c_typ(outtb(ix+1)); //** scilab index start from 1
      II=[];
      switchtxt=list()
      for i=1: Noutport
        switchtxt(i)=write_code_ozdoit(clkptr(bk)+i-1,1);
        if switchtxt(i)<>[] then II=[II i];end
      end
      if II<>[] then
        txt=[txt;
             '    '+get_comment('evtselect_blk',list(bk));]
        //** C **//
        tmp_='*(('+TYPE+' *)'+XX_VARPREFIX+'outtbptr['+string(ix)+'])'
        txt=[txt;
             '    if (phase==1 || block_'+rdnom+'['+string(bk-1)+'].nmode==0){';
             '      i=max(min((int) '+...
               tmp_+',block_'+rdnom+'['+string(bk-1)+'].evout),1);'
             '    else {'
             '      i=block_'+rdnom+'['+string(bk-1)+'].mode[0];'
             '    }']
        txt=[txt;
             '      switch(i)'
             '      {'];
        //*******//
        for i=II
          //** C **//
          txt=[txt;
               '       case '+string(i)+' :';]
          //*******//
          txt=[txt;
               BigIndent+write_code_ozdoit(clkptr(bk)+i-1,1);]
          //** C **//
          txt=[txt;
               BigIndent+'break;']
          //*******//
        end
        //** C **//
        txt=[txt;
             '      }'];
        //*******//
      end
    //** Unknown block
    else
      error('Unknown block type '+string(bk));
    end
  end

  //** second pass (flag 9)
  for j=1:nzord
    bk=zord(j,1);
    pt=zord(j,2);
    //** blk
    if funtyp(bk)>-1 then
        if or(bk==act) | or(bk==cap) then 
          if stalone then
            txt=[txt;
                 '    '+call_block42(bk,pt,9)
                 ''];
          end
        else
          txt2=call_block42(bk,pt,9);
          if txt2<>[] then
            txt=[txt;
                 '    '+txt2
                 ''];
          end
        end

    //** ifthenelse blk
    elseif funtyp(bk)==-1 then
        ix=-1+inplnk(inpptr(bk));
        TYPE=mat2c_typ(outtb(ix+1)); //** scilab index start from 1
        //** C **//
        tmp_='*(('+TYPE+' *)'+XX_VARPREFIX+'outtbptr['+string(ix)+'])'
        //*******//
        thentxt=write_code_zzdoit(clkptr(bk),9);
        elsetxt=write_code_zzdoit(clkptr(bk)+1,9);
        txt=[txt;
             '    '+get_comment('ifthenelse_blk',list(bk));]
        //** C **//
        txt=[txt;
              '    g['+string(zcptr(bk)-1)+']=(double)'+tmp_+';']
        //*******//
        if thentxt<>[] | elsetxt<>[] then
           //** C **//
           txt=[txt;
                '    if (g['+string(zcptr(bk)-1)+'] > 0.){']
           //*******//
           txt=[txt;
                Indent+thentxt]
           //** C **//
           txt=[txt;
                '      }']
           //*******//
           if elsetxt <> [] then
             //** C **//
             txt=[txt;
                  '      else {']
             //*******//
             txt=[txt;
                  Indent+elsetxt]
             //** C **//
             txt=[txt;
                  '      }']
             //*******//
           end
        end
        //** C **//
        txt=[txt;
              '    if(phase==1 && block_'+rdnom+'['+string(bk-1)+'].nmode > 0){'
              '      if (g['+string(zcptr(bk)-1)+'] > 0.){'
              '        block_'+rdnom+'['+string(bk-1)+'].mode[0] = 1;'
              '      }'
              '      else {'
              '        block_'+rdnom+'['+string(bk-1)+'].mode[0] = 2;'
              '      }'
              '    }']
        //*******//
    //** eventselect blk
    elseif funtyp(bk)==-2 then
        Noutport=clkptr(bk+1)-clkptr(bk);
        ix=-1+inplnk(inpptr(bk));
        TYPE=mat2c_typ(outtb(ix+1));  //** scilab index start from 1
        //** C **//
        tmp_='*(('+TYPE+' *)'+XX_VARPREFIX+'outtbptr['+string(ix)+'])'
        //*******//
        II=[];
        switchtxt=list()
        for i=1:Noutport
          switchtxt(i)=write_code_zzdoit(clkptr(bk)+i-1,9);
          if switchtxt(i)<>[] then II=[II i];end
        end
        txt=[txt;
             '    '+get_comment('evtselect_blk',list(bk));]
        if II<>[] then
          //** C **//
          txt=[txt;
               '    j=max(min((int) '+...
                tmp_+',block_'+rdnom+'['+string(bk-1)+'].nevout),1);']
          txt=[txt;
               '    switch(j)'
               '    {'];
          //*******//
          for i=II
            //** C **//
            txt=[txt;
                 '     case '+string(j)+' :';]
            //*******//
            txt=[txt;
                 BigIndent+write_code_zzdoit(clkptr(bk)+i-1,9);]
            //** C **//
            txt=[txt;
                 BigIndent+'break;']
            //*******//
          end
          //** C **//
          txt=[txt;
               '    }'];
          //*******//
        end
        //** C **//
        txt=[txt;
             '  for (jj=0;jj<block_'+rdnom+'['+string(fun-1)+'].nevout-1;++jj) {'
             '    g['+string(zcptr(bk)-1)+'+jj]=(double)'+tmp_+'-(double)(jj+2);'
             '  }'
             '  if(phase==1 && block_'+rdnom+'['+string(bk-1)+'].nmode>0){'
             '    j=max(min((int) '+tmp_+','
             '              block_'+rdnom+'['+string(bk-1)+'].nevout),1);'
             '    block_'+rdnom+'['+string(bk-1)+'].mode[0]= j;'
             '  }']
        //*******//
    //** Unknown block
    else
      error('Unknown block type '+string(bk));
    end
  end

endfunction

//write_code_zzdoit : generate body of the code for
//                    flag 9
//
//input: ev  : evt number for block's call
//      flag : flag number for block's call
//
//output : txt for flag 9
//
//12/07/07 Alan Layec
function [txt]=write_code_zzdoit(ev,flag)
  txt=[];

  for j=ordptr(ev):ordptr(ev+1)-1
    bk=ordclk(j,1);
    pt=ordclk(j,2);
    //** blk
    if funtyp(bk)>-1 then
      if or(bk==act) | or(bk==cap) then
        if stalone then
          txt=[txt;
               '    '+call_block42(bk,pt,flag)
               ''];
        end
      else
        txt2=call_block42(bk,pt,flag);
        if txt2<>[] then
          txt=[txt;
               '    '+txt2
               ''];
        end
      end
    //** ifthenelse blk
    elseif funtyp(bk)==-1 then
        ix=-1+inplnk(inpptr(bk));
        TYPE=mat2c_typ(outtb(ix+1)); //** scilab index start from 1
        //** C **//
        tmp_='*(('+TYPE+' *)'+XX_VARPREFIX+'outtbptr['+string(ix)+'])'
        //*******//
        thentxt=write_code_zzdoit(clkptr(bk),9);
        elsetxt=write_code_zzdoit(clkptr(bk)+1,9);
        txt=[txt;
             '    '+get_comment('ifthenelse_blk',list(bk));]
        //** C **//
        txt=[txt;
              '    g['+string(zcptr(bk)-1)+']=(double)'+tmp_+';']
        //*******//
        if thentxt<>[] | elsetxt<>[] then
           //** C **//
           txt=[txt;
                '    if (g['+string(zcptr(bk)-1)+'] > 0.){']
           //*******//
           txt=[txt;
                Indent+thentxt]
           //** C **//
           txt=[txt;
                '      }']
           //*******//
           if elsetxt <> [] then
             //** C **//
             txt=[txt;
                  '      else {']
             //*******//
             txt=[txt;
                  Indent+elsetxt]
             //** C **//
             txt=[txt;
                  '      }']
             //*******//
           end
        end
        //** C **//
        txt=[txt;
              '    if(phase==1 && block_'+rdnom+'['+string(bk-1)+'].nmode > 0){'
              '      if (g['+string(zcptr(bk)-1)+'] > 0.){'
              '        block_'+rdnom+'['+string(bk-1)+'].mode[0] = 1;'
              '      }'
              '      else {'
              '        block_'+rdnom+'['+string(bk-1)+'].mode[0] = 2;'
              '      }'
              '    }']
        //*******//

    //** eventselect blk
    elseif funtyp(bk)==-2 then
        Noutport=clkptr(bk+1)-clkptr(bk);
        ix=-1+inplnk(inpptr(bk));
        TYPE=mat2c_typ(outtb(ix+1));  //** scilab index start from 1
        //** C **//
        tmp_='*(('+TYPE+' *)'+XX_VARPREFIX+'outtbptr['+string(ix)+'])'
        //*******//
        II=[];
        switchtxt=list()
        for i=1:Noutport
          switchtxt(i)=write_code_zzdoit(clkptr(bk)+i-1,9);
          if switchtxt(i)<>[] then II=[II i];end
        end
        txt=[txt;
             '    '+get_comment('evtselect_blk',list(bk));]
        if II<>[] then
          //** C **//
          txt=[txt;
               '    j=max(min((int) '+...
                tmp_+',block_'+rdnom+'['+string(bk-1)+'].nevout),1);']
          txt=[txt;
               '    switch(j)'
               '    {'];
          //*******//
          for i=II
            //** C **//
            txt=[txt;
                 '     case '+string(j)+' :';]
            //*******//
            txt=[txt;
                 BigIndent+write_code_zzdoit(clkptr(bk)+i-1,9);]
            //** C **//
            txt=[txt;
                 BigIndent+'break;']
            //*******//
          end
          //** C **//
          txt=[txt;
               '    }'];
          //*******//
        end
        //** C **//
        txt=[txt;
             '  for (jj=0;jj<block_'+rdnom+'['+string(fun-1)+'].nevout-1;++jj) {'
             '    g['+string(zcptr(bk)-1)+'+jj]=(double)'+tmp_+'-(double)(jj+2);'
             '  }'
             '  if(phase==1 && block_'+rdnom+'['+string(bk-1)+'].nmode>0){'
             '    j=max(min((int) '+tmp_+','
             '              block_'+rdnom+'['+string(bk-1)+'].nevout),1);'
             '    block_'+rdnom+'['+string(bk-1)+'].mode[0]= j;'
             '  }']
        //*******//

    //** Unknown block
    else
      error('Unknown block type '+string(bk));
    end
  end

endfunction

//mat2scs_c_typ matrix to scicos C type
//
//input : outtb : a matrix
//
//output : txt : the string of the C scicos type
//               of the data of outtb
//
//16/06/07 Author : A.Layec
function [txt]=mat2scs_c_typ(outtb)
 select type(outtb)
   //real matrix
   case 1 then
      if isreal(outtb) then
        txt = "SCSREAL_N"
      else
        txt = "SCSCOMPLEX_N"
      end
   //integer matrix
   case 8 then
      select typeof(outtb)
         case 'int32' then
           txt = "SCSINT32_N"
         case 'int16' then
           txt = "SCSINT16_N"
         case 'int8' then
           txt = "SCSINT8_N"
         case 'uint32' then
           txt = "SCSUINT32_N"
         case 'uint16' then
           txt = "SCSUINT16_N"
         case 'uint8' then
           txt = "SCSUINT8_N"
      end
   else
     break;
 end
endfunction

