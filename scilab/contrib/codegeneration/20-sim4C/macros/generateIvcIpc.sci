//Generate the 20-sim 4C interprocess communication files:
// ivcipc.c and ivcipc.h
//
//Author : Maarten Meijer
//
//
function ok=generateIvcIpc(nrParameters, nrInitialValues, nrVariables, nrStates, nrRates)

  //** Generate ivcipc.c
  Code=makeIvcIpc_c(nrParameters, nrInitialValues, nrVariables, nrStates, nrRates);
 
  //Create ivcipc.c
  ierr=execstr('mputl(Code,rpat+''/src/ivcipc.c'')', 'errcatch')
  if ierr<>0 then
    message(lasterror())
    ok=%f
  end
  
  //** Generate ivcipc.h
  Code=makeIvcIpc_h(nrParameters, nrInitialValues, nrVariables, nrStates, nrRates);
 
  //Create ivcipc.h
  ierr=execstr('mputl(Code,rpat+''/src/ivcipc.h'')', 'errcatch')
  if ierr<>0 then
    message(lasterror())
    ok=%f
  end
endfunction

//** Generate ivcipc.c
function Code=makeIvcIpc_c(nrParameters, nrInitialValues, nrVariables, nrStates, nrRates)
  Code=[makeHeaderComment('ivcipc.c')
        ''
        '#include '"ivcipc.h'"'
        '#include '"ivcstorage.h'"'
        '#include '"ivcdebug.h'"'
		''
		'#include '"'+XX_VARPREFIX+'model.h'"'
        ''
        '#include <stdio.h>'
        '#include <stdlib.h>'
        '#include <string.h>'
        ''
		'/* Set the special variable and parameter tables to the 20-sim default */'
		'#define ivcSpecialVariables '"xx_SV'"'
		'#define ivcSpecialParameters '"xx_SP'"'
		''
        '/**********************************************************'
        ' *The shared memory is declared prior to runnning in order to declare the memory outside the real-time loop'
        ' * It contains all the global variables, the parameters, the variables, the states and the rates.'
        ' * It has allocated memory for a list of variables (and others) that may be logged or monitored (logging & monitoring are mutual exclusive)'
        ' * It has allocated a fixed amount of memory for variables(and others) that may be monitored'
        ' * Futhermore it contains a little state information, e.g. to mark the parameters out of sync, to allow lock free data sharing, and to specifiy logging or monitoring operation.'
        ' *'
        ' * Lock free data sharing is used.'
        ' * The data is spit into two, '
        ' *      a part that receives parameters from the ''extern'' lib to the ''intern'' model (e --> i)'
        ' *      a part that sends the ''internal'' model state to the ''extern'' lib                       (i --> e)'
        ' * For both parts of the memory there will be one writer and one reader, therefore the memory size for exchanging data is (3 * data)'
        ' * The memory layout is as follows :'
        ' * _________________________'
        ' *     Offsets for lock free data sharing'
        ' * to_model_read_offset'
        ' * to_model_recent_offset'
        ' * from_model_read_offset'
        ' * from_model_recent_offset'
        ' * _________________________'
        ' * Data '
        ' * __________________________'
        ' * Data'
        ' * __________________________'
        ' * Data'
        ' * __________________________'
        ' * Monitor Data'
        ' * __________________________'
        ' *'
        ' * The layout of a single data block is the following :'
        ' * __________________________'
        ' * Parameters                                                                                           <--  to_model'
        ' * Special Parameters:                                                                               <--  to_model'
        ' *        start_time,  finish_time,  step_size, stop_simulation'
        ' * InitialValues                                                                                        <-- to_model'
        ' * Variables                                                                                             <-- from_model'
        ' * Special Variables:                                                                                 <-- from_model '
        ' *           time, executionTime                                                                     <-- from_model'
        ' * States                                                                                                 <-- from_model'
        ' * Rates                                                                                                   <-- from_model'
        '  *'
        ' * (monitor)'
        ' * count                                                                                                   <--to_model'
        ' * rate_divider                                                                                         <--to_model'
        ' * indexes                                                                                                <--to_model'
        ' * (log)'
        ' * count                                                                                                    <--to_model'
        ' * rate_divider                                                                                          <--to_model'
        ' * start_time                                                                                            <--to_model'
        ' * stop_time                                                                                             <--to_model'
        ' * indexes                                                                                                 <--to_model'
        ' * state                                                                                                    <--from_model'
        ' * sample_count                                                                                         <--from_model'
        ' * ___________________________'
        ' '
        ' **********************************************************/'
        ''
        '#define XX_TABLE_COUNT            7'
        '#define XX_SPECIAL_PARAMETERS     4'
        '#define XX_SPECIAL_VARIABLES      2'
        '#define XX_NUMBER_PARAMETERS      ' + string(nrParameters)
        '#define XX_NUMBER_INITIAL_VALUES  ' + string(nrInitialValues)
        '#define XX_NUMBER_VARIABLES       ' + string(nrVariables)
        '#define XX_NUMBER_STATES          ' + string(nrStates)
        ''
        '/* shm size and data size */'
        'XXInteger '+XX_VARPREFIX+'shm_size     = 0;'
        'XXInteger '+XX_VARPREFIX+'data_size    = 0;'
        '/* The size of the monitor is chosen such that it can hold 8 doubles for a period of 1/2 sec at 1024 hz */'
        'XXInteger xx_monitor_size    = 4096;'
        ''
        '/* The size of the log buffer is 4MB */'
        'XXInteger xx_log_size        = %TC_MAX_LOG_SIZE%;'
        ''
        '/* all the size are in bytes */'
        'XXInteger '+XX_VARPREFIX+'size_ptr                           = sizeof(XXInteger) * 8;                              /*the size of the lock free data offsets */'
        'XXInteger '+XX_VARPREFIX+'size_'+XX_PARAMETER_NAME+'     = sizeof(XXDouble) * (XX_NUMBER_PARAMETERS   + 1);'
        'XXInteger '+XX_VARPREFIX+'size_S'+XX_PARAMETER_NAME+'    = sizeof(XXDouble) * (XX_SPECIAL_PARAMETERS + 1);'
        'XXInteger '+XX_VARPREFIX+'size_'+XX_INIT_VALUE_NAME+' = sizeof(XXDouble) * (XX_NUMBER_INITIAL_VALUES + 1);'
        'XXInteger '+XX_VARPREFIX+'size_'+XX_VARIABLE_NAME+'      = sizeof(XXDouble) * (XX_NUMBER_VARIABLES    + 1);'
        'XXInteger '+XX_VARPREFIX+'size_S'+XX_VARIABLE_NAME+'     = sizeof(XXDouble) * (XX_SPECIAL_VARIABLES  + 1);'
        'XXInteger '+XX_VARPREFIX+'size_'+XX_STATE_NAME+'         = sizeof(XXDouble) * (XX_NUMBER_STATES       + 1);'
        ''
        '/* the total number of parameters, initial values, variables, states & rates */'
        'XXInteger '+XX_VARPREFIX+'index_count = (XX_NUMBER_PARAMETERS + 1) + (XX_SPECIAL_PARAMETERS + 1) + (XX_NUMBER_INITIAL_VALUES + 1) + (XX_NUMBER_VARIABLES + 1) + (XX_SPECIAL_VARIABLES + 1) + (2 * (XX_NUMBER_STATES + 1));'
        ''
        '/* the offsets(bytes)  within data segments */'
        'XXInteger '+XX_VARPREFIX+'offset_'+XX_PARAMETER_NAME+'      = 0;'
        'XXInteger '+XX_VARPREFIX+'offset_S'+XX_PARAMETER_NAME+'     = 0;'
        'XXInteger '+XX_VARPREFIX+'offset_'+XX_INIT_VALUE_NAME+'  = 0;'
        'XXInteger '+XX_VARPREFIX+'offset_'+XX_VARIABLE_NAME+'       = 0;'
        'XXInteger '+XX_VARPREFIX+'offset_S'+XX_VARIABLE_NAME+'      = 0;'
        'XXInteger '+XX_VARPREFIX+'offset_'+XX_STATE_NAME+'          = 0;'
        'XXInteger '+XX_VARPREFIX+'offset_'+XX_RATE_NAME+'           = 0;'
        'XXInteger '+XX_VARPREFIX+'offset_monitor_count                  = 0;'
        'XXInteger '+XX_VARPREFIX+'offset_monitor_rate_divider           = 0;'
        'XXInteger '+XX_VARPREFIX+'offset_monitor_indexes                = 0;'
        'XXInteger '+XX_VARPREFIX+'offset_log_count                      = 0;'
        'XXInteger '+XX_VARPREFIX+'offset_log_rate_divider               = 0;'
        'XXInteger '+XX_VARPREFIX+'offset_log_indexes                    = 0;'
        'XXInteger '+XX_VARPREFIX+'offset_log_start_time                 = 0;'
        'XXInteger '+XX_VARPREFIX+'offset_log_stop_time                  = 0;'
        'XXInteger '+XX_VARPREFIX+'offset_log_state                      = 0;'
        'XXInteger '+XX_VARPREFIX+'offset_log_sample_count               = 0;'
        ''
        ''
        '/* reference  and offsets to various parts of the shared memory */'
        'void*      '+XX_VARPREFIX+'shm                       = NULL;		/* The complete shared memory */'
        'void*      '+XX_VARPREFIX+'shm_log                   = NULL;		/* The shared memory for logging*/'
        ''
        '/* lock free offsets for the data */'
        'XXInteger* '+XX_VARPREFIX+'to_model_read_offset      = NULL;		/*  to model read offset*/'
        'XXInteger* '+XX_VARPREFIX+'to_model_recent_offset    = NULL;		/*  to model most recent offset */'
        'XXInteger* '+XX_VARPREFIX+'from_model_read_offset    = NULL;		/*  from model read offset */'
        'XXInteger* '+XX_VARPREFIX+'from_model_recent_offset  = NULL;		/*  from model most recent offset */'
        'XXInteger  '+XX_VARPREFIX+'data1_offset              = 0;		/* The first data block in the shared memory */'
        'XXInteger  '+XX_VARPREFIX+'data2_offset              = 0;		/* The second data block in the shared memory */'
        'XXInteger  '+XX_VARPREFIX+'data3_offset              = 0;		/* The third data block in the shared memory */'
        'XXInteger  xx_monitor_offset            = 0;		/* The monitor block in the shared memory */'
        ''
        '/* local state */'
        'XXInteger '+XX_VARPREFIX+'to_model_read_prev = -1;    /*bogus value, will force update for the first time */'
        ''
        'XXInteger xx_monitor_active_count = 0;'
        'XXInteger xx_monitor_rate_divider = 1;'
        'XXInteger xx_monitor_rate_divider_count = 0;'
        'XXInteger xx_monitor_write_offset = 0;'
        'XXInteger xx_monitor_active_indexes[ (XX_NUMBER_PARAMETERS + 1) + (XX_SPECIAL_PARAMETERS + 1) + (XX_NUMBER_INITIAL_VALUES + 1) + (XX_NUMBER_VARIABLES + 1) + (XX_SPECIAL_VARIABLES + 1) + (2 * (XX_NUMBER_STATES + 1)) ]; '
        ''
        'XXInteger xx_log_active_count = 0;'
        'XXInteger xx_log_rate_divider = 1;'
        'XXInteger xx_log_rate_divider_count = 0;'
        'XXInteger xx_log_write_offset = 0;'
        'XXInteger xx_log_active_indexes[ (XX_NUMBER_PARAMETERS + 1) + (XX_SPECIAL_PARAMETERS + 1) + (XX_NUMBER_INITIAL_VALUES + 1) + (XX_NUMBER_VARIABLES + 1) + (XX_SPECIAL_VARIABLES + 1) + (2 * (XX_NUMBER_STATES + 1)) ];'
        'XXDouble xx_log_start_time = 0.0;'
        'XXDouble xx_log_stop_time = 0.0;'
        'XXInteger xx_log_state = 0;'
        'XXInteger xx_log_sample_count = 0;'
        ''
        ''
        'void ipcInitializeSizes(void)'
        '{'
        '	/* The data size contains all shareable data */'
        '	'+XX_VARPREFIX+'data_size = '+XX_VARPREFIX+'size_'+XX_PARAMETER_NAME+''
        '						 + '+XX_VARPREFIX+'size_S'+XX_PARAMETER_NAME+''
        '						 + '+XX_VARPREFIX+'size_'+XX_INIT_VALUE_NAME+''
        '						 + '+XX_VARPREFIX+'size_'+XX_VARIABLE_NAME+''
        '						 + '+XX_VARPREFIX+'size_S'+XX_VARIABLE_NAME+''
        '						 + '+XX_VARPREFIX+'size_'+XX_STATE_NAME+''
        '						 + '+XX_VARPREFIX+'size_'+XX_STATE_NAME+''
        '						 + sizeof(XXInteger)                               /* the monitor count */'
        '						 + sizeof(XXInteger)                               /* the monitor rate divider */'
        '						 + ( '+XX_VARPREFIX+'index_count * sizeof(XXInteger) )  /* the monitor indexes */'
        '						 + sizeof(XXInteger)                               /* the log count */'
        '						 + sizeof(XXInteger)                               /* the log rate divider */'
        '						 + sizeof(XXDouble)                                /* the log start time */'
        '						 + sizeof(XXDouble)                                /* the log stop time */'
        '						 + ( '+XX_VARPREFIX+'index_count * sizeof(XXInteger) ) /* the log indexes */'
        '						 + sizeof(XXInteger)                               /* the log state */'
        '						 + sizeof(XXInteger);                              /* the log sample_count */'
        ''
        '	/* The total size of the shared memory is the datasize plus the read / most recent integers  */'
        '	'+XX_VARPREFIX+'shm_size = '+XX_VARPREFIX+'size_ptr + (3 * '+XX_VARPREFIX+'data_size) + xx_monitor_size;'
        ''
        '	/* the model data block offsets */'
        '	'+XX_VARPREFIX+'data1_offset   = '+XX_VARPREFIX+'size_ptr;'
        '	'+XX_VARPREFIX+'data2_offset   = '+XX_VARPREFIX+'data1_offset + '+XX_VARPREFIX+'data_size;'
        '	'+XX_VARPREFIX+'data3_offset   = '+XX_VARPREFIX+'data2_offset + '+XX_VARPREFIX+'data_size;'
        '	xx_monitor_offset = '+XX_VARPREFIX+'data3_offset + '+XX_VARPREFIX+'data_size;'
        ''
        '	/* the offsets in the data blocks */'
        '	'+XX_VARPREFIX+'offset_'+XX_PARAMETER_NAME+'      = 0;'
        '	'+XX_VARPREFIX+'offset_S'+XX_PARAMETER_NAME+'     = '+XX_VARPREFIX+'offset_'+XX_PARAMETER_NAME+'  + '+XX_VARPREFIX+'size_'+XX_PARAMETER_NAME+';'
        '	'+XX_VARPREFIX+'offset_'+XX_INIT_VALUE_NAME+'  = '+XX_VARPREFIX+'offset_S'+XX_PARAMETER_NAME+' + '+XX_VARPREFIX+'size_S'+XX_PARAMETER_NAME+';'
        '	'+XX_VARPREFIX+'offset_'+XX_VARIABLE_NAME+'       = '+XX_VARPREFIX+'offset_'+XX_INIT_VALUE_NAME+' + '+XX_VARPREFIX+'size_'+XX_INIT_VALUE_NAME+';'
        '	'+XX_VARPREFIX+'offset_S'+XX_VARIABLE_NAME+'      = '+XX_VARPREFIX+'offset_'+XX_VARIABLE_NAME+'  + '+XX_VARPREFIX+'size_'+XX_VARIABLE_NAME+';'
        '	'+XX_VARPREFIX+'offset_'+XX_STATE_NAME+'          = '+XX_VARPREFIX+'offset_S'+XX_VARIABLE_NAME+' + '+XX_VARPREFIX+'size_S'+XX_VARIABLE_NAME+';'
        '	'+XX_VARPREFIX+'offset_'+XX_RATE_NAME+'           = '+XX_VARPREFIX+'offset_'+XX_STATE_NAME+'  + '+XX_VARPREFIX+'size_'+XX_STATE_NAME+';'
        ''
        '	/* the monitor information */'
        '	'+XX_VARPREFIX+'offset_monitor_count        = '+XX_VARPREFIX+'offset_R  + '+XX_VARPREFIX+'size_'+XX_STATE_NAME+';'
        '	'+XX_VARPREFIX+'offset_monitor_rate_divider = '+XX_VARPREFIX+'offset_monitor_count + sizeof(XXInteger);'
        '	'+XX_VARPREFIX+'offset_monitor_indexes      = '+XX_VARPREFIX+'offset_monitor_rate_divider + sizeof(XXInteger);'
        ''
        '	/* the log information */'
        '	'+XX_VARPREFIX+'offset_log_count            = '+XX_VARPREFIX+'offset_monitor_indexes + ( sizeof(XXInteger) * '+XX_VARPREFIX+'index_count );'
        '	'+XX_VARPREFIX+'offset_log_rate_divider     = '+XX_VARPREFIX+'offset_log_count + sizeof(XXInteger);'
        '	'+XX_VARPREFIX+'offset_log_indexes          = '+XX_VARPREFIX+'offset_log_rate_divider + sizeof(XXInteger);'
        '	'+XX_VARPREFIX+'offset_log_start_time       = '+XX_VARPREFIX+'offset_log_indexes + ( sizeof(XXInteger) * '+XX_VARPREFIX+'index_count );'
        '	'+XX_VARPREFIX+'offset_log_stop_time        = '+XX_VARPREFIX+'offset_log_start_time + sizeof(XXDouble);'
        '	'+XX_VARPREFIX+'offset_log_state            = '+XX_VARPREFIX+'offset_log_stop_time + sizeof(XXDouble);'
        '	'+XX_VARPREFIX+'offset_log_sample_count     = '+XX_VARPREFIX+'offset_log_state + sizeof(XXInteger);'
        ''
        '}'
        ''
        'void ipcInitializePointers(void)'
        '{'
        '	/* the lock free data offsets reference and values*/'
        '	'+XX_VARPREFIX+'to_model_read_offset        = ((XXInteger*)'+XX_VARPREFIX+'shm);		/*  read address block at start of shm*/'
        '	'+XX_VARPREFIX+'to_model_recent_offset      = '+XX_VARPREFIX+'to_model_read_offset + 1;'
        '	'+XX_VARPREFIX+'from_model_read_offset      = '+XX_VARPREFIX+'to_model_read_offset + 2;'
        '	'+XX_VARPREFIX+'from_model_recent_offset    = '+XX_VARPREFIX+'to_model_read_offset + 3;'
        '}'
        ''
        '#ifndef IPC_LIBRARY'
        ''
        'int '+XX_FUNCTIONPREFIX+'OpenSharedMemory(void)'
        '{'
        '	/* Initializse the sizes */'
        '	ipcInitializeSizes();'
        ''
        '	if ( OpenSharedMemory('"%SUBMODEL_NAME%'", '+XX_VARPREFIX+'shm_size, &'+XX_VARPREFIX+'shm) != 0 )'
        '	{'
        '		FPRINTF(stderr, '"Fatal Error : The shared memory cannot be opened.\n'");'
        ''
        '		/* close the streams */'
        '		FPRINTF(stdout, '"Application has been terminated.\n'");'
        '		FCLOSE(stdout);'
        '		FCLOSE(stderr);'
        ''
        '		exit(1);'
        '	}'
        ''
        '	if ( OpenSharedMemory('"%SUBMODEL_NAME%_LOG'", xx_log_size, &'+XX_VARPREFIX+'shm_log) != 0 )'
        '	{'
        '		FPRINTF(stderr, '"Fatal Error : The shared memory for logging cannot be opened.\n'");'
        ''
        '		/* close the streams */'
        '		FPRINTF(stdout, '"Application has been terminated.\n'");'
        '		FCLOSE(stdout);'
        '		FCLOSE(stderr);'
        ''
        '		exit(1);'
        '	}'
        ''
        '	/* memset everything to zero */'
        '	memset('+XX_VARPREFIX+'shm_log, 0, xx_log_size);'
        ''
        '	/* Initialize the data pointers */'
        '	ipcInitializePointers();'
        ''
        '	return 0;'
        '}'
        ''
        'void '+XX_FUNCTIONPREFIX+'CloseSharedMemory(void)'
        '{'
        '	CloseSharedMemory('"%SUBMODEL_NAME%'", &'+XX_VARPREFIX+'shm);'
        '}'
        ''
        ''
        'void '+XX_FUNCTIONPREFIX+'SharedMemoryToModel(void)'
        '{'
        '	/* Set the ''model read offset'' to the ''most recent offset'' */'
        '	'+XX_VARPREFIX+'to_model_read_offset[0] = '+XX_VARPREFIX+'to_model_recent_offset[0];'
        ''
        '	/* If the read offset equals the previous read offset no new data has been received */'
        '	/* Get parameters (and perform static calculation */'
        '	if ( '+XX_VARPREFIX+'to_model_read_offset[0] != '+XX_VARPREFIX+'to_model_read_prev )'
        '	{'
        '		/*Set the previous read off set to detect if new values are written */'
        '		'+XX_VARPREFIX+'to_model_read_prev = '+XX_VARPREFIX+'to_model_read_offset[0];'
        '		FPRINTF(stdout, '"[%f] Model received update.\n'", '+XX_VARPREFIX+'time);'
		''
        '		/*Copy the parameters from the shared memory*/'
        '		memcpy ('+XX_VARPREFIX+''+XX_PARAMETER_NAME+', '+XX_VARPREFIX+'shm + '+XX_VARPREFIX+'to_model_read_offset[0], '+XX_VARPREFIX+'size_'+XX_PARAMETER_NAME+');'
        ''
        '		/*Copy the special parameters from the shared memory */'
        '		XXDouble* special_parameters = '+XX_VARPREFIX+'shm + '+XX_VARPREFIX+'to_model_read_offset[0] + '+XX_VARPREFIX+'offset_S'+XX_PARAMETER_NAME+';'
        '		'+XX_VARPREFIX+'start_time      = special_parameters[0];'
        '		'+XX_VARPREFIX+'finish_time     = special_parameters[1];'
        '		'+XX_VARPREFIX+'step_size       = special_parameters[2];'
        '		'+XX_VARPREFIX+'stop_simulation = ( special_parameters[3] > 0 ) ? XXTRUE : XXFALSE;'
        ''
        '		/*Copy the initial values from the shared memory*/'
        '		memcpy ('+XX_VARPREFIX+''+XX_INIT_VALUE_NAME+', '+XX_VARPREFIX+'shm + '+XX_VARPREFIX+'to_model_read_offset[0] + '+XX_VARPREFIX+'offset_'+XX_INIT_VALUE_NAME+', '+XX_VARPREFIX+'size_'+XX_INIT_VALUE_NAME+');'
        ''
        '		/* Copy the monitor info from the shared memory */'
        '		XXInteger monitor_count = 0;'
        '		memcpy (&monitor_count, '+XX_VARPREFIX+'shm + '+XX_VARPREFIX+'to_model_read_offset[0] + '+XX_VARPREFIX+'offset_monitor_count, sizeof(monitor_count) );'
        '		memcpy (&xx_monitor_rate_divider, '+XX_VARPREFIX+'shm + '+XX_VARPREFIX+'to_model_read_offset[0] + '+XX_VARPREFIX+'offset_monitor_rate_divider, sizeof(xx_monitor_rate_divider) );'
        ''
        '		if (monitor_count != xx_monitor_active_count)'
        '		{'
        '			/* monitor count has been changed */'
        '			xx_monitor_active_count = monitor_count;'
        ''
        '			/* Clear the montitor data and the offset and start again */'
        '			memset('+XX_VARPREFIX+'shm + xx_monitor_offset, 0, xx_monitor_size);'
        '			xx_monitor_write_offset = 0;'
        ''
        '			/*Copy the monitor information from the shared memory*/'
        '			/* TODO copy the correct count!! */'
        '			memcpy (xx_monitor_active_indexes, '+XX_VARPREFIX+'shm + '+XX_VARPREFIX+'to_model_read_offset[0] + '+XX_VARPREFIX+'offset_monitor_indexes, sizeof(XXInteger) * ( xx_monitor_active_count + 8) );'
        ''
        '			/* Set the rate divider to max, so that sampling starts at zero */'
        '			xx_monitor_rate_divider_count = xx_monitor_rate_divider;'
        ''
        '			FPRINTF(stdout, '"[%f] The monitor count has changed to %i\n'", '+XX_VARPREFIX+'time, xx_monitor_active_count);'
        '		}'
        ''
        '		/* ----------------------------------------------------- */'
        '		/* Copy the log info from the shared memory */'
        '		/* ----------------------------------------------------- */'
        '		XXInteger log_count = 0;'
        '		memcpy (&log_count, '+XX_VARPREFIX+'shm + '+XX_VARPREFIX+'to_model_read_offset[0] + '+XX_VARPREFIX+'offset_log_count, sizeof(log_count) );'
        ''
        '		if (log_count != xx_log_active_count)'
        '		{'
        '			/*Only start if the previous log count is 0 */'
        '			if (xx_log_active_count == 0)'
        '			{'
        '			xx_log_state = 0;'
        '			xx_log_sample_count = 0;'
        ''
        '			/* log count has been changed */'
        '			xx_log_active_count = log_count;'
        ''
        '			/* Set the rate divider */'
        '			memcpy (&xx_log_rate_divider, '+XX_VARPREFIX+'shm + '+XX_VARPREFIX+'to_model_read_offset[0] + '+XX_VARPREFIX+'offset_log_rate_divider, sizeof(xx_log_rate_divider) );'
        ''
        '			/* Set the start time */'
        '			memcpy (&xx_log_start_time, '+XX_VARPREFIX+'shm + '+XX_VARPREFIX+'to_model_read_offset[0] + '+XX_VARPREFIX+'offset_log_start_time, sizeof(xx_log_start_time) );'
        ''
        '			/* Set the stop time */'
        '			memcpy (&xx_log_stop_time, '+XX_VARPREFIX+'shm + '+XX_VARPREFIX+'to_model_read_offset[0] + '+XX_VARPREFIX+'offset_log_stop_time, sizeof(xx_log_stop_time) );'
        ''
        '			/*Copy the monitor information from the shared memory*/'
        '			memcpy (xx_log_active_indexes, '+XX_VARPREFIX+'shm + '+XX_VARPREFIX+'to_model_read_offset[0] + '+XX_VARPREFIX+'offset_log_indexes, sizeof(XXInteger) * ( xx_log_active_count + 8 ) );'
        ''
        '			'
        '			/* Set the rate divider to max, so that sampling starts at zero */'
        '			xx_log_rate_divider_count = xx_log_rate_divider;'
        '			'
        '			FPRINTF(stdout,'"[%f] The log has been set %i signals, %i rate divider, %f starttime, %f stoptime.\n'", '+XX_VARPREFIX+'time, xx_log_active_count, xx_log_rate_divider, xx_log_start_time, xx_log_stop_time);'
        '			}'
        '			else'
        '			{'
        '				FPRINTF(stderr,'"The log count has changed but already logging, previous log is not cleared.\n'");'
        '			}'
        '		}'
        '		else'
        '		{'
        '			/* Log count reset */'
        '			if (log_count == 0)'
        '			{'
        '				xx_log_state = 0;'
        '				xx_log_sample_count = 0;'
        '			}'
        '		}'
        '	}'
        '}'
        ''
        'void '+XX_FUNCTIONPREFIX+'InitializeFromSharedMemory(void)'
        '{'
        '	'+XX_FUNCTIONPREFIX+'SharedMemoryToModel();'
        '}'
        ''
        'void '+XX_FUNCTIONPREFIX+'SynchronizeSharedMemory(void)'
        '{'
        '	/*'
        '	// Copy values from shm to model'
        '	*/'
        '	'+XX_FUNCTIONPREFIX+'SharedMemoryToModel();'
        ''
        '	/*'
        '	// Copy values from model to shm'
        '	*/'
        ''
        '	/* First find the new write offset from model */'
        '	/* The new write offset must differ from the read offset and the most recent offset */'
        '	XXInteger w_offset = '+XX_VARPREFIX+'data1_offset;'
        '	'
        '	if ( (w_offset == '+XX_VARPREFIX+'from_model_read_offset[0]) || (w_offset == '+XX_VARPREFIX+'from_model_recent_offset[0]) ) '
        '	{'
        '		w_offset= '+XX_VARPREFIX+'data2_offset; '
        '		if ( (w_offset == '+XX_VARPREFIX+'from_model_read_offset[0]) || (w_offset == '+XX_VARPREFIX+'from_model_recent_offset[0]) ) '
        '		{'
        '			w_offset = '+XX_VARPREFIX+'data3_offset; '
        '		}'
        '	}'
        ''
        '	/* set the write pointer to shm + data offset */'
        '	void* w_ptr = '+XX_VARPREFIX+'shm + w_offset;'
        ''
        '	/*Copy the variables*/'
        '	memcpy (w_ptr + '+XX_VARPREFIX+'offset_'+XX_VARIABLE_NAME+', '+XX_VARPREFIX+''+XX_VARIABLE_NAME+', '+XX_VARPREFIX+'size_'+XX_VARIABLE_NAME+' );'
        ''
        '	/* Copy the special variables */'
        '	/* Copy the time */'
        '	XXDouble* tmpSpecialVariables = w_ptr + '+XX_VARPREFIX+'offset_S'+XX_VARIABLE_NAME+';'
        '	tmpSpecialVariables[0] = '+XX_VARPREFIX+'time;'
        '	tmpSpecialVariables[1] = '+XX_VARPREFIX+'executionTime;'
        ''
        '	/*Copy the states*/'
        '	memcpy (w_ptr + '+XX_VARPREFIX+'offset_'+XX_STATE_NAME+', '+XX_VARPREFIX+''+XX_STATE_NAME+', '+XX_VARPREFIX+'size_'+XX_STATE_NAME+' );'
        ''
        '	/*Copy the rates*/'
        '	memcpy (w_ptr + '+XX_VARPREFIX+'offset_'+XX_RATE_NAME+', '+XX_VARPREFIX+''+XX_RATE_NAME+', '+XX_VARPREFIX+'size_'+XX_STATE_NAME+' );'
        ''
        '	/* If monitor_active_count > 0 ,write the indexed monitor values to the monitor shared memory */'
        '	if ( xx_monitor_active_count > 0 )'
        '	{'
        '		/* First check if the rateDivider has reached its count */'
        '		xx_monitor_rate_divider_count++;'
        '		if (xx_monitor_rate_divider_count >= xx_monitor_rate_divider)'
        '		{'
        '			xx_monitor_rate_divider_count = 0;'
        '		'
        '			/* Check if data still fits in the buffer, if not recycle buffer by writing at zero position */'
        '			if ( ( xx_monitor_write_offset + (sizeof(XXDouble) * xx_monitor_active_count) )>= xx_monitor_size ) '
        '			{ '
        '				xx_monitor_write_offset = 0;'
        '			}'
        ''
        '			/* First write the time */'
        '			memcpy ('+XX_VARPREFIX+'shm + xx_monitor_offset + xx_monitor_write_offset, &'+XX_VARPREFIX+'time , sizeof(XXDouble) );'
        '			xx_monitor_write_offset += sizeof(XXDouble);'
        ''
        '			int i = 0;'
        '			int index = 0;'
        '			int table_index = 0;'
        ''
        '			int cur_count = xx_monitor_active_indexes[ index ];'
        '			index++;'
        '			for (i = 1; i <= cur_count; i++)'
        '			{'
        '				table_index = xx_monitor_active_indexes[index];'
        '				memcpy ('+XX_VARPREFIX+'shm + xx_monitor_offset + xx_monitor_write_offset, &'+XX_PARAMETER_ARRAY_NAME+'[table_index] , sizeof(XXDouble) );'
        ''
        '				/* Increase the write offset */'
        '				xx_monitor_write_offset += sizeof(XXDouble);'
        '				index++;'
        '			}'
        ''
        '			/* Skip the SP table */'
        '			/* TODO iterate all the tables in correct order */'
        '			index++;'
        ''
        '			/* The initial values */'
        '			cur_count = xx_monitor_active_indexes[ index ];'
        '			index++;'
        '			for (i = 1; i <= cur_count; i++)'
        '			{'
        '				table_index = xx_monitor_active_indexes[index];'
        '				memcpy ('+XX_VARPREFIX+'shm + xx_monitor_offset + xx_monitor_write_offset, &'+XX_INIT_VALUE_ARRAY_NAME+'[table_index] , sizeof(XXDouble) );'
        ''
        '				/* Increase the write offset */'
        '				xx_monitor_write_offset += sizeof(XXDouble);'
        '				index++;'
        '			}'
        ''
        '			/* The variables */'
        '			cur_count = xx_monitor_active_indexes[ index ];'
        '			index++;'
        '			for (i = 1; i <= cur_count; i++)'
        '			{'
        '				table_index = xx_monitor_active_indexes[index];'
        '				memcpy ('+XX_VARPREFIX+'shm + xx_monitor_offset + xx_monitor_write_offset, &'+XX_VARIABLE_ARRAY_NAME+'[table_index] , sizeof(XXDouble) );'
        ''
        '				/* Increase the write offset */'
        '				xx_monitor_write_offset += sizeof(XXDouble);'
        '				index++;'
        '			}'
        ''
        '			/* Skip the SV table */'
        '			/* TODO iterate all the tables in correct order */'
        '			index++;'
        ''
        '			/* The states */'
        '			cur_count = xx_monitor_active_indexes[ index ];'
        '			index++;'
        '			for (i = 1; i <= cur_count; i++)'
        '			{'
        '				table_index = xx_monitor_active_indexes[index];'
        '				memcpy ('+XX_VARPREFIX+'shm + xx_monitor_offset + xx_monitor_write_offset, &'+XX_STATE_ARRAY_NAME+'[table_index] , sizeof(XXDouble) );'
        ''
        '				/* Increase the write offset */'
        '				xx_monitor_write_offset += sizeof(XXDouble);'
        '				index++;'
        '			}'
        ''
        '			/* The rates */'
        '			cur_count = xx_monitor_active_indexes[ index ];'
        '			index++;'
        '			for (i = 1; i <= cur_count; i++)'
        '			{'
        '				table_index = xx_monitor_active_indexes[index];'
        '				memcpy ('+XX_VARPREFIX+'shm + xx_monitor_offset + xx_monitor_write_offset, &'+XX_RATE_ARRAY_NAME+'[table_index] , sizeof(XXDouble) );'
        ''
        '				/* Increase the write offset */'
        '				xx_monitor_write_offset += sizeof(XXDouble);'
        '				index++;'
        '			}'
        '		}'
        '	}'
        ''
        '	/* If log_active_count > 0 ,write the indexed log values to the log shared memory */'
        '	if ( ( xx_log_active_count > 0 ) && ('+XX_VARPREFIX+'shm_log != NULL) )'
        '	{'
        '		/* Check if current time is in between start_time & stop_time */'
        '		if ( ( '+XX_VARPREFIX+'time >= xx_log_start_time ) && ('+XX_VARPREFIX+'time <= xx_log_stop_time) )'
        '		{'
        '			xx_log_state = 1;'
        ''
        '			/* First check if the rateDivider has reached its count */'
        '			xx_log_rate_divider_count++;'
        '			'
        '			/* Check if data still fits in the buffer, if not recycle buffer by writing at zero position, better than stopping */'
        '			if ( ( xx_log_write_offset + (sizeof(XXDouble) * ( xx_log_active_count + 1 ) ) )>= xx_log_size ) '
        '			{ '
        '				xx_log_write_offset = 0;'
        '				xx_log_sample_count = 0;'
        '			}'
        ''
        '			if (xx_log_rate_divider_count >= xx_log_rate_divider)'
        '			{'
        '				xx_log_rate_divider_count = 0;'
        ''
        '				/* First write the time */'
        '				memcpy ('+XX_VARPREFIX+'shm_log + xx_log_write_offset, &'+XX_VARPREFIX+'time , sizeof(XXDouble) );'
        '				xx_log_write_offset += sizeof(XXDouble);'
        ''
        '				int i = 0;'
        '				int index = 0;'
        '				int table_index = 0;'
        '				'
        '				int cur_count = xx_log_active_indexes[ index ];'
        '				index++;'
        '				for (i = 1; i <= cur_count; i++)'
        '				{'
        '					table_index = xx_log_active_indexes[index];'
        '					memcpy ('+XX_VARPREFIX+'shm_log + xx_log_write_offset, &'+XX_VARPREFIX+''+XX_PARAMETER_NAME+'[table_index] , sizeof(XXDouble) );'
        ''
        '					/* Increase the write offset */'
        '					xx_log_write_offset += sizeof(XXDouble);'
        '					index++;'
        '				}'
        ''
        '				/* Skip the SP table */'
        '				/* TODO iterate all the tables in correct order */'
        '				index++;'
        ''
        '				/* The initial values */'
        '				cur_count = xx_log_active_indexes[ index ];'
        '				index++;'
        '				for (i = 1; i <= cur_count; i++)'
        '				{'
        '					table_index = xx_log_active_indexes[index];'
        '					memcpy ('+XX_VARPREFIX+'shm_log + xx_log_write_offset, &'+XX_VARPREFIX+''+XX_INIT_VALUE_NAME+'[table_index] , sizeof(XXDouble) );'
        ''
        '					/* Increase the write offset */'
        '					xx_log_write_offset += sizeof(XXDouble);'
        '					index++;'
        '				}'
        ''
        '				/* The variables */'
        '				cur_count = xx_log_active_indexes[ index ];'
        '				index++;'
        '				for (i = 1; i <= cur_count; i++)'
        '				{'
        '					table_index = xx_log_active_indexes[index];'
        '					memcpy ('+XX_VARPREFIX+'shm_log + xx_log_write_offset, &'+XX_VARPREFIX+''+XX_VARIABLE_NAME+'[table_index] , sizeof(XXDouble) );'
        ''
        '					/* Increase the write offset */'
        '					xx_log_write_offset += sizeof(XXDouble);'
        '					index++;'
        '				}'
        ''
        '				/* Skip the SV table */'
        '				/* TODO iterate all the tables in correct order */'
        '				index++;'
        ''
        '				/* The states */'
        '				cur_count = xx_log_active_indexes[ index ];'
        '				index++;'
        '				for (i = 1; i <= cur_count; i++)'
        '				{'
        '					table_index = xx_log_active_indexes[index];'
        '					memcpy ('+XX_VARPREFIX+'shm_log + xx_log_write_offset, &'+XX_VARPREFIX+''+XX_STATE_NAME+'[table_index] , sizeof(XXDouble) );'
        ''
        '					/* Increase the write offset */'
        '					xx_log_write_offset += sizeof(XXDouble);'
        '					index++;'
        '				}'
        ''
        '				/* The rates */'
        '				cur_count = xx_log_active_indexes[ index ];'
        '				index++;'
        '				for (i = 1; i <= cur_count; i++)'
        '				{'
        '					table_index = xx_log_active_indexes[index];'
        '					memcpy ('+XX_VARPREFIX+'shm_log + xx_log_write_offset, &'+XX_VARPREFIX+''+XX_RATE_NAME+'[table_index] , sizeof(XXDouble) );'
        ''
        '					/* Increase the write offset */'
        '					xx_log_write_offset += sizeof(XXDouble);'
        '					index++;'
        '				}'
        ''
        '				/* Increase the sample count */'
        '				xx_log_sample_count++;'
        '			}'
        '		}'
        ''
        '		if ('+XX_VARPREFIX+'time >= xx_log_stop_time)'
        '		{'
        '			FPRINTF(stdout, '"[%f] Logging has finished.\n'", '+XX_VARPREFIX+'time);'
        '			xx_log_state = 2;'
        '			xx_log_write_offset = 0;'
        '			xx_log_active_count = 0;'
        '		}'
        '	}'
        ''
        '	/* copy the log sample count & log state information information */'
        '	memcpy (w_ptr + '+XX_VARPREFIX+'offset_log_state, &xx_log_state , sizeof(XXInteger) );'
        '	memcpy (w_ptr + '+XX_VARPREFIX+'offset_log_sample_count, &xx_log_sample_count , sizeof(XXInteger) );'
        ''
        '	/* set the most recent offset */'
        '	'+XX_VARPREFIX+'from_model_recent_offset[0] = w_offset;'
        '}'
        ''
        '#else'
        '/* the library functions */'
        ''
        '/* Declare the storage */'
        'ivcStorage xx_storage;'
        ''
        '/* Declare the tables */'
        'ivcTable xx_tables[XX_TABLE_COUNT];'
        ''
        '/* Declare the monitor */'
        'ivcMonitor xx_monitor;'
        ''
        '/* Declare the log */'
        'ivcLog xx_log;'
        ''
        'void IVCIPC_BuildStorage(void)'
        '{'
        '	/* initialize the storage */'
        '	/* The size of the storage is the size of the data +  and the size of the monitor */'
        '	xx_storage.size = '+XX_VARPREFIX+'data_size + xx_monitor_size;'
        '	'
        '	/* create the storage buffer with zero data*/'
        '	xx_storage.pbuf = malloc(xx_storage.size);'
        '	memset(xx_storage.pbuf, 0, xx_storage.size);'
        '	'
        '	xx_storage.table_count = XX_TABLE_COUNT;'
        '	xx_storage.tables = xx_tables;'
        '	xx_storage.monitor = &xx_monitor;'
        '	xx_storage.log = &xx_log;'
        ''
        '	/* initialize parameter array table */'
        '	xx_tables[0].offset        = 0;'
        '	xx_tables[0].count         = XX_NUMBER_PARAMETERS + 1;'
        '	xx_tables[0].element_size  = sizeof(XXDouble);'
        '	xx_tables[0].name          = '"'+XX_VARPREFIX+''+XX_PARAMETER_NAME+''";'
        ''
        '	/* initialize special parameter array table */'
        '	xx_tables[1].offset        = xx_tables[0].offset + xx_tables[0].count * xx_tables[0].element_size;'
        '	xx_tables[1].count         = XX_SPECIAL_PARAMETERS + 1;'
        '	xx_tables[1].element_size  = sizeof(XXDouble);'
        '	xx_tables[1].name          = ivcSpecialParameters;'
        ''
        '	/* initialize initial value array table */'
        '	xx_tables[2].offset        = xx_tables[1].offset + xx_tables[1].count * xx_tables[1].element_size;'
        '	xx_tables[2].count         = XX_NUMBER_INITIAL_VALUES + 1;'
        '	xx_tables[2].element_size  = sizeof(XXDouble);'
        '	xx_tables[2].name          = '"'+XX_VARPREFIX+''+XX_INIT_VALUE_NAME+''";'
        '	'
        '	/* initialize variable array table */'
        '	xx_tables[3].offset        = xx_tables[2].offset + xx_tables[2].count * xx_tables[2].element_size;'
        '	xx_tables[3].count         = XX_NUMBER_VARIABLES + 1;'
        '	xx_tables[3].element_size  = sizeof(XXDouble);'
        '	xx_tables[3].name          = '"'+XX_VARPREFIX+''+XX_VARIABLE_NAME+''";'
        ''
        '	/* initialize special variable array table */'
        '	xx_tables[4].offset        = xx_tables[3].offset + xx_tables[3].count * xx_tables[3].element_size;'
        '	xx_tables[4].count         = XX_SPECIAL_VARIABLES + 1;'
        '	xx_tables[4].element_size  = sizeof(XXDouble);'
        '	xx_tables[4].name          = ivcSpecialVariables;'
        ''
        '	/* initialize state array table */'
        '	xx_tables[5].offset        = xx_tables[4].offset + xx_tables[4].count * xx_tables[4].element_size;'
        '	xx_tables[5].count         = XX_NUMBER_STATES + 1;'
        '	xx_tables[5].element_size  = sizeof(XXDouble);'
        '	xx_tables[5].name          = '"'+XX_VARPREFIX+''+XX_STATE_NAME+''";'
        ''
        '	/* initialize rate array table */'
        '	xx_tables[6].offset        = xx_tables[5].offset + xx_tables[5].count * xx_tables[5].element_size;'
        '	xx_tables[6].count         = XX_NUMBER_STATES + 1;'
        '	xx_tables[6].element_size  = sizeof(XXDouble);'
        '	xx_tables[6].name          = '"'+XX_VARPREFIX+''+XX_RATE_NAME+''";'
        ''
        '	/* initialize the monitor */'
        '	xx_monitor.size             = sizeof(XXInteger)*(2 + '+XX_VARPREFIX+'index_count);'
        '	xx_monitor.offset           = '+XX_VARPREFIX+'offset_monitor_count;  /* todo change this */'
        '	'
        '	xx_monitor.index_count_ptr  = (unsigned int*)(xx_storage.pbuf + '+XX_VARPREFIX+'offset_monitor_count);'
        '	xx_monitor.max_index_count  = ('+XX_VARPREFIX+'index_count);'
        '	xx_monitor.rate_divider_ptr = xx_monitor.index_count_ptr + 1;'
        '	xx_monitor.indexes_ptr      = xx_monitor.rate_divider_ptr + 1;'
        '	xx_monitor.data_ptr         = (double*)(xx_storage.pbuf + '+XX_VARPREFIX+'data_size); /* points to monitor data after data blocks in shm */'
        '	xx_monitor.data_size        = xx_monitor_size;'
        ''
        '	/* initialize the log */'
        '	xx_log.size                 = ( sizeof(XXInteger)*(4 + '+XX_VARPREFIX+'index_count) ) + ( sizeof(XXDouble) * 2);'
        '	xx_log.offset               = '+XX_VARPREFIX+'offset_log_count; /* todo change this */'
        '	'
        '	xx_log.index_count_ptr      = (unsigned int*)(xx_storage.pbuf + '+XX_VARPREFIX+'offset_log_count);'
        '	xx_log.max_index_count      = ('+XX_VARPREFIX+'index_count);'
        '	xx_log.rate_divider_ptr     = xx_log.index_count_ptr + 1;'
        '	xx_log.indexes_ptr          = xx_log.rate_divider_ptr + 1;'
        '	xx_log.start_time_ptr       = (double*)(xx_log.indexes_ptr + xx_log.max_index_count);'
        '	xx_log.stop_time_ptr        = xx_log.start_time_ptr + 1;'
        '	xx_log.state                = (unsigned int*)(xx_log.stop_time_ptr + 1);'
        '	xx_log.sample_count         = xx_log.state + 1;'
        ''
        '	xx_log.data_ptr             = NULL;'
        '	xx_log.data_size            = xx_log_size;'
        '}'
        ''
        'DLLEXPORT void* IVCIPC_CreateSharedMemory(void)'
        '{'
        '	/* Initializse the sizes */'
        '	ipcInitializeSizes();'
        ''
        '	if ( CreateSharedMemory('"%SUBMODEL_NAME%'", '+XX_VARPREFIX+'shm_size, &'+XX_VARPREFIX+'shm) != 0 )'
        '	{'
        '		FPRINTF(stderr, '"Fatal Error : The shared memory cannot be created.\n'");'
        '		return NULL;'
        '	}'
        ''
        '	/* memset everything to zero */'
        '	memset('+XX_VARPREFIX+'shm, 0,  '+XX_VARPREFIX+'shm_size);'
        ''
        '	/* Initialize the data pointers */'
        '	ipcInitializePointers();'
        ''
        '	/* build the storage */'
        '	IVCIPC_BuildStorage();'
        ''
        ''
        '	/*'
        '	// Create share memory for logging'
        '	*/'
        '	if ( CreateSharedMemory('"%SUBMODEL_NAME%_LOG'", xx_log_size, &'+XX_VARPREFIX+'shm_log ) != 0 )'
        '	{'
        '		FPRINTF(stderr, '"Fatal Error : The shared memory with size %u for logging cannot be created.\n'", xx_log_size);'
        '		return NULL;'
        '	}'
        ''
        '	/* memset everything to zero */'
        '	memset('+XX_VARPREFIX+'shm_log, 0, xx_log_size);'
        ''
        '	/* Set the data_ptr of the log */'
        '	xx_log.data_ptr = (double*)'+XX_VARPREFIX+'shm_log;'
        ''
        '	/* return reference to the storage */'
        '	return (void*)&xx_storage;'
        '}'
        ''
        'DLLEXPORT void IVCIPC_CloseSharedMemory(void)'
        '{'
        '	/* close the shared memory */'
        '	CloseSharedMemory('"%SUBMODEL_NAME%'", &'+XX_VARPREFIX+'shm);'
        '	'
        '	/* close shared memory for logging */'
        '	CloseSharedMemory('"%SUBMODEL_NAME%_LOG'", &'+XX_VARPREFIX+'shm_log );'
        '}'
        ''
        'DLLEXPORT void IVCIPC_InitializeSharedMemory(void* source)'
        '{'
        '	/* Initialize all the offsets for lock-free data sharing to the first data block */'
        '	'+XX_VARPREFIX+'to_model_read_offset[0]     = '+XX_VARPREFIX+'data1_offset;'
        '	'+XX_VARPREFIX+'to_model_recent_offset[0]   = '+XX_VARPREFIX+'data1_offset;'
        '	'+XX_VARPREFIX+'from_model_read_offset[0]   = '+XX_VARPREFIX+'data1_offset;'
        '	'+XX_VARPREFIX+'from_model_recent_offset[0] = '+XX_VARPREFIX+'data1_offset;'
        '}'
        ''
        'DLLEXPORT void IVCIPC_StorageFromModel(void)'
        '{'
        '	/* Set the ''from model read offset'' to the ''most recent offset'' */'
        '	'+XX_VARPREFIX+'from_model_read_offset[0] = '+XX_VARPREFIX+'from_model_recent_offset[0];'
        ''
        '	/* Copy the variables to the the storage */'
        '	memcpy (xx_storage.pbuf + xx_tables[3].offset, '+XX_VARPREFIX+'shm + '+XX_VARPREFIX+'from_model_read_offset[0] + '+XX_VARPREFIX+'offset_V, '+XX_VARPREFIX+'size_'+XX_VARIABLE_NAME+');'
        ''
        '	/* Copy the special variables to the storage */'
        '	memcpy (xx_storage.pbuf + xx_tables[4].offset, '+XX_VARPREFIX+'shm + '+XX_VARPREFIX+'from_model_read_offset[0] + '+XX_VARPREFIX+'offset_SV, '+XX_VARPREFIX+'size_S'+XX_VARIABLE_NAME+');'
        ''
        '	/* Copy the states to the storage */'
        '	memcpy (xx_storage.pbuf + xx_tables[5].offset, '+XX_VARPREFIX+'shm + '+XX_VARPREFIX+'from_model_read_offset[0] + '+XX_VARPREFIX+'offset_S, '+XX_VARPREFIX+'size_'+XX_STATE_NAME+');'
        ''
        '	/* Copy the rates to the storage */'
        '	memcpy (xx_storage.pbuf + xx_tables[6].offset, '+XX_VARPREFIX+'shm + '+XX_VARPREFIX+'from_model_read_offset[0] + '+XX_VARPREFIX+'offset_R, '+XX_VARPREFIX+'size_'+XX_STATE_NAME+');'
        '	'
        '	/* Copy the monitor data, perhaps check if there is valid monitor data.... */'
        '	memcpy ( xx_monitor.data_ptr, '+XX_VARPREFIX+'shm + xx_monitor_offset, xx_monitor.data_size);'
        ''
        '	/* Copy the log information, only state & sample count */'
        '	memcpy ( xx_log.state, '+XX_VARPREFIX+'shm + '+XX_VARPREFIX+'from_model_read_offset[0] + '+XX_VARPREFIX+'offset_log_state, 2 * sizeof(XXInteger) );'
        ''
        '}'
        ''
        'DLLEXPORT void IVCIPC_StorageToModel(void)'
        '{'
        '	/* First find the new ''write offset'' to model */'
        '	/* The new write offset must differ from the read offset and the most recent offset */'
        '	XXInteger w_offset = '+XX_VARPREFIX+'data1_offset;'
        '	'
        '	if ( (w_offset == '+XX_VARPREFIX+'to_model_read_offset[0]) || (w_offset == '+XX_VARPREFIX+'to_model_recent_offset[0]) ) '
        '	{'
        '		w_offset = '+XX_VARPREFIX+'data2_offset; '
        '		if ( (w_offset == '+XX_VARPREFIX+'to_model_read_offset[0]) || (w_offset == '+XX_VARPREFIX+'to_model_recent_offset[0]) )'
        '		{'
        '			w_offset = '+XX_VARPREFIX+'data3_offset;'
        '		}'
        '	}'
        ''
        '	void* w_ptr = '+XX_VARPREFIX+'shm + w_offset;'
        ''
        '	/* The actual copying */'
        ''
        '	/* Copy the parameters (offset is 0 )*/'
        '	memcpy (w_ptr, xx_storage.pbuf, '+XX_VARPREFIX+'size_'+XX_PARAMETER_NAME+');'
        ''
        '	/* copy the special parameters */'
        '	memcpy (w_ptr + '+XX_VARPREFIX+'offset_S'+XX_PARAMETER_NAME+', xx_storage.pbuf + xx_tables[1].offset , xx_tables[1].count *  xx_tables[1].element_size);'
        ''
        '	/* copy the initial values */'
        '	memcpy (w_ptr + '+XX_VARPREFIX+'offset_'+XX_INIT_VALUE_NAME+', xx_storage.pbuf + xx_tables[2].offset , xx_tables[2].count *  xx_tables[2].element_size);'
        ''
        '	/* Copy the monitor count, rate divider and the indexes */'
        '	memcpy (w_ptr + '+XX_VARPREFIX+'offset_monitor_count, xx_monitor.index_count_ptr, xx_monitor.size );'
        ''
        '	/* Copy the log count, rate divider, indexes, start_time & stop_time */'
        '	memcpy (w_ptr + '+XX_VARPREFIX+'offset_log_count, xx_log.index_count_ptr, xx_log.size );'
        ''
        '	/* set the most recent pointer */'
        '	'+XX_VARPREFIX+'to_model_recent_offset[0] = w_offset;'
        '}'
        ''
        '#endif'
        ''];
endfunction
  
//** Generate ivcipc.h
function Code=makeIvcIpc_h(nrParameters, nrInitialValues, nrVariables, nrStates, nrRates)
  Code=[makeHeaderComment('ivcipc.h')
        ''
        '#ifndef IVC_IPC_H'
        '#define IVC_IPC_H'
        ''
        '#include '"xxtypes.h'"'
        '#include '"ivcplatformfunctions.h'"'
        ''
        '#ifdef WIN32'
        '	#define DLLEXPORT __declspec(dllexport)'
        '#else'
        '	#define DLLEXPORT'
        '#endif'
        ''
        '/* Functions used both by library and internal */'
        'void ipcInitializeSizes(void);'
        'void ipcInitializePointers(void);'
        ''
        '#ifndef IPC_LIBRARY'
        '/* These functions are used by standalone */'
        'int '+XX_FUNCTIONPREFIX+'OpenSharedMemory(void);'
        'void '+XX_FUNCTIONPREFIX+'CloseSharedMemory(void);'
        'void '+XX_FUNCTIONPREFIX+'InitializeFromSharedMemory(void);'
        'void '+XX_FUNCTIONPREFIX+'SynchronizeSharedMemory(void);'
        ''
        '#else'
        '/* These functions are used by IVC in the shared library */'
        'DLLEXPORT void* IVCIPC_CreateSharedMemory(void);'
        'DLLEXPORT void IVCIPC_CloseSharedMemory(void);'
        'DLLEXPORT void IVCIPC_InitializeSharedMemory(void* source);'
        ''
        'DLLEXPORT void IVCIPC_StorageToModel(void);'
        'DLLEXPORT void IVCIPC_StorageFromModel(void);'
        ''
        'void IVCIPC_BuildStorage(void);'
        '#endif'
        ''
        '#endif /* IVC_IPC_H */'
        ''];
endfunction
