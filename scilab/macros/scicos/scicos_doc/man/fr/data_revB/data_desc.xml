<?xml version="1.0" encoding="ISO-8859-1" standalone="no"?>
<DATA flag="desc">

<FILE name='ABCD_Blocks' type='XML'>
  <DESCRIPTION>

  </DESCRIPTION>
</FILE>

<FILE name='ABSBLK_f' type='LATEX'>
Le bloc Abs calcule à la sortie, la valeur absolue de l'entrée.
</FILE>

<FILE name='ABS_VALUE' type='LATEX'>
Le bloc Abs calcule à la sortie, la valeur absolue de l'entrée.
</FILE>

<FILE name='AFFICH_f' type='LATEX'>
Pendant la simulation, ce bloc affiche sur le diagramme 
la valeur lue sur son unique port d'entrée événementiel.\\
{\bf Attention :} à chaque fois que le bloc est déplacé, l'utilisateur
doit cliquer sur celui-ci pour éditer ses paramètres. La position
d'affichage est alors automatiquement ajustée.
</FILE>

<FILE name='AFFICH_m' type='LATEX'>
Pendant la simulation, ce bloc affiche sur le diagramme 
la valeur lue sur son unique port d'entrée événementiel.\\
{\bf Attention :} à chaque fois que le bloc est déplacé, l'utilisateur
doit cliquer sur celui-ci pour éditer ses paramètres. La position
d'affichage est alors automatiquement ajustée.
</FILE>

<FILE name='ANDBLK' type='LATEX'>
TODO
</FILE>

<FILE name='ANDLOG_f' type='LATEX'>
Ce bloc possédant deux entrées événementielles et une sortie régulière,
délivre +1 ou -1 sur sa sortie régulière suivant ses entrées événementielles.
\begin{enumerate}
\item[+1]: Lorsque les événements sont synchrones (même événement présent sur
           les deux ports événementiels simultanément),

\item[-1]: Lorsqu'un seul événement est présent.
 \end{enumerate}
</FILE>

<FILE name='BACKLASH' type='LATEX'>
The Backlash block implements a system in which a change in input
causes an equal change in output. However, when the input changes
direction, an initial change in input has no effect on the output.
The amount of side-to-side play in the system is referred to as the
{\em deadband or gap}.
</FILE>

<FILE name='BIGSOM_f' type='LATEX'>
Le bloc somme réalise l'addition de ses entrées.
Ce bloc peut additionner des scalaires ou des vecteurs d'entrée.
</FILE>

<FILE name='BITCLEAR' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  This blocks set the specified bit of the integer input to 0.
	  The user can specify the bit in the field:"index of bit".
	  Bit 0 is the least significant bit.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='BITSET' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  This blocks set the specified bit of the integer input to 1.
	  The user can specify the bit in the field:"index of bit".
	  Bit 0 is the least significant bit.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='BOUNCE' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='BOUNCEXY' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='Bache' type='LATEX'>
Ce composant représente une bache thermo-hydraulique qui consiste en
deux ports d'entrée et deux ports de sortie.  Conventionnellement, la
direction positive pour la rentrée est quand le fluide {\bf entre}
dans le port d'entree (ports noirs) et la direction positive pour les
ports de sortie est quand le fluide {\bf sort} des port de sortie
(ports blancs).  La surface de la bache, la température initiale et
l'altitude initiale du fluide peuvent être definies par l'utilisateur.
Si un port reste non-utilisé, il doit être bouché par le bloc {\bf
Bouchon}.
</FILE>

<FILE name='Branching_pal' type='LATEX'>
Dans la palette Branching, vous pouvez trouver divers blocs
pour la gestion des données véhiculées par les liens réguliers.
</FILE>

<FILE name='CANIMXY' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  This block realizes the visualization of the evolution of
          the two regular input signals by drawing the second input
          as a function of the first at instants of events on the
          event input port.  When a point is drawn on screen it stays
          until the buffer length is reached. This scope is useful to
          make simple animations.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='CANIMXY3D' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  This block realizes the visualization of the evolution of
          the three regular input signals by drawing the third input
          as a function of the two others at instants of events on the
          event input port. When a point is drawn on screen it stays
          until the buffer length is reached. This scope is useful to
          make simple animations.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='CBLOCK' type='LATEX'>
Ce bloc crée une fonction de calcul squelette en C.
Il crée aussi une librairie et un fichier objet à la compilation.
</FILE>

<FILE name='CEVENTSCOPE' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  This block realizes the visualization of the input event
          signals.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='CFSCOPE' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  This is a floating scope block.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='CLINDUMMY_f' type='LATEX'>
Ce bloc peut être placé dans tous diagrammes qui contient un ou
des blocs 'zero-crossing' et qui ne dispose pas de blocs contenant
des états continus (x) temps dépendant (dep\_t=\%t).
Grâce à cela, le simulateur utilisera le solveur ode pour la détection
de surfaces des blocs 'zero-crossing'.
</FILE>

<FILE name='CLKFROM' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  This block is used to connect events ports. For more
          information on how it works please refer to the
          documentation of the FROM block by clicking on the link in
          the "See also" field.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='CLKGOTO' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  This block is used to connect events ports. For more
	  information on how it works please refer to the
	  documentation of the GOTO block by clicking on the link in
	  the "See also" field.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='CLKGotoTagVisibility' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  This block is used in the event case. For more information
	  on how it works please refer to the documentation of the
	  GotoTagVisibility block by clicking on the link in
	  the "See also" field.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='CLKINV_f' type='LATEX'>
Ce bloc doit seulement être utilisé à l'intérieur des superblocs.
Il est utilisé pour représenter un port d'entrée événementiel.
Dans un superbloc, les ports doivent être numérotés à partir de 1
jusqu'au nombre de ports.  
</FILE>

<FILE name='CLKIN_f' type='LATEX'>
Ce bloc doit seulement être utilisé à l'intérieur des superblocs.
Il est utilisé pour représenter un port d'entrée événementiel.
Dans un superbloc, les ports doivent être numérotés à partir de 1
jusqu'au nombre de ports.  
</FILE>

<FILE name='CLKOUTV_f' type='LATEX'>
Ce bloc doit seulement être utilisé à l'intérieur des superblocs.
Il est utilisé pour représenter un port de sortie événementiel.
Dans un superbloc, les ports doivent être numérotés à partir de 1
jusqu'au nombre de ports.  
</FILE>

<FILE name='CLKOUT_f' type='LATEX'>
Ce bloc doit seulement être utilisé à l'intérieur des superblocs.
Il est utilisé pour représenter un port de sortie événementiel.
Dans un superbloc, les ports doivent être numérotés à partir de 1
jusqu'au nombre de ports.
</FILE>

<FILE name='CLKSOMV_f' type='LATEX'>
Ce bloc est un bloc d'addition d'événement à trois entrées.
La sortie reproduit les événements de tous les ports d'entrées.
A proprement parler, CLKSOMV n'est pas un vrai bloc scicos, car
il est ignoré pendant la phase de compilation.\\
Les sorties et les entrées de ce bloc sont synchronisées.
</FILE>

<FILE name='CLKSOM_f' type='LATEX'>
Ce bloc est un bloc d'addition d'événement à trois entrées.
La sortie reproduit les événements de tous les ports d'entrées.
A proprement parler, CLKSOM\_f n'est pas un vrai bloc scicos, car
il est ignoré pendant la phase de compilation.\\
Les sorties et les entrées de ce bloc sont synchronisées.
</FILE>

<FILE name='CLKSPLIT_f' type='XML'>
<DESCRIPTION>

</DESCRIPTION>
</FILE>

<FILE name='CLOCK_c' type='LATEX'>
Ce bloc est un super-bloc construit grâce au bloc
\htmladdnormallink{EVTDLY\_c}{EVTDLY_c.htm} qui 
est rebouclé sur lui-même.\\
L'unique sortie de ce bloc génère des événements
à des dates précises, qui sont déterminées par le
paramètre {\bf Period} de la boîte de dialogue.
</FILE>

<FILE name='CLOCK_f' type='LATEX'>
Ce bloc est un super-bloc construit grâce au bloc
\htmladdnormallink{EVTDLY\_f}{EVTDLY_f.htm} qui
est rebouclé sur lui-même.\\
L'unique sortie de ce bloc génère des événements
à des dates précises, qui sont déterminées par le
paramètre {\bf Period} de la boîte de dialogue.
</FILE>

<FILE name='CLR' type='LATEX'>
Ce bloc réalise un système linéaire SISO (Single Input Single Output) 
représenté par une fonction de transfert rationnelle.
La fonction rationnelle doit être une fonction propre.
</FILE>

<FILE name='CLR_f' type='LATEX'>
Ce bloc réalise un système linéaire SISO (Single Input Single Output) 
représenté par une fonction de transfert rationnelle.
La fonction rationnelle doit être une fonction propre.
</FILE>

<FILE name='CLSS' type='LATEX'>
Ce bloc réalise un système linéaire d'équations d'état en temporel continu.
\begin{eqnarray}
\dot x&=&Ax+Bu\\
  y   &=&C*x+D*u
\end{eqnarray}
Le système est défini par les matrices $(A,B,C,D)$
et par l'état initial $x_0$.
Les dimensions des matrices et de l'état initial doivent être appropriées.
</FILE>

<FILE name='CLSS_f' type='LATEX'>
Ce bloc réalise un système linéaire d'équations d'état en temporel continu.
\begin{eqnarray}
\dot x&=&Ax+Bu\\
  y   &=&C*x+D*u
\end{eqnarray}
Le système est défini par les matrices $(A,B,C,D)$
et par l'état initial $x_0$.
Les dimensions des matrices et de l'état initial doivent être appropriées.
</FILE>

<FILE name='CMAT3D' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  CMAT3D est un scope qui montre les valeurs en Z des matrices
          sur une grille xy.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='CMATVIEW' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
          CMATVIEW est un scope qui montre les valeurs des matrices
          sur une grille en couleur.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='CMSCOPE' type='LATEX'>
Au début de la simulation, ce bloc ouvre une fenêtre  pour afficher
l'évolution temporelle des données qui seront lues sur les ports
d'entrées réguliers.
Ce bloc est donc similaire à un oscilloscope.
Il permet l'affichage de multiple abscisses (une par entrée).
Ces abscisses peuvent avoir des échelles temporelles différentes
qui seront définies par le paramètre {\bf Refresh period}.
</FILE>

<FILE name='CONST' type='LATEX'>
Ce bloc est un générateur de valeurs constantes.
</FILE>

<FILE name='CONSTRAINT_f' type='LATEX'>
Ce bloc définit des relations algébriques implicites.
</FILE>

<FILE name='CONST_f' type='LATEX'>
Ce bloc est un générateur de valeurs constantes.
</FILE>

<FILE name='CONST_m' type='LATEX'>
Ce bloc est un générateur de valeurs constantes.
</FILE>

<FILE name='CONVERT' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	This block converts an input signal of any data type to a
        specified data type. The input can be real, complex or integer.
        When the output is an integer and when overflow occurs the block
        three different forms of results :
        </P>
	  <P>1- A normal non saturated result.</P>
	  <P>2- A saturated result.</P>
	  <P>3- An error message warning the user about the overflow..</P>
	<P>
        The user can select one of these three forms by setting
        the "DO ON OVERFLOW" field to 0,1 or 2.
        </P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='COSBLK_f' type='LATEX'>
$$y=\cos(u)$$
</FILE>

<FILE name='CSCOPE' type='LATEX'>
Au début de la simulation, ce bloc ouvre une fenêtre  pour afficher
l'évolution temporelle des données qui seront lues sur le port
d'entrée régulier.
Ce bloc est donc similaire à un oscilloscope.
Il permet d'afficher sur une même figure l'évolution des
éléments d'un vecteur.
Ce bloc ne possède qu'une seule échelle temporelle.
</FILE>

<FILE name='CSCOPXY' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  This block realizes the visualization of the evolution of the
          two regular inputs signals by drawing the second input as a
          function of the first at instants of events on the event input
          port. When a point is drawn on screen it stays until the
          simulation is finished.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='CSCOPXY3D' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  This block realizes the visualization of the evolution of the
          three regular inputs signals by drawing the third input as a
          function of the two others at instants of events on the event
          input port. When a point is drawn on screen it stays until the
          simulation is finished.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='CUMSUM' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  The CUMSUM block sums the element of an input m*n matrix u
          along either the rows, the columns or the first non singleton
          dimension. When the "Sum along" parameter is set to "1", the
          block sums across the elements of each row. The result will be
          displayed as a m*1 matrix.
	</P>
	<P>
	  When the "Sum along" parameter is set to "2", the block sums
          across the elements of each column. The result will be display
          as a 1*n matrix.
	</P>
	<P>
	  When the "Sum along" parameter is set to "0", the block sums
          across the first non singleton dimension. The result will be
          displayed as one element.
	  This block is equivalent to cumsum in scilab.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='CURVE_c' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
This block allows the user to create signals and use them as a signal
source block. The signals can be created either graphically by the
user or be defined by specifying two vectors, i.e., a vector for time
and a vector for amplitude. These vectors define the mesh points and
the signal value at intermediate points are obtained by interpolating
the points. Several interpolation methods are available. This block
can also generate the signal periodically. It is also possible to read
data from Excel data-sheets and from formatted C data files.
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='CURV_f' type='LATEX'>
Ce bloc définit une fonction tabulée en fonction du temps.
Entre chaque point des mailles, ce bloc réalise une interpolation
linéaire. En dehors des points tabulés, il fournit les derniers
points rencontrés. L'utilisateur peut définir les différents points
en utilisant un éditeur graphique de courbes.
</FILE>

<FILE name='Capacitor' type='LATEX'>
Un condensateur est un composant électrique ou électronique dont
l'intérêt de base est d'avoir une capacité électrique. Son
comportement électrique idéal est:
      \[  I = C{dV\over dt}\]
où:
\begin{itemize}
\item $I$ est le courant qui traverse le composant.
\item $V$ est la tension aux bornes du composant.
\item $C$ est la capacité électrique du condensateur.
\item $\textstyle{{dV\over dt}}$ est la variation de tension avec le temps.
\end{itemize}

Le condensateur peut être utilisé pour distinguer les signaux
haute-fréquences et basse-fréquence. Cette faculté est très utile
dans la conception des filtres.
</FILE>

<FILE name='ConstantVoltage' type='LATEX'>
Ce composant est un modèle pour n'importe quel dispositif ou système
qui produit une force électromotrice constante entre ses terminaux. La
tension aux bornes de cette source est C. C est définie par
l'utilisateur. Le port noir indique la tension positive. La résistance
ohmique de ce composant est zéro.
</FILE>

<FILE name='Counter' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
          Ce bloc, suivant la loi choisie, compte à partir d'un minimum
          vers un maximum ou d'un maximum vers un minimun.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='CurrentSensor' type='LATEX'>
Ce bloc est inséré en série dans un circuit électrique pour mesurer le
courant qui passe à travers. Si le courant positif {\bf entre} par le
port noir, il est consideré positif. La résistance ohmique de ce
composant est zéro.
</FILE>

<FILE name='DEADBAND' type='LATEX'>
Fournit une zone où la sortie est égale à zéro.
</FILE>

<FILE name='DEBUG_SCICOS' type='LATEX'>

</FILE>

<FILE name='DELAYV_f' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='DELAY_f' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
          Ce super-bloc compilé réalise un retard discret.
          Il est construit avec un registre à décalage et une horloge.
          La valeur du retard est donnée par la pas temporel discret multiplié
          par le nombre-1 d'état du registre.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='DEMUX' type='LATEX'>
En fournissant un vecteur sur le port d'entrée régulier, ce bloc
peut séparer les éléments de l'entrée par des vecteurs sur les ports
de sortie.
L'entrée est donc définie $u=[y_1;y_2,\cdots;y_n]$, où  $y_i$ sont
numérotés dans un ordre décroissant.
Les tailles des ports d'entrée et de sortie sont déterminées par le contexte.
</FILE>

<FILE name='DEMUX_f' type='LATEX'>
Given a vector valued input this block splits inputs over vector
valued outputs. So $ u=[y_1;y_2,\cdots;y_n]$ , where  $y_i$  are
numbered from top to bottom. Input and Output port sizes are
determined by the context.
</FILE>

<FILE name='DERIV' type='LATEX'>
Le bloc dérivée fait l'approximation de la dérivée de son entrée en calculant:
$$\frac{\Delta u}{\Delta t}$$.
</FILE>

<FILE name='DFLIPFLOP' type='LATEX'>
The DFLIPFLOP block outputs the input state when the enable is
set and on the rising edge of the clock. The input is D the
enable is en and the clock is clk. Q and !Q are the outputs of
this block. This block is almostly used with digital number, 
the input data type is int8.\\

The truth table of this block is
\begin{tabular}{|c|c||c|c|}
\hline
en&
D&
Q&
!Q\\
\hline
0&
0&
0&
1\\
\hline
0&
1&
0&
1\\
\hline
1&
0&
0&
1\\
\hline
1&
1&
1&
0\\
\hline
\end{tabular}
</FILE>

<FILE name='DIFF_f' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='DLATCH' type='LATEX'>
This block outputs the input state when the input gate is high.
The input is D the enable is C. Q and !Q are the outputs of 
this block. This block is almostly used with digital number, 
the input data type is int8.\\

The truth table of this block is

\begin{tabular}{|c|c||c|c|}
\hline
C&
D&
Q&
!Q\\
\hline
0&
0&
0&
1\\
\hline 
0&
1&
0&
1\\
\hline 
1&
0&
0&
1\\
\hline 
1&
1&
1&
0\\
\hline
\end{tabular}
</FILE>

<FILE name='DLR' type='LATEX'>
Ce bloc réalise un système linéaire SISO (Single Input Single Output) 
représenté par une fonction de transfert rationnelle
dans l'espace de la transformée en z.
La fonction rationnelle doit être une fonction propre.
</FILE>

<FILE name='DLRADAPT_f' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='DLR_f' type='LATEX'>
Ce bloc réalise un système linéaire SISO (Single Input Single Output) 
représenté par une fonction de transfert rationnelle
dans l'espace de la transformée en z.
La fonction rationnelle doit être une fonction propre.
</FILE>

<FILE name='DLSS' type='LATEX'>
Ce bloc réalise un système d'équations d'état temporel discret.
Le système est défini par les matrices $(A,B,C,D)$
et par l'état initial $x_0$.
Les dimensions des matrices et de l'état initial doivent être appropriées.
Lorsque qu'un événement active le bloc (par son unique port événementiel)
l'état est alors mis à jour.
</FILE>

<FILE name='DLSS_f' type='LATEX'>
Ce bloc réalise un système d'équations d'état temporel discret.
Le système est défini par les matrices $(A,B,C,D)$
et par l'état initial $x_0$.
Les dimensions des matrices et de l'état initial doivent être appropriées.
Lorsque qu'un événement active le bloc (par son unique port événementiel)
l'état est alors mis à jour.
</FILE>

<FILE name='DOLLAR' type='LATEX'>
Le bloc retard retarde ses entrées de la période spécifiée au niveau du port
d'entrée événementiel.
Ce bloc est équivalent à l'opérateur discret $z^{-1}$.
Il accepte une seule entrée et génére une seule sortie qui peuvent être
aussi bien un scalaire qu'un vecteur.
Si l'entrée est un vecteur alors tous les éléments du vecteur sont
retardés par la même période.
</FILE>

<FILE name='DOLLAR_f' type='LATEX'>
Le bloc retard retarde ses entrées de la période spécifiée au niveau du port
d'entrée événementiel.
Ce bloc est équivalent à l'opérateur discret $z^{-1}$.
Il accepte une seule entrée et génére une seule sortie qui peuvent être
aussi bien un scalaire qu'un vecteur.
Si l'entrée est un vecteur alors tous les éléments du vecteur sont
retardés par la même période.
</FILE>

<FILE name='DOLLAR_m' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
        Le bloc retard retarde ses entrées de la période spécifiée au niveau
        du port d'entrée événementiel. Ce bloc est équivalent à l'opérateur
        discret z-1.
	Il accepte une seule entrée et génére une seule sortie qui peuvent
        être aussi bien un scalaire qu'un vecteur.
	Si l'entrée est un vecteur alors tous les éléments du vecteur sont
        retardés par la même période.
	</P>
	<P>
        Ce bloc supporte tous les types de données de scicos.
        Les types de données en entrée/sortie sont hérités du paramètre
        "initial condition".
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='DemoBlocks_pal' type='LATEX'>
Les blocs de cette palette sont utilisés pour faire des
diagrammes de démonstration.
</FILE>

<FILE name='Diode' type='LATEX'>
Ce composant consiste en une diode simple mise en parallèle avec une résistance
ohmique $R$. Le courant qui passe dans la diode est défini en
fonction de la tension aux bornes de le diode, {\it c.-à-d.},

\[I = I_{ds} (\exp^{v/V_t} - 1) + \frac {v} {R} \]

où $I_{ds}$ et $V_t$ sont le courant de saturation et la tension
équivalente de la température, respectivement. Si la valeur de $v/V_t$
atteint une certaine limite ($Maxexp$), la courbe caractéristique de
la diode devient linéaire pour éviter un dépassement numérique.
</FILE>

<FILE name='EDGETRIGGER' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='EDGE_TRIGGER' type='XML'>
<DESCRIPTION>

</DESCRIPTION>
</FILE>

<FILE name='ESELECT_f' type='LATEX'>
Bloc spécial similaire au bloc If-Then-Else. Les entrées/sorties
événementielles sont synchronisées. L'événement entrant est redirigé
sur l'un des ports de sortie événementiels suivant le valeur de
l'entrée régulière.
</FILE>

<FILE name='EVTDLY_c' type='LATEX'>
Chaque événement de sortie est réalisé après l'événement 
d'entrée par un laps de temps {\bf Delay}.\\
La date de l'événement de sortie est donc déterminée par la formule :
\begin{eqnarray}
 t_{i}&=&t_{\rm{init}} + i * T_{\rm{delay}},
\end{eqnarray}
</FILE>

<FILE name='EVTDLY_f' type='LATEX'>
Ce bloc génére à la sortie des événements retardés par rapport aux
événements qui arrivent à l'entrée.
Le retard est définit par la valeur du paramètre {\bf Delay}.
Ce bloc peut aussi généré un événement à une date initiale.
</FILE>

<FILE name='EVTGEN_f' type='LATEX'>
Un événement est généré sur le port unique de sortie événementiel
si la valeur du paramètre {\bf Event time} est plus grand ou égal à
zéro.
Si cette valeur est négative alors aucun événement ne sera généré.
</FILE>

<FILE name='EVTVARDLY' type='LATEX'>
Ce bloc génére à la sortie des événements retardés par rapport aux
événements qui arrivent à l'entrée.
Le retard est définit par la valeur qui est lu sur le port d'entrée
régulier.
Ce bloc peut aussi généré un événement à une date initiale.
</FILE>

<FILE name='EXPBLK_f' type='LATEX'>
Ce bloc calcule $y(i)=a^u(i)$. 
Les tailles des ports d'entrée et de sortie sont déterminées par
le compilateur.
</FILE>

<FILE name='EXPBLK_m' type='LATEX'>
Ce bloc calcule $y(i)=a^u(i)$. \\
Les tailles des ports d'entrée et de sortie sont déterminées par
le compilateur.
</FILE>

<FILE name='EXPRESSION' type='LATEX'>
Le bloc EXPRESSION applique à son entrée les fonctions Scilab spécifiées
en paramètre.
</FILE>

<FILE name='EXTRACT' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  The EXTRACT block extracts some elements from the matrix.
          The size of the output depends on the number of rows and
          number of columns to extract.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='EXTRACTBITS' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	This block outputs a contiguous selection of bits from the input
        integer number.The Bits to extract defines the method by which
        the user select the output bits.
        </P>
	  <P>
          1- When "Upper Half" is selected the block outputs the half
             of the input that contain the most significant bit. In this
             case the third parameter "number of bits or index of bit"
             is ignored.
          </P>
	  <P>
          2- When "Lower Half" is selected the block outputs the half
             of the input that contain the least significant bit. In this
             case the third parameter "number of bits or index of bit"
             is ignored.
          </P>
	  <P>
          3- When "Range starting with most significant bit" is selected
             the block outputs certain number of bits of the input that
             contain the most significant bit. In this case the third
             parameter "number of bits or index of bit" defines the
             number of bits to extract.
          </P>
	  <P>
          4- When "Range ending with least significant bit" is selected
             the block outputs certain number of bits of the input that
             contain the least significant bit. In this case the third
             parameter "number of bits or index of bit" defines the
             number of bits to extract.
          </P>
	  <P>
          5- When "Range of bits" is selected the block outputs a range
             of bits of the input. In this case the third parameter
             "number of bits or index of bit" defines the range of bits
             to extract, it must be a vector with the format [start,end].
          </P>
	<P>
        The extracted value depends on the forth parameter "Treat bit
        field as an integer". When it is set to 0 the input scaling is
        used to determine the output scaling. When it is set to 1, only
        the extracted bits forms the output number.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='EXTRACTOR' type='LATEX'>
Extrait ou sélectionne une entrée régulière parmi plusieurs entrées régulières.
</FILE>

<FILE name='EXTTRI' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	The EXTTRI block extracts some elements from the input matrix u.
        </P>
	<P>
        When the "Extraction type" is set to "1", the block copies the
        elements on and above the main diagonal to an output matrix of
        the same size. The elements below the main diagonal are set to
        zero.
        </P>
	<P>
        When the "Extraction type" is set to "2", the block copies the
        elements on and below the main diagonal to an output matrix of
        the same size. The elements above the main diagonal are set to
        zero.
        </P>
	<P>
        When the "Extraction type" is set to "3", the block copies the
        elements on the main diagonal to an output matrix of the same
        size. The elements above and below the main diagonal are set to
        zero.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='Electrical_pal' type='LATEX'>
La boîte à outils électrique contient les composants basiques
électriques tels que la source de tension, la diode, le condensateur,
etc.
</FILE>

<FILE name='Events_pal' type='LATEX'>
La palette 'Events' (événements) est utilisée pour manipuler les
événements sur le diagramme. Elle contient entre autre plusieurs
sources d'activation, des blocs synchrones ainsi que des blocs
pour regrouper/combiner les événements sur un seul lien.
</FILE>

<FILE name='Extract_Activation' type='XML'>
  <DESCRIPTION>

  </DESCRIPTION>
</FILE>

<FILE name='FROM' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	The main role of the GOTO/FROM blocks is to transport signals
        from a block to another block without connecting them physically.
        The FROM block transports its received data (from the
        correponding GOTO) to its output. Multiples FROM blocks can
        receive data from one GOTO, although a GOTO can send data to
        multiple FROM.
        </P>
	<P>
        The GOTO and FROM blocks are connected by the tag parameter.
        </P>
	<P>
        For information on the visibility and limitation of these blocks
        please refer to the GOTO documentation.
        </P>
	<P>
        This block can support all the data types.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='FROMMO' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  This block is used to connect modelica's blocks. For more
          information on how it works please refer to the documentation
          of the FROM block by clicking on the link in the "See also"
          field.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='FROMWSB' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
    <DESCRIPTION_ITEM>
    <P>
    Ajoutez ici un paragraphe pour la description de la fonction
    </P>
    </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='FROMWS_c' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
    <DESCRIPTION_ITEM>
    <P>
    Ajoutez ici un paragraphe pour la description de la fonction
    </P>
    </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='FSV_f' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='GAINBLK' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  Le bloc GAINBLK calcule le produit d'une matrice carré A par une matrice
          d'entrée U, où le nombre de lignes/colonnes de A est égal au nombre de lignes
          de U. Les types de données des entrées/sorties sont définis par le type de
          donnée de la matrice gain A.
	  <P>
          Lorsqu'un dépassement intervient, le résulat peut prendre des valeurs
          différentes suivant le paramètre "DO ON OVERFLOW":
          </P>
	  <P>1- Un résulat non saturé.</P>
	  <P>2- Un résultat saturé.</P>
	  <P>3- Un message d'erreur est signalé lorsqu'un dépassement intervient.</P>
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='GAINBLK_f' type='LATEX'>
Le bloc GAINBLK calcule le produit d'une matrice carré A par une matrice d'entrée U,
où le nombre de lignes/colonnes de A est égal au nombre de lignes de U.
</FILE>

<FILE name='GAIN_f' type='LATEX'>
Ce bloc calcule le produit d'une matrice carré A par une matrice d'entrée U, où le
nombre de lignes/colonnes de A est égal au nombre de lignes de U.
</FILE>

<FILE name='GENERAL_f' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='GENSIN_f' type='LATEX'>
Ce bloc est un générateur de sinusoïde : $M*\sin(F*t+P)$
</FILE>

<FILE name='GENSQR_f' type='LATEX'>
Ce bloc est un générateur de signal carré : la sortie prend des valeurs
entre -M et M.
Pour chaque événement reçu, la sortie saute d'une valeur -M à M 
ou de M à -M.
</FILE>

<FILE name='GOTO' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	The main role of the GOTO/FROM blocks is to transport signals
        from a block to another block without connecting them physically.
        The GOTO block transports its input data to its corresponding
        FROM block. A simple GOTO block can send data to multiple FROM,
        although a FROM can receive data from only one GOTO.
        </P>
	<P>
        The GOTO and FROM blocks are connected by the tag parameter.
        </P>
	<P>
        The "Tag Visibility" parameter indicates if the location of
        the FROM block is limitted:
        </P>
	  <P>
          - Local: means that the corresponding FROM of that GOTO must
                   be in the same subsystem.
          </P>
	  <P>
          - Scoped: means that the corresponding FROM of that GOTO must
                    be in the same subsystem or in any subsystem below
                    the GotoTagVisibility block in the model hierarchy.
          </P>
	  <P>
          - Global: means that the corresponding FROM of that GOTO can
                    be anywhere in the model.
          </P>
	<P>
        This block can support all the data types.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='GOTOMO' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  This block is used to connect modelica's blocks. For more
          information on how it works please refer to the documentation
          of the GOTO block by clicking on the link in the "See also"
          field.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='GotoTagVisibility' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  This block defines the accessibility of the GOTO block
          when it is configure as "scoped". The FROM block corresponding
          to that GOTO must be in the same subsystem of the
          GotoTagVisibility or in subsystems below it in the model
          hierarchy.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='GotoTagVisibilityMO' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  This block is used in case of modelica's connection.
          For more information on how it works please refer to the
          GotoTagVisibility block by clicking on the link in the
          "See also" field.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='Ground' type='LATEX'>
Cet élément est un composant électrique simple fournissant une tension
de référence dans des circuits électriques. Le potentiel au noeud de
Terre est zéro. Chaque circuit électrique doit contenir au moins un
élément Terre.
</FILE>

<FILE name='HALT_f' type='LATEX'>
Ce bloc a un unique port d'entrée événementiel.
Lorsqu'un événement se présente sur ce port, alors la simulation
est arrêtée et la main est rendue à la fenêtre principale de Scicos.
La simulation peut être redémarrée ou continuée grâce au bouton Run.
</FILE>

<FILE name='HYSTHERESIS' type='LATEX'>
Permutte la valeur de la sortie entre deux constantes.
TODO
</FILE>

<FILE name='IFTHEL_f' type='LATEX'>
Ce bloc génére un événement sur l'une ses deux sorties événementielles
lorsqu'un événement en entrée active celui-ci.
Suivant le signe de la valeur lue sur le port d'entrée régulier,
l'événement est généré soit sur la branche 'then' ou bien sur la branche
'else'.
Ce bloc est un bloc synchrone, ce qui signifie que les événements en entrée
et en sortie sont générés exactement à la même date et simultanément.
</FILE>

<FILE name='IMPSPLIT_f' type='XML'>
  <DESCRIPTION>

  </DESCRIPTION>
</FILE>

<FILE name='INIMPL_f' type='LATEX'>
Les ports d'entrée INIMPL\_f sont des liens qui permettent de connecter
l'intérieur d'un système vers l'extérieur.
</FILE>

<FILE name='INTEGRAL' type='LATEX'>
Ce bloc est un intégrateur. La sortie est l'intégrale de l'entrée.
</FILE>

<FILE name='INTEGRAL_f' type='LATEX'>
Ce bloc est un intégrateur. La sortie est l'intégrale de l'entrée.
</FILE>

<FILE name='INTEGRAL_m' type='LATEX'>
Ce bloc est un intégrateur. La sortie est l'intégrale de l'entrée.
</FILE>

<FILE name='INTMUL' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	The INTMUL block computes the matrix multiplication of two
        integers inputs matrices.The number of rows of the second
        matrix must be equal to the number of columns of the first
        matrix. The output is a matrix where the number of rows is
        equal to the number of rows of the first input matrix and
        the number of columns is equal to the number of columns of
        the second input matrix. This block support all the integer
        data type.
        </P>
	<P>
        On overflow, the result can take different forms:
        </P>
	 <P>1- A normal non saturated result.</P>
	 <P>2- A saturated result.</P>
	 <P>3- An error message warning the user about the overflow.</P>
	<P>
        The user can select one of these three forms by setting
        the "DO ON OVERFLOW" field to 0,1 or 2.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='INTRP2BLK_f' type='LATEX'>
La sortie de ce bloc est fonction de l'entrée obtenue par interpolation
bilinéaire.
Ce bloc a deux entrées scalaires et une seule sortie scalaire.
Les grandeurs $X(i)$ et $Y(i)$ donnent respectivement les coordonnées
$X,Y$ du $i^{\rm \grave{e}me}$ point de donnée et $Z(Y(i),X(i))$
sa valeur.
</FILE>

<FILE name='INTRPLBLK_f' type='LATEX'>
La sortie de ce bloc est fonction de l'entrée obtenue par interpolation
linéaire.
Ce bloc a une seule entrée scalaire et une seule sortie scalaire.
Les grandeurs $X$ et $Y$ donnent respectivement les coordonnées
$X,Y$ des points de données qui seront interpolés.
$X$ doit être strictement croissant.
</FILE>

<FILE name='INVBLK' type='LATEX'>
Ce bloc calcule $y(i)=1/u(i)$.
La taille de l'entrée/sortie est déterminée par le contexte.
</FILE>

<FILE name='INVBLK_f' type='LATEX'>
Ce bloc calcule $y(i)=1/u(i)$.
La taille de l'entrée/sortie est déterminée par le contexte.
</FILE>

<FILE name='IN_f' type='LATEX'>
Ce bloc doit être utilisé dans un superbloc pour représenter un port
d'entrée régulier. La taille de ce port est automatiquement ajustée.
Dans un superbloc, les ports d'entrée réguliers doivent être numérotés
de 1 jusqu'au nombre de ports d'entrée réguliers composant le superbloc.
</FILE>

<FILE name='ISELECT_f' type='LATEX'>
Sélectionne des signaux suivant les événements d'entrée.
Ce bloc a un seul port régulier d'entrée.
</FILE>

<FILE name='ISELECT_m' type='LATEX'>
Sélectionne des signaux suivant les événements d'entrée.
Ce bloc a un seul port régulier d'entrée.
</FILE>

<FILE name='Inductor' type='LATEX'>
Une bobine est un composant électrique qui peut stocker l'énergie
dans des circuits électriques.  Le rapport entre la tension $v$ aux
borne d'une bobine d'inductance $L$ et le courant $I$ passant à
travers le composant est donné par :

\[v = L \frac{dI}{dt}\]

 Des inductances peuvent également être utilisées pour distinguer les
 signaux haute fréquence des signaux de basse fréquence et ceci
 rend les inductances utiles dans la conception des filtres. Une
 inductance présente une forte impédance pour les signaux haute
 fréquence et est passante pour les signaux DC.
</FILE>

<FILE name='Integer_pal' type='LATEX'>
Cette palette est dédicacée aux nombres entiers.
Des opérateurs variés sont ici implémentés pour la logique
et la manipulation des champs de bits ainsi que des portes
logiques qui sont fréquemment utilisées dans les circuits numériques.
</FILE>

<FILE name='JKFLIPFLOP' type='LATEX'>
The JK flip flop is the most versatile of the basic flip-flops.
It has two inputs traditionaly labeled J and K. When J and K are
different, the output takes the value of J at the next falling edge.
When J and K are both low, no change occurs in the output state,
when they are both high the output will toggle from one state to other.
It can perform the functions of the set/reset flip-flop and has the
advantage that there are no ambiguous states. It can also act as a
T flip-flop to accomplish toggling action if J and K are tied together.
This toggle application finds extensive use in binary counters. 
This block is almostly used with digital number, the input data type
is int8.\\

The truth table of this block is

\begin{tabular}{|c|c||c|c|}
\hline
J&
K&
Q(t)&
!Q(t)\\
\hline
0&
0&
Q(t-1)&
!Q(t-1)\\
\hline
0&
1&
0&
1\\
\hline
1&
0&
1&
0\\
\hline
1&
1&
!Q(t-1)&
Q(t-1)\\
\hline
\end{tabular}
</FILE>

<FILE name='Keyboard_shortcuts' type='XML'>
<DESCRIPTION>

</DESCRIPTION>
</FILE>

<FILE name='LOGBLK_f' type='LATEX'>
Ce bloc calcule $y(i)=log(u(i))/log(a)$. 
Les tailles des ports d'entrée/sortie sont déterminés par le contexte.
</FILE>

<FILE name='LOGIC' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  This block implements a standard truth table for modeling
          programming array, digital circuit and any other boolean
          expressions. The user can specify a matrix that defines all
          the possible block output in the Truth table field. Each row
          of the matrix contains the output of different combination
          of input elements. The number of rows must be a power of two,
          it defines the number of inputs using the equation:
        </P>
	<P>number of row = 2 ^ (number of input)</P>
	<P>
          The number of outputs is equal to the number of columns of
          the matrix.
        </P>
	<P>
          This block support only the int8 data type. When the input
          is positif, the input is considered as logical 1, When it is
          negatif or zero it is considered as logical 0.
        </P>
	<P>
          This block can be activated by an implicit input event or it
          can herit the clock from the regular input.
        </P>
	<P>
          This block is used to implement SR and JK flip-flops.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='LOGICAL_OP' type='LATEX'>
Le bloc Opérateur Logique réalise une opération logique
sur ses entrées qui est spécifiée en paramètre.
Une valeur d'entrée est VRAI (1), si elle est différente de zéro, et
elle est FAUSSE (0) si elle est égale zéro.
</FILE>

<FILE name='LOOKUP_f' type='LATEX'>
Ce bloc réalise une fonction non-linéaire qui est défini grâce à un
éditeur graphique.
</FILE>

<FILE name='Linear_pal' type='LATEX'>
Cette palette contient des opérateurs basiques et des sous-systèmes
linéaires.
</FILE>

<FILE name='MATBKSL' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  The MATBKSL block outputs the left matrix division. It is
          a solution to A*x=B. The higher input is the A matrix, the
          lower one is the B matrix, and the output is x. If A is an
          M-by-N1 matrix, B must be a M-by-N2 where N1 and N2 can be
          different or equal.
	  The output x is a N1-by-N2 matrix.
        </P>
	<P>
          The equivalent of BACKSLASH is "\" in Scilab.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='MATCATH' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  The MATCATH Block outputs the horizontal concatenation
          of multiple matrices. It is also called concatenation
          according to the columns. The inputs U1,U2,...,Un must
          have the same number of rows. The output is a
          M-by-(N1+N2+...+Nn) matrix, where N1,N2,...,Nn are the
          numbers of columns of the inputs matrices, and M is the
          number of rows.
	</P>
	<P>
          The equivalent of MATCATH in Scilab is y=[U1 U2 ... Un].
        </P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='MATCATV' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  The MATCATV Block outputs the vertical concatenation of
          multiple matrices. It is also called concatenation according
          to the rows. The inputs U1,U2,...,Un must have the same
          number of columns. The output is a (M1+M2+...+Mn)-by-N
          matrix, where M1,M2,...,Mn are the numbers of rows of the
          inputs matrices, and N is the number of columns.
	</P>
	<P>
          The equivalent of MATCATH in Scilab is y=[U1;U2;...;Un]
        </P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='MATDET' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	The MATDET outputs the determinant of a square input matrix.
        If the input A=[A11 A12 A13;A21 A22 A23;A31 A32 A33] then the
        output of the block has the form of:
        y=A11*(A22*A33-A23*A32)-A12*(A21*A33-A23*A31)+A13*(A21*A32-A22*A31).
       </P>
	<P>
        The equivalent of MATDET in Scilab is "det"
        </P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='MATDIAG' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  The MATDIAG block create a diagonal matrix from a 1D vector.
          If the input is a M-by-1 vector than the output is an M-by-M
          matrix.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='MATDIV' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
        The MATDIV block outputs the right matrix division. It is a
        solution to x*B=A. The higher input is the A matrix, the lower
        one is the B matrix, and the output is x. If A is an M1-by-N
        matrix, B must be a M2-by-N where M1 and M2 can be different
        or equal. The output x is a M1-by-M2 matrix.
        </P>
	<P>
        The equivalent of BACKSLASH is "/" in Scilab.
        </P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='MATEIG' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	The MATEIG calculate the eigenvalues and the eigenvectors
        of a square input matrix U.
        </P>
	<P>
        When the "Decomposition type" is set to 1, the block outputs
        the eigenvalues in a vector form, if the input is a M-by-M
        matrix the output is a M-by-1 vector.
        </P>
	<P>
        When the "Decomposition type" is set to 2, the block outputs
        two matrices. for an M-by-M input matrix,the first output is
        a M-by-M diagonal matrix composed by the eigenvalues, and the
        second is a M-by-M matrices composed by the eigenvectors; the
        eigenvectors are represented by the columns of the matrix.
        </P>
	<P>
        The equivalent of the MATEIG block in Scilab is "spec(A)"
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='MATEXPM' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  The MATEXPM outputs the matrix exponential of a square
          matrix input by the pade's approximants. The output is
          a square matrix with the same size of the input. The
          equivalent of this block in Scilab is "expm".
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='MATINV' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  The MATINV Block outputs the inverse of a square input matrix
          using the LU factorization. A warning message is printed if
          the input is badly scaled or nearly singular. The equivalent
          function of this block in Scilab is "inv".
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='MATLU' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  The MATLU Block outputs two matrices L and U, with row
          pivoting, from the LU factorization of a square input
          matrix. If A is the input matrix then E*A=L*U where E
          is the permutation matrix.The equivalent function of
          this block in Scilab is "[l,u,e]=lu(A)"
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='MATMAGPHI' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>MATMAGPHI Block has two types of decomposotions.</P>
	<P>
        When the type is set to one, the block converts a complex
        number to the magnitude and the radian angle, in this case
        the input is complex and the outputs are real double. If
        the input is real double, the angle will be zero or PI and
        the magnitude will be equal to the absolute of the input number.
        </P>
	<P>
        When the type is set to two, the block outputs a complex number
        given the magnitude and the radian angle. In this case the inputs
        are real double and the output is complex.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='MATMUL' type='XML'>
<DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  Le bloc MATMUL fait la multiplication matricielle de ses deux entrées. Le
          nombre de lignes de la seconde matrice doit être égal au nombre de colonnes
          de la première. La sortie est une matrice où le nombre de lignes est égal à
          celui de la première matrice d'entrée et où le nombre de colonnes est égal à
          celui de la deuxième matrice d'entrée.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='MATPINV' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	The MATPINV Block outputs the inverse of a non square input
        matrix using the SVD theory.if the SVD decomposition of A is
        equal to:
        </P>
	 <P>A=USV'</P>
	<P>
        The pseudoinverse x of A is given by:
        </P>
	 <P>X=VS"U' where S"(i,j)=1/S(i,j) (if S(i,j)~=0),
	    U' and V are respectivly the transpose of U and V'.
         </P>
	<P>
        and we have A*X*A=A and X*A*X=X. Both A*X and X*A
        are Hermitian . A warning message is printed if the input
        is badly scaled or nearly singular.
        </P>
	<P>
        When the input is a M-by-N matrix the output is a
        N-by-M matrix. The eqivalent function of this block
        in Scilab is "pinv".
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='MATRESH' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  The RESHAPE block changes the dimensions of a matrix or
          a vector to another dimensions specified by the user in
          the "output size desired" label. The output size must be
          less or equal to the input size.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='MATSING' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
        The MATSING block computes the economy sized SVD of the
        M-by-N input matrix A by finding U,S and V such that
        </P>
	 <P>A=U*S*V'.</P>
	<P>
        When the decomposition type is set to one, the output is
        a vector composed by the singular values.
        </P>
	<P>
        When the decomposition type is set to two, we have three
        outputs: the second output is a diagonal matrix S composed
        by the singular values and the other two outputs are the
        unitary matrices U and V.
        </P>
	<P>
        The equivalent function of this block in Scilab is "svd".
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='MATSUM' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  The MATSUM block returns the sum of the element of an input matrix/vector.
	  When the Sum along is set to all the block outputs the sum of all the
          elements of the matrix. The output is then a scalar.
	  When the Sum along is set to lines the block is a rowwise sum. The output is
          a row vector.
	  When the Sum along is set to Columns the block is a columnwise sum. The
          output is a column vector.
	  The equivalent function of this block in scilab is: "sum".
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='MATTRAN' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  Ce bloc fait la transposition d'une matrice de taille MxN en matrice de
          taille NxM. Pour les données de type complexe, celui-ci utilise une
          transposition Hermitienne. L'instruction scilab équivalente de ce bloc est
          y=u'.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='MATZCONJ' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  This blocks computes the conjugate of a complex input matrix.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='MATZREIM' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  This block decomposes a complex number by seperating the real
          and imaginary parts or compose a comples number by joining the
          two parts. The user can select even to seperate or to join real
          and imaginary part by setting the decomposition type to 1 or 2.
          When it is set to 1, the input is a complex matrix and the
          outputs are the real and imaginary parts of the input. When it
          set to 2, The inputs are two real matrices, the output is a
          complex number with real part the first input and imaginary
          part the second input.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='MAXMIN' type='LATEX'>
Ce bloc peut trouver aussi bien le maximum que le minimum dans les
éléments de ses entrées.
La fonction min ou max peut être choisie dans les paramètres de la
boîte de dialogue.
</FILE>

<FILE name='MAX_f' type='LATEX'>
Ce bloc trouve la valeur maximale dans les éléments
de son vecteur d'entrée.
</FILE>

<FILE name='MBLOCK' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
    <DESCRIPTION_ITEM>
    <P>
    The block "MBlock" provides an easy way to build a Scicos block
    whose behavior is specified by a Modelica program.  Using this
    block, the user will be able to write and compile Modelica
    programs in Scicos without creating any interfacing function.  The
    associated Modelica program of this block can be either given in a
    file or written in the window opened by the block. In order to
    link this block to other Scicos blocks that may be other Modelica
    blocks, the types of block ports' as well as their associated variables
    should be specified.
    </P>
    </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='MCLOCK_f' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='MEMORY_f' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='MFCLCK_f' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='MIN_f' type='LATEX'>
Ce bloc trouve la valeur minimale dans les éléments
de son vecteur d'entrée.
</FILE>

<FILE name='MOTOR' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='MUX' type='LATEX'>
Ce bloc regroupe $n$ vecteurs d'entrée en un seul vecteur à la sortie.
La sortie est $y=[u_1;u_2;\cdots;u_n]$ , où les $u_i$ numérotées dans
un ordre croissant correspondent aux ports réguliers d'entrée du haut
vers le bas.
Les tailles d'entrée/sortie sont soit déterminées automatiquement
à la compilation ou alors déterminées par le paramètre
{\bf number of input ports or vector of sizes}.
</FILE>

<FILE name='MUX_f' type='LATEX'>
Ce bloc regroupe $n$ vecteurs d'entrée en un seul vecteur à la sortie.
La sortie est $y=[u_1;u_2;\cdots;u_n]$ , où les $u_i$ numérotées dans
un ordre croissant correspondent aux ports réguliers d'entrée du haut
vers le bas.
Les tailles d'entrée/sortie sont soit déterminées automatiquement
à la compilation ou alors déterminées par le paramètre
{\bf number of input ports or vector of sizes}.
</FILE>

<FILE name='M_SWITCH' type='LATEX'>
The Multi-Port Switch block chooses between a number of inputs. The
first (top) input is called the control input, while the rest of the
inputs are called data inputs. The value of the control input
determines which data input is passed through to the output port.
</FILE>

<FILE name='M_freq' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	This blocks generates events at specific sample time of the
        simulation time. The sample time is given in the "Sample Time"
        field and the offset is given in the "Offset" field. This
        block has one event input, the number of event outputs depends
        on the number of different sample time. For exemple if the vector
        of sample time is [1 1 2] and the vector of offset is [0 .5 0]
        then the block has 7 outputs.
        </P>
	<P> - The first output is activated when the simulation time
              is equal to a multiple of the first sample time plus
              the first offset
        </P>
	<P> - The second output is activated when the simulation time
              is equal to a multiple of the second sample time plus
              the second offset.
        </P>
	<P> - The third output is activated when we have both cases,
              first case and second case.
        </P>
	<P> - The fourth output is activated when the simulation time
              is equal to a multiple of the third sample time plus
              the third offset.
        </P>
	<P> - The fifth output is activated when we have both cases,
              first case and forth case.
        </P>
	<P> - The sixth output is activated when we have both cases,
              second case and fourth case.
        </P>
	<P> - The seventh output is activated when we have both cases,
              third case and forth case.
        </P>
	<P> etc...</P>
	<P>
        So the number of outputs is equal to 2**number of differents
        time values. Each of these time values is represented by a
        binary number associated to the output's number in decimal.
        </P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='Matrix_pal' type='LATEX'>
Cette palette contient tous les blocs dont vous avez
besoin pour réaliser des opérations matricielles 
simples et complexes.
</FILE>

<FILE name='Menu_entries' type='XML'>
<DESCRIPTION>

</DESCRIPTION>
</FILE>

<FILE name='Modulo_Count' type='LATEX'>
Ce bloc est un bloc discret.
Il délivre un signal scalaire périodique qui a une forme déterminée
par les choix de l'utilisateur.
</FILE>

<FILE name='NEGTOPOS_f' type='LATEX'>
Un événement est généré lorsque l'unique entrée de ce bloc traverse
la valeur zéro lors d'un front montant.
</FILE>

<FILE name='NPN' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ce bloc est un modèle simple pour le transistor bipolaire NPN basé sur
le modèle  Ebers-Moll.
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='NRMSOM_f' type='LATEX'>
The Merge block combines its inputs into a single output line whose
value at any time is equal to the most recently computed output of its
driving blocks. You can specify any number of inputs by setting the
block's Number of inputs parameter.  
</FILE>

<FILE name='Non_linear_pal' type='LATEX'>
Cette palette contient des fonctions non-linéaires.
</FILE>

<FILE name='OUTIMPL_f' type='LATEX'>
Les ports de sortie OUTIMPL\_f sont des liens qui permettent de connecter
l'extérieur d'un système vers l'intérieur.
</FILE>

<FILE name='OUT_f' type='LATEX'>
Ce bloc doit être utilisé dans un superbloc pour représenter un port
de sortie régulier. La taille de ce port est ajustée automatiquement.
Dans un superbloc, les ports de sortie réguliers doivent être numérotés
de 1 jusqu'au nombre de ports de sortie réguliers composant le superbloc.
</FILE>

<FILE name='OldBlocks_pal' type='LATEX'>
Cette palette contient des anciens blocs Scicos.
Elle est fournie pour pouvoir assurer la compatibilité
avec des anciens diagrammes contenant ces anciens blocs.
</FILE>

<FILE name='Others_pal' type='XML'>
<DESCRIPTION>

</DESCRIPTION>
</FILE>

<FILE name='PDE' type='LATEX'>
This block is an implementation of several numerical schemes (Finite Elements (1st and 2nd order),
Finite Differences (1st and 2nd order), Finite Volumes (1st order)) to solve mono dimensional 
PDE (Partial Differential Equation) within SCICOS.
The mathematical framwork was restricts in PDEs linear scalars with maximum order 2 in time and space.
The goal is to provide engineers and physicists with an easy to use toolbox in SCICOS that will let them
graphically describe the PDE to be solved. A decision system selects the most efficient numerical scheme
depending on the type of the PDE and runs the solvers.
</FILE>

<FILE name='PID' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
    <DESCRIPTION_ITEM>
    <P>
    Ajoutez ici un paragraphe pour la description de la fonction
    </P>
    </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='PNP' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ce bloc est un modèle simple pour le transistor bipolaire PNP basé sur
le modèle  Ebers-Moll.
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='POSTONEG_f' type='LATEX'>
Un événement est généré lorsque l'unique entrée de ce bloc traverse
la valeur zéro lors d'un front descendant.
</FILE>

<FILE name='POWBLK_f' type='LATEX'>
Ce bloc réalise $y(i)=u(i)^a$.
Les tailles des ports d'entrée/sortie sont déterminées par le
compilateur.
</FILE>

<FILE name='PRODUCT' type='LATEX'>
The Product block performs multiplication or division of its
inputs. This block produces outputs using either element-wise or
matrix multiplication, depending on the value of the Multiplication
parameter. You specify the operations with the Number of inputs
parameter. Multiply(+1) and divide (-1) characters indicate the
operations to be performed on the inputs.
</FILE>

<FILE name='PROD_f' type='LATEX'>
La sortie de ce bloc est le produit élément par élément des entrées.
</FILE>

<FILE name='PerteDP' type='LATEX'>
Un bloc de PertDP représente un tuyau hydraulique avec des pertes de
charge. Ce composant représente une perte de charge hydraulique où la
perte de pression est directement proportionnelle au débit, état
laminaire.  Ce bloc a une direction; c.-à-d. la direction positive est
quand le fluide entre par le port d'entrée (le noir). Ceci signifie
que ce bloc suppose que le débit est positif si le fluide découle du
port noir vers le port blanc.  Les paramètres importants de ce composant
sont la longueur, le diamètre du tuyau, les altitudes des ports
d'entrée et de sortie, et quelques autres coefficients
thermo-hydrauliques.
</FILE>

<FILE name='PotentialSensor' type='LATEX'>
Ce bloc est employé pour mesurer la tension d'un noeud par rapport à
celle de terre (zero) dans un circuit électrique. La tension est
donnée à la partie explicite du modèle par un port explicite.
</FILE>

<FILE name='PuitsP' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  Ce composant représente un puit thermo-hydraulique de
	  pression constante. Ce bloc est défini avec sa pression
          et sa température. La direction positive est quand le
          fluide coule dans le bloc.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='QUANT_f' type='LATEX'>
Ce bloc quantifie le signal d'entrée suivant les méthodes choisies :
\begin{enumerate}
\item méthode 'Round' :
\begin{eqnarray}
 y(i)&={\rm Step}*({\rm int}(u(i)/{\rm Step}+0.5)-0.5) &\texttt{si} \; u(i)<0 .\\
 y(i)&={\rm Step}*({\rm int}(u(i)/{\rm Step}-0.5)+0.5) &\texttt{si} \; u(i)>=0 .
\end{eqnarray}
\item méthode 'Truncation' :
\begin{eqnarray}
 y(i)&={\rm Step}*({\rm int}(u(i)/{\rm Step}+0.5)) &\texttt{si} \; u(i)<0 .  \\
 y(i)&={\rm Step}*({\rm int}(u(i)/{\rm Step}-0.5)) &\texttt{si} \; u(i)>=0 .
\end{eqnarray}
\item méthode 'Floor' :
\begin{eqnarray}
 y(i)&={\rm Step}*({\rm int}(u(i)/{\rm Step}+0.5))  .
\end{eqnarray}
\item  méthode 'Ceil' :
\begin{eqnarray}
 y(i)&={\rm Step}*({\rm int}(u(i)/{\rm Step}-0.5))
\end{eqnarray}
\end{enumerate}
</FILE>

<FILE name='RAMP' type='LATEX'>
Le bloc RAMP génére un signal qui commence à une date et à une valeur
spécifiées et évolue suivant une pente donnée.
Les paramètres {\bf Slope , Start time} et {\bf Initial output} déterminent
les caractéristiques du signal de sortie.
Ces paramètres doivent avoir des dimensions identiques.
</FILE>

<FILE name='RAND_f' type='LATEX'>
Ce bloc est un générateur de nombres aléatoires : chaque composante de sortie
prend des valeurs constantes aléatoires par morceaux. Pour chaque événement les
sorties prennent des nouvelles valeurs indépendantes.\\
La taille du port de sortie est déterminée par la taille des vecteurs {\bf A} et {\bf B}.
</FILE>

<FILE name='RAND_m' type='LATEX'>
Ce bloc est un générateur de nombres aléatoires : chaque composante de sortie
prend des valeurs constantes aléatoires par morceaux. Pour chaque événement les
sorties prennent des nouvelles valeurs indépendantes.\\
La taille du port de sortie est déterminée par la taille des matrices {\bf A} et {\bf B}.
</FILE>

<FILE name='RATELIMITER' type='LATEX'>
The Rate Limiter block limits the first derivative of the signal
passing through it. The output changes no faster than the specified
limit.
</FILE>

<FILE name='READAU_f' type='LATEX'>
Charge un son enregistré dans un fichier 'au'.
Les données échantillonnées seront écrites sur la sortie y du bloc.
Si l'extension du fichier n'est pas spécifiée alors l'extension '.au' est
automatiquement ajoutée.
Les valeurs d'amplitude sont comprises entre [-1,+1].
La lecture 'au' supporte les données multi-canaux sous les formats suivants :
\begin{itemize}
   \item 8-bit mu-law 
   \item 8-, 16-, and 32-bit linear
   \item Floating-point
\end{itemize}
</FILE>

<FILE name='READC_f' type='LATEX'>
Ce bloc permet de lire des données dans un fichier C.
Les paramètres {\bf Output record selection] et {\bf Time record Selection}
permettent de sélectionner des données dans les enregistrements du fichier.
Chaque appel au bloc, fait avancer d'un enregistrement dans le fichier.
</FILE>

<FILE name='REGISTER' type='LATEX'>
Ce bloc réalise un registre à décalage.
Pour chaque événement d'entrée, le registre est décalé d'un élément.
</FILE>

<FILE name='REGISTER_f' type='LATEX'>
Ce bloc réalise un registre à décalage.
Pour chaque événement d'entrée, le registre est décalé d'un élément.
</FILE>

<FILE name='RELATIONALOP' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
    <DESCRIPTION_ITEM>
    <P>
    Ajoutez ici un paragraphe pour la description de la fonction
    </P>
    </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='RELAY_f' type='LATEX'>
This block routes one of the regular inputs to the unique regular
output. the choice of which input is to be routed is done, initially
by the "initial connected input" parameter. Then, every time an input
event arrives on the i-th input event port, the i-th regular input
port is routed to the regular output.
</FILE>

<FILE name='RFILE' type='LATEX'>
Ce bloc permet à l'utilisateur de lire des données dans un fichier.
Ces données peuvent être formatées ou binaires.
Les paramètres {\bf  Output record selection} et {\bf Time record selection}
permettent de selectionner des données parmi les enregistrements du fichier.
Chaque appel au bloc avance d'un enregistrement.\\
Ce bloc fonctionne de paire avec le bloc \htmladdnormallink{WFILE}{WFILE.htm}.
</FILE>

<FILE name='RFILE_f' type='LATEX'>
Ce bloc permet à l'utilisateur de lire des données dans un fichier.
Ces données peuvent être formatées ou binaires.
Les paramètres {\bf  Output record selection} et {\bf Time record selection}
permettent de selectionner des données parmi les enregistrements du fichier.
Chaque appel au bloc avance d'un enregistrement.\\
Ce bloc fonctionne de paire avec le bloc \htmladdnormallink{WFILE\_f}{WFILE_f.htm}
</FILE>

<FILE name='RICC' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	This block computes the solution of riccati equation using
        different method and for both case continuous and discrete.
        </P>
	<P> The riccati equation in continuous time is:</P>
	<P>     A*X+X*A+C-X*D*X=0 </P>
	<P> The riccati equation in discrete time is:</P>
	<P>     A*X*(inv(In-D))*A-X+C=0</P>
	<P>
         where A is an NxN matrix, it is the first input of the block,
         C and D are two NxN symetrics matrices and are respectivly the
         second and third input of the RICC block. X represent the
         output of the block, it is also a NxN matrix.
        </P>
	<P>
         The user can choose between two methods of computation. For the
         continuous time he can use even the Schur method or the matrix
         sign function approach method, by setting the Model parameter
         to 1 or 2. For the discrete time, the models are the Schur
         method and the inverse free spectral decomposition method.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='ROOTCOEF' type='LATEX'>
Ce bloc calcule les coefficients d'un polynôme grâce aux valeurs
des racines.
</FILE>

<FILE name='Resistor' type='LATEX'>
Une résistance est un composant électrique à deux ports qui résiste à
un courant électrique en produisant une chute de tension ($V$) : la loi
d'Ohm.

 \[ R = \frac {V}{I}\] 

  La résistance électrique ($R$) est égale à la chute de tension entre
les ports de la résistance divisée par le courant qui passe au travers
($I$).
</FILE>

<FILE name='SAMPHOLD' type='LATEX'>
A chaque fois qu'un événement est reçu, ce bloc copie la valeur de son
entrée sur sa sortie et maintient cette valeur jusqu'au prochain
événement.
Pour réaliser un échantillonneur bloqueur périodique, l'entrée
événementielle doit être connectée à une horloge {\bf Clock}.
</FILE>

<FILE name='SAMPHOLD_m' type='LATEX'>
A chaque fois qu'un événement est reçu, ce bloc copie la valeur de son
entrée sur sa sortie et maintient cette valeur jusqu'au prochain
événement.
Pour réaliser un échantillonneur bloqueur périodique, l'entrée
événementielle doit être connectée à une horloge {\bf Clock}.
</FILE>

<FILE name='SAMPLEHOLD_f' type='LATEX'>
A chaque fois qu'un événement est reçu, ce bloc copie la valeur de son
entrée sur sa sortie et maintient cette valeur jusqu'au prochain
événement.
Pour réaliser un échantillonneur bloqueur périodique, l'entrée
événementielle doit être connectée à une horloge {\bf Clock}.
</FILE>

<FILE name='SATURATION' type='LATEX'>
Le bloc saturation impose des limites maximale et minimale sur un signal.
Lorsque le signal est compris dans l'échelle définie par les paramètres
{\bf Upper limit} et {\bf Lower limit}, celui ci est reporté à la sortie
sans modifications.
Lorsque le signal sort de ces limites, alors le signal sature à la sortie
du bloc.
</FILE>

<FILE name='SAT_f' type='LATEX'>
Le bloc saturation impose des limites maximale et minimale sur un signal.
Lorsque le signal est compris dans l'échelle définie par les paramètres
{\bf Upper limit} et {\bf Lower limit}, celui ci est reporté à la sortie
sans modifications.
Lorsque le signal sort de ces limites, alors le signal sature à la sortie
du bloc.
</FILE>

<FILE name='SAWTOOTH_f' type='LATEX'>
Ce bloc est un générateur de dents de scie : 
la sortie de ce bloc est calculée par $(t-t_i)$ de $t_i$ jusqu'à $t_{i+1}$
où $t_i$ et $t_{i+1}$ sont les instants de deux événements d'entrée successifs.
</FILE>

<FILE name='SCALAR2VECTOR' type='LATEX'>
Ce bloc convertit une valeur scalaire en un vecteur.
Lorsque des blocs avec plus d'un port régulier son utilisés (comme Somme
ou le bloc Relational Operator), vous pouvez mixer des entrées scalaires
et vectorielles.
Lorsque vous faites cela, les entrées scalaires sont étendues à des vecteurs
dont les tailles sont égales aux tailles des vecteurs d'entrée.
Si plus d'un port d'entrée est vectoriel, alors ils doivent avoir la même taille.
</FILE>

<FILE name='SELECT_f' type='LATEX'>
Ce bloc redirige l'une de ses entrées régulières sur l'unique
sortie régulière.
Le choix qui est fait pour savoir quel est le port d'entrée redirigé
est initalement fait par le paramètre {\bf initial connected input}.
Pendant la simulation, à chaque fois que ce bloc est activé par son
entrée événementielle $i$, alors la valeur présente sur le
 $i^{\rm \grave{e}me}$ port régulier est recopiée sur la sortie. 
</FILE>

<FILE name='SELECT_m' type='LATEX'>
Un bloc selecteur accepte sur son entrée aussi bien un vecteur qu'une matrice.
Vous pouvez définir le paramètre {\bf Input Type} au type de signal que vous
utilisez dans votre modèle (matrice ou vecteur).
Les paramètres de la boîte de dialogue et l'aspect du bloc changent en accord
avec le type de l'entrée, ainsi que la manière dont il détermine les éléments 
à sélectionner.
%Ce bloc redirige l'une de ses entrées régulières sur l'unique
%sortie régulière.
%Le choix qui est fait pour savoir quel est le port d'entrée redirigé
%est initalement fait par le paramètre {\bf initial connected input}.
%Pendant la simulation, à chaque fois que ce bloc est activé par son
%entrée événementielle $i$, alors la valeur présente sur le
% $i^{\rm \grave{e}me}$ port régulier est recopiée sur la sortie.
</FILE>

<FILE name='SHIFT' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  This block shifts the bits of the input signal. In this
          operation the digits are moved to the right or to the left.
	  The user can choose the rule to shifts the bits. It can be
          normal or cycle by setting the "Shifttype" parameter to "0"
          or "1".
        </P>
	<P>
          When the Shifttype is 0, an arithmetic shift is applied to the
          input signal. In this case, the bits that are shifted out of
          either end are discarded. Zeros are shifted in on the right,
          in the case of left shift; in the case of right shifts, copies
          of the sign bit is shifted in on the left.
        </P>
	<P>
          When the "Shifttype" is 1,a circular shift is applied to the
          input signal. In this case, the bits are rotated as if the left
          and right ends of the register are joined. The value that is
          shifted in on the right during a left-shift is whatever values
          was shifted out on the left, and vice versa.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='SIGNUM' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
    <DESCRIPTION_ITEM>
    <P>
    Ajoutez ici un paragraphe pour la description de la fonction
    </P>
    </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='SINBLK_f' type='LATEX'>
$$y={\rm sin}(u)$$
</FILE>

<FILE name='SLIDER_f' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='SPLIT_f' type='XML'>
<DESCRIPTION>

</DESCRIPTION>
</FILE>

<FILE name='SQRT' type='LATEX'>
Ce bloc calcule les racines carré de cahque élément de la matrice d'entrée.
Il supporte les types de donnée réels et complexes.
</FILE>

<FILE name='SRFLIPFLOP' type='LATEX'>
This block describe the simplest and the most fundamental latch
the SR flip flop. Where S and R are the input and Q and !Q are the
outputs.If S (Set) is pulsed high while R is held low, then the Q
output is forced high, and stays high when S returns low; similarly,
if R (Reset) is pulsed high while S is held low, then the Q output
is forced low, and stays low when R returns low. When both are low,
Q(t) takes the same state as Q(t-1). When they are both high, both Q
and !Q take the low values we are in an unstable state. Practicaly we
have to avoid this case.This block is almostly used with digital
number, the input data type is int8.\\

The truth table of this block is

\begin{tabular}{|c|c||c|c|}
\hline
S&
R&
Q(t)&
!Q(t)\\
\hline
0&
0&
Q(t-1)&
!Q(t-1)\\
\hline
0&
1&
0&
1\\
\hline
1&
0&
1&
0\\
\hline
1&
1&
0&
0\\
\hline --> This case is to avoid
\end{tabular}
</FILE>

<FILE name='STEP' type='XML'>
<DESCRIPTION>

</DESCRIPTION>
</FILE>

<FILE name='STEP_FUNCTION' type='LATEX'>
Le bloc 'Step' réalise un saut entre deux niveaux définis à un temps
spécifié.
Si le temps de simulation est inférieur au paramètre {\bf Step time}, la 
sortie est égale à la valeur du paramètre {\bf Initial value}.
Pour les temps de simulation supérieurs, la sortie est égale à la valeur
du paramètre {\bf Final value}.
</FILE>

<FILE name='SUBMAT' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  This block outputs a sub matrix of the input matrix.
          The output matrix will be defining by using the parameters
          of this block.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='SUMMATION' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P> Ce bloc fait l'addition ou la soustraction de ses entrées. Ce bloc
	peut additioner et soustraire des grandeurs scalaires, vectorielles et
	matricielles. Il peut aussi faire la somme cumulative d'une seule entrée
	vectorielle.</P>
	<P>
        Le nombre d'entrée est donné par le second paramètre de la boite de dialogue.
        Ce paramètre peut être un vecteur de nombre +1 et -1 ou bien
	il peut être une seule valeur positive. Dans le premier cas le vecteur donne le
        nombre d'entrée et le signe indique si c'est une addition ou une soustraction.
        Pour le second choix, ce bloc est un additionneur dont le nombre d'entrée est
        déterminée par la valeur de ce paramètre.
        </P>
	<P>
        Lorsqu'un dépassement intervient, le résulat peut prendre des valeurs
        différentes suivant le troisième paramètre "DO ON OVERFLOW":
       </P>
	<P>1- Un résulat non saturé.</P>
	<P>2- Un résultat saturé.</P>
	<P>3- Un message d'erreur est signalé lorsqu'un dépassement intervient.</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='SUM_f' type='LATEX'>
Le bloc somme réalise l'addition de ses entrées.
Ce bloc peut additionner des scalaires ou des vecteurs d'entrée.
</FILE>

<FILE name='SUPER_f' type='LATEX'>
This block opens up a new Scicos window for editing a new block
diagram. This diagram describes the internal functions of the super
block.  

Super block inputs and outputs (regular or event) are
designated by special (input or output) blocks.  

Regular input blocks
must be numbered from 1 to the number of regular input ports. Regular
input ports of the super block are numbered from the top of the block
shape to the bottom.  Regular output portss must be numbered from 1 to
the number of regular output ports. Regular output ports of the super
block are numbered from the top of the block shape to the bottom.
Event input blocks must be numbered from 1 to the number of event
input ports. Event input ports of the super block are numbered from
the left of the block shape to the right.  Event output ports must be
numbered from 1 to the number of event output ports. Event output
ports of the super block are numbered from the left of the block shape
to the right.
</FILE>

<FILE name='SWITCH2' type='LATEX'>
The Switch block passes through the first (top) input or the third
(bottom) input based on the value of the second (middle) input. The
first and third inputs are called data inputs. The second input is
called the control input. You select the conditions under which the
first input is passed with the Criteria for passing first input
parameter. You can make the block check whether the control input is
greater than or equal to the threshold value, purely greater than the
threshold value, or nonzero. If the control input meets the condition
set in the Criteria for passing first input parameter, then the first
input is passed. Otherwise, the third input is passed. 
</FILE>

<FILE name='SWITCH2_m' type='LATEX'>
The Switch block passes through the first (top) input or the third
(bottom) input based on the value of the second (middle) input. The
first and third inputs are called data inputs. The second input is
called the control input. You select the conditions under which the
first input is passed with the Criteria for passing first input
parameter. You can make the block check whether the control input is
greater than or equal to the threshold value, purely greater than the
threshold value, or nonzero. If the control input meets the condition
set in the Criteria for passing first input parameter, then the first
input is passed. Otherwise, the third input is passed. 
</FILE>

<FILE name='SWITCH_f' type='LATEX'>
Ce bloc est un 'interrupteur' manuel.
Il sélectionne une de ses entrées pour la rédigirer vers sa sortie.
Les entrées non sélectionnées ne sont donc pas propagées.
</FILE>

<FILE name='SampleCLK' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	The difference between the SampleCLK and the CLOCK_c is that
        all the SampleCLK blocks in our diagram are synchronous. The
        synchronism is done due to two differents methods of computation
        in the compilation phase.
        </P>
	<P>
        The first method consists of computing a clock that is faster
        than all the SampleCLK connected to a counter which activate
        the event select block.
        </P>
	<P>The clock is calculated due to the following rule.</P>
	<P>
        If all the blocks have the same offset then the frequency of
        the clock is the gcd of the sample time, and the offset of the
        clock is equal to the offset.
        </P>
	<P>
        If the offsets are differents, then the frequency of the clock
        is the gcd of the sample time and the offset, and the offset of
        the clock is equal to 0.
        </P>
	<P>
        The Counter counts from one to the least commun multiple of the
        sample time (lcm).
        </P>
	<P>
        The number of outputs of the ESELECT_f block is equal to the lcm.
        </P>
	<P>
        The second method uses the Multifrequency block it generates
        events only for specific time. Events in this method are not
        periodicly generated as in the first one.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='Sigbuilder' type='LATEX'>
The Signal Builder block is a superblock containing a
\htmladdnormallink{CURVE\_c}{CURVE_c.htm} block whose output event
port is connected to its input event port. This event feedback gives
the possibility to generate events at discontinuous point of the
signal. The generated events automatically restart the numerical
solver and avoids numerical problems. The generated event is also made
available to the user for possible use. Remind that if higher
interpolation methods are used, the events are generated only at the
beginning and at the end of the signal.
</FILE>

<FILE name='SineVoltage' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ce bloc est un bloc Modelica pour une source de tension sinusoïdale.
La résistance ohmique interne de ce bloc est zéro.
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='Sinks_pal' type='LATEX'>
Dans la palette Sinks, vous pouvez trouver une variété de
blocs utilisés pour afficher (Scope) et écrire les données
dans des fichiers pendant la simulation ainsi que des ports
de sortie utilisés dans les superblocs.\\
Les blocs de cette palette ne possèdent pas de ports réguliers
de sortie.
</FILE>

<FILE name='SourceP' type='LATEX'>
Ce composant représente une source thermohydraulique de pression
constante. Ce bloc est défini avec sa pression et sa température.  La
direction positive conventionnelle est quand le fluide sort du bloc.
</FILE>

<FILE name='Sources_pal' type='LATEX'>
La plupart des blocs de la palette source peuvent être compris comme
des générateurs de données.
Cette palette contient aussi des blocs pour lire des données dans des
fichers, ainsi que des ports d'entrée utilisés dans les superblocs.\\
Les blocs de cette palette ne possèdent pas de ports réguliers d'entrée.
</FILE>

<FILE name='TANBLK_f' type='LATEX'>
$$y={\rm tan}(u)$$
</FILE>

<FILE name='TCLSS' type='LATEX'>
Ce bloc réalise un système d'équations d'etat en temporel continu avec
la possibilités de réaliser des sauts dans l'état.
Le nombre d'entrées de ce bloc est deux.
La première entrée est l'entrée régulière du système linéaire.
La seconde fournie la valeur du nouvel état qui est copié dans l'état du système lorsque le bloc est activé par un événement sur son unique port d'entrée événementiel.
Cela signifique que l'état du système saute à la valeur présente sur le deuxième port d'entrée (de taille égale à l'état du système).
Le système est défini par les matrices $(A,B,C,D)$
et par l'état initial $x_0$.
Les dimensions des matrices et de l'état initial doivent être appropriées.
Les tailles des entrées et des sorties sont ajustées automatiquement.
</FILE>

<FILE name='TCLSS_f' type='LATEX'>
Ce bloc réalise un système d'équations d'etat en temporel continu avec
la possibilités de réaliser des sauts dans l'état.
Le nombre d'entrées de ce bloc est deux.
La première entrée est l'entrée régulière du système linéaire.
La seconde fournie la valeur du nouvel état qui est copié dans l'état du système lorsque le bloc est activé par un événement sur son unique port d'entrée événementiel.
Cela signifique que l'état du système saute à la valeur présente sur le deuxième port d'entrée (de taille égale à l'état du système).
Le système est défini par les matrices $(A,B,C,D)$
et par l'état initial $x_0$.
Les dimensions des matrices et de l'état initial doivent être appropriées.
Les tailles des entrées et des sorties sont ajustées automatiquement.
</FILE>

<FILE name='TEXT_f' type='LATEX'>
Ce bloc spécial est utilisé pour ajouter du texte dans un diagramme scicos.
Il n'affecte pas la simulation.
</FILE>

<FILE name='TIME_DELAY' type='LATEX'>
Ce bloc retarde l'entrée par un laps de temps spécifié.
Il peut être utilisé pour la simulation d'un retad temporel.
Au début de la simulation, le bloc délivre la valeur du paramètre
{\bf Initial input} jusqu'à ce que le temps de la simulation dépasse
le paramètre {\bf Time delay}, auquel cas, le bloc commence à réaliser
le retard.\\
La valeur du paramètre {\bf Time delay} doit être non-négative.
</FILE>

<FILE name='TIME_f' type='LATEX'>
Ce bloc est un générateur de temps.\\
La seule sortie régulière de ce bloc donne le temps courant de la
simulation.
</FILE>

<FILE name='TOWS_c' type='LATEX'>
Ce bloc est utilisé pour transférer des données simulées dans
l'environnement Scilab.\\
A chaque instants d'échantillonnage, aussi bien les dates que les valeurs
de l'entrée sont enregistrées.
</FILE>

<FILE name='TRASH_f' type='XML'>
<DESCRIPTION>
 <DESCRIPTION_INDENT>
  <DESCRIPTION_ITEM>
  <P>
  Ce bloc est un bloc de terminaison.
  Il ne fait rien.
  </P>
  </DESCRIPTION_ITEM>
 </DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='ThermoHydraulics_pal' type='LATEX'>
La boîte à outils de thermohydraulique contient certains composants
thermohydrauliques tels que la source de pression, le tuyau, les vannes
réglantes, etc.
</FILE>

<FILE name='Threshold_pal' type='LATEX'>
Les blocs de cette palette sont utilisés pour détecter des passages à
certaines valeurs des variables d'état pendant la simulation.
Ces blocs utilisent les solveurs (EDO ou EAD) pour réaliser cette
opération.
</FILE>

<FILE name='TrigFun' type='LATEX'>
The Trigonometric Function block performs numerous common
trigonometric functions. You can select one of these functions from
the Function list: sin, cos, tan, asin, acos, atan, atan2, sinh, cosh,
and tanh. The block output is the result of the operation of the
function on the input or inputs. 
</FILE>

<FILE name='VARIABLE_DELAY' type='LATEX'>
The Variable Transport Delay block can be used to simulate a variable
time delay. The block might be used to model a system with a pipe
where the speed of a motor pumping fluid in the pipe is variable. The
block accepts two inputs: the first input is the signal that passes
through the block; the second input is the time delay. 
</FILE>

<FILE name='VVsourceAC' type='LATEX'>
Ce bloc est un modèle pour une source de tension CA contrôlable. Ce
composant fournit une tension sinusoidale entre ses
ports. L'amplitude de la tension de sortie est définie par une entrée
explicite et la fréquence est définie par l'utilisateur. La résistance
ohmique de ce bloc est zéro.
</FILE>

<FILE name='VanneReglante' type='LATEX'>
Le bloc de VanneReglante représente une Vanne Reglante ou une vanne à
orifice variable. Le débit du fluide passe par la vanne et est
proportionnel à l'ouverture de vanne, {\it c.-à-d.},

\[
  \Delta P \times h\times\left| h \right| = k\times Q\times \left|Q\right|
\]

là où $h$ est l'ouverture de vanne, $\delta P$ est la différence de
pression, et $Q$ est le débit. Ce modèle est seulement employé pour
les régimes laminaires d'écoulement. $k$ est une constante qui dépend
de la géométrie de la vanne et de la masse volumique de fluide.
</FILE>

<FILE name='VariableResistor' type='LATEX'>
Ce composant représente une résistance ohmique variable. La résistance
est commandée par le port d'entrée explicite.  \[ R_x = \frac {V}{I}
\]
</FILE>

<FILE name='VoltageSensor' type='LATEX'>
Ce composant est employé pour mesurer la différence de tension entre
deux noeuds dans un circuit électrique. Le signal de sortie est la
différence entre la tension du port noir et celle du port blanc.
La conductance ohmique de ce bloc est zéro.
</FILE>

<FILE name='VsourceAC' type='LATEX'>
Ce composant est une source de tension CA avec une tension de sortie
sinusoidale. L'amplitude et la fréquence de la tension de sortie
sont définies par l'utilisateur. La résistance ohmique de ce bloc est
zéro.
</FILE>

<FILE name='WFILE' type='LATEX'>
Ce bloc permet à l'utilisateur de sauvegarder des données dans un fichier.
Ces données peuvent être formatées ou binaires.
Chaque appel au bloc correspond à un enregistrement.
Chaque enregistrement à la forme suivante :  $[t,V1,...,Vn]$ où $t$ est la valeur du temps lorsque le bloc est appelé et $V_i$ est la $i^{\rm\grave{e}me}$ valeur d'entrée.
Ce bloc fonctionne de paire avec le bloc \htmladdnormallink{RFILE}{RFILE.htm}.
</FILE>

<FILE name='WFILE_f' type='LATEX'>
Ce bloc permet à l'utilisateur de sauvegarder des données dans un fichier.
Ces données peuvent être formatées ou binaires.
Chaque appel au bloc correspond à un enregistrement.
Chaque enregistrement à la forme suivante :  $[t,V1,...,Vn]$ où $t$ est la valeur du temps lorsque le bloc est appelé et $V_i$ est la $i^{\rm\grave{e}me}$ valeur d'entrée.\\
Ce bloc fonctionne de paire avec le bloc \htmladdnormallink{RFILE\_f}{RFILE_f.htm}.
</FILE>

<FILE name='WRITEAU_f' type='LATEX'>
Ce bloc écrit un fichier son de type 'au'.
Les données doivent être rangées avec un canal par colonne.
Les valeurs en dehors de l'échelle [-1 +1] seront coupées à l'écriture.
L'écriture 'au' supporte les données multi-canaux pour les formats
'8-bit mu-law' et '8-,16-bit linear'.
</FILE>

<FILE name='WRITEC_f' type='LATEX'>
Ce bloc permet d'écrire des données dans un fichier C au format binaire.
</FILE>

<FILE name='ZCROSS_f' type='LATEX'>
Un événement est généré lorsque toutes les entrées traverse la valeur
zéro simultanément.
</FILE>

<FILE name='buildouttb' type='LATEX'>
Construit une liste "outtb" initialisée.
</FILE>

<FILE name='c_block' type='LATEX'>
Ce bloc crée une fonction de calcul squelette en C.
Il crée aussi une librairie et un fichier objet à la compilation.
</FILE>

<FILE name='curblock' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
    <DESCRIPTION_ITEM>
    <P>
    Ajoutez ici un paragraphe pour la description de la fonction
    </P>
    </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='fortran_block' type='LATEX'>
Ce bloc crée une fonction de calcul squelette en fortran.
Il crée aussi une librairie et un fichier objet à la compilation.
</FILE>

<FILE name='freq_div' type='LATEX'>
Ce bloc est un superbloc.
L'entrée événementielle est redirigée une fois parmi n à la sortie.
</FILE>

<FILE name='func_block' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='generic_block' type='LATEX'>

</FILE>

<FILE name='generic_block2' type='LATEX'>
The block provides a generic interfacing function but the
computational function needs to be defined separately, either as a
Scilab function or  a Fortran or a C function. Besides the name of the
function, user should specify information such as the type, whether or
not the block contains a direct feed-through term. The function
realising computational functions of generic blocks of a scicos
diagram must be saved along with the diagram and loaded or dynamically
linked before simulation. 
</FILE>

<FILE name='generic_block3' type='LATEX'>
The block provides a generic interfacing function but the
computational function needs to be defined separately, either as a
Scilab function or  a Fortran or a C function. Besides the name of the
function, user should specify information such as the type, whether or
not the block contains a direct feed-through term. The function
realising computational functions of generic blocks of a scicos
diagram must be saved along with the diagram and loaded or dynamically
linked before simulation. 
</FILE>

<FILE name='getblocklabel' type='XML'>
  <DESCRIPTION>

  </DESCRIPTION>
</FILE>

<FILE name='getscicosvars' type='XML'>
  <DESCRIPTION>
    <P>
    Cette fonction utilitaire est utilisée pour retrouver les tableaux de travail du
    compilateur et du simulateur scicos pendant la simulation.
    </P>
    <P>
      Elle peut-être utilisée dans un bloc scilab pour retourner des informations de
      tous types de blocs. Cette fonction est très utile pour débugger les diagrammes
      et pour prototyper des simulations.
    </P>
  </DESCRIPTION>
</FILE>

<FILE name='lincos' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  Construct a linear state-space system by linearizing a model
	  given as a Scicos diagram.
	</P>
      </DESCRIPTION_ITEM>
      <DESCRIPTION_ITEM>
	<P>
	  The output is a Scilab data structure of type continuous-time state-space
          linear system.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='phase_simulation' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  Cette fonction permet de savoir si le simulateur scicos est dans sa phase
          d'intégration temporelle.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='pointer_xproperty' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
    <DESCRIPTION_ITEM>
    <P>
    Ajoutez ici un paragraphe pour la description de la fonction
    </P>
    </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='scicos' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  Scicos is a visual editor for constructing models of hybrid
	  dynamical systems. Invoking Scicos with no argument opens up an
	  empty Scicos window. Models can then be assembled, loaded,
	  saved, compiled, simulated, using GUI of Scicos.  Scicos
	  serves as an interface to the various block diagram compilers
	  and the hybrid simulator scicosim.
	</P>
      </DESCRIPTION_ITEM>
      <DESCRIPTION_ITEM>
	<P>
	  The input and output arguments are useful for debugging purposes.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='scicos_block' type='XML'>
  <DESCRIPTION>

  </DESCRIPTION>
</FILE>

<FILE name='scicos_cpr' type='XML'>
  <DESCRIPTION>

  </DESCRIPTION>
</FILE>

<FILE name='scicos_debug' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  Cette fonction sert à paramétrer le niveau de débogage de la simulation
          scicos.
	</P>
	<P>
	  Elle peut être utilisée soit en mode "Calc" dans l'éditeur Scicos ou en tant
          qu'instruction dans un bloc scilab et encore dans une fonction d'interfaçage.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='scicos_diagram' type='XML'>
  <DESCRIPTION>

  </DESCRIPTION>
</FILE>

<FILE name='scicos_graphics' type='XML'>
  <DESCRIPTION>

  </DESCRIPTION>
</FILE>

<FILE name='scicos_link' type='XML'>
  <DESCRIPTION>

  </DESCRIPTION>
</FILE>

<FILE name='scicos_model' type='XML'>
  <DESCRIPTION>

  </DESCRIPTION>
</FILE>

<FILE name='scicos_params' type='XML'>
  <DESCRIPTION>

  </DESCRIPTION>
</FILE>

<FILE name='scicos_sim' type='XML'>
  <DESCRIPTION>

  </DESCRIPTION>
</FILE>

<FILE name='scicos_simulate' type='XML'>
  <DESCRIPTION>
    <P>
      This function is used to simulate scicos diagrams in batch
      mode. It requires the scs_m structure which can be obtained by
      loading in Scilab the .cos file (e.g. load
      mydiagram.cos).
    </P>
    <P>
      Contrary to the function <LINK> scicosim</LINK>, the diagram
      need not be compiled before being saved.
    </P>
  </DESCRIPTION>
</FILE>

<FILE name='scicos_state' type='XML'>
  <DESCRIPTION>

  </DESCRIPTION>
</FILE>

<FILE name='scicos_time' type='XML'>
<DESCRIPTION>

</DESCRIPTION>
</FILE>

<FILE name='scicosim' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  Simulator for Scicos compiled diagram.
	</P>
	<P>
	  Usually scicosim is called by scicos to perform simulation of
	  a diagram.
	</P>
	<P>
	  But scicosim may also be called outside Scicos. Typical usage
	  in such a case may be :
	</P>
      </DESCRIPTION_ITEM>
      <DESCRIPTION_ITEM>
	<DESCRIPTION_ITEM>
	  <P>
	    1- Use Scicos to define a block diagram, compile it.
	  </P>
	  <P>
	    2- Save the compiled diagram using Save,SaveAs Scicos menus.
	  </P>
	  <P>
	    3- In Scilab, load saved file using load function. You get
	       variables scicos_ver, scs_m, %cpr scs_m is the diagram Scicos
               main data structure.
	  </P>
	  <P>
	    %cpr is the data structure containing (state,sim,cor,corinv)
	    if the diagram had been compiled before saved, else %cpr=list().
	  </P>
	  <P>
	    4- Extract state, sim out of cpr.
	  </P>
	  <P>
	    5- Execute [state,t]=scicosim(state,0,tf,sim,'start',tol) for
               initialisation.
	  </P>
	  <P>
	    6- Execute [state,t]=scicosim(state,0,tf,sim,'run',tol) for
	       simulation from 0 to tf.
	  </P>
	  <P>
	    Many successives such calls may be
	    performed changing initial and final time.
	  </P>
	  <P>
	    7- Execute [state,t]=scicosim(state,0,tf,sim,'finish',tol) at
	       the very end of the simulation to close files,...
	  </P>
	</DESCRIPTION_ITEM>
      </DESCRIPTION_ITEM>
      <DESCRIPTION_ITEM>
	<P>
	  For advanced user it is possible to "manually"
	  change some parameters or state values.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='scifunc_block' type='LATEX'>
This block can realize any type of Scicos block. The function of the
block is defined interactively using dialogue boxes and in Scilab
language. During simulation, these instructions are interpreted by
Scilab; the simulation of diagrams that include these types of blocks
is slower. For more information see Scicos reference manual. 
</FILE>

<FILE name='scifunc_block_m' type='LATEX'>
This block can realize any type of Scicos block. The function of the
block is defined interactively using dialogue boxes and in Scilab
language. During simulation, these instructions are interpreted by
Scilab; the simulation of diagrams that include these types of blocks
is slower. For more information see Scicos reference manual. 
</FILE>

<FILE name='set_xproperty' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
    <DESCRIPTION_ITEM>
    <P>
    Ajoutez ici un paragraphe pour la description de la fonction
    </P>
    </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='steadycos' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  This function finds the steady state for a given system described
	  by a Scicos diagram. The diagram consists in general of a Super
	  block with input and output port blocks. The steady states
	  concerns only the continuous-time dynamics.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='var2vec' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  Les fonctions var2vec / vec2var sont utilisées dans les fonctions
          d'interfaçages des blocs scilab pour donner la possibilité à l'utilisateur de
          manipuler des objets scilab avec le registre des paramètres réels (rpar) et
          avec le registre des états discrets (z).
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='vec2var' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  Les fonctions var2vec / vec2var sont utilisées dans les fonctions
          d'interfaçages des blocs scilab pour donner la possibilité à l'utilisateur de
          manipuler des objets scilab avec le registre des paramètres réels (rpar) et
          avec le registre des états discrets (z).
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>


</DATA>
