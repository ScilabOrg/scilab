<?xml version="1.0" encoding="ISO-8859-1" standalone="no"?>

<!--  Scicos

   Copyright (C) INRIA - METALAU Project <scicos@inria.fr>

  This program is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 2 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

  See the file ../license.txt
-->

<DATA flag="desc">

<FILE name='ABCD_Blocks' type='XML'>
  <DESCRIPTION>

  </DESCRIPTION>
</FILE>

<FILE name='ABSBLK_f' type='LATEX'>
Le bloc Abs calcule � la sortie, la valeur absolue de l'entr�e.
</FILE>

<FILE name='ABS_VALUE' type='LATEX'>
Le bloc Abs calcule � la sortie, la valeur absolue de l'entr�e.
</FILE>

<FILE name='AFFICH_f' type='LATEX'>
Pendant la simulation, ce bloc affiche sur le diagramme
la valeur lue sur son unique port d'entr�e.
</FILE>

<FILE name='AFFICH_m' type='LATEX'>
Pendant la simulation, ce bloc affiche sur le diagramme
la valeur lue sur son unique port d'entr�e.
</FILE>

<FILE name='ANDBLK' type='LATEX'>
The Bus Creator block combines a set of signals, i.e., a
group of signals represented by a single line in a block diagram. It
allows you to reduce the number of lines required to route signals
from one part of a diagram to another. This makes your easier to
understand.
</FILE>

<FILE name='ANDLOG_f' type='LATEX'>
Ce bloc poss�dant deux entr�es �v�nementielles et une sortie r�guli�re,
d�livre {\bf +1} ou {\bf -1} sur sa sortie r�guli�re suivant ses entr�es �v�nementielles.

\begin{itemize}
  \item{\bf +1 :} Lorsque les �v�nements sont synchrones (m�me �v�nement pr�sent sur
                  les deux ports �v�nementiels simultan�ment),

  \item{\bf -1 :} Lorsqu'un seul �v�nement est pr�sent.
\end{itemize}
</FILE>

<FILE name='AUTOMAT' type='LATEX'>
This block gives the possibility to construct hybrid automata, i.e., a
hybrid system whose discrete part is defined via modes and transitions
between modes, and the continuous part is defined via DAE
(differential algebraic equations). 

The automaton block provides a switching mechanism between subsystems
corresponding to control modes of an automaton.  Subsystems are
constructed in such a way that they have the state vector as input (
coming from the automaton block) and compute the flow and jump
functions (zero-crossing) and pass them back to the automaton
block. The state variables are defined in the automaton block and the
subsystems are static functions.

Suppose that a hybrid automaton consists of {\bf $M$} control
 modes. The continuous-time dynamics in mode $i$ is defined with DAE
 ($0=F_i(\dot x, x, u)$) where $i\in \{1 \dots M\}$ and the dimension
 of $x$ is $N$ ($N\ge0$) for any $i\in \{1 \dots M\}$. Suppose that in
 control mode $i$, there are $Z_i$ jump conditions indicating jumps
 toward other modes. The jump conditions are defined by
 $Jump_{ij}(\dot x,x,u)$ functions where $j\in \{1 \dots Z_i\}$.

 When a jump function changes sign and becomes positive, a mode
 transition will happen. When $k^{th}$ transition function becomes
 positive, a transition to mode $k$ happens and  state vector $x$ is reset
 to $Reset_k(\dot x,x,u)$, {\it i.e.,} $x_l=Reset_{kl}(\dot x,x,u)$
 for $l\in \{1 \dots N\}$.

 In order to develop an automaton containing a mode with multiple
 reset functions, the value of the current and previous active modes
 should be used. These values are available at the first output port
 of the block.


The automaton block has the following input/output ports.

\begin{itemize}
\item {\bf Output 1:} The first output port is a vector of size two
 consisting of the current and the previous active control modes,
 i.e., $OUT_1=[current-mode,~previous-mode]^t$.

\item {\bf Output 2:} The second output port is a vector of size {\bf
  $2N$} providing the state vector and its first time derivative, {\it
  i.e.,} $[ x,\dot x]^t$.  

\item {\bf Inputs:} The automaton block has $M$ vector input ports
  corresponding to $M$ modes or subsystems of the automaton.  Each
  input defines the dynamic behavior in the control each mode as well
  as the reset functions and the transition functions.  The input port
  $i$ which is the output of the $i^{th}$ subsystem is a vector of
  size $2N+Z_i$. Each input is composed of  the following vector.

  $Input_i=\left[F_i(\dot x,x,u),~ Reset_i(\dot x,x,u),~ Jump_i(\dot
  x,x,u) \right]^t$

\begin{itemize}
\item The first $N$ elements of the $Input_i$ are the continuous-time
dynamics.  The dynamics of the system in the control mode $i$ is
described by a smooth index-1 DAE ({\it i.e.,} $0=F_i(\dot x,x,u,t)$).

\item The next $N$ elements of $Input_i$ are the values used to
 reset the continuous-time states when a transition \underline{to} 
 control mode $i$ is activated.

\item The next $Z_i$ elements of $Input_i$ are the jump or
zero-crossing functions. If the $j^{th}$ zero-crossing function of
mode $i$ crosses zero with negative to positive direction, a
transition to $j^{th}$ destination mode happens.
\end{itemize}

\item {\bf Event Output:} This is an event output port, which is
activated whenever a mode transition happens. This event is useful
when an event is needed to activate or initialize a part of the
subsystem not included in the internal dynamics of the automaton
block.
\end{itemize}
 In the interface window, the number of control modes, the initial
control mode and the initial value of continuous-time states at the
beginning of the simulation should be given.

Find more documentation and demos about the Automaton block oat
www.scicos.org. Interested users are referred to the paper "Modeling
Hybrid Automata in Scicos", Masoud Najafi, Ramine Nikoukhah, 2007 IEEE
Multi-conference on Systems and Control, Singapore. 
</FILE>

<FILE name='About_scicos' type='LATEX'>
 \subsection{Au sujet de Scicos...}

  Scicos version 4.2 a �t� d�velopp� dans l'�quipe-projet 'Metalau', de
  mani�re tr�s proche au consortium Scilab, � l'unit� de Rocquencourt de
  l'INRIA.

  Les principaux contributeurs de cette version sont :

  {\bf Designers :} \\
  \begin{itemize}
       \item {\bf Fady Nassif} (INRIA) \\
          Jeu de blocs matriciels/entiers.\\
          Comportement simulink (blocs SampleClk/Goto-from).

       \item {\bf Masoud Najafi} (INRIA) \\
          Int�gration Modelica.\\
          Int�gration 'Sundials' dans le simulateur.

       \item {\bf Simone Mannori} (INRIA) \\
          Conception de l'�diteur nouveau graphique.

       \item {\bf Alan Layec} (INRIA) \\
          Int�gration des donn�es matricielles typ�es.\\
          Coeur du g�n�rateur de code C.\\
          Documentation Html.

       \item {\bf Benoit Bayol} (Etudiant) \\
          Jeu de blocs pour l'affichage des donn�es (nouveau graphique)

 \end{itemize}

  {\bf Guru : Serge Steer} (INRIA)

  {\bf Mentor : Ramine Nikoukhah} (INRIA)
</FILE>

<FILE name='BACKLASH' type='LATEX'>
The Backlash block implements a system in which a change in input
causes an equal change in output. However, when the input changes
direction, an initial change in input has no effect on the output.
The amount of side-to-side play in the system is referred to as the
{\em deadband or gap}.
</FILE>

<FILE name='BIGSOM_f' type='LATEX'>
Le bloc somme r�alise l'addition de ses entr�es.
Ce bloc peut additionner des scalaires ou des vecteurs d'entr�e.
</FILE>

<FILE name='BITCLEAR' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  This blocks set the specified bit of the integer input to 0.
	  The user can specify the bit in the field:"index of bit".
	  Bit 0 is the least significant bit.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='BITSET' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  This blocks set the specified bit of the integer input to 1.
	  The user can specify the bit in the field:"index of bit".
	  Bit 0 is the least significant bit.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='BOUNCE' type='XML'>
<DESCRIPTION>

</DESCRIPTION>
</FILE>

<FILE name='BOUNCEXY' type='XML'>
<DESCRIPTION>

</DESCRIPTION>
</FILE>

<FILE name='BPLATFORM' type='XML'>
  <DESCRIPTION>

  </DESCRIPTION>
</FILE>

<FILE name='Bache' type='LATEX'>
Ce composant repr�sente une bache thermo-hydraulique qui consiste en
deux ports d'entr�e et deux ports de sortie.  Conventionnellement, la
direction positive pour la rentr�e est quand le fluide {\bf entre}
dans le port d'entree (ports noirs) et la direction positive pour les
ports de sortie est quand le fluide {\bf sort} des port de sortie
(ports blancs).  La surface de la bache, la temp�rature initiale et
l'altitude initiale du fluide peuvent �tre definies par l'utilisateur.
Si un port reste non-utilis�, il doit �tre bouch� par le bloc {\bf
Bouchon}.
</FILE>

<FILE name='Branching_pal' type='LATEX'>
Dans la palette Branching, vous pouvez trouver divers blocs
pour la gestion des donn�es v�hicul�es par les liens r�guliers.
</FILE>

<FILE name='CANIMXY' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  This block realizes the visualization of the evolution of
          the two regular input signals by drawing the second input
          as a function of the first at instants of events on the
          event input port.  When a point is drawn on screen it stays
          until the buffer length is reached. This scope is useful to
          make simple animations.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='CANIMXY3D' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  This block realizes the visualization of the evolution of
          the three regular input signals by drawing the third input
          as a function of the two others at instants of events on the
          event input port. When a point is drawn on screen it stays
          until the buffer length is reached. This scope is useful to
          make simple animations.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='CBLOCK' type='LATEX'>
Ce bloc cr�e une fonction de calcul squelette en C.
Il cr�e aussi une librairie et un fichier objet � la compilation.
</FILE>

<FILE name='CCS' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
    <DESCRIPTION_ITEM>
    <P>

    This block is an ideal current source. The current value is
    controlled through the explicit input of the block (connected to
    standard Scicos blocks). The voltage across the block is
    independent of the current value.

    </P>
    </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='CEVENTSCOPE' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  This block realizes the visualization of the input event
          signals.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='CFSCOPE' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  This is a floating scope block.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='CLINDUMMY_f' type='LATEX'>
Ce bloc peut �tre plac� dans tous diagrammes qui contient un ou
des blocs 'zero-crossing' et qui ne dispose pas de blocs contenant
des �tats continus (x) temps d�pendant (dep\_t=\%t).
Gr�ce � cela, le simulateur utilisera le solveur ode pour la d�tection
de surfaces des blocs 'zero-crossing'.
</FILE>

<FILE name='CLKFROM' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  This block is used to connect events ports. For more
          information on how it works please refer to the
          documentation of the FROM block by clicking on the link in
          the "See also" field.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='CLKGOTO' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  This block is used to connect events ports. For more
	  information on how it works please refer to the
	  documentation of the GOTO block by clicking on the link in
	  the "See also" field.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='CLKGotoTagVisibility' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  This block is used in the event case. For more information
	  on how it works please refer to the documentation of the
	  GotoTagVisibility block by clicking on the link in
	  the "See also" field.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='CLKINV_f' type='LATEX'>
Ce bloc doit seulement �tre utilis� � l'int�rieur des superblocs.
Il est utilis� pour repr�senter un port d'entr�e �v�nementiel.
Dans un superbloc, les ports doivent �tre num�rot�s � partir de 1
jusqu'au nombre de ports.  
</FILE>

<FILE name='CLKIN_f' type='LATEX'>
Ce bloc doit seulement �tre utilis� � l'int�rieur des superblocs.
Il est utilis� pour repr�senter un port d'entr�e �v�nementiel.
Dans un superbloc, les ports doivent �tre num�rot�s � partir de 1
jusqu'au nombre de ports.  
</FILE>

<FILE name='CLKOUTV_f' type='LATEX'>
Ce bloc doit seulement �tre utilis� � l'int�rieur des superblocs.
Il est utilis� pour repr�senter un port de sortie �v�nementiel.
Dans un superbloc, les ports doivent �tre num�rot�s � partir de 1
jusqu'au nombre de ports.  
</FILE>

<FILE name='CLKOUT_f' type='LATEX'>
Ce bloc doit seulement �tre utilis� � l'int�rieur des superblocs.
Il est utilis� pour repr�senter un port de sortie �v�nementiel.
Dans un superbloc, les ports doivent �tre num�rot�s � partir de 1
jusqu'au nombre de ports.
</FILE>

<FILE name='CLKSOMV_f' type='LATEX'>
Ce bloc est un bloc d'addition d'�v�nement � trois entr�es.
La sortie reproduit les �v�nements de tous les ports d'entr�es.
A proprement parler, CLKSOMV n'est pas un vrai bloc scicos, car
il est ignor� pendant la phase de compilation.\\
Les sorties et les entr�es de ce bloc sont synchronis�es.
</FILE>

<FILE name='CLKSOM_f' type='LATEX'>
Ce bloc est un bloc d'addition d'�v�nement � trois entr�es.
La sortie reproduit les �v�nements de tous les ports d'entr�es.
A proprement parler, CLKSOM\_f n'est pas un vrai bloc scicos, car
il est ignor� pendant la phase de compilation.\\
Les sorties et les entr�es de ce bloc sont synchronis�es.
</FILE>

<FILE name='CLKSPLIT_f' type='XML'>
<DESCRIPTION>

</DESCRIPTION>
</FILE>

<FILE name='CLOCK_c' type='LATEX'>
Ce bloc est un super-bloc construit gr�ce au bloc
\htmladdnormallink{EVTDLY\_c}{EVTDLY_c.htm} qui 
est reboucl� sur lui-m�me.\\
L'unique sortie de ce bloc g�n�re des �v�nements
� des dates pr�cises, qui sont d�termin�es par le
param�tre {\bf Period} de la bo�te de dialogue.
</FILE>

<FILE name='CLOCK_f' type='LATEX'>
Ce bloc est un super-bloc construit gr�ce au bloc
\htmladdnormallink{EVTDLY\_f}{EVTDLY_f.htm} qui
est reboucl� sur lui-m�me.\\
L'unique sortie de ce bloc g�n�re des �v�nements
� des dates pr�cises, qui sont d�termin�es par le
param�tre {\bf Period} de la bo�te de dialogue.
</FILE>

<FILE name='CLR' type='LATEX'>
Ce bloc r�alise un syst�me lin�aire SISO (Single Input Single Output) 
repr�sent� par une fonction de transfert rationnelle.
La fonction rationnelle doit �tre une fonction propre.
</FILE>

<FILE name='CLR_f' type='LATEX'>
Ce bloc r�alise un syst�me lin�aire SISO (Single Input Single Output) 
repr�sent� par une fonction de transfert rationnelle.
La fonction rationnelle doit �tre une fonction propre.
</FILE>

<FILE name='CLSS' type='LATEX'>
Ce bloc r�alise un syst�me lin�aire d'�quations d'�tat en temporel continu.
\begin{eqnarray}
\dot x&=&Ax+Bu\\
  y   &=&C*x+D*u
\end{eqnarray}
Le syst�me est d�fini par les matrices $(A,B,C,D)$
et par l'�tat initial $x_0$.
Les dimensions des matrices et de l'�tat initial doivent �tre appropri�es.
</FILE>

<FILE name='CLSS_f' type='LATEX'>
Ce bloc r�alise un syst�me lin�aire d'�quations d'�tat en temporel continu.
\begin{eqnarray}
\dot x&=&Ax+Bu\\
  y   &=&C*x+D*u
\end{eqnarray}
Le syst�me est d�fini par les matrices $(A,B,C,D)$
et par l'�tat initial $x_0$.
Les dimensions des matrices et de l'�tat initial doivent �tre appropri�es.
</FILE>

<FILE name='CMAT3D' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  CMAT3D est un scope qui montre les valeurs en Z des matrices
          sur une grille xy.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='CMATVIEW' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
          CMATVIEW est un scope qui montre les valeurs des matrices
          sur une grille en couleur.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='CMSCOPE' type='LATEX'>
Au d�but de la simulation, ce bloc ouvre une fen�tre  pour afficher
l'�volution temporelle des donn�es qui seront lues sur les ports
d'entr�es r�guliers.
Ce bloc est donc similaire � un oscilloscope.
Il permet l'affichage de multiple abscisses (une par entr�e).
Ces abscisses peuvent avoir des �chelles temporelles diff�rentes
qui seront d�finies par le param�tre {\bf Refresh period}.
</FILE>

<FILE name='CONST' type='LATEX'>
Ce bloc est un g�n�rateur de valeurs constantes.
</FILE>

<FILE name='CONSTRAINT_f' type='LATEX'>
Ce bloc d�finit des relations alg�briques implicites.
</FILE>

<FILE name='CONST_f' type='LATEX'>
Ce bloc est un g�n�rateur de valeurs constantes.
</FILE>

<FILE name='CONST_m' type='LATEX'>
Ce bloc est un g�n�rateur de valeurs constantes.
</FILE>

<FILE name='CONVERT' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	This block converts an input signal of any data type to a
        specified data type. The input can be real, complex or integer.
        When the output is an integer and when overflow occurs the block
        three different forms of results :
        </P>
	  <P>1- A normal non saturated result.</P>
	  <P>2- A saturated result.</P>
	  <P>3- An error message warning the user about the overflow..</P>
	<P>
        The user can select one of these three forms by setting
        the "DO ON OVERFLOW" field to 0,1 or 2.
        </P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='COSBLK_f' type='LATEX'>
$$y=\cos(u)$$
</FILE>

<FILE name='CSCOPE' type='LATEX'>
Au d�but de la simulation, ce bloc ouvre une fen�tre  pour afficher
l'�volution temporelle des donn�es qui seront lues sur le port
d'entr�e r�gulier.
Ce bloc est donc similaire � un oscilloscope.
Il permet d'afficher sur une m�me figure l'�volution des
�l�ments d'un vecteur.
Ce bloc ne poss�de qu'une seule �chelle temporelle.
</FILE>

<FILE name='CSCOPXY' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  This block realizes the visualization of the evolution of the
          two regular inputs signals by drawing the second input as a
          function of the first at instants of events on the event input
          port. When a point is drawn on screen it stays until the
          simulation is finished.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='CSCOPXY3D' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  This block realizes the visualization of the evolution of the
          three regular inputs signals by drawing the third input as a
          function of the two others at instants of events on the event
          input port. When a point is drawn on screen it stays until the
          simulation is finished.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='CUMSUM' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  The CUMSUM block sums the element of an input m*n matrix u
          along either the rows, the columns or the first non singleton
          dimension. When the "Sum along" parameter is set to "1", the
          block sums across the elements of each row. The result will be
          displayed as a m*1 matrix.
	</P>
	<P>
	  When the "Sum along" parameter is set to "2", the block sums
          across the elements of each column. The result will be display
          as a 1*n matrix.
	</P>
	<P>
	  When the "Sum along" parameter is set to "0", the block sums
          across the first non singleton dimension. The result will be
          displayed as one element.
	  This block is equivalent to cumsum in scilab.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='CURVE_c' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
This block allows the user to create signals and use them as a signal
source block. The signals can be created either graphically by the
user or be defined by specifying two vectors, i.e., a vector for time
and a vector for amplitude. These vectors define the mesh points and
the signal value at intermediate points are obtained by interpolating
the points. Several interpolation methods are available. This block
can also generate the signal periodically. It is also possible to read
data from Excel data-sheets and from formatted C data files.
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='CURV_f' type='LATEX'>
Ce bloc d�finit une fonction tabul�e en fonction du temps.
Entre chaque point des mailles, ce bloc r�alise une interpolation
lin�aire. En dehors des points tabul�s, il fournit les derniers
points rencontr�s. L'utilisateur peut d�finir les diff�rents points
en utilisant un �diteur graphique de courbes.
</FILE>

<FILE name='CVS' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
    <DESCRIPTION_ITEM>
    <P>
    This block is an ideal voltage source. The voltage value is
    controlled through the explicit input of the block (connected to
    standard Scicos blocks). The current passing through  the block is
    independent of the voltage across the block terminals.
    </P>
    </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='C_macros' type='LATEX'>

The following C macros are avialable by including the file \htmladdnormallink{scicos\_block4.h}
{scicos_block4_rout.htm} in a C computational function.

\subsection{Inputs/outputs}
\begin{tabular}{|p{8cm}||p{20cm}|}
\hline 
{\bf Macro}&
{\bf Description}\vspace{0.2cm}\\
\hline
\hline 
GetNin(blk)&
Get number of regular input port.\vspace{0.2cm}\\
\hline 
GetInPortRows(blk,x)&
Get number of rows (first dimension) of regular input port number
x.\vspace{0.2cm}\\
\hline 
GetInPortCols(blk,x)&
Get number of columns (second dimension) of regular input port number
x.\vspace{0.2cm}\\
\hline 
GetInPortSize(blk,x,y)&
Get regular input port size number x. (y=1 for the first dimension,
y=2 for the second dimension)\vspace{0.2cm}\\
\hline 
GetInType(blk,x)&
Get type of regular input port number x.\vspace{0.2cm}\\
\hline 
GetInPortPtrs(blk,x)&
Get regular input port pointer of port number x.\vspace{0.2cm}\\
\hline 
GetRealInPortPtrs(blk,x)&
Get pointer of real part of regular input port number x.\vspace{0.2cm}\\
\hline 
GetImagInPortPtrs(blk,x)&
Get pointer of imaginary part of regular input port number x.\vspace{0.2cm}\\
\hline 
Getint8InPortPtrs(blk,x)&
Get pointer of int8 typed regular input port number x.\vspace{0.2cm}\\
\hline 
Getint16InPortPtrs(blk,x)&
Get pointer of int16 typed regular input port number x.\vspace{0.2cm}\\
\hline 
Getint32InPortPtrs(blk,x)&
Get pointer of int32 typed regular input port number x.\vspace{0.2cm}\\
\hline 
Getuint8InPortPtrs(blk,x)&
Get pointer of uint8 typed regular input port number x.\vspace{0.2cm}\\
\hline 
Getuint16InPortPtrs(blk,x)&
Get pointer of uint16 typed regular input port number x.\vspace{0.2cm}\\
\hline 
Getuint32InPortPtrs(blk,x)&
Get pointer of uint32 typed regular input port number x.\vspace{0.2cm}\\
\hline 
GetSizeOfIn(blk,x)&
Get the sizeof of the regular input port number x.\vspace{0.2cm}\\
\hline 
GetNout(blk)&
Get number of regular output port.\vspace{0.2cm}\\
\hline 
GetOutPortRows(blk,x)&
Get number of rows (first dimension) of regular output port number
x.\vspace{0.2cm}\\
\hline 
GetOutPortCols(blk,x)&
Get number of columns (second dimension) of regular output port number
x.\vspace{0.2cm}\\
\hline 
GetOutPortSize(blk,x,y)&
Get regular output port size number x. (y=1 for the first dimension,
y=2 for the second dimension)\vspace{0.2cm}\\
\hline 
GetOutType(blk,x)&
Get type of regular output port number x.\vspace{0.2cm}\\
\hline 
GetOutPortPtrs(blk,x)&
Get regular output port pointer of port number x.\vspace{0.2cm}\\
\hline 
GetRealOutPortPtrs(blk,x)&
Get pointer of real part of regular output port number x.\vspace{0.2cm}\\
\hline 
GetImagOutPortPtrs(blk,x)&
Get pointer of imaginary part of regular output port number x.\vspace{0.2cm}\\
\hline 
Getint8OutPortPtrs(blk,x)&
Get pointer of int8 typed regular output port number x.\vspace{0.2cm}\\
\hline 
Getint16OutPortPtrs(blk,x)&
Get pointer of int16 typed regular output port number x.\vspace{0.2cm}\\
\hline 
Getint32OutPortPtrs(blk,x)&
Get pointer of int32 typed regular output port number x.\vspace{0.2cm}\\
\hline 
Getuint8OutPortPtrs(blk,x)&
Get pointer of uint8 typed regular output port number x.\vspace{0.2cm}\\
\hline 
Getuint16OutPortPtrs(blk,x)&
Get pointer of uint16 typed regular output port number x.\vspace{0.2cm}\\
\hline 
Getuint32OutPortPtrs(blk,x)&
Get pointer of uint32 typed regular output port number x.\vspace{0.2cm}\\
\hline 
GetSizeOfOut(blk,x)&
Get the sizeof of the regular output port number x.\vspace{0.2cm}\\
\hline
\end{tabular}

\subsection{Events}

\begin{tabular}{|p{8cm}||p{20cm}|}
\hline 
{\bf Macro}&
{\bf Description}\vspace{0.2cm}\\
\hline
\hline 
GetNevIn(blk)&
Get the input event number.\vspace{0.2cm}\\
\hline 
GetNevOut(blk)&
Get number of event output port.\vspace{0.2cm}\\
\hline 
GetNevOutPtrs(blk)&
Get pointer of event output register.\vspace{0.2cm}\\
\hline
\end{tabular}

\subsection{Parameters}

\begin{tabular}{|p{8cm}||p{20cm}|}
\hline 
{\bf Macro}&
{\bf Description}\vspace{0.2cm}\\
\hline
\hline 
GetNipar(blk)&
Get number of integer parameters.\vspace{0.2cm}\\
\hline 
GetIparPtrs(blk)&
Get pointer of the integer parameters register\vspace{0.2cm}\\
\hline 
GetNrpar(blk)&
Get number of real parameters.\vspace{0.2cm}\\
\hline 
GetRparPtrs(blk)&
Get pointer of the real parameters register.\vspace{0.2cm}\\
\hline 
GetNopar(blk)&
Get number of object parameters.\vspace{0.2cm}\\
\hline 
GetOparType(blk,x)&
Get type of object parameters number x.\vspace{0.2cm}\\
\hline 
GetOparSize(blk,x,y)&
Get size of object parameters number x. (y=1 for the first dimension,
y=2 for the second dimension)\vspace{0.2cm}\\
\hline 
GetOparPtrs(blk,x)&
Get pointer of object parameters number x.\vspace{0.2cm}\\
\hline 
GetRealOparPtrs(blk,x)&
Get pointer of real object parameters number x.\vspace{0.2cm}\\
\hline 
GetImagOparPtrs(blk,x)&
Get pointer of imaginary part of object parameters number x.\vspace{0.2cm}\\
\hline 
Getint8OparPtrs(blk,x)&
Get pointer of int8 typed object parameters number x.\vspace{0.2cm}\\
\hline 
Getint16OparPtrs(blk,x)&
Get pointer of int16 typed object parameters number x.\vspace{0.2cm}\\
\hline 
Getint32OparPtrs(blk,x)&
Get pointer of int32 typed object parameters number x.\vspace{0.2cm}\\
\hline 
Getuint8OparPtrs(blk,x)&
Get pointer of uint8 typed object parameters number x.\vspace{0.2cm}\\
\hline 
Getuint16OparPtrs(blk,x)&
Get pointer of uint16 typed object parameters number x.\vspace{0.2cm}\\
\hline 
Getuint32OparPtrs(blk,x)&
Get pointer of uint32 typed object parameters number x.\vspace{0.2cm}\\
\hline 
GetSizeOfOpar(blk,x)&
Get the sizeof of the object parameters number x.\vspace{0.2cm}\\
\hline
\end{tabular}

\subsection{States and work}

\begin{tabular}{|p{8cm}||p{20cm}|}
\hline 
{\bf Macro}&
{\bf Description}\vspace{0.2cm}\\
\hline
\hline 
GetNstate(blk)&
Get number of continuous state.\vspace{0.2cm}\\
\hline 
GetState(blk)&
Get pointer of the continuous state register.\vspace{0.2cm}\\
\hline 
GetDstate(blk)&
Get number of discrete state.\vspace{0.2cm}\\
\hline 
GetNdstate(blk)&
Get pointer of the discrete state register.\vspace{0.2cm}\\
\hline 
GetNoz(blk)&
Get number of object state.\vspace{0.2cm}\\
\hline 
GetOzType(blk,x)&
Get type of object state number x.\vspace{0.2cm}\\
\hline 
GetOzSize(blk,x,y)&
Get size of object state number x. (y=1 for the first dimension, y=2
for the second dimension)\vspace{0.2cm}\\
\hline 
GetOzPtrs(blk,x)&
Get pointer of object state number x.\vspace{0.2cm}\\
\hline 
GetRealOzPtrs(blk,x)&
Get pointer of real object state number x.\vspace{0.2cm}\\
\hline 
GetImagOzPtrs(blk,x)&
Get pointer of imaginary part of object state number x.\vspace{0.2cm}\\
\hline 
Getint8OzPtrs(blk,x)&
Get pointer of int8 typed object state number x.\vspace{0.2cm}\\
\hline 
Getint16OzPtrs(blk,x)&
Get pointer of int16 typed object state number x.\vspace{0.2cm}\\
\hline 
Getint32OzPtrs(blk,x)&
Get pointer of int32 typed object state number x.\vspace{0.2cm}\\
\hline 
Getuint8OzPtrs(blk,x)&
Get pointer of uint8 typed object state number x.\vspace{0.2cm}\\
\hline 
Getuint16OzPtrs(blk,x)&
Get pointer of uint16 typed object state number x.\vspace{0.2cm}\\
\hline 
Getuint32OzPtrs(blk,x)&
Get pointer of uint32 typed object state number x.\vspace{0.2cm}\\
\hline 
GetSizeOfOz(blk,x)&
Get the sizeof of the object state number x.\vspace{0.2cm}\\
\hline
GetWorkPtrs(blk)(blk)&
Get the pointer of the Work array.\vspace{0.2cm}\\
\hline
\end{tabular}

\subsection{Zero crossing surfaces and modes}

\begin{tabular}{|p{8cm}||p{20cm}|}
\hline 
{\bf Macro}&
{\bf Description}\vspace{0.2cm}\\
\hline
\hline 
GetNg(blk)&
Get number of zero crossing surface.\vspace{0.2cm}\\
\hline 
GetGPtrs(blk)&
Get pointer of the zero crossing register.\vspace{0.2cm}\\
\hline 
GetNmode(blk)&
Get number of modes.\vspace{0.2cm}\\
\hline 
GetModePtrs(blk)&
Get pointer of the mode register.\vspace{0.2cm}\\
\hline
\end{tabular}
</FILE>

<FILE name='C_struct' type='LATEX'>

The C structure of a Scicos block defines all the fields to handle data provided by the simulator
such inputs/outputs, parameters, states, ...

That structure of type {\tt scicos\_block} is defined in the file \htmladdnormallink{scicos\_block4.h}
{scicos_block4_rout.htm}, and user must include that header in each computational functions in the form :

\begin{verbatim}
#include "scicos_block4.h"

void mycomputfunc(scicos_block *block,int flag)
{
 ...
}
\end{verbatim}

The fields, that can be either C pointers or directly data, are then accessible via the {\tt *block}
structure :

\begin{verbatim}
block->field
\end{verbatim}

This access is a \textbf{direct} approach and most of users should prefer the \textbf{\htmladdnormallink{C\_macros}
{C_macros.htm}} approach for facilities purpose.

In the current version of Scicos, the {\tt scicos->block} structure is defined :

\begin{verbatim}
/* scicos_block structure definition */
typedef struct {
  int nevprt;
  voidg funpt ;
  int type;
  int scsptr;
  int nz;
  double *z;
  int noz;
  int *ozsz;
  int *oztyp;
  void **ozptr;
  int nx;
  double *x;
  double *xd;
  double *res;
  int nin;
  int *insz;
  void **inptr;
  int nout;
  int *outsz;
  void **outptr;
  int nevout;
  double *evout;
  int nrpar;
  double *rpar;
  int nipar;
  int *ipar;
  int nopar;
  int *oparsz;
  int *opartyp;
  void **oparptr;
  int ng;
  double *g;
  int ztyp;
  int *jroot;
  char *label;
  void **work;
  int nmode;
  int *mode;
} scicos_block;
\end{verbatim}

\subsection{Inputs/outputs}

\begin{itemize}
 \item {\bf block->nin :} Integer that gives the number of regular input ports of the block.\\
                   One can't override the index {\tt (3*block->nin)-1} when reading sizes of
                   input ports in the array {\tt insz} and the index {\tt block->nin-1} when reading
                   data in the array {\tt inptr} with a C computational function.\\
                   The number of regular input ports can also be got by the use of the C macros
                   {\tt GetNin(block)}.

 \item {\bf block->insz :} An array of integers of size {\tt 3*nin,1} that respectively gives the first dimensions,
                    the second dimensions and the type of data driven by regular input ports.\\
                    Note that this array of size differs from the array {\tt ozsz} and {\tt oparsz} to
                    provide full compatibilty with blocks that only use a single dimension.\\
                    Suppose that you have a block with three inputs : the first is an int32 matrix of
                    size 3,2, the second a single complex number (matrix of size 1,1) and the last a real
                    matrix of size 4,1.\\
                    In the  \htmladdnormallink{scicos\_model}{scicos_model.htm} of such a block, the inputs
                    will be defined :

                    {\tt
                     model.in    = [3;1;4] \\
                     model.in2   = [2;1;1] \\
                     model.intyp = [2;1;3] \\
                    }

                    and the corresponding {\tt block->insz} field at C computational function level will be
                    coded as :

                     \begin{figure}[!h]
                      \begin{center}
                       \scalebox{0.7}{\input{insz.pstex_t}}
                      \end{center}
                     \end{figure}

                     Do the difference here in the type numbers defined at the {\bf Scilab level} (2,1,3)
                     and the type numbers defined at the {\bf C level} (84,11,10). The following table gives
                     the correspondance for all Scicos type:

                     \begin{center}
                      \begin{tabular}{|p{4cm}|p{4cm}||p{4cm}|p{4cm}|}
                       \hline
                       {\bf Scilab Type}&
                       {\bf Scilab Number}&
                       {\bf C Type}&
                       {\bf C Number}\\
                       \hline
                       \hline
                       real&
                       1&
                       double&
                       10\\
                       \hline
                       complex&
                       2&
                       double&
                       11\\
                       \hline
                       int32&
                       3&
                       long&
                       84\\
                       \hline
                       int16&
                       4&
                       short&
                       82\\
                       \hline
                       int8&
                       5&
                       char&
                       81\\
                       \hline
                       uint32&
                       6&
                       unsigned long&
                       814\\
                       \hline
                       uint16&
                       7&
                       unsigned short&
                       812\\
                       \hline
                       uint8&
                       8&
                       unsigned char&
                       811\\
                       \hline
                      \end{tabular}
                     \end{center}

 \item {\bf block->inptr :} An array of pointers of size nin,1 that allows to directly acces to the
                     data contained in the regular input matrices.\\
                     Suppose the previous example (block with three inputs : an int32 matrix of size [3,2],
                     a complex scalar and a real matrix of size [4,1]).\\
                     {\tt block->inptr} contains three pointers, and should be viewed as arrays contained
                     the data for the int32, the real and the complex matrices :

                     \begin{figure}[!h]
                      \begin{center}
                       \scalebox{0.7}{\input{inptr.pstex_t}}
                      \end{center}
                     \end{figure}

                    For i.e., to directly access to the data, the user can use theses instructions :

                    {\tt
                     \#include "scicos\_block4.h"\\
                     ...\\
                     SCSINT32\_COP *ptr\_i;\\
                     SCSCOMPLEX\_COP *ptr\_dc;\\
                     SCSREAL\_COP *ptr\_d;\\
                     int n1,m1;\\
                     SCSINT32\_COP cumsum\_i=0;\\
                     int i;\\
                     ...\\
                     void mycomputfunc(scicos\_block *block,int flag) \\
                     \{\\
                     ...\\
                     /*get the ptrs of the first int32 regular input port*/\\
                     ptr\_i = (SCSINT32\_COP *) block->inptr[0];\\
                     /*get the ptrs of the second complex regular input port*/\\
                     ptr\_dc = (SCSCOMPLEX\_COP *) block->inptr[1];\\
                     /*get the ptrs of the third real regular input port*/\\
                     ptr\_d = (SCSREAL\_COP *) block->inptr[2];\\
                     ...\\
                     /*get the dimension of the first int32 regular input port*/\\
                     n1=block->insz[0];\\
                     m1=block->insz[3];\\
                     ...\\
                     /*compute the cumsum of the input int32 matrix*/\\
                     for(i=0;i<n1*m1;i++) \{\\
                     cumsum\_i += ptr\_i[i];\\
                     \}\\
                     ...\\
                     \}
                    }

                    One can also use the set of C macros :\\
                    {\tt GetInPortPtrs(blk,x)}, {\tt GetRealInPortPtrs(block,x)}, \\
                    {\tt GetImagInPortPtrs(block,x)}, {\tt Getint8InPortPtrs(block,x)}, \\
                    {\tt Getint16InPortPtrs(block,x)}, {\tt Getint32InPortPtrs(block,x)}, \\
                    {\tt Getuint8InPortPtrs(block,x)}, {\tt Getuint16InPortPtrs(block,x)}, \\
                    {\tt Getuint32InPortPtrs(block,x)} \\
                    to have the appropiate pointer of the data to handle and \\
                    {\tt GetNin(block)}, {\tt GetInPortRows(block,x)}, \\
                    {\tt GetInPortCols(block,x)}, {\tt GetInPortSize(block,x,y)}, \\
                    {\tt GetInType(block,x)}, {\tt GetSizeOfIn(block,x)} \\
                    to handle number, dimensions and type of regular input ports.
                    ({\bf x is numbered from 1 to nin and \bf y numbered  from 1 to 2}).\\

                    For the previous example that gives :

                    {\tt
                     \#include "scicos\_block4.h"\\
                     ...\\
                     SCSINT32\_COP *ptr\_i;\\
                     SCSCOMPLEX\_COP *ptr\_dc;\\
                     SCSREAL\_COP *ptr\_d;\\
                     int n1,m1;\\
                     SCSINT32\_COP cumsum\_i=0;\\
                     int i;\\
                     ...\\
                     void mycomputfunc(scicos\_block *block,int flag)\\
                     \{\\
                     ...\\
                     /*get the ptrs of the first int32 regular input port*/\\
                     ptr\_i = Getint32InPortPtrs(block,1);\\
                     /*get the ptrs of the second complex regular input port*/\\
                     ptr\_dc = GetRealInPortPtrs(block,2);\\
                     /*get the ptrs of the third real regular input port*/\\
                     ptr\_d = GetRealInPortPtrs(block,3);\\
                     ...\\
                     /*get the dimension of the first int32 regular input port*/\\
                     n1=GetInPortRows(block,1);\\
                     m1=GetInPortCols(block,1);\\
                     ...\\
                     \}
                    }

                    Finally note that the regular input port registers are only accessible for reading.

 \item {\bf block->nout :} Integer that gives the number of regular output ports of the block.\\
                    One can't override the index {\tt (3*block->nout)-1} when reading sizes of
                    output ports in the array {\tt outsz} and the index {\tt block->nout-1} when reading
                    data in the array {\tt outptr} with a C computational function.\\
                    The number of regular output ports can also be got by the use of the C macros
                    {\tt GetNout(block)}.

 \item {\bf block->outsz :} An array of integers of size {\tt 3*nout,1} that respectively gives the first dimensions,
                     the second dimensions and the type of data driven by regular output ports.\\
                     Note that this array of size differs from the array {\tt ozsz} and {\tt oparsz} to
                     provide full compatibilty with blocks that only use a single dimension.\\
                     Suppose that you have a block with two outputs : the first is an int32 matrix of
                     size 3,2, the second a single complex number (matrix of size 1,1) and the last a real
                     matrix of size 4,1.\\
                     In the  \htmladdnormallink{scicos\_model}{scicos_model.htm} of such a block, the outputs
                     will be defined :

                     {\tt
                      model.out   = [3;1;4] \\
                      model.out2   = [2;1;1] \\
                      model.outtyp = [2;1;3] \\
                     }

                     and the corresponding {\tt block->outsz} field at C computational function level will be
                     coded as :

                     \begin{figure}[!h]
                      \begin{center}
                       \scalebox{0.7}{\input{outsz.pstex_t}}
                      \end{center}
                     \end{figure}

                     Do the difference here in the type numbers defined at the {\bf Scilab level} (2,1,3)
                     and the type numbers defined at the {\bf C level} (84,11,10) and please report to the 
                     previous table to have the correspondence for all Scicos type.

 \item {\bf block->outptr :} An array of pointers of size nout,1 that allows to directly acces to the
                     data contained in the regular output matrices.\\
                     Suppose the previous example (block with three outputs : an int32 matrix of size [3,2],
                     a complex scalar and a real matrix of size [4,1]).\\
                     {\tt block->outptr} contains three pointers, and should be viewed as arrays contained
                     the data for the int32, the real and the complex matrices :

                     \begin{figure}[!h]
                      \begin{center}
                       \scalebox{0.7}{\input{outptr.pstex_t}}
                      \end{center}
                     \end{figure}

                    For i.e., to directly access to the data, the user can use theses instructions :

                    {\tt
                     \#include "scicos\_block4.h"\\
                     ...\\
                     SCSINT32\_COP *ptr\_i;\\
                     SCSCOMPLEX\_COP *ptr\_dc;\\
                     SCSREAL\_COP *ptr\_d;\\
                     int n1,m1;\\
                     SCSINT32\_COP cumsum\_i=0;\\
                     int i;\\
                     ...\\
                     void mycomputfunc(scicos\_block *block,int flag)\\
                     \{\\
                     /*get the ptrs of the first int32 regular output port*/\\
                     ptr\_i = (SCSINT32\_COP *) block->outptr[0];\\
                     /*get the ptrs of the second complex regular output port*/\\
                     ptr\_dc = (SCSCOMPLEX\_COP *) block->outptr[1];\\
                     /*get the ptrs of the third real regular output port*/\\
                     ptr\_d = (SCSREAL\_COP *) block->outptr[2];\\
                     ...\\
                     /*get the dimension of the first int32 regular output port*/\\
                     n1=block->outsz[0];\\
                     m1=block->outsz[3];\\
                     ...\\
                     /*compute the cumsum of the output int32 matrix*/\\
                     for(i=0;i<n1*m1;i++) \{\\
                     cumsum\_i += ptr\_i[i];\\
                     \}\\
                     ...\\
                     \}\\
                    }

                    One can also use the set of C macros :\\
                    {\tt GetOutPortPtrs(block,x)}, {\tt GetRealOutPortPtrs(block,x)}, \\
                    {\tt GetImagOutPortPtrs(block,x)}, {\tt Getint8OutPortPtrs(block,x)}, \\
                    {\tt Getint16OutPortPtrs(block,x)}, {\tt Getint32OutPortPtrs(block,x)}, \\
                    {\tt Getuint8OutPortPtrs(block,x)}, {\tt Getuint16OutPortPtrs(block,x)}, \\
                    {\tt Getuint32OutPortPtrs(block,x)} \\
                    to have the appropiate pointer of the data to handle and \\
                    {\tt GetNout(block)}, {\tt GetOutPortRows(block,x)}, \\
                    {\tt GetOutPortCols(block,x)}, {\tt GetOutPortSize(block,x,y)}, \\
                    {\tt GetOutType(block,x)}, {\tt GetSizeOfOut(block,x)} \\
                    to handle number, dimensions and type of regular output ports.
                    ({\bf x is numbered from 1 to nout and \bf y is numbered  from 1 to 2}).

                    For the previous example that gives :

                    {\tt
                     \#include "scicos\_block4.h"\\
                     ...\\
                     SCSINT32\_COP *ptr\_i;\\
                     SCSCOMPLEX\_COP *ptr\_dc;\\
                     SCSREAL\_COP *ptr\_d;\\
                     int n1,m1;\\
                     SCSINT32\_COP cumsum\_i=0;\\
                     int i;\\
                     ...\\
                     void mycomputfunc(scicos\_block *block,int flag)\\
                     \{\\
                     ...\\
                     /*get the ptrs of the first int32 regular output port*/\\
                     ptr\_i = GetOutPortPtrs(block,1);\\
                     /*get the ptrs of the second complex regular output port*/\\
                     ptr\_dc = GetRealOutPortPtrs(block,2);\\
                     /*get the ptrs of the third real regular output port*/\\
                     ptr\_d = GetRealOutPortPtrs(block,3);\\
                     ...\\
                     /*get the dimension of the first int32 regular output port*/\\
                     n1=GetOutPortRows(block,1);\\
                     m1=GetOutPortCols(block,1);\\
                     ...\\
                     \}\\
                    }

                    Finally note that the regular output port registers must be only written for {\tt flag}=1.
\end{itemize}

\subsection{Events}

\begin{itemize}
 \item {\bf block->nevprt :} Integer that gives the event input port number by which the block has been activated.
                      This number is a binary coding. For i.e, if block have two event inputs ports,
                      {\tt block->nevptr} can take the value 1 if the block has been called by its first
                      event input port, the value 2 if it has been called by the second event input port and 3
                      if it is called by the same event on both input port 1 and 2.\\
                      Note that {\tt block->nevptr} can be -1 if the block is internally called. \\
                      One can also retrieve this number by using the C macros {\tt GetNevIn(block)}.


 \item {\bf block->nevout :} Integer that gives the number of event output ports of the block (also called
                      the length of the output event register).\\
                      One can't override the index {\tt (block->nevout)-1} when setting value of events
                      in the output event register {\tt evout}.\\
                      The number of event output ports can also be got by the use of the C macro
                      {\tt GetNevOut(block)}.

 \item {\bf block->evout :} Array of double of size nevout,1 corresponding to the output event register. That register
                     is used to program date of events during the simulation.\\
                     When setting values in that array, you must understand that you give a delay relative
                     to the current time of simulator :
                     \begin{eqnarray}
                         t_{\rm event} = t_{\rm cur} + T_{\rm delay}
                     \end{eqnarray}
                     where $t_{\rm event}$ is the date of the programmed event, $t_{\rm cur}$ is the current time
                     in the simulator and $T_{\rm delay}$ the value that must be informed in the output event register.

                     For i.e, suppose that you want generate an event with the first event output port, 1ms after
                     each calls of the block, then you'll use :

                     {\tt
                      \#include "scicos\_block4.h"\\
                      ...\\
                      void mycomputfunc(scicos\_block *block,int flag)\\
                      \{\\
                      ...\\
                      if (flag==3) \{ \\
                       block->evout[0]=0.001;\\
                      \}\\
                      ...\\
                     \}\\
                     }\\

                     Note that every events generated from output event register will be asynchronous with event
                     coming from event input port (even if you set {\tt block->evout[x]=0}). \\
                     The event output register must be only written for {\tt flag}=3.
\end{itemize}

\subsection{Parameters}

\begin{itemize}

 \item {\bf block->nrpar :} Integer that gives the length of the real parameter register.\\
                     One can't override the index {\tt (block->nrpar)-1} when reading value of real
                     parameters in the register {\tt rpar}.\\
                     The total number of real parameters can also be got by the use of the C macro
                     {\tt GetNrpar(block)}.

 \item {\bf block->rpar :} Array of double of size nrpar,1 corresponding to the real parameter register. That register
                    is used to pass real parameters coming from the scilab/scicos environment to your block
                    model.\\
                    The C type of that array is {\tt double *} (or C scicos type {\tt SCSREAL\_COP *}).\\
                    Suppose that you have defined the following real parameters in the
                    \htmladdnormallink{scicos\_model}{scicos_model.htm} of a block :

                    {\tt
                     model.rpar   = [\%pi;\%pi/2;\%pi/4]\\
                    }

                    you can retrieve the previous data in the C computational function with :

                    {\tt
                     \#include "scicos\_block4.h"\\
                     ...\\
                     double PI;\\
                     double PI\_2;\\
                     double PI\_4;\\
                     ...\\
                     void mycomputfunc(scicos\_block *block,int flag)\\
                     \{\\
                     ...\\
                     /*get the first value of the real param register*/\\
                     PI = block->rpar[0];\\
                     /*get the second value of the real param register*/\\
                     PI\_2 = block->rpar[1];\\
                     /*get the third value of the real param register*/\\
                     PI\_4 = block->rpar[2];\\
                     ...\\
                     \}\\
                    }

                    You can also use the C macro {\tt GetRparPtrs(block)} to get the pointer of the
                    real parameter register. For i.e., if we define the following
                    \htmladdnormallink{scicos\_model}{scicos_model.htm} in an interfacing function of a
                    scicos block :

                    {\tt
                     A = [1.3 ; 4.5 ; 7.9 ; 9.8];\\
                     B = [0.1 ; 0.98]; \\
                     model.rpar   = [A;B] \\
                    }

                    in the corresponding C computational function of that block, we'll use :

                    {\tt
                     \#include "scicos\_block4.h"\\
                     ...\\
                     double *rpar;\\
                     double *A; \\
                     double *B; \\
                     ...\\
                     void mycomputfunc(scicos\_block *block,int flag)\\
                     \{\\
                     ...\\
                     /*get ptrs of the real param register*/\\
                     rpar = GetRparPtrs(block); \\
                     /*get the A ptrs array*/\\
                     A = rpar;\\
                     /*get the B ptrs array*/\\
                     B = \&rpar[4];\\
                     /*or B = rpar + 4;*/\\
                     ...\\
                     \}\\
                    }

                    Note that real parameters register is only accessible for reading.

 \item {\bf block->nipar :} Integer that gives the length of the integer parameter register.\\
                     One can't override the index {\tt (block->nipar)-1} when reading value of integer
                     parameters in the register {\tt ipar}.\\
                     The total number of integer parameters can also be got by the use of the C macro
                     {\tt GetNipar(block)}.

 \item {\bf block->ipar :} Array of int of size nipar,1 corresponding to the integer parameter register. That register
                    is used to pass integer parameters coming from the scilab/scicos environment to your block
                    model.\\
                    The C type of that array is {\tt int *} (or C scicos type {\tt SCSINT\_COP *}).\\
                    Suppose that you have defined the following integer parameters in the
                    \htmladdnormallink{scicos\_model}{scicos_model.htm} of a block :

                    {\tt
                     model.ipar   = [(1:3)';5] \\
                    }

                    you can retrieve the previous data in the C computational function with :

                    {\tt
                     \#include "scicos\_block4.h"\\
                     ...\\
                     int one;\\
                     int two;\\
                     int three;\\
                     int five;\\
                     ...\\
                     void mycomputfunc(scicos\_block *block,int flag)\\
                     \{\\
                     ...\\
                     /*get the first value of the integer param register*/\\
                     one = block->ipar[0]; \\
                     /*get the second value of the integer param register*/\\
                     two = block->ipar[1]; \\
                     /*get the third value of the integer param register*/\\
                     three = block->ipar[2]; \\
                     /*get the fourth value of the integer param register*/\\
                     five = block->ipar[3]; \\
                     ...\\
                     \}\\
                    }

                    You can also use the C macro {\tt GetIparPtrs(block)} to get the pointer of the
                    real parameter register.\\
                    Most of time in the scicos C block libraries, the integer register is used to
                    parametrize the length of real parameters. For i.e. if you define the following
                    \htmladdnormallink{scicos\_model}{scicos_model.htm} in a block :

                    {\tt
                     // set a random size for the first real parameters \\
                     A\_sz = int(rand(10)*10); \\
                     // set a random size for the second real parameters \\
                     B\_sz = int(rand(10)*10); \\
                     // set the first real parameters \\
                     A = rand(A\_sz,1,``uniform''); \\
                     // set the second real parameters \\
                     B = rand(B\_sz,1,``normal''); \\
                     // set ipar \\
                     model.ipar = [A\_sz;B\_sz] \\
                     // set rpar (length of A\_sz+B\_sz) \\
                     model.rpar = [A;B] \\
                    }

                    the array of real parameters (parametrized by ipar) can be retrieved in the
                    correspondig C computational function with :

                    {\tt
                     \#include "scicos\_block4.h"\\
                     ...\\
                     int A\_sz; \\
                     int B\_sz; \\
                     double *rpar; \\
                     double *A; \\
                     double *B; \\
                     double cumsum;\\
                     int i;�\\
                     ...\\
                     void mycomputfunc(scicos\_block *block,int flag)\\
                     \{\\
                     ...\\
                     /*get ptrs of the real param register*/\\
                     rpar = GetRparPtrs(block); \\
                     /*get size of the first real param register*/\\
                     A\_sz = block->ipar[0]; \\
                     /*get size of the second real param register*/\\
                     B\_sz = block->ipar[1]; \\
                     /*get the A ptrs array*/\\
                     A = rpar; \\
                     /*get the B ptrs array*/\\
                     B = \&rpar[A\_sz]; \\
                     ...\\
                     /*compute the cumsum of the first real parameter array*/\\
                     cumsum = 0;\\
                     for(i=0;i<A\_sz;i++) \{\\
                     cumsum += A[i];\\
                     \}\\
                     ...\\
                     /*compute the cumsum of the second real parameter array*/\\
                     cumsum = 0;\\
                     for(i=0;i<B\_sz;i++) \{\\
                     cumsum += B[i]; \\
                     \}\\
                    }

                    Note that integer parameters register is only accessible for reading.

 \item {\bf block->nopar :} Integer that gives the number of the object parameters.\\
                     One can't override the index {\tt block->nopar-1} when accessing data in the arrays
                     {\tt oparsz}, {\tt opartyp} and {\tt oparptr} in a C computational function.\\
                     This value is also accessible via the C macro {\tt GetNopar(block)}.

 \item {\bf block->oparsz :} An array of integer of size nopar,2 that contains the dimensions of matrices of
                     object parameters.\\
                     The first column is for the first dimension and the second for the second dimension.
                     For i.e. if we want the dimensions of the last object parameters, we'll use the instructions :

                    {\tt
                     \#include "scicos\_block4.h"\\
                     ...\\
                     int nopar;\\
                     int n,m;\\
                     ...\\
                     void mycomputfunc(scicos\_block *block,int flag)\\
                     \{\\
                     ...\\
                     /*get the number of object parameter*/\\
                     nopar=block\->nopar;\\
                     ...\\
                     /*get number of row of the last object parameter*/\\
                     n=block\->oparsz[nopar-1];\\
                     /*get number of column of the last object parameter*/\\
                     m=block\->oparsz[2*nopar-1];\\
                     ...\\
                     \}\\
                    }

                    The dimensions of object parameters can be get with the following C macro :

                    {\tt
                     GetOparSize(block,x,1); /*get first dimension of opar*/ \\
                     GetOparSize(block,x,2); /*get second dimension of opar*/ \\
                    }

                    with {\tt x} an integer that gives the index of the object parameter, {\bf numbered
                    from 1 to nopar}.

 \item {\bf block->opartyp :} An array of integer of size nopar,1 that contains the type of matrices of
                     object parameters.\\
                     The following table gives the correspondence for scicos type expressed in Scilab number,
                     in C number and also corresponding C pointers and C macros used for {\tt oparptr} :

                     \begin{tabular}{|p{4cm}|p{3cm}|p{3cm}|p{4cm}|p{5cm}|}
                      \hline
                      {\bf Scilab}&
                      &
                      {\bf C}&
                      &
                      \\
                      \hline
                      \hline
                      Type&
                      Number&
                      Number&
                      Type&
                      Macros\\
                      \hline
                      real matrix&
                      1&
                      10&
                      double&
                      SCSREAL\_COP\\
                      \hline
                      complex matrix&
                      2&
                      11&
                      double&
                      SCSCOMPLEX\_COP\\
                      \hline
                      int32 matrix&
                      3&
                      84&
                      long int&
                      SCSINT32\_COP\\
                      \hline
                      int16 matrix&
                      4&
                      82&
                      short&
                      SCSINT16\_COP\\
                      \hline
                      int8 matrix&
                      5&
                      81&
                      char&
                      SCSINT8\_COP\\
                      \hline
                      uint32 matrix&
                      6&
                      814&
                      unsigned long int&
                      SCSUINT32\_COP\\
                      \hline
                      uint16 matrix&
                      7&
                      812&
                      unsigned short&
                      SCSUNINT16\_COP\\
                      \hline
                      uint8 matrix&
                      8&
                      811&
                      unsigned char&
                      SCSUINT8\_COP\\
                      \hline
                      all others data&
                      &
                      -1&
                      double&
                      SCSUNKNOWN\_COP\\
                      \hline
                     \end{tabular}

                     The type of object parameter can also be got by the use of the C macro
                     {\tt GetOparType(block,x)}. For i.e, if we want the C number type of the first
                     object parameter, we'll use the following C instructions:

                     {\tt
                      \#include "scicos\_block4.h"\\
                     ...\\
                      int opartyp\_1;\\
                     ...\\
                      void mycomputfunc(scicos\_block *block,int flag)\\
                      \{\\
                      ...\\
                      /*get the number type of the first object parameter*/\\
                      opartyp\_1 = GetOparType(block,1);\\
                      ...\\
                     \}\\
                     }

 \item {\bf block->oparptr :} An array of pointers of size nopar,1 that allows to directly acces to the
                     data contained in the object parameter.\\
                     Suppose that you have defined in the editor a block with the following 
                     \textbf{opar} field in \htmladdnormallink{scicos\_model}{scicos_model.htm} :

                     {\tt model.opar=list(int32([1,2;3,4]),[1+\%i \%i 0.5]);}

                     Then we have two object parameters, one is an 32-bit integer matrix with two rows and two
                     columns and the second is a vector of complex numbers that can be understand as a matrix
                     of size 1,3.\\
                     At the C computational function level, the instructions {\tt block->oparsz[0]},
                     {\tt block->oparsz[1]},�{\tt block->oparsz[2]}, {\tt block->oparsz[3]} will respectively return the
                     values 2,1,2,3 and the instructions {\tt block->opartyp[0]}, {\tt block->opartyp[1]} the values 11 and
                     84.\\
                     {\tt block->oparptr} will contain then two pointers, and should be viewed as arrays contained data of
                     object parameter as shown in the following figure :

                     \begin{figure}[!h]
                      \begin{center}
                       \scalebox{0.7}{\input{opar.pstex_t}}
                      \end{center}
                     \end{figure}

                    For i.e., to directly access to the data, the user can use theses instructions :

                    {\tt
                     \#include "scicos\_block4.h"\\
                     ...\\
                     SCSINT32\_COP *ptr\_i;\\
                     SCSINT32\_COP cumsum\_i;\\
                     SCSCOMPLEX\_COP *ptr\_d;\\
                     SCSREAL\_COP cumsum\_d;\\
                     ...\\
                     void mycomputfunc(scicos\_block *block,int flag)\\
                     \{\\
                     ...\\
                     /*get the ptrs of an int32 object parameter*/\\
                     ptr\_i = (SCSINT32\_COP *) block->oparptr[0];\\
                     /*get the ptrs of a double object parameter*/\\
                     ptr\_d = (SCSCOMPLEX\_COP *) block->oparptr[1];\\
                     ...\\
                     /*compute the cumsum of the int32 matrix*/\\
                     cumsum\_i = ptr\_i[0]+ptr\_i[1]+ptr\_i[2]+ptr\_i[3];
                     ...\\
                     /*compute the cumsum of the real part of the complex matrix*/\\
                     cumsum\_d = ptr\_d[0]+ptr\_d[1]+ptr\_d[2];\\
                     ...\\
                     \}\\
                    }

                    One can also use the set of C macros :\\
                    {\tt GetRealOparPtrs(block,x)},  {\tt GetImagOparPtrs(block,x)},\\
                    {\tt Getint8OparPtrs(block,x)},  {\tt Getint16OparPtrs(block,x)},\\
                    {\tt Getint32OparPtrs(block,x)}, {\tt Getuint8OparPtrs(block,x)},\\
                    {\tt Getuint16OparPtrs(block,x)}, {\tt Getuint32OparPtrs(block,x)}\\
                    to have the appropiate pointer of the data to handle ({\bf x is numbered from 1 to nopar}).\\
                    For the previous example that gives :

                    {\tt
                     \#include "scicos\_block4.h"\\
                     ...\\
                     SCSINT32\_COP *ptr\_i;\\
                     SCSREAL\_COP *ptr\_dr;\\
                     SCSREAL\_COP *ptr\_di;\\
                     ...\\
                     void mycomputfunc(scicos\_block *block,int flag)\\
                     \{\\
                     ...\\
                     /*get the ptrs of an int32 object parameter*/\\
                     ptr\_i = Getint32OparPtrs(block,1);\\
                     /*get the ptrs of a double object parameter*/\\
                     ptr\_dr = GetRealOparPtrs(block,2);\\
                     ptr\_di = GetImagOparPtrs(block,2);\\
                     ...\\
                     \}\\
                    }

                    Note that object parameters register is only accessible for reading.
\end{itemize}

\subsection{States and work}

\begin{itemize}
 \item {\bf block->nx :} Integer that gives the length of the continus state register.\\
                  One can't override the index {\tt block->nx-1} when reading or writing data in 
                  the array {\tt x}, {\tt xd} or {\tt res} with a C computational function.

 \item {\bf block->x :} Array of double of size nx,1 corresponding to the continuous state register.\\
                 That gives the result of the computation of the state derivative.\\
                 A value of a continuous state is readable (for i.e the first state) with
                 the C instructions :

                 {\tt
                  \#include "scicos\_block4.h"\\
                  ...\\
                  double x\_1;\\
                  ...\\
                  void mycomputfunc(scicos\_block *block,int flag)\\
                  \{\\
                  ...\\
                  x\_1=block->x[0];\\
                  ...\\
                  \}\\
                 }

                 Note that on {\tt flag}=4, user can write some initial conditions in that register.\\
                 The pointer of that array can also be retrieve via the C macro {\tt GetState(block)}.

 \item {\bf block->xd :} Array of double of size nx,1 corresponding to the derivative of the continuous state register.\\
                  When systems are explicitly given in terms of Ordinary Differential Equations (ODE), it can be
                  explicitly expressed or implicitly used in the residual vector {\tt res} when systems are expressed
                  in terms of Differantial Algebraic Equations (DAE). \\
                  Both systems must be programmed with {\tt flag= 0}.\\
                  For i.e the Lorentz attractor written as an ODE system with three state variables, of the form :

                   \begin{eqnarray}
                        \dot{x} &=& f(x,t)
                   \end{eqnarray}
                  will be defined :

                  {\tt
                   \#include "scicos\_block4.h"\\
                   ...\\
                   double *x = block->x;\\
                   double *xd = block->xd;\\
                   ...\\
                   /* define parameters */\\
                   double a = 10;\\
                   double b = 28;\\
                   double c = 8/3;\\
                   ...\\
                   void mycomputfunc(scicos\_block *block,int flag)\\
                   \{\\
                   ...\\
                   if (flag == 0) \{\\
                      xd[0] = a*(x[1]-x[0]);\\
                      xd[1] = x[1]*(b-x[2])-x[1];\\
                      xd[2] = x[0]*x[1]-c*x[2];\\
                   \}\\
                   ...\\
                   \}\\
                  }

 \item {\bf block->res :} Array of double of size nx,1 corresponding to Differential Algebraic Equation (DAE) residual.\\
                   It is used to write the vector of systems that have the following form :
                   \begin{eqnarray}
                        f(\dot{x},x,t) &=& 0
                   \end{eqnarray}
                   For i.e the Lorentz attractor written as a DAE system with three state variables, will be defined :

                   {\tt
                    \#include "scicos\_block4.h"\\
                    ...\\
                    double *x = block->x;\\
                    double *xd = block->xd;\\
                    double *res = block->res;\\
                    ...\\
                    /* define parameters */\\
                    double a = 10;\\
                    double b = 28;\\
                    double c = 8/3;\\
                    ...\\
                    void mycomputfunc(scicos\_block *block,int flag)\\
                    \{\\
                    ...\\
                    if (flag == 0) \{\\
                      res[0] =  - xd[0] + (a*(x[1]-x[0]));\\
                      res[1] =  - xd[1] + (x[0]*(b-x[2])-x[1]);\\
                      res[2] =  - xd[2] + (x[0]*x[1]-c*x[2]);\\
                    \}\\
                    ...\\
                    \}\\
                   }


 \item {\bf block->nz :} Integer that gives the length of the discrete state register.\\
                  One can't override the index {\tt block->nz-1} when reading data in the array {\tt z}
                  with a C computational function.\\
                  This value is also accessible via the C macros {\tt GetNdstate(block)}.

 \item {\bf block->z :} Array of double of size nz,1 corresponding to the discrete state register.\\
                 A value of a discrete state is directly readable (for i.e the second state) with
                 the C instructions :

                 {\tt
                  \#include "scicos\_block4.h"\\
                  ...\\
                  double z\_2;\\
                  ...\\
                  void mycomputfunc(scicos\_block *block,int flag)\\
                  \{\\
                  ...\\
                  z\_2=block->z[1];\\
                  ...\\
                  \}\\
                 }

                 Note that the state register should be only written for {\tt flag}=4 and {\tt flag}=2.\\
                 The pointer of that array can also be retrieve via the C macro {\tt GetDstate(block)}.

 \item {\bf block->noz :} Integer that gives the number of the discrete object states.\\
                   One can't override the index {\tt block->noz-1} when accessing data in the arrays
                   {\tt ozsz}, {\tt oztyp} and {\tt ozptr} in a C computational function.\\
                   This value is also accessible via the C macro {\tt GetNoz(block)}.

 \item {\bf block->ozsz :} An array of integer of size noz,2 that contains the dimensions of matrices of
                    discrete object states.\\
                    The first column is for the first dimension and the second for the second dimension.
                    For i.e. if we want the dimensions of the last object state, we'll use the instructions :

                    {\tt
                     \#include "scicos\_block4.h"\\
                     ...\\
                     int noz;\\
                     int n,m;\\
                     ...\\
                     /*get the number of object state*/\\
                     noz=block\->noz;\\
                     ...\\
                     void mycomputfunc(scicos\_block *block,int flag)\\
                     \{\\
                     ...\\
                     /*get number of row of the last object state*/\\
                     n=block\->ozsz[noz-1];\\
                     /*get number of column of the last object state*/\\
                     m=block\->ozsz[2*noz-1];\\
                     ...\\
                     \}\\
                    }

                    The dimensions of object discrete states can be get with the following C macro :

                    {\tt
                     GetOzSize(block,x,1); /*get first dimension of oz*/ \\
                     GetOzSize(block,x,2); /*get second dimension of oz*/ \\
                    }

                    with {\tt x} an integer that gives the index of the discrete object state, {\bf numbered
                    from 1 to noz}.

 \item {\bf block->oztyp :} An array of integer of size noz,1 that contains the type of matrices of
                     discrete object states.\\
                     The following table gives the correspondence table for scicos type expressed in Scilab number,
                     in C number and also corresponding C pointers and C macros used for {\tt ozptr} :

                     \begin{tabular}{|p{4cm}|p{3cm}|p{3cm}|p{4cm}|p{5cm}|}
                      \hline
                      {\bf Scilab}&
                      &
                      {\bf C}&
                      &
                      \\
                      \hline
                      \hline
                      Type&
                      Number&
                      Number&
                      Type&
                      Macros\\
                      \hline
                      real matrix&
                      1&
                      10&
                      double&
                      SCSREAL\_COP\\
                      \hline
                      complex matrix&
                      2&
                      11&
                      double&
                      SCSCOMPLEX\_COP\\
                      \hline
                      int32 matrix&
                      3&
                      84&
                      long int&
                      SCSINT32\_COP\\
                      \hline
                      int16 matrix&
                      4&
                      82&
                      short&
                      SCSINT16\_COP\\
                      \hline
                      int8 matrix&
                      5&
                      81&
                      char&
                      SCSINT8\_COP\\
                      \hline
                      uint32 matrix&
                      6&
                      814&
                      unsigned long int&
                      SCSUINT32\_COP\\
                      \hline
                      uint16 matrix&
                      7&
                      812&
                      unsigned short&
                      SCSUNINT16\_COP\\
                      \hline
                      uint8 matrix&
                      8&
                      811&
                      unsigned char&
                      SCSUINT8\_COP\\
                      \hline
                      all others data&
                      &
                      -1&
                      double&
                      SCSUNKNOWN\_COP\\
                      \hline
                     \end{tabular}

                     The type of discrete object state can also be got by the use of the C macro
                     {\tt GetOzType(block,x)}. For i.e, if we want the C number type of the first
                     discrete object state, we'll use the following C instructions:

                     {\tt
                      \#include "scicos\_block4.h"\\
                      ...\\
                      int oztyp\_1;\\
                      ...\\
                      void mycomputfunc(scicos\_block *block,int flag)\\
                      \{\\
                      ...\\
                      /*get the number type of the first object state*/\\
                      oztyp\_1 = GetOzType(block,1);\\
                     ...\\
                     \}\\
                     }

 \item {\bf block->ozptr :} An array of pointers of size noz,1 that allows to directly acces to the
                     data contained in the discrete object state.\\
                     Suppose that you have defined in the editor a block with the following 
                     \textbf{odstate} field in \htmladdnormallink{scicos\_model}{scicos_model.htm} :

                     {\tt model.odstate=list(int32([1,2;3,4]),[1+\%i \%i 0.5]);}

                     Then we have two discrete object states, one is an 32-bit integer matrix with two rows and two
                     columns and the second is a vector of complex numbers that can be understand as a matrix
                     of size 1,3.\\
                     At the C computational function level, the instructions {\tt block->ozsz[0]},
                     {\tt block->ozsz[1]},�{\tt block->ozsz[2]}, {\tt block->ozsz[3]} will respectively return the
                     values 2,1,2,3 and the instructions {\tt block->oztyp[0]}, {\tt block->oztyp[1]} the values 11 and
                     84.\\
                     {\tt block->ozptr} will contain then two pointers, and should be viewed as arrays contained data of
                     discrete object state as shown in the following figure :

                     \begin{figure}[!h]
                      \begin{center}
                       \scalebox{0.7}{\input{oz.pstex_t}}
                      \end{center}
                     \end{figure}

                    For i.e., to directly access to the data, the user can use theses instructions :

                    {\tt
                     \#include "scicos\_block4.h"\\
                     ...\\
                     SCSINT32\_COP *ptr\_i;\\
                     SCSINT32\_COP cumsum\_i;\\
                     SCSCOMPLEX\_COP *ptr\_d;\\
                     SCSREAL\_COP cumsum\_d;
                     ...\\
                     void mycomputfunc(scicos\_block *block,int flag)\\
                     \{\\
                     ...\\
                     /*get the ptrs of an int32 discrete object state*/\\
                     ptr\_i = (SCSINT32\_COP *) block->ozptr[0];\\
                     /*get the ptrs of a double discrete object state*/\\
                     ptr\_d = (SCSCOMPLEX\_COP *) block->ozptr[1];\\
                     ...\\
                     /*compute the cumsum of the int32 matrix*/\\
                     cumsum\_i = ptr\_i[0]+ptr\_i[1]+ptr\_i[2]+ptr\_i[3];\\
                     ...\\
                     /*compute the cumsum of the real part of the complex matrix*/\\
                     cumsum\_d = ptr\_d[0]+ptr\_d[1]+ptr\_d[2];\\
                     ...\\
                     \}\\
                    }

                    One can also use the set of C macros :\\
                    {\tt GetRealOzPtrs(block,x)},  {\tt GetImagOzPtrs(block,x)},\\
                    {\tt Getint8OzPtrs(block,x)},  {\tt Getint16OzPtrs(block,x)},\\
                    {\tt Getint32OzPtrs(block,x)}, {\tt Getuint8OzPtrs(block,x)},\\
                    {\tt Getuint16OzPtrs(block,x)}, {\tt Getuint32OzPtrs(block,x)} \\
                    to have the appropiate pointer of the data to handle ({\bf x is numbered from 1 to noz}).\\
                    For the previous example that gives :

                    {\tt
                     \#include "scicos\_block4.h"\\
                     ...\\
                     SCSINT32\_COP *ptr\_i;\\
                     SCSREAL\_COP *ptr\_dr;\\
                     SCSREAL\_COP *ptr\_di;\\
                     ...\\
                     void mycomputfunc(scicos\_block *block,int flag)\\
                     \{\\
                     ...\\
                     /*get the ptrs of an int32 discrete object state*/\\
                     ptr\_i = Getint32OzPtrs(block,1);\\
                     /*get the ptrs of a double discrete object state*/\\
                     ptr\_dr = GetRealOzPtrs(block,2);\\
                     ptr\_di = GetImagOzPtrs(block,2);\\
                     ...\\
                     \}\\
                    }

                    Finally note that the discrete objects state should be only written for {\tt flag}=4 and {\tt flag}=2.

 \item {\bf block->work :} A free pointer to set a working array for the block.\\
                           The work pointer must be firstly allocated when {\tt flag} = 4 and finally be free in the
                           {\tt flag} = 5.\\
                           Then a basic life cyle of that pointer in a C computational function should be :

                           {\tt
                            \#include "scicos\_block4.h"\\
                            ...\\
                            void** work=block->work;\\
                            ...\\
                            void mycomputfunc(scicos\_block *block,int flag)\\
                            \{\\
                           ...\\
                            /*initialization*/\\
                            if (flag==4) \{\\
                              /*allocation of work*/\\
                              if (*work=scicos\_malloc(sizeof(double))==NULL) \{\\
                               set\_block\_error(-16);\\
                               return;\\
                              \}\\
                            ...\\
                            \}\\
                            ...\\
                            /*other flag treatment*/\\
                            ...\\
                            /*finish*/\\
                            else if (flag==5) \{\\
                               scicos\_free(*work);\\
                            \}\\
                            ...\\
                            \}\\
                           }

                           Note that if a block use a {\tt work} pointer, it will be called with {\tt flag}=2 even if
                           the block don't use discrete states.\\
                           The pointer of that array can also be retrieve via the C macro {\tt GetWorkPtrs(block)}.
\end{itemize}

\subsection{Zero crossing surfaces and modes}

\begin{itemize}
 \item {\bf block->ng :} Integer that gives the number of zero crossing surface of the block.\\
                         One can't override the index {\tt (block->ng)-1} when reading/writing data
                         in the array {\tt g} with a C computational function.\\
                         The number of zero crossing surface can also be got by the use of the C macro
                         {\tt GetNg(block)}.

 \item {\bf block->g :} Array of double of size ng,1 corresponding to the zero crossing surface register.\\
                        That register is used to detect zero crossing of state variable during time domain
                        integration.\\
                        Note that it is accessible for writting for {\tt flag} = 9.\\
                        The pointer of that array can also be retrieve via the C macro {\tt GetGPtrs(block)}.

 \item {\bf block->nmode :} Integer that gives the number of mode of the block.\\
                            One can't override the index {\tt (block->mode)-1} when reading/writing data
                            in the array {\tt mode} with a C computational function.\\
                            The number of mode can also be got by the use of the C macro
                            {\tt GetNmode(block)}.

 \item {\bf block->mode :} Array of integer of size nmode,1 corresponding to the mode register.\\
                           That register is used to set the mode of state variable during time domain
                           integration.\\
                           It is typically accessible for writting for {\tt flag} = 9.\\
                           The pointer of that array can also be retrieve via the C macro {\tt GetModePtrs(block)}.

 %\item {\bf jroot :}
\end{itemize}

\subsection{Miscallaneous}

\begin{itemize}
 %\item {\bf funpt :}
 %\item {\bf scsptr :}
 %\item {\bf ztyp :}

 \item {\bf block->type :} Integer that gives the type of the computational function. For C blocks, this number
                    is equal to 4.

 \item {\bf block->label :} Strings array that allows to retrieve the label of the block.
\end{itemize}
</FILE>

<FILE name='C_utils' type='LATEX'>

The \htmladdnormallink{scicos\_block4.h}{scicos_block4_rout.htm} header provides some utilities
functions to interact with the simulator in the C computational functions.

\begin{itemize}

\item {\bf void do\_cold\_restart();}\\
      This function forces the solver to do a cold restart. It should be used in situations
      where the block creates a non smooth signal. Note that in most situations, non smooth
      situations are detected by zero-crossings and this function is not needed. This block is
      used in very exceptional situations.

\item {\bf int get\_phase\_simulation();} \\
      That function returns an integer which says if the simulator is realizing time domain
      integration. It can returns :
      \begin{itemize}
        \item {\bf 1 :} The simulator is on a discrete activation time.
        \item {\bf 2 :} The simulator is realizing a continuous time domain integration.
      \end{itemize}

\item {\bf double get\_scicos\_time();} \\
      That function returns the current time of simulator.

\item {\bf int get\_block\_number();}\\
      That function returns an integer : the block index in the compiled structure. Each
      block in the simulated diagram have a single index, and blocks are numbered from
      1 to nblk (the total number of blocks in the compiled structure).

\item {\bf void set\_block\_error(int);}\\
       Function to set a specific error during the simulation for the current block. If it is used, then
       after the execution of the computational function of the block, the simulator will end and will
       return an error message associated to the number given in the integer argument.\\
       The following calls are allowed :
       \begin{itemize}
          \item{\bf set\_block\_error(-1); :} the block has been called with input out of its domain,
          \item{\bf set\_block\_error(-2); :} singularity in a block,
          \item{\bf set\_block\_error(-3); :} block produces an internal error,
          \item{\bf set\_block\_error(-16); :} cannot allocate memory in block.
       \end{itemize}

\item {\bf void end\_scicos\_sim();}\\
      A very specific function to set the current time of the simulator to the final time integration.\\
      Only expert user should use this function.

\item {\bf void set\_pointer\_xproperty(int* pointer);}\\
       This function set a vector of integer to inform the type (algebraic or differential) of the 
       continuous state variables of the block.

\item {\bf void * scicos\_malloc(size\_t);}\\
      That function must be used to do allocation of scicos pointers inside a C computational function and
      in particular for {\tt flag}=4 for the work pointer {\tt *block->work}.

\item {\bf void scicos\_free(void *p);}\\
      That function must be used to free scicos pointers inside a C computational function and
      in particular for {\tt flag}=5 for the work pointer {\tt *block->work}.

%double Get_Jacobian_parameter(void);
%double Get_Scicos_SQUR(void);
%void Set_Jacobian_flag(int flag);
\end{itemize}
</FILE>

<FILE name='Capacitor' type='LATEX'>
Un condensateur est un composant �lectrique ou �lectronique dont
l'int�r�t de base est d'avoir une capacit� �lectrique. Son
comportement �lectrique id�al est:
      \[  I = C{dV\over dt}\]
o�:
\begin{itemize}
\item $I$ est le courant qui traverse le composant.
\item $V$ est la tension aux bornes du composant.
\item $C$ est la capacit� �lectrique du condensateur.
\item $\textstyle{{dV\over dt}}$ est la variation de tension avec le temps.
\end{itemize}

Le condensateur peut �tre utilis� pour distinguer les signaux
haute-fr�quences et basse-fr�quence. Cette facult� est tr�s utile
dans la conception des filtres.
</FILE>

<FILE name='ConstantVoltage' type='LATEX'>
Ce composant est un mod�le pour n'importe quel dispositif ou syst�me
qui produit une force �lectromotrice constante entre ses terminaux. La
tension aux bornes de cette source est C. C est d�finie par
l'utilisateur. Le port noir indique la tension positive. La r�sistance
ohmique de ce composant est z�ro.
</FILE>

<FILE name='Context' type='LATEX'>
\subsection{Introduction}
In most cases, double clicking on a Scicos block leads to the opening of a dialog box used
to set the values of block parameters. These parameters, which we refer to as GUI parameters,
are not necessarily the exact duplicate of the block parameters used in the {\em computational function}
of the block used during simulation. For example the GUI parameters of a linear system block can be
the numerator and the denominator of its transfer function, whereas the parameters used during the
simulation are the {\bf A}, {\bf B}, {\bf C} and {\bf D} matrices associated with the time domain specification of
this transfer function. It is the role of the {\em interfacing function} of the block to examine the
GUI parameters given by the user, generate error messages if needed, and convert them into simulation
parameters.

In specifying the GUI parameters, the user can enter numerical expressions in the dialog box, for example
{\tt 23} or {\tt [1,4;0,2]}, but he can also enter Scilab expressions such as: {\tt exp(.4*3)+sin(.3)} or 
{\tt ones(5,5)+diag([1:5])}. But more importantly, the user can enter expressions using Scilab
variables: {\tt A}, {\tt cos(theta)/2}. These variables, which we call {\em symbolic parameters} of the block,
must have been previously defined; in most cases this is done in a {\em context}.

Using symbolic parameters in specifying GUI parameters allows the user to easily change a system parameter
affecting multiple blocks (otherwise the GUI parameter of each block has to be individually changed). To
make an analogy with standard programming languages such as C, it would be like setting {\tt double mass=0.3;} 
and using {\tt mass} everywhere in the program instead of {\tt 0.3}. Symbolic parameters can also be used to
construct parameterized models, for example it is possible to build the model
of a fully generic linear-system-Kalman-filter system in which even the size of the blocks' states 
and input/outputs are not determined in advance and vary depending on the value of the parameters. 
Indeed, the sizes of the symbolic parameters can also be changed if it does not create inconsistencies in the diagram.  

\subsection{Diagram context}
Each Scicos diagram (the main diagram as well as the Super Blocks) has a context associated with it.
The context is a {\em Scilab script}; it can be edited interactively using the ``Diagram/Context'' menu of
the diagram. To use a symbolic parameter, say the matrix {\tt A}, to be used in defining 
the GUI parameter of a block, {\tt A}
can be defined in the context of the diagram. But all the symbolic parameters of all the blocks in a diagram
are not necessarily defined in the context of that same diagram.

\subsubsection{Scope of a context variable}
A Scilab variable defined in the context of a diagram is accessible not only to the blocks of that diagram,
but also to the contexts and the blocks of all sub-diagrams below it. For example if {\tt A} is defined in the
context of Diagram D1, and Diagram D2 is a sub-diagram of D1 (is the content of a super block of D1), then
{\tt A} is available to the context of D2 and can be used in the definition of the GUI parameters of its blocks.
The context of D2 can for example contain the following instruction: {\tt B=A+2}.

If the variable {\tt A} is redefined in the context of Dn, one of the sub-diagrams of D1, then it is the new value
that is available in the blocks of Dn, and the context and the blocks of the sub-diagrams below it. So in general, to
find the definition of a symbolic parameter used in a block, first the context of the diagram containing the
block must be examined. If the parameter is not defined there, the context of the diagram containing the
first diagram must be examined and so on until the definition of the parameter is found.  

This hierarchical treatment of parameter definition using multiple contexts as opposed to a single workspace
has many advantages. The most important advantage is that a Super Block can be placed inside a diagram
without any risk of conflict, even if symbolic parameters with similar names are used in both. Another advantage
is its natural usage in the masking operation that we shall see later.

\subsubsection{Evaluation of the context}
As previously stated, a context is nothing but a list of Scilab instructions: a Scilab script. The context
of a diagram must be evaluated (script executed) in order to compute 
the symbolic parameters that are used in the definition of the GUI parameters of its blocks. The contexts
are evaluated only when necessary, in particular when the content of a context is modified. In that case,
all the GUI parameters of all the blocks in the diagram in which the context has been modified are re-evaluated, and
so are the context and the blocks' GUI parameters of all the sub-diagrams below it. The reason for re-evaluating
the sub-diagrams below it has to do with the scope of the parameters defined in the context of the first diagram.
Indeed any change in this context can affect GUI parameters of all the blocks within sub-diagrams below this first
diagram.

When a diagram is opened, its context is also evaluated so that symbolic parameters are 
made available in the environment.
The GUI parameters of the blocks are however not re-evaluated. The reason is that it is assumed that two
evaluation of the same identical contexts leads necessary to the same values of symbolic parameters. So, since
the content of the context of the diagram has not changed since it has last been saved, the blocks GUI parameters
must be up to date. This assumption holds in most cases, but not if functions such as {\tt rand} or {\tt date} are
used in the context. Another instruction that can invalidate the assumption is the execution of an external
script, for example {\tt exec('myprog.sce')}. Clearly if the file {\tt myprog.sce} is modified, the re-evaluation
of the context can lead to different values for the symbolic parameters. Scicos attempts to identify the presence 
of such commands inside the text of the context and issues a full re-evaluation if it finds it necessary when
a diagram is opened. But this identification is not full proof and a manual ``Evaluate'' button is provided to
force a full re-evaluation if the user finds it necessary. 

The ``Evaluate'' button is particularly useful when the context contains an {\tt exec} command since Scicos
does not know if the executed file is edited. In such a case, it is up to the user to force an evaluation.

Finally it should be noted that all the variables defined in a context, except for functions, are available 
as symbolic parameters. So it is recommended that intermediate variables used in the context be cleared at
the end of the context to avoid overloading the list of symbolic parameters. 


\subsection{Masking operation}
The masking operation consists of modifying a Super Block in such a way that it resembles a regular block.
Double clicking on a masked block, opens a GUI, just as in the case of a regular block (double clicking on
a Super Block opens up the diagram contained in the Super Block). The GUI parameters of a masked block
are the symbolic parameters needed to evaluate its content. These parameters are identified automatically
when the ``Create Mask'' operation is applied to a Super Block. 

By choosing to define or not to define in the context various symbolic parameters needed in a Super Block, user
can specify the GUI parameters of the block obtained after the masking operation. This is an easy way of
constructing custom blocks. The dialog box associated with the block can also be customized using the
``Customize Mask'' operation. Finally, the mask can be removed  by the ``Remove Mask'' operation. 
</FILE>

<FILE name='Counter' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	Ce bloc, suivant la loi choisie, compte � partir d'un minimum vers un maximum ou d'un maximum vers un minimun.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='CurrentSensor' type='LATEX'>
Ce bloc est ins�r� en s�rie dans un circuit �lectrique pour mesurer le
courant qui passe � travers. Si le courant positif {\bf entre} par le
port noir, il est consider� positif. La r�sistance ohmique de ce
composant est z�ro.
</FILE>

<FILE name='DEADBAND' type='LATEX'>
Fournit une zone o� la sortie est �gale � z�ro.
</FILE>

<FILE name='DEBUG_SCICOS' type='LATEX'>

The DEBUG block is a powerful debugging tool in Scicos. When placed in a Scicos diagram,
during simulation, it impersonates every block, once before its activation, once after.
By opening the DEBUG block, user can write the scilab script that will be executed when
it is activated. The DEBUG block is very similar to a standard type 5 Scilab block. It is
called with two arguments (block and flag), it has access to functions such as
curblock(), scicos\_time(), etc., and its output is block.

For every block, during simulation, the DEBUG block is called first (as if it were the
block itself). Then the simulation routine of the block is called, and finally the DEBUG
is called a second time the same way. This way, the DEBUG block can be used to monitor
the block values before and after executation. The DEBUG block can also modify these
values, thus making it a powerful debugging tool.

For example if a simple pause is placed in the DEBUG block, then the simulation runs in
single step mode. But the pause statement can also be made conditional. For example:

{\tt
if curblock()==3 \& scicos\_time()>2 \& flag==2 then pause, end
}

The test can also be made dependent on the values of the block, for example:
if block.outptr(1)(1)>9 then disp(scicos\_time()),end

This block can also be used to create log files by printing information about the block
values during simulation.

Note that for the DEBUG block to function, the debugging level must be set to 2 or
higher. The debugging level is changed automatically when the DEBUG block is placed
inside the diagram. It is possible to disable a DEBUG block by changing back the
debugging level to 0, without having to remove it from the diagram. This can be done by
using the menu Debug Level, or at the Scilab prompt (often under pause), using the
scicos\_debug() function.
</FILE>

<FILE name='DELAYV_f' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='DELAY_f' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
          Ce super-bloc compil� r�alise un retard discret.
          Il est construit avec un registre � d�calage et une horloge.
          La valeur du retard est donn�e par la pas temporel discret multipli�
          par le nombre-1 d'�tat du registre.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='DEMUX' type='LATEX'>
En fournissant un vecteur sur le port d'entr�e r�gulier, ce bloc
peut s�parer les �l�ments de l'entr�e par des vecteurs sur les ports
de sortie.
L'entr�e est donc d�finie $u=[y_1;y_2,\cdots;y_n]$, o�  $y_i$ sont
num�rot�s dans un ordre d�croissant.
Les tailles des ports d'entr�e et de sortie sont d�termin�es par le contexte.
</FILE>

<FILE name='DEMUX_f' type='LATEX'>
Given a vector valued input this block splits inputs over vector
valued outputs. So $ u=[y_1;y_2,\cdots;y_n]$ , where  $y_i$  are
numbered from top to bottom. Input and Output port sizes are
determined by the context.
</FILE>

<FILE name='DERIV' type='LATEX'>
Le bloc d�riv�e fait l'approximation de la d�riv�e de son entr�e en calculant:
$$\frac{\Delta u}{\Delta t}$$.
</FILE>

<FILE name='DFLIPFLOP' type='LATEX'>
The DFLIPFLOP block outputs the input state when the enable is
set and on the rising edge of the clock. The input is D the
enable is en and the clock is clk. Q and !Q are the outputs of
this block. This block is almostly used with digital number, 
the input data type is int8.\\

The truth table of this block is
\begin{tabular}{|c|c||c|c|}
\hline
en&
D&
Q&
!Q\\
\hline
0&
0&
0&
1\\
\hline
0&
1&
0&
1\\
\hline
1&
0&
0&
1\\
\hline
1&
1&
1&
0\\
\hline
\end{tabular}
</FILE>

<FILE name='DIFF_f' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='DLATCH' type='LATEX'>
This block outputs the input state when the input gate is high.
The input is D the enable is C. Q and !Q are the outputs of 
this block. This block is almostly used with digital number, 
the input data type is int8.\\

The truth table of this block is

\begin{tabular}{|c|c||c|c|}
\hline
C&
D&
Q&
!Q\\
\hline
0&
0&
0&
1\\
\hline 
0&
1&
0&
1\\
\hline 
1&
0&
0&
1\\
\hline 
1&
1&
1&
0\\
\hline
\end{tabular}
</FILE>

<FILE name='DLR' type='LATEX'>
Ce bloc r�alise un syst�me lin�aire SISO (Single Input Single Output) 
repr�sent� par une fonction de transfert rationnelle
dans l'espace de la transform�e en z.
La fonction rationnelle doit �tre une fonction propre.
</FILE>

<FILE name='DLRADAPT_f' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='DLR_f' type='LATEX'>
Ce bloc r�alise un syst�me lin�aire SISO (Single Input Single Output) 
repr�sent� par une fonction de transfert rationnelle
dans l'espace de la transform�e en z.
La fonction rationnelle doit �tre une fonction propre.
</FILE>

<FILE name='DLSS' type='LATEX'>
Ce bloc r�alise un syst�me d'�quations d'�tat temporel discret.
Le syst�me est d�fini par les matrices $(A,B,C,D)$
et par l'�tat initial $x_0$.
Les dimensions des matrices et de l'�tat initial doivent �tre appropri�es.
Lorsque qu'un �v�nement active le bloc (par son unique port �v�nementiel)
l'�tat est alors mis � jour.
</FILE>

<FILE name='DLSS_f' type='LATEX'>
Ce bloc r�alise un syst�me d'�quations d'�tat temporel discret.
Le syst�me est d�fini par les matrices $(A,B,C,D)$
et par l'�tat initial $x_0$.
Les dimensions des matrices et de l'�tat initial doivent �tre appropri�es.
Lorsque qu'un �v�nement active le bloc (par son unique port �v�nementiel)
l'�tat est alors mis � jour.
</FILE>

<FILE name='DOLLAR' type='LATEX'>
Le bloc retard retarde ses entr�es de la p�riode sp�cifi�e au niveau du port
d'entr�e �v�nementiel.
Ce bloc est �quivalent � l'op�rateur discret $z^{-1}$.
Il accepte une seule entr�e et g�n�re une seule sortie qui peuvent �tre
aussi bien un scalaire qu'un vecteur.
Si l'entr�e est un vecteur alors tous les �l�ments du vecteur sont
retard�s par la m�me p�riode.
</FILE>

<FILE name='DOLLAR_f' type='LATEX'>
Le bloc retard retarde ses entr�es de la p�riode sp�cifi�e au niveau du port
d'entr�e �v�nementiel.
Ce bloc est �quivalent � l'op�rateur discret $z^{-1}$.
Il accepte une seule entr�e et g�n�re une seule sortie qui peuvent �tre
aussi bien un scalaire qu'un vecteur.
Si l'entr�e est un vecteur alors tous les �l�ments du vecteur sont
retard�s par la m�me p�riode.
</FILE>

<FILE name='DOLLAR_m' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
        Le bloc retard retarde ses entr�es de la p�riode sp�cifi�e au niveau
        du port d'entr�e �v�nementiel. Ce bloc est �quivalent � l'op�rateur
        discret z-1.
	Il accepte une seule entr�e et g�n�re une seule sortie qui peuvent
        �tre aussi bien un scalaire qu'un vecteur.
	Si l'entr�e est un vecteur alors tous les �l�ments du vecteur sont
        retard�s par la m�me p�riode.
	</P>
	<P>
        Ce bloc supporte tous les types de donn�es de scicos.
        Les types de donn�es en entr�e/sortie sont h�rit�s du param�tre
        "initial condition".
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='DemoBlocks_pal' type='LATEX'>
Les blocs de cette palette sont utilis�s pour faire des
diagrammes de d�monstration.
</FILE>

<FILE name='Diode' type='LATEX'>
Ce composant consiste en une diode simple mise en parall�le avec une r�sistance
ohmique $R$. Le courant qui passe dans la diode est d�fini en
fonction de la tension aux bornes de le diode, {\it c.-�-d.},

\[I = I_{ds} (\exp^{v/V_t} - 1) + \frac {v} {R} \]

o� $I_{ds}$ et $V_t$ sont le courant de saturation et la tension
�quivalente de la temp�rature, respectivement. Si la valeur de $v/V_t$
atteint une certaine limite ($Maxexp$), la courbe caract�ristique de
la diode devient lin�aire pour �viter un d�passement num�rique.
</FILE>

<FILE name='EDGETRIGGER' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ce bloc est utilis� seulement dans le super bloc EDGE_TRIGGER.
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='EDGE_TRIGGER' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ce bloc g�n�re un �v�nement sur le front montant, descendant ou
les deux (en fonction du param�tre du bloc). Un front montant correspond
� un changement de valeur n�gative vers positive ou nulle, ou z�ro
vers positive. Le front descendant est l'inverse. A noter que ce bloc
g�n�re un �v�nement si l'entr�e saute � cause d'une
activation par �v�nement. L'�v�nement g�n�r� est synchrone
avec l'�v�nement d'origine. Ce bloc ne d�tecte pas les travers�s de
z�ro des signaux continus.
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='ENDBLK' type='LATEX'>
Ce bloc peut �tre utiliser pour param�trer le temps final de la simulation.
Lorsque ce bloc est correctement param�tr� alors le simulateur fera avancer le
temps au temps final d�finit par le param�tre 'final integration time' de l'entr�e
Setup du menu Simulate � la date d�finie par le param�tre de la bo�te de dialogue
'Final simulation time'.
L'unique entr�e de la bo�te de dialogue peut �tre une valeur num�rique
ou bien une variable symbolique d�finit dans le contexte.
</FILE>

<FILE name='END_c' type='LATEX'>
Ce bloc fait avancer le temps courant au temps final d'int�gration lorsque celui-ci
est activ� la premi�re fois :
\begin{eqnarray}
  {\rm T_{f}} & = & {\rm T_{cur}}
\end{eqnarray}
avec {\bf Tcur} la date d'activation de ce bloc et {\bf Tf} le temps final d'int�gration
d�finit via l'entr�e Setup du menu Simulate (scs\_m.props.tf).
</FILE>

<FILE name='ESELECT_f' type='LATEX'>
Bloc sp�cial similaire au bloc If-Then-Else. Les entr�es/sorties
�v�nementielles sont synchronis�es. L'�v�nement entrant est redirig�
sur l'un des ports de sortie �v�nementiels suivant le valeur de
l'entr�e r�guli�re.
</FILE>

<FILE name='EVTDLY_c' type='LATEX'>
Chaque �v�nement de sortie est r�alis� apr�s l'�v�nement 
d'entr�e par un laps de temps {\bf Delay}.\\
La date de l'�v�nement de sortie est donc d�termin�e par la formule :
\begin{eqnarray}
 t_{i}&=&t_{\rm{init}} + i * T_{\rm{delay}},
\end{eqnarray}
</FILE>

<FILE name='EVTDLY_f' type='LATEX'>
Ce bloc g�n�re � la sortie des �v�nements retard�s par rapport aux
�v�nements qui arrivent � l'entr�e.
Le retard est d�finit par la valeur du param�tre {\bf Delay}.
Ce bloc peut aussi g�n�r� un �v�nement � une date initiale.
</FILE>

<FILE name='EVTGEN_f' type='LATEX'>
Un �v�nement est g�n�r� sur le port unique de sortie �v�nementiel
si la valeur du param�tre {\bf Event time} est plus grand ou �gal �
z�ro.
Si cette valeur est n�gative alors aucun �v�nement ne sera g�n�r�.
</FILE>

<FILE name='EVTVARDLY' type='LATEX'>
Ce bloc g�n�re � la sortie des �v�nements retard�s par rapport aux
�v�nements qui arrivent � l'entr�e.
Le retard est d�finit par la valeur qui est lu sur le port d'entr�e
r�gulier.
Ce bloc peut aussi g�n�r� un �v�nement � une date initiale.
</FILE>

<FILE name='EXPBLK_f' type='LATEX'>
Ce bloc calcule $y(i)=a^u(i)$. 
Les tailles des ports d'entr�e et de sortie sont d�termin�es par
le compilateur.
</FILE>

<FILE name='EXPBLK_m' type='LATEX'>
Ce bloc calcule $y(i)=a^u(i)$. \\
Les tailles des ports d'entr�e et de sortie sont d�termin�es par
le compilateur.
</FILE>

<FILE name='EXPRESSION' type='LATEX'>
Le bloc EXPRESSION applique � son entr�e les fonctions Scilab sp�cifi�es
en param�tre.
</FILE>

<FILE name='EXTRACT' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  The EXTRACT block extracts some elements from the matrix.
          The size of the output depends on the number of rows and
          number of columns to extract.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='EXTRACTBITS' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	This block outputs a contiguous selection of bits from the input
        integer number.The Bits to extract defines the method by which
        the user select the output bits.
        </P>
	  <P>
          1- When "Upper Half" is selected the block outputs the half
             of the input that contain the most significant bit. In this
             case the third parameter "number of bits or index of bit"
             is ignored.
          </P>
	  <P>
          2- When "Lower Half" is selected the block outputs the half
             of the input that contain the least significant bit. In this
             case the third parameter "number of bits or index of bit"
             is ignored.
          </P>
	  <P>
          3- When "Range starting with most significant bit" is selected
             the block outputs certain number of bits of the input that
             contain the most significant bit. In this case the third
             parameter "number of bits or index of bit" defines the
             number of bits to extract.
          </P>
	  <P>
          4- When "Range ending with least significant bit" is selected
             the block outputs certain number of bits of the input that
             contain the least significant bit. In this case the third
             parameter "number of bits or index of bit" defines the
             number of bits to extract.
          </P>
	  <P>
          5- When "Range of bits" is selected the block outputs a range
             of bits of the input. In this case the third parameter
             "number of bits or index of bit" defines the range of bits
             to extract, it must be a vector with the format [start,end].
          </P>
	<P>
        The extracted value depends on the forth parameter "Treat bit
        field as an integer". When it is set to 0 the input scaling is
        used to determine the output scaling. When it is set to 1, only
        the extracted bits forms the output number.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='EXTRACTOR' type='LATEX'>
Extrait ou s�lectionne une entr�e r�guli�re parmi plusieurs entr�es r�guli�res.
</FILE>

<FILE name='EXTTRI' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	The EXTTRI block extracts some elements from the input matrix u.
        </P>
	<P>
        When the "Extraction type" is set to "1", the block copies the
        elements on and above the main diagonal to an output matrix of
        the same size. The elements below the main diagonal are set to
        zero.
        </P>
	<P>
        When the "Extraction type" is set to "2", the block copies the
        elements on and below the main diagonal to an output matrix of
        the same size. The elements above the main diagonal are set to
        zero.
        </P>
	<P>
        When the "Extraction type" is set to "3", the block copies the
        elements on the main diagonal to an output matrix of the same
        size. The elements above and below the main diagonal are set to
        zero.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='Electrical_pal' type='LATEX'>
La bo�te � outils �lectrique contient les composants basiques
�lectriques tels que la source de tension, la diode, le condensateur,
etc.
</FILE>

<FILE name='Events_pal' type='LATEX'>
La palette 'Events' (�v�nements) est utilis�e pour manipuler les
�v�nements sur le diagramme. Elle contient entre autre plusieurs
sources d'activation, des blocs synchrones ainsi que des blocs
pour regrouper/combiner les �v�nements sur un seul lien.
</FILE>

<FILE name='Extract_Activation' type='XML'>
  <DESCRIPTION>

  </DESCRIPTION>
</FILE>

<FILE name='FROM' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	The main role of the GOTO/FROM blocks is to transport signals
        from a block to another block without connecting them physically.
        The FROM block transports its received data (from the
        correponding GOTO) to its output. Multiples FROM blocks can
        receive data from one GOTO, although a GOTO can send data to
        multiple FROM.
        </P>
	<P>
        The GOTO and FROM blocks are connected by the tag parameter.
        </P>
	<P>
        For information on the visibility and limitation of these blocks
        please refer to the GOTO documentation.
        </P>
	<P>
        This block can support all the data types.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='FROMMO' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  This block is used to connect modelica's blocks. For more
          information on how it works please refer to the documentation
          of the FROM block by clicking on the link in the "See also"
          field.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='FROMWSB' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
    <DESCRIPTION_ITEM>
    <P>
    That block is used to get data defined in the Scilab workspace
    and use them in Scicos. Data should have "time" and "values" fields.
    </P>
    </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='FROMWS_c' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
    <DESCRIPTION_ITEM>
    <P>
     This block is used in \htmladdnormallink{FROMWSB}{FROMWSB.htm} superblock.
    </P>
    </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='FSV_f' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='GAINBLK' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  Le bloc GAINBLK calcule le produit d'une matrice carr� A par une matrice
          d'entr�e U, o� le nombre de lignes/colonnes de A est �gal au nombre de lignes
          de U. Les types de donn�es des entr�es/sorties sont d�finis par le type de
          donn�e de la matrice gain A.
	  <P>
          Lorsqu'un d�passement intervient, le r�sulat peut prendre des valeurs
          diff�rentes suivant le param�tre "DO ON OVERFLOW":
          </P>
	  <P>1- Un r�sulat non satur�.</P>
	  <P>2- Un r�sultat satur�.</P>
	  <P>3- Un message d'erreur est signal� lorsqu'un d�passement intervient.</P>
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='GAINBLK_f' type='LATEX'>
Le bloc GAINBLK calcule le produit d'une matrice carr� A par une matrice d'entr�e U,
o� le nombre de lignes/colonnes de A est �gal au nombre de lignes de U.
</FILE>

<FILE name='GAIN_f' type='LATEX'>
Ce bloc calcule le produit d'une matrice carr� A par une matrice d'entr�e U, o� le
nombre de lignes/colonnes de A est �gal au nombre de lignes de U.
</FILE>

<FILE name='GENERAL_f' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='GENSIN_f' type='LATEX'>
Ce bloc est un g�n�rateur de sinuso�de : $M*\sin(F*t+P)$
</FILE>

<FILE name='GENSQR_f' type='LATEX'>
Ce bloc est un g�n�rateur de signal carr� : la sortie prend des valeurs
entre -M et M.
Pour chaque �v�nement re�u, la sortie saute d'une valeur -M � M 
ou de M � -M.
</FILE>

<FILE name='GOTO' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	The main role of the GOTO/FROM blocks is to transport signals
        from a block to another block without connecting them physically.
        The GOTO block transports its input data to its corresponding
        FROM block. A simple GOTO block can send data to multiple FROM,
        although a FROM can receive data from only one GOTO.
        </P>
	<P>
        The GOTO and FROM blocks are connected by the tag parameter.
        </P>
	<P>
        The "Tag Visibility" parameter indicates if the location of
        the FROM block is limitted:
        </P>
	  <P>
          - Local: means that the corresponding FROM of that GOTO must
                   be in the same subsystem.
          </P>
	  <P>
          - Scoped: means that the corresponding FROM of that GOTO must
                    be in the same subsystem or in any subsystem below
                    the GotoTagVisibility block in the model hierarchy.
          </P>
	  <P>
          - Global: means that the corresponding FROM of that GOTO can
                    be anywhere in the model.
          </P>
	<P>
        This block can support all the data types.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='GOTOMO' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  This block is used to connect modelica's blocks. For more
          information on how it works please refer to the documentation
          of the GOTO block by clicking on the link in the "See also"
          field.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='GotoTagVisibility' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  This block defines the accessibility of the GOTO block
          when it is configure as "scoped". The FROM block corresponding
          to that GOTO must be in the same subsystem of the
          GotoTagVisibility or in subsystems below it in the model
          hierarchy.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='GotoTagVisibilityMO' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  This block is used in case of modelica's connection.
          For more information on how it works please refer to the
          GotoTagVisibility block by clicking on the link in the
          "See also" field.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='Ground' type='LATEX'>
Cet �l�ment est un composant �lectrique simple fournissant une tension
de r�f�rence dans des circuits �lectriques. Le potentiel au noeud de
Terre est z�ro. Chaque circuit �lectrique doit contenir au moins un
�l�ment Terre.
</FILE>

<FILE name='Gyrator' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
    <DESCRIPTION_ITEM>
    <P>
 A gyrator is a two-port element defined by the following equations:
    <SP>
    i1 =  G2 * v2
    </SP>
    <SP>
    i2 = -G1 * v1
    </SP>
where the constants G1, G2 are called the gyration conductance.
    </P>
    </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='HALT_f' type='LATEX'>
Ce bloc a un unique port d'entr�e �v�nementiel.
Lorsqu'un �v�nement se pr�sente sur ce port, alors la simulation
est arr�t�e et la main est rendue � la fen�tre principale de Scicos.
La simulation peut �tre red�marr�e ou continu�e gr�ce au bouton Run.
</FILE>

<FILE name='HYSTHERESIS' type='LATEX'>
Permutte la valeur de la sortie entre deux constantes.
TODO
</FILE>

<FILE name='IFTHEL_f' type='LATEX'>
Ce bloc g�n�re un �v�nement sur l'une ses deux sorties �v�nementielles
lorsqu'un �v�nement en entr�e active celui-ci.
Suivant le signe de la valeur lue sur le port d'entr�e r�gulier,
l'�v�nement est g�n�r� soit sur la branche 'then' ou bien sur la branche
'else'.
Ce bloc est un bloc synchrone, ce qui signifie que les �v�nements en entr�e
et en sortie sont g�n�r�s exactement � la m�me date et simultan�ment.
</FILE>

<FILE name='IMPSPLIT_f' type='XML'>
  <DESCRIPTION>

  </DESCRIPTION>
</FILE>

<FILE name='INIMPL_f' type='LATEX'>
Les ports d'entr�e INIMPL\_f sont des liens qui permettent de connecter
l'int�rieur d'un syst�me vers l'ext�rieur.
</FILE>

<FILE name='INTEGRAL' type='LATEX'>
Ce bloc est un int�grateur. La sortie est l'int�grale de l'entr�e.
</FILE>

<FILE name='INTEGRAL_f' type='LATEX'>
Ce bloc est un int�grateur. La sortie est l'int�grale de l'entr�e.
</FILE>

<FILE name='INTEGRAL_m' type='LATEX'>
Ce bloc est un int�grateur. La sortie est l'int�grale de l'entr�e.
</FILE>

<FILE name='INTMUL' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	The INTMUL block computes the matrix multiplication of two
        integers inputs matrices.The number of rows of the second
        matrix must be equal to the number of columns of the first
        matrix. The output is a matrix where the number of rows is
        equal to the number of rows of the first input matrix and
        the number of columns is equal to the number of columns of
        the second input matrix. This block support all the integer
        data type.
        </P>
	<P>
        On overflow, the result can take different forms:
        </P>
	 <P>1- A normal non saturated result.</P>
	 <P>2- A saturated result.</P>
	 <P>3- An error message warning the user about the overflow.</P>
	<P>
        The user can select one of these three forms by setting
        the "DO ON OVERFLOW" field to 0,1 or 2.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='INTRP2BLK_f' type='LATEX'>
La sortie de ce bloc est fonction de l'entr�e obtenue par interpolation
bilin�aire.
Ce bloc a deux entr�es scalaires et une seule sortie scalaire.
Les grandeurs $X(i)$ et $Y(i)$ donnent respectivement les coordonn�es
$X,Y$ du $i^{\rm \grave{e}me}$ point de donn�e et $Z(Y(i),X(i))$
sa valeur.
</FILE>

<FILE name='INTRPLBLK_f' type='LATEX'>
La sortie de ce bloc est fonction de l'entr�e obtenue par interpolation
lin�aire.
Ce bloc a une seule entr�e scalaire et une seule sortie scalaire.
Les grandeurs $X$ et $Y$ donnent respectivement les coordonn�es
$X,Y$ des points de donn�es qui seront interpol�s.
$X$ doit �tre strictement croissant.
</FILE>

<FILE name='INVBLK' type='LATEX'>
Ce bloc calcule $y(i)=1/u(i)$.
La taille de l'entr�e/sortie est d�termin�e par le contexte.
</FILE>

<FILE name='INVBLK_f' type='LATEX'>
Ce bloc calcule $y(i)=1/u(i)$.
La taille de l'entr�e/sortie est d�termin�e par le contexte.
</FILE>

<FILE name='IN_f' type='LATEX'>
Ce bloc doit �tre utilis� dans un superbloc pour repr�senter un port
d'entr�e r�gulier. La taille de ce port est automatiquement ajust�e.
Dans un superbloc, les ports d'entr�e r�guliers doivent �tre num�rot�s
de 1 jusqu'au nombre de ports d'entr�e r�guliers composant le superbloc.
</FILE>

<FILE name='ISELECT_f' type='LATEX'>
S�lectionne des signaux suivant les �v�nements d'entr�e.
Ce bloc a un seul port r�gulier d'entr�e.
</FILE>

<FILE name='ISELECT_m' type='LATEX'>
S�lectionne des signaux suivant les �v�nements d'entr�e.
Ce bloc a un seul port r�gulier d'entr�e.
</FILE>

<FILE name='IdealTransformer' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
    <DESCRIPTION_ITEM>
    <P>
The ideal transformer is an ideal two-port resistive circuit element
which is characterized by the following two equations:
    <SP>
    v1 =  n * v2
    </SP>
    <SP>
    i2 = -n * i1
    </SP>
where n is a real number called the turns ratio.
    </P>
    </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='Inductor' type='LATEX'>
Une bobine est un composant �lectrique qui peut stocker l'�nergie
dans des circuits �lectriques.  Le rapport entre la tension $v$ aux
borne d'une bobine d'inductance $L$ et le courant $I$ passant �
travers le composant est donn� par :

\[v = L \frac{dI}{dt}\]

 Des inductances peuvent �galement �tre utilis�es pour distinguer les
 signaux haute fr�quence des signaux de basse fr�quence et ceci
 rend les inductances utiles dans la conception des filtres. Une
 inductance pr�sente une forte imp�dance pour les signaux haute
 fr�quence et est passante pour les signaux DC.
</FILE>

<FILE name='Integer_pal' type='LATEX'>
Cette palette est d�dicac�e aux nombres entiers.
Des op�rateurs vari�s sont ici impl�ment�s pour la logique
et la manipulation des champs de bits ainsi que des portes
logiques qui sont fr�quemment utilis�es dans les circuits num�riques.
</FILE>

<FILE name='JKFLIPFLOP' type='LATEX'>
The JK flip flop is the most versatile of the basic flip-flops.
It has two inputs traditionaly labeled J and K. When J and K are
different, the output takes the value of J at the next falling edge.
When J and K are both low, no change occurs in the output state,
when they are both high the output will toggle from one state to other.
It can perform the functions of the set/reset flip-flop and has the
advantage that there are no ambiguous states. It can also act as a
T flip-flop to accomplish toggling action if J and K are tied together.
This toggle application finds extensive use in binary counters. 
This block is almostly used with digital number, the input data type
is int8.\\

The truth table of this block is

\begin{tabular}{|c|c||c|c|}
\hline
J&
K&
Q(t)&
!Q(t)\\
\hline
0&
0&
Q(t-1)&
!Q(t-1)\\
\hline
0&
1&
0&
1\\
\hline
1&
0&
1&
0\\
\hline
1&
1&
!Q(t-1)&
Q(t-1)\\
\hline
\end{tabular}
</FILE>

<FILE name='Keyboard_shortcuts' type='XML'>
<DESCRIPTION>

</DESCRIPTION>
</FILE>

<FILE name='LOGBLK_f' type='LATEX'>
Ce bloc calcule $y(i)=log(u(i))/log(a)$. 
Les tailles des ports d'entr�e/sortie sont d�termin�s par le contexte.
</FILE>

<FILE name='LOGIC' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  This block implements a standard truth table for modeling
          programming array, digital circuit and any other boolean
          expressions. The user can specify a matrix that defines all
          the possible block output in the Truth table field. Each row
          of the matrix contains the output of different combination
          of input elements. The number of rows must be a power of two,
          it defines the number of inputs using the equation:
        </P>
	<P>number of row = 2 ^ (number of input)</P>
	<P>
          The number of outputs is equal to the number of columns of
          the matrix.
        </P>
	<P>
          This block support only the int8 data type. When the input
          is positif, the input is considered as logical 1, When it is
          negatif or zero it is considered as logical 0.
        </P>
	<P>
          This block can be activated by an implicit input event or it
          can herit the clock from the regular input.
        </P>
	<P>
          This block is used to implement SR and JK flip-flops.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='LOGICAL_OP' type='LATEX'>
Le bloc Op�rateur Logique r�alise une op�ration logique
sur ses entr�es qui est sp�cifi�e en param�tre.
Une valeur d'entr�e est VRAI (1), si elle est diff�rente de z�ro, et
elle est FAUSSE (0) si elle est �gale z�ro.
</FILE>

<FILE name='LOOKUP_f' type='LATEX'>
Ce bloc r�alise une fonction non-lin�aire qui est d�fini gr�ce � un
�diteur graphique.
</FILE>

<FILE name='Linear_pal' type='LATEX'>
Cette palette contient des op�rateurs basiques et des sous-syst�mes
lin�aires.
</FILE>

<FILE name='Lorentz_diagr' type='LATEX'>
Le syst�me de Lorentz est d�fini par le syst�me continu
d'�quations non-lin�aires diff�rentielles suivant :
\begin{eqnarray}
\frac{dx(t)}{dt}&=&a\left(-x(t)+y(t)\right)\\
\frac{dy(t)}{dt}&=&bx(t)-y(t)-x(t)y(t)\\
\frac{dz(t)}{dt}&=&-cx(t)+x(t)y(t)
\end{eqnarray}
Les variables d'�tats $x(t)$, $y(t)$ et $z(t)$ sont respectivement la temp�rature de
l'air, la vitesse du vent et une troisi�me variable qui repr�sente la variation de la
temp�rature en fonction de l'altitude.
</FILE>

<FILE name='MATBKSL' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  The MATBKSL block outputs the left matrix division. It is
          a solution to A*x=B. The higher input is the A matrix, the
          lower one is the B matrix, and the output is x. If A is an
          M-by-N1 matrix, B must be a M-by-N2 where N1 and N2 can be
          different or equal.
	  The output x is a N1-by-N2 matrix.
        </P>
	<P>
          The equivalent of BACKSLASH is "\" in Scilab.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='MATCATH' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  The MATCATH Block outputs the horizontal concatenation
          of multiple matrices. It is also called concatenation
          according to the columns. The inputs U1,U2,...,Un must
          have the same number of rows. The output is a
          M-by-(N1+N2+...+Nn) matrix, where N1,N2,...,Nn are the
          numbers of columns of the inputs matrices, and M is the
          number of rows.
	</P>
	<P>
          The equivalent of MATCATH in Scilab is y=[U1 U2 ... Un].
        </P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='MATCATV' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  The MATCATV Block outputs the vertical concatenation of
          multiple matrices. It is also called concatenation according
          to the rows. The inputs U1,U2,...,Un must have the same
          number of columns. The output is a (M1+M2+...+Mn)-by-N
          matrix, where M1,M2,...,Mn are the numbers of rows of the
          inputs matrices, and N is the number of columns.
	</P>
	<P>
          The equivalent of MATCATH in Scilab is y=[U1;U2;...;Un]
        </P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='MATDET' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	The MATDET outputs the determinant of a square input matrix.
        If the input A=[A11 A12 A13;A21 A22 A23;A31 A32 A33] then the
        output of the block has the form of:
        y=A11*(A22*A33-A23*A32)-A12*(A21*A33-A23*A31)+A13*(A21*A32-A22*A31).
       </P>
	<P>
        The equivalent of MATDET in Scilab is "det"
        </P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='MATDIAG' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  The MATDIAG block create a diagonal matrix from a 1D vector.
          If the input is a M-by-1 vector than the output is an M-by-M
          matrix.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='MATDIV' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
        The MATDIV block outputs the right matrix division. It is a
        solution to x*B=A. The higher input is the A matrix, the lower
        one is the B matrix, and the output is x. If A is an M1-by-N
        matrix, B must be a M2-by-N where M1 and M2 can be different
        or equal. The output x is a M1-by-M2 matrix.
        </P>
	<P>
        The equivalent of BACKSLASH is "/" in Scilab.
        </P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='MATEIG' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	The MATEIG calculate the eigenvalues and the eigenvectors
        of a square input matrix U.
        </P>
	<P>
        When the "Decomposition type" is set to 1, the block outputs
        the eigenvalues in a vector form, if the input is a M-by-M
        matrix the output is a M-by-1 vector.
        </P>
	<P>
        When the "Decomposition type" is set to 2, the block outputs
        two matrices. for an M-by-M input matrix,the first output is
        a M-by-M diagonal matrix composed by the eigenvalues, and the
        second is a M-by-M matrices composed by the eigenvectors; the
        eigenvectors are represented by the columns of the matrix.
        </P>
	<P>
        The equivalent of the MATEIG block in Scilab is "spec(A)"
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='MATEXPM' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  The MATEXPM outputs the matrix exponential of a square
          matrix input by the pade's approximants. The output is
          a square matrix with the same size of the input. The
          equivalent of this block in Scilab is "expm".
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='MATINV' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  The MATINV Block outputs the inverse of a square input matrix
          using the LU factorization. A warning message is printed if
          the input is badly scaled or nearly singular. The equivalent
          function of this block in Scilab is "inv".
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='MATLU' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  The MATLU Block outputs two matrices L and U, with row
          pivoting, from the LU factorization of a square input
          matrix. If A is the input matrix then E*A=L*U where E
          is the permutation matrix.The equivalent function of
          this block in Scilab is "[l,u,e]=lu(A)"
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='MATMAGPHI' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>MATMAGPHI Block has two types of decomposotions.</P>
	<P>
        When the type is set to one, the block converts a complex
        number to the magnitude and the radian angle, in this case
        the input is complex and the outputs are real double. If
        the input is real double, the angle will be zero or PI and
        the magnitude will be equal to the absolute of the input number.
        </P>
	<P>
        When the type is set to two, the block outputs a complex number
        given the magnitude and the radian angle. In this case the inputs
        are real double and the output is complex.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='MATMUL' type='XML'>
<DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  Le bloc MATMUL fait la multiplication matricielle de ses deux entr�es. Le
          nombre de lignes de la seconde matrice doit �tre �gal au nombre de colonnes
          de la premi�re. La sortie est une matrice o� le nombre de lignes est �gal �
          celui de la premi�re matrice d'entr�e et o� le nombre de colonnes est �gal �
          celui de la deuxi�me matrice d'entr�e.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='MATPINV' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	The MATPINV Block outputs the inverse of a non square input
        matrix using the SVD theory.if the SVD decomposition of A is
        equal to:
        </P>
	 <P>A=USV'</P>
	<P>
        The pseudoinverse x of A is given by:
        </P>
	 <P>X=VS"U' where S"(i,j)=1/S(i,j) (if S(i,j)~=0),
	    U' and V are respectivly the transpose of U and V'.
         </P>
	<P>
        and we have A*X*A=A and X*A*X=X. Both A*X and X*A
        are Hermitian . A warning message is printed if the input
        is badly scaled or nearly singular.
        </P>
	<P>
        When the input is a M-by-N matrix the output is a
        N-by-M matrix. The eqivalent function of this block
        in Scilab is "pinv".
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='MATRESH' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  The RESHAPE block changes the dimensions of a matrix or
          a vector to another dimensions specified by the user in
          the "output size desired" label. The output size must be
          less or equal to the input size.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='MATSING' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
        The MATSING block computes the economy sized SVD of the
        M-by-N input matrix A by finding U,S and V such that
        </P>
	 <P>A=U*S*V'.</P>
	<P>
        When the decomposition type is set to one, the output is
        a vector composed by the singular values.
        </P>
	<P>
        When the decomposition type is set to two, we have three
        outputs: the second output is a diagonal matrix S composed
        by the singular values and the other two outputs are the
        unitary matrices U and V.
        </P>
	<P>
        The equivalent function of this block in Scilab is "svd".
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='MATSUM' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  The MATSUM block returns the sum of the element of an input matrix/vector.
	  When the Sum along is set to all the block outputs the sum of all the
          elements of the matrix. The output is then a scalar.
	  When the Sum along is set to lines the block is a rowwise sum. The output is
          a row vector.
	  When the Sum along is set to Columns the block is a columnwise sum. The
          output is a column vector.
	  The equivalent function of this block in scilab is: "sum".
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='MATTRAN' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  Ce bloc fait la transposition d'une matrice de taille MxN en matrice de
          taille NxM. Pour les donn�es de type complexe, celui-ci utilise une
          transposition Hermitienne. L'instruction scilab �quivalente de ce bloc est
          y=u'.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='MATZCONJ' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  This blocks computes the conjugate of a complex input matrix.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='MATZREIM' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  This block decomposes a complex number by seperating the real
          and imaginary parts or compose a comples number by joining the
          two parts. The user can select even to seperate or to join real
          and imaginary part by setting the decomposition type to 1 or 2.
          When it is set to 1, the input is a complex matrix and the
          outputs are the real and imaginary parts of the input. When it
          set to 2, The inputs are two real matrices, the output is a
          complex number with real part the first input and imaginary
          part the second input.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='MAXMIN' type='LATEX'>
Ce bloc peut trouver aussi bien le maximum que le minimum dans les
�l�ments de ses entr�es.
La fonction min ou max peut �tre choisie dans les param�tres de la
bo�te de dialogue.
</FILE>

<FILE name='MAX_f' type='LATEX'>
Ce bloc trouve la valeur maximale dans les �l�ments
de son vecteur d'entr�e.
</FILE>

<FILE name='MBLOCK' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
    <DESCRIPTION_ITEM>
    <P>
    The block "MBlock" provides an easy way to build a Scicos block
    whose behavior is specified by a Modelica program.  Using this
    block, the user will be able to write and compile Modelica
    programs in Scicos without creating any interfacing function.  The
    associated Modelica program of this block can be either given in a
    file or written in the window opened by the block. In order to
    link this block to other Scicos blocks that may be other Modelica
    blocks, the types of block ports' as well as their associated variables
    should be specified.
    </P>
    </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='MCLOCK_f' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='MEMORY_f' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='MFCLCK_f' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='MIN_f' type='LATEX'>
Ce bloc trouve la valeur minimale dans les �l�ments
de son vecteur d'entr�e.
</FILE>

<FILE name='MOTOR' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='MUX' type='LATEX'>
Ce bloc regroupe $n$ vecteurs d'entr�e en un seul vecteur � la sortie.
La sortie est $y=[u_1;u_2;\cdots;u_n]$ , o� les $u_i$ num�rot�es dans
un ordre croissant correspondent aux ports r�guliers d'entr�e du haut
vers le bas.
Les tailles d'entr�e/sortie sont soit d�termin�es automatiquement
� la compilation ou alors d�termin�es par le param�tre
{\bf number of input ports or vector of sizes}.
</FILE>

<FILE name='MUX_f' type='LATEX'>
Ce bloc regroupe $n$ vecteurs d'entr�e en un seul vecteur � la sortie.
La sortie est $y=[u_1;u_2;\cdots;u_n]$ , o� les $u_i$ num�rot�es dans
un ordre croissant correspondent aux ports r�guliers d'entr�e du haut
vers le bas.
Les tailles d'entr�e/sortie sont soit d�termin�es automatiquement
� la compilation ou alors d�termin�es par le param�tre
{\bf number of input ports or vector of sizes}.
</FILE>

<FILE name='M_SWITCH' type='LATEX'>
The Multi-Port Switch block chooses between a number of inputs. The
first (top) input is called the control input, while the rest of the
inputs are called data inputs. The value of the control input
determines which data input is passed through to the output port.
</FILE>

<FILE name='M_freq' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	This blocks generates events at specific sample time of the
        simulation time. The sample time is given in the "Sample Time"
        field and the offset is given in the "Offset" field. This
        block has one event input, the number of event outputs depends
        on the number of different sample time. For exemple if the vector
        of sample time is [1 1 2] and the vector of offset is [0 .5 0]
        then the block has 7 outputs.
        </P>
	<P> - The first output is activated when the simulation time
              is equal to a multiple of the first sample time plus
              the first offset
        </P>
	<P> - The second output is activated when the simulation time
              is equal to a multiple of the second sample time plus
              the second offset.
        </P>
	<P> - The third output is activated when we have both cases,
              first case and second case.
        </P>
	<P> - The fourth output is activated when the simulation time
              is equal to a multiple of the third sample time plus
              the third offset.
        </P>
	<P> - The fifth output is activated when we have both cases,
              first case and forth case.
        </P>
	<P> - The sixth output is activated when we have both cases,
              second case and fourth case.
        </P>
	<P> - The seventh output is activated when we have both cases,
              third case and forth case.
        </P>
	<P> etc...</P>
	<P>
        So the number of outputs is equal to 2**number of differents
        time values. Each of these time values is represented by a
        binary number associated to the output's number in decimal.
        </P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='Matrix_pal' type='LATEX'>
Cette palette contient tous les blocs dont vous avez
besoin pour r�aliser des op�rations matricielles 
simples et complexes.
</FILE>

<FILE name='Menu_entries' type='XML'>
<DESCRIPTION>

</DESCRIPTION>
</FILE>

<FILE name='Modulo_Count' type='LATEX'>
Ce bloc est un bloc discret.
Il d�livre un signal scalaire p�riodique qui a une forme d�termin�e
par les choix de l'utilisateur.
</FILE>

<FILE name='Multiwindow' type='LATEX'>
\subsection{Introduction}
A serious limitation of the Scicos editor has been its inability to
handle more than one diagram at a time. This limitation has been
lifted; it is now possible to open and edit multiple diagrams as
long as they are sub-diagrams of the same Scicos model. In most cases,
the multi-window editing is needed in this situation. The extension
that would allow the simultaneous editing of multiple Scicos models is
forthcoming.  

There are a number of new functionalities available in the new editor
for taking advantage of its muti-windows capabilites. This document
gives a brief description of these functionalities.

\subsection{Active diagram}
In the new editor multiple diagrams can be simultaneously
open. Standard object editing capabilities are available in all of the
diagrams as usual (but not palettes which are read only). But editing
across diagrams is also allowed. For example a block can be ``copied''
in one diagram and ``pasted'' to another one. 

Any action on a diagram window, such as clicking or selecting a menu,
activates the diagram. In most cases the user does not care which
diagram is active because most operations activate the diagram in
which the action has taken place immediately in a completely
transparent manner. 

When a diagram is activated, all the necessary steps are taken by
Scicos to make sure that the environment of the diagram is up to
date. In particular, the symbolic parameters defined in the context of
the diagram and all other diagrams above it are available. This
implies that the user can start editing the diagram without any risk
of inconsistency with the rest of the model.

In most cases, inactive diagrams are also up to date. There is however
an exception. If the number of input/output ports of a Super Block is
modified, the parent diagram is affected. If the parent diagram is
open, it should be updated. This modification however is not
materialized until either the first diagram is closed or the parent
diagram is activated. Once again there is no risk in creating any
inconsistency because the parent diagram, which may not be up to date
at a given time, cannot be edited without being activated.


\subsection{Scicos Browser}
It is very easy to lose track of the topology of a model when many
diagrams are open at the same time. To obtain a hierachical view of
the structure of the model, a Browser functionality has been made
available. The Browser gives a global view of the full model as a tree
like structure. It also indicates the node corresponding to the active
diagram (diagram in which the Browser operation has been launched). 

The Browser is more than just a viewing facility. By double clicking
on a node in the Browser, the corresponding diagram is activated
(opened first if not already open). The main diagram, which
is the root of the tree like structure in the Browser, is not a
node. To activate the main diagram use the
``Diagram/Up\_to\_Main\_diagram'' menu. 

Note that the Browser display is not updated dynamically as the diagram is
edited. So if a Super Block is removed or a new one is created, the
tree structure would no longer be correct. In that case the Browser must
be launched again.

\subsection{Limited Undo operations}
Scicos has always had a single step undo facility. This has not
been really improved in the new editor, however, now each diagram has
its own single step undo facility. In most cases the undo operations
are independent from one window to another, but there is an
exception. If a low-level diagram of a diagram is edited, the undo
operation in this latter diagram can undo all the editing done in the
low-level diagram since it has been opened. To avoid loss of work by an
inadvertent undo operation, a warning message is displayed in such situations.

\subsection{Scilab window activation}
One of the most important features of the new editor is that it allows the user
to activate the Scilab shell without really leaving Scicos. Such a
functionality did exist previously through the Calc command. But Calc activated
the Scilab shell under the pause environment. Even though user could have used this
environment to perform calculations, the result was lost upon leaving the shell
back to Scicos. This was particularly annoying for loaded functions which were
not usable in Scicos.

The Activate Scilab Window operation in Tools menu activates the Scilab prompt
at normal level. This operation is particularly useful for From/To workspace
blocks. For most usages, except perhaps very advanced debugging, this operation
replaces the Calc operation.


</FILE>

<FILE name='NEGTOPOS_f' type='LATEX'>
Un �v�nement est g�n�r� lorsque l'unique entr�e de ce bloc traverse
la valeur z�ro lors d'un front montant.
</FILE>

<FILE name='NMOS' type='LATEX'>

The NMos model is a simple model of a n-channel metal-oxide
semiconductor FET. It differs slightly from the device used in the
SPICE simulator. For more details please care for H. Spiro.

The model does not consider capacitances. A small fixed drain-source
resistance is included (to avoid numerical difficulties).

\begin{tabular}{|p{2cm}|p{2cm}|p{2cm}|p{2cm}|p{2cm}|p{2cm}|p{2cm}|p{2cm}|p{3.5cm}|}
\hline
W [m] & L [m] &  Beta [1/V�]& Vt [V] &  K2 & K5 & DW [m]& DL[m] & \\
\hline
12.e-6&  4.e-6&  .062    &   -4.5   &   .24 &     .61  &   -1.2e-6 &    -.9e-6 & depletion\\
60.e-6&  3.e-6&  .048    &     .1   &  .08  &    .68   &  -1.2e-6  &   -.9e-6  & enhancement\\
12.e-6&  4.e-6&  .0625   &    -.8   &   .21 &     .78  &   -1.2e-6 &    -.9e-6 & zero\\
50.e-6&  8.e-6&  .0299   &     .24  &  1.144&     .7311&   -5.4e-6 &   -4.e-6  &     \\
20.e-6&  6.e-6&  .041    &     .8   &  1.144&     .7311&   -2.5e-6 &   -1.5e-6 &     \\
30.e-6&  9.e-6&  .025    &   -4.    &   .861&     .878 &   -3.4e-6 &   -1.74e-6&     \\
30.e-6&  5.e-6&  .031    &     .6   &  1.5  &     .72  &    0      &   -3.9e-6 &     \\
50.e-6&  6.e-6&  .0414   &   -3.8   &   .34 &     .8  &    -1.6e-6 &   -2.e-6  & depletion\\
50.e-6&  5.e-6&  .03     &     .37  &   .23 &     .86 &    -1.6e-6 &   -2.e-6  & enhancement\\
50.e-6&  6.e-6&  .038    &    -.9   &   .23 &     .707&    -1.6e-6 &   -2.e-6  & zero\\
20.e-6&  4.e-6&  .06776\;&     .5409&   .065&     .71 &     -.8e-6 &    -.2e-6 &     \\
20.e-6&  4.e-6&  .06505  &     .6209&   .065&     .71 &     -.8e-6 &    -.2e-6 &     \\
20.e-6&  4.e-6&  .05365  &     .6909&   .03 &     .8  &     -.3e-6 &    -.2e-6 &     \\
20.e-6&  4.e-6&  .05365  &     .4909&   .03 &     .8  &     -.3e-6 &    -.2e-6 &     \\
12.e-6&  4.e-6&  .023    &   -4.5   &   .29 &     .6  &     0      &    0      & depletion\\
60.e-6&  3.e-6&  .022    &     .1   &   .11 &     .65 &     0      &    0      & enhancement\\
12.e-6&  4.e-6&  .038    &    -.8   &   .33 &     .6  &     0      &    0     &  zero\\
20.e-6&  6.e-6&  .022    &     .8   &  1    &     .66 &     0      &    0     &      \\
\hline
\end{tabular}

</FILE>

<FILE name='NPN' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ce bloc est un mod�le simple pour le transistor bipolaire NPN bas� sur
le mod�le  Ebers-Moll.
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='NRMSOM_f' type='LATEX'>
The Merge block combines its inputs into a single output line whose
value at any time is equal to the most recently computed output of its
driving blocks. You can specify any number of inputs by setting the
block's Number of inputs parameter.  
</FILE>

<FILE name='Non_linear_pal' type='LATEX'>
Cette palette contient des fonctions non-lin�aires.
</FILE>

<FILE name='OUTIMPL_f' type='LATEX'>
Les ports de sortie OUTIMPL\_f sont des liens qui permettent de connecter
l'ext�rieur d'un syst�me vers l'int�rieur.
</FILE>

<FILE name='OUT_f' type='LATEX'>
Ce bloc doit �tre utilis� dans un superbloc pour repr�senter un port
de sortie r�gulier. La taille de ce port est ajust�e automatiquement.
Dans un superbloc, les ports de sortie r�guliers doivent �tre num�rot�s
de 1 jusqu'au nombre de ports de sortie r�guliers composant le superbloc.
</FILE>

<FILE name='OldBlocks_pal' type='LATEX'>
Cette palette contient des anciens blocs Scicos.
Elle est fournie pour pouvoir assurer la compatibilit�
avec des anciens diagrammes contenant ces anciens blocs.
</FILE>

<FILE name='OpAmp' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
    <DESCRIPTION_ITEM>
    <P>
The ideal OpAmp is a two-port. The left port is fixed to v1=0 and i1=0
(nullator). At the right port both any voltage v2 and any current i2
are possible (norator).
    </P>
    </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='Others_pal' type='XML'>
<DESCRIPTION>

</DESCRIPTION>
</FILE>

<FILE name='PDE' type='LATEX'>
This block is an implementation of several numerical schemes (Finite Elements (1st and 2nd order),
Finite Differences (1st and 2nd order), Finite Volumes (1st order)) to solve mono dimensional 
PDE (Partial Differential Equation) within SCICOS.
The mathematical framwork was restricts in PDEs linear scalars with maximum order 2 in time and space.
The goal is to provide engineers and physicists with an easy to use toolbox in SCICOS that will let them
graphically describe the PDE to be solved. A decision system selects the most efficient numerical scheme
depending on the type of the PDE and runs the solvers.
</FILE>

<FILE name='PID' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
    <DESCRIPTION_ITEM>
    <P>
    Ce bloc impl�mente un r�gulateur PID. Un r�gulateur Proportionnel Int�gral
D�riv� (PID) est un organe de contr�le permettant d'effectuer une r�gulation en
boucle ferm�e d'un syst�me industriel. C'est le r�gulateur le plus utilis� dans l'industrie et permet de contr�ler la grande majorit� des
proc�d�s.
    </P>
    </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='PMOS' type='LATEX'>

The PMOS model is a simple model of a p-channel metal-oxide
semiconductor FET. It differs slightly from the device used in the
SPICE simulator. For more details please care for H. Spiro.

The model does not consider capacitances. A small fixed drain-source
resistance is included (to avoid numerical difficulties).

Some typical parameter sets are:

\begin{tabular}{ |c|c|c|c|c|c|c|c|}
\hline
W [m]&L[m]&Beta [1/V�]& Vt [V]& K2 & K5&  DW [m]& DL [m] \\
\hline
50.e-6 &8.e-6 &.0085    &-.15 &   .41  &   .839  & -3.8e-6  & -4.0e-6  \\
20.e-6 &6.e-6 &.0105    &-1.0 &    .41 &    .839 &  -2.5e-6 &  -2.1e-6 \\
30.e-6 &5.e-6 &.0059    &-.3  &   .98  &  1.01   &  0       & -3.9e-6  \\
30.e-6 &5.e-6 &.0152\;  &-.69 &   .104 &  1.1    &  -.8e-6  &  -.4e-6  \\
30.e-6 &5.e-6 &.0163    &-.69 &   .104 &  1.1    &  -.8e-6  &  -.4e-6  \\
30.e-6 &5.e-6 &.0182    &-.69 &   .086 &  1.06   &  -.1e-6  &  -.6e-6  \\
20.e-6 &6.e-6 &.0074    &-1.  &    .4  &    .59  &   0      &   0 \\
\hline
\end{tabular}

</FILE>

<FILE name='PNP' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ce bloc est un mod�le simple pour le transistor bipolaire PNP bas� sur
le mod�le  Ebers-Moll.
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='POSTONEG_f' type='LATEX'>
Un �v�nement est g�n�r� lorsque l'unique entr�e de ce bloc traverse
la valeur z�ro lors d'un front descendant.
</FILE>

<FILE name='POWBLK_f' type='LATEX'>
Ce bloc r�alise $y(i)=u(i)^a$.
Les tailles des ports d'entr�e/sortie sont d�termin�es par le
compilateur.
</FILE>

<FILE name='PRODUCT' type='LATEX'>
The Product block performs multiplication or division of its
inputs. This block produces outputs using either element-wise or
matrix multiplication, depending on the value of the Multiplication
parameter. You specify the operations with the Number of inputs
parameter. Multiply(+1) and divide (-1) characters indicate the
operations to be performed on the inputs.
</FILE>

<FILE name='PROD_f' type='LATEX'>
La sortie de ce bloc est le produit �l�ment par �l�ment des entr�es.
</FILE>

<FILE name='PerteDP' type='LATEX'>
Un bloc de PertDP repr�sente un tuyau hydraulique avec des pertes de
charge. Ce composant repr�sente une perte de charge hydraulique o� la
perte de pression est directement proportionnelle au d�bit, �tat
laminaire.  Ce bloc a une direction; c.-�-d. la direction positive est
quand le fluide entre par le port d'entr�e (le noir). Ceci signifie
que ce bloc suppose que le d�bit est positif si le fluide d�coule du
port noir vers le port blanc.  Les param�tres importants de ce composant
sont la longueur, le diam�tre du tuyau, les altitudes des ports
d'entr�e et de sortie, et quelques autres coefficients
thermo-hydrauliques.
</FILE>

<FILE name='PotentialSensor' type='LATEX'>
Ce bloc est employ� pour mesurer la tension d'un noeud par rapport �
celle de terre (zero) dans un circuit �lectrique. La tension est
donn�e � la partie explicite du mod�le par un port explicite.
</FILE>

<FILE name='PuitsP' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  Ce composant repr�sente un puit thermo-hydraulique de
	  pression constante. Ce bloc est d�fini avec sa pression
          et sa temp�rature. La direction positive est quand le
          fluide coule dans le bloc.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='QUANT_f' type='LATEX'>
Ce bloc quantifie le signal d'entr�e suivant les m�thodes choisies :
\begin{enumerate}
\item m�thode 'Round' :
\begin{eqnarray}
 y(i)&={\rm Step}*({\rm int}(u(i)/{\rm Step}+0.5)-0.5) &\texttt{si} \; u(i)<0 .\\
 y(i)&={\rm Step}*({\rm int}(u(i)/{\rm Step}-0.5)+0.5) &\texttt{si} \; u(i)>=0 .
\end{eqnarray}
\item m�thode 'Truncation' :
\begin{eqnarray}
 y(i)&={\rm Step}*({\rm int}(u(i)/{\rm Step}+0.5)) &\texttt{si} \; u(i)<0 .  \\
 y(i)&={\rm Step}*({\rm int}(u(i)/{\rm Step}-0.5)) &\texttt{si} \; u(i)>=0 .
\end{eqnarray}
\item m�thode 'Floor' :
\begin{eqnarray}
 y(i)&={\rm Step}*({\rm int}(u(i)/{\rm Step}+0.5))  .
\end{eqnarray}
\item  m�thode 'Ceil' :
\begin{eqnarray}
 y(i)&={\rm Step}*({\rm int}(u(i)/{\rm Step}-0.5))
\end{eqnarray}
\end{enumerate}
</FILE>

<FILE name='RAMP' type='LATEX'>
Le bloc RAMP g�n�re un signal qui commence � une date et � une valeur
sp�cifi�es et �volue suivant une pente donn�e.
Les param�tres {\bf Slope , Start time} et {\bf Initial output} d�terminent
les caract�ristiques du signal de sortie.
Ces param�tres doivent avoir des dimensions identiques.
</FILE>

<FILE name='RAND_f' type='LATEX'>
Ce bloc est un g�n�rateur de nombres al�atoires : chaque composante de sortie
prend des valeurs constantes al�atoires par morceaux. Pour chaque �v�nement les
sorties prennent des nouvelles valeurs ind�pendantes.\\
La taille du port de sortie est d�termin�e par la taille des vecteurs {\bf A} et {\bf B}.
</FILE>

<FILE name='RAND_m' type='LATEX'>
Ce bloc est un g�n�rateur de nombres al�atoires : chaque composante de sortie
prend des valeurs constantes al�atoires par morceaux. Pour chaque �v�nement les
sorties prennent des nouvelles valeurs ind�pendantes.\\
La taille du port de sortie est d�termin�e par la taille des matrices {\bf A} et {\bf B}.
</FILE>

<FILE name='RATELIMITER' type='LATEX'>
The Rate Limiter block limits the first derivative of the signal
passing through it. The output changes no faster than the specified
limit.
</FILE>

<FILE name='READAU_f' type='LATEX'>
Charge un son enregistr� dans un fichier 'au'.
Les donn�es �chantillonn�es seront �crites sur la sortie y du bloc.
Si l'extension du fichier n'est pas sp�cifi�e alors l'extension '.au' est
automatiquement ajout�e.
Les valeurs d'amplitude sont comprises entre [-1,+1].
La lecture 'au' supporte les donn�es multi-canaux sous les formats suivants :
\begin{itemize}
   \item 8-bit mu-law 
   \item 8-, 16-, and 32-bit linear
   \item Floating-point
\end{itemize}
</FILE>

<FILE name='READC_f' type='LATEX'>
Ce bloc permet de lire des donn�es dans un fichier C.
Les param�tres {\bf Output record selection] et {\bf Time record Selection}
permettent de s�lectionner des donn�es dans les enregistrements du fichier.
Chaque appel au bloc, fait avancer d'un enregistrement dans le fichier.
</FILE>

<FILE name='REGISTER' type='LATEX'>
Ce bloc r�alise un registre � d�calage.
Pour chaque �v�nement d'entr�e, le registre est d�cal� d'un �l�ment.
</FILE>

<FILE name='REGISTER_f' type='LATEX'>
Ce bloc r�alise un registre � d�calage.
Pour chaque �v�nement d'entr�e, le registre est d�cal� d'un �l�ment.
</FILE>

<FILE name='RELATIONALOP' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
    <DESCRIPTION_ITEM>
    <P>
    Ajoutez ici un paragraphe pour la description de la fonction
    </P>
    </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='RELAY_f' type='LATEX'>
This block routes one of the regular inputs to the unique regular
output. the choice of which input is to be routed is done, initially
by the "initial connected input" parameter. Then, every time an input
event arrives on the i-th input event port, the i-th regular input
port is routed to the regular output.
</FILE>

<FILE name='RFILE' type='LATEX'>
Ce bloc permet � l'utilisateur de lire des donn�es dans un fichier.
Ces donn�es peuvent �tre format�es ou binaires.
Les param�tres {\bf  Output record selection} et {\bf Time record selection}
permettent de selectionner des donn�es parmi les enregistrements du fichier.
Chaque appel au bloc avance d'un enregistrement.\\
Ce bloc fonctionne de paire avec le bloc \htmladdnormallink{WFILE}{WFILE.htm}.
</FILE>

<FILE name='RFILE_f' type='LATEX'>
Ce bloc permet � l'utilisateur de lire des donn�es dans un fichier.
Ces donn�es peuvent �tre format�es ou binaires.
Les param�tres {\bf  Output record selection} et {\bf Time record selection}
permettent de selectionner des donn�es parmi les enregistrements du fichier.
Chaque appel au bloc avance d'un enregistrement.\\
Ce bloc fonctionne de paire avec le bloc \htmladdnormallink{WFILE\_f}{WFILE_f.htm}
</FILE>

<FILE name='RICC' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	This block computes the solution of riccati equation using
        different method and for both case continuous and discrete.
        </P>
	<P> The riccati equation in continuous time is:</P>
	<P>     A*X+X*A+C-X*D*X=0 </P>
	<P> The riccati equation in discrete time is:</P>
	<P>     A*X*(inv(In-D))*A-X+C=0</P>
	<P>
         where A is an NxN matrix, it is the first input of the block,
         C and D are two NxN symetrics matrices and are respectivly the
         second and third input of the RICC block. X represent the
         output of the block, it is also a NxN matrix.
        </P>
	<P>
         The user can choose between two methods of computation. For the
         continuous time he can use even the Schur method or the matrix
         sign function approach method, by setting the Model parameter
         to 1 or 2. For the discrete time, the models are the Schur
         method and the inverse free spectral decomposition method.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='ROOTCOEF' type='LATEX'>
Ce bloc calcule les coefficients d'un polyn�me gr�ce aux valeurs
des racines.
</FILE>

<FILE name='Resistor' type='LATEX'>
Une r�sistance est un composant �lectrique � deux ports qui r�siste �
un courant �lectrique en produisant une chute de tension ($V$) : la loi
d'Ohm.

 \[ R = \frac {V}{I}\] 

  La r�sistance �lectrique ($R$) est �gale � la chute de tension entre
les ports de la r�sistance divis�e par le courant qui passe au travers
($I$).
</FILE>

<FILE name='SAMPHOLD' type='LATEX'>
A chaque fois qu'un �v�nement est re�u, ce bloc copie la valeur de son
entr�e sur sa sortie et maintient cette valeur jusqu'au prochain
�v�nement.
Pour r�aliser un �chantillonneur bloqueur p�riodique, l'entr�e
�v�nementielle doit �tre connect�e � une horloge {\bf Clock}.
</FILE>

<FILE name='SAMPHOLD_m' type='LATEX'>
A chaque fois qu'un �v�nement est re�u, ce bloc copie la valeur de son
entr�e sur sa sortie et maintient cette valeur jusqu'au prochain
�v�nement.
Pour r�aliser un �chantillonneur bloqueur p�riodique, l'entr�e
�v�nementielle doit �tre connect�e � une horloge {\bf Clock}.
</FILE>

<FILE name='SAMPLEHOLD_f' type='LATEX'>
A chaque fois qu'un �v�nement est re�u, ce bloc copie la valeur de son
entr�e sur sa sortie et maintient cette valeur jusqu'au prochain
�v�nement.
Pour r�aliser un �chantillonneur bloqueur p�riodique, l'entr�e
�v�nementielle doit �tre connect�e � une horloge {\bf Clock}.
</FILE>

<FILE name='SATURATION' type='LATEX'>
Le bloc saturation impose des limites maximale et minimale sur un signal.
Lorsque le signal est compris dans l'�chelle d�finie par les param�tres
{\bf Upper limit} et {\bf Lower limit}, celui ci est report� � la sortie
sans modifications.
Lorsque le signal sort de ces limites, alors le signal sature � la sortie
du bloc.
</FILE>

<FILE name='SAT_f' type='LATEX'>
Le bloc saturation impose des limites maximale et minimale sur un signal.
Lorsque le signal est compris dans l'�chelle d�finie par les param�tres
{\bf Upper limit} et {\bf Lower limit}, celui ci est report� � la sortie
sans modifications.
Lorsque le signal sort de ces limites, alors le signal sature � la sortie
du bloc.
</FILE>

<FILE name='SAWTOOTH_f' type='LATEX'>
Ce bloc est un g�n�rateur de dents de scie : 
la sortie de ce bloc est calcul�e par $(t-t_i)$ de $t_i$ jusqu'� $t_{i+1}$
o� $t_i$ et $t_{i+1}$ sont les instants de deux �v�nements d'entr�e successifs.
</FILE>

<FILE name='SCALAR2VECTOR' type='LATEX'>
Ce bloc convertit une valeur scalaire en un vecteur.
Lorsque des blocs avec plus d'un port r�gulier son utilis�s (comme Somme
ou le bloc Relational Operator), vous pouvez mixer des entr�es scalaires
et vectorielles.
Lorsque vous faites cela, les entr�es scalaires sont �tendues � des vecteurs
dont les tailles sont �gales aux tailles des vecteurs d'entr�e.
Si plus d'un port d'entr�e est vectoriel, alors ils doivent avoir la m�me taille.
</FILE>

<FILE name='SELECT_f' type='LATEX'>
Ce bloc redirige l'une de ses entr�es r�guli�res sur l'unique
sortie r�guli�re.
Le choix qui est fait pour savoir quel est le port d'entr�e redirig�
est initalement fait par le param�tre {\bf initial connected input}.
Pendant la simulation, � chaque fois que ce bloc est activ� par son
entr�e �v�nementielle $i$, alors la valeur pr�sente sur le
 $i^{\rm \grave{e}me}$ port r�gulier est recopi�e sur la sortie. 
</FILE>

<FILE name='SELECT_m' type='LATEX'>
Un bloc selecteur accepte sur son entr�e aussi bien un vecteur qu'une matrice.
Vous pouvez d�finir le param�tre {\bf Input Type} au type de signal que vous
utilisez dans votre mod�le (matrice ou vecteur).
Les param�tres de la bo�te de dialogue et l'aspect du bloc changent en accord
avec le type de l'entr�e, ainsi que la mani�re dont il d�termine les �l�ments 
� s�lectionner.
%Ce bloc redirige l'une de ses entr�es r�guli�res sur l'unique
%sortie r�guli�re.
%Le choix qui est fait pour savoir quel est le port d'entr�e redirig�
%est initalement fait par le param�tre {\bf initial connected input}.
%Pendant la simulation, � chaque fois que ce bloc est activ� par son
%entr�e �v�nementielle $i$, alors la valeur pr�sente sur le
% $i^{\rm \grave{e}me}$ port r�gulier est recopi�e sur la sortie.
</FILE>

<FILE name='SHIFT' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  This block shifts the bits of the input signal. In this
          operation the digits are moved to the right or to the left.
	  The user can choose the rule to shifts the bits. It can be
          normal or cycle by setting the "Shifttype" parameter to "0"
          or "1".
        </P>
	<P>
          When the Shifttype is 0, an arithmetic shift is applied to the
          input signal. In this case, the bits that are shifted out of
          either end are discarded. Zeros are shifted in on the right,
          in the case of left shift; in the case of right shifts, copies
          of the sign bit is shifted in on the left.
        </P>
	<P>
          When the "Shifttype" is 1,a circular shift is applied to the
          input signal. In this case, the bits are rotated as if the left
          and right ends of the register are joined. The value that is
          shifted in on the right during a left-shift is whatever values
          was shifted out on the left, and vice versa.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='SIGNUM' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
    <DESCRIPTION_ITEM>
    <P>
    Ajoutez ici un paragraphe pour la description de la fonction
    </P>
    </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='SINBLK_f' type='LATEX'>
$$y={\rm sin}(u)$$
</FILE>

<FILE name='SLIDER_f' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='SPLIT_f' type='XML'>
<DESCRIPTION>

</DESCRIPTION>
</FILE>

<FILE name='SQRT' type='LATEX'>
Ce bloc calcule les racines carr� de cahque �l�ment de la matrice d'entr�e.
Il supporte les types de donn�e r�els et complexes.
</FILE>

<FILE name='SRFLIPFLOP' type='LATEX'>
This block describe the simplest and the most fundamental latch
the SR flip flop. Where S and R are the input and Q and !Q are the
outputs.If S (Set) is pulsed high while R is held low, then the Q
output is forced high, and stays high when S returns low; similarly,
if R (Reset) is pulsed high while S is held low, then the Q output
is forced low, and stays low when R returns low. When both are low,
Q(t) takes the same state as Q(t-1). When they are both high, both Q
and !Q take the low values we are in an unstable state. Practicaly we
have to avoid this case.This block is almostly used with digital
number, the input data type is int8.\\

The truth table of this block is

\begin{tabular}{|c|c||c|c|}
\hline
S&
R&
Q(t)&
!Q(t)\\
\hline
0&
0&
Q(t-1)&
!Q(t-1)\\
\hline
0&
1&
0&
1\\
\hline
1&
0&
1&
0\\
\hline
1&
1&
0&
0\\
\hline --> This case is to avoid
\end{tabular}
</FILE>

<FILE name='STEP' type='XML'>
<DESCRIPTION>

</DESCRIPTION>
</FILE>

<FILE name='STEP_FUNCTION' type='LATEX'>
Le bloc 'Step' r�alise un saut entre deux niveaux d�finis � un temps
sp�cifi�.
Si le temps de simulation est inf�rieur au param�tre {\bf Step time}, la 
sortie est �gale � la valeur du param�tre {\bf Initial value}.
Pour les temps de simulation sup�rieurs, la sortie est �gale � la valeur
du param�tre {\bf Final value}.
</FILE>

<FILE name='SUBMAT' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  This block outputs a sub matrix of the input matrix.
          The output matrix will be defining by using the parameters
          of this block.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='SUMMATION' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P> Ce bloc fait l'addition ou la soustraction de ses entr�es. Ce bloc
	peut additioner et soustraire des grandeurs scalaires, vectorielles et
	matricielles. Il peut aussi faire la somme cumulative d'une seule entr�e
	vectorielle.</P>
	<P>
        Le nombre d'entr�e est donn� par le second param�tre de la boite de dialogue.
        Ce param�tre peut �tre un vecteur de nombre +1 et -1 ou bien
	il peut �tre une seule valeur positive. Dans le premier cas le vecteur donne le
        nombre d'entr�e et le signe indique si c'est une addition ou une soustraction.
        Pour le second choix, ce bloc est un additionneur dont le nombre d'entr�e est
        d�termin�e par la valeur de ce param�tre.
        </P>
	<P>
        Lorsqu'un d�passement intervient, le r�sulat peut prendre des valeurs
        diff�rentes suivant le troisi�me param�tre "DO ON OVERFLOW":
       </P>
	<P>1- Un r�sulat non satur�.</P>
	<P>2- Un r�sultat satur�.</P>
	<P>3- Un message d'erreur est signal� lorsqu'un d�passement intervient.</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='SUM_f' type='LATEX'>
Le bloc somme r�alise l'addition de ses entr�es.
Ce bloc peut additionner des scalaires ou des vecteurs d'entr�e.
</FILE>

<FILE name='SUPER_f' type='LATEX'>
This block opens up a new Scicos window for editing a new block
diagram. This diagram describes the internal functions of the super
block.  

Super block inputs and outputs (regular or event) are
designated by special (input or output) blocks.  

Regular input blocks
must be numbered from 1 to the number of regular input ports. Regular
input ports of the super block are numbered from the top of the block
shape to the bottom.  Regular output portss must be numbered from 1 to
the number of regular output ports. Regular output ports of the super
block are numbered from the top of the block shape to the bottom.
Event input blocks must be numbered from 1 to the number of event
input ports. Event input ports of the super block are numbered from
the left of the block shape to the right.  Event output ports must be
numbered from 1 to the number of event output ports. Event output
ports of the super block are numbered from the left of the block shape
to the right.
</FILE>

<FILE name='SWITCH2' type='LATEX'>
The Switch block passes through the first (top) input or the third
(bottom) input based on the value of the second (middle) input. The
first and third inputs are called data inputs. The second input is
called the control input. You select the conditions under which the
first input is passed with the Criteria for passing first input
parameter. You can make the block check whether the control input is
greater than or equal to the threshold value, purely greater than the
threshold value, or nonzero. If the control input meets the condition
set in the Criteria for passing first input parameter, then the first
input is passed. Otherwise, the third input is passed. 
</FILE>

<FILE name='SWITCH2_m' type='LATEX'>
The Switch block passes through the first (top) input or the third
(bottom) input based on the value of the second (middle) input. The
first and third inputs are called data inputs. The second input is
called the control input. You select the conditions under which the
first input is passed with the Criteria for passing first input
parameter. You can make the block check whether the control input is
greater than or equal to the threshold value, purely greater than the
threshold value, or nonzero. If the control input meets the condition
set in the Criteria for passing first input parameter, then the first
input is passed. Otherwise, the third input is passed. 
</FILE>

<FILE name='SWITCH_f' type='LATEX'>
Ce bloc est un 'interrupteur' manuel.
Il s�lectionne une de ses entr�es pour la r�digirer vers sa sortie.
Les entr�es non s�lectionn�es ne sont donc pas propag�es.
</FILE>

<FILE name='SampleCLK' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	The difference between the SampleCLK and the CLOCK_c is that
        all the SampleCLK blocks in our diagram are synchronous. The
        synchronism is done due to two differents methods of computation
        in the compilation phase.
        </P>
	<P>
        The first method consists of computing a clock that is faster
        than all the SampleCLK connected to a counter which activate
        the event select block.
        </P>
	<P>The clock is calculated due to the following rule.</P>
	<P>
        If all the blocks have the same offset then the frequency of
        the clock is the gcd of the sample time, and the offset of the
        clock is equal to the offset.
        </P>
	<P>
        If the offsets are differents, then the frequency of the clock
        is the gcd of the sample time and the offset, and the offset of
        the clock is equal to 0.
        </P>
	<P>
        The Counter counts from one to the least commun multiple of the
        sample time (lcm).
        </P>
	<P>
        The number of outputs of the ESELECT_f block is equal to the lcm.
        </P>
	<P>
        The second method uses the Multifrequency block it generates
        events only for specific time. Events in this method are not
        periodicly generated as in the first one.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='Sigbuilder' type='LATEX'>
The Signal Builder block is a superblock containing a
\htmladdnormallink{CURVE\_c}{CURVE_c.htm} block whose output event
port is connected to its input event port. This event feedback gives
the possibility to generate events at discontinuous point of the
signal. The generated events automatically restart the numerical
solver and avoids numerical problems. The generated event is also made
available to the user for possible use. Remind that if higher
interpolation methods are used, the events are generated only at the
beginning and at the end of the signal.
</FILE>

<FILE name='SineVoltage' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ce bloc est un bloc Modelica pour une source de tension sinuso�dale.
La r�sistance ohmique interne de ce bloc est z�ro.
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='Sinks_pal' type='LATEX'>
Dans la palette Sinks, vous pouvez trouver une vari�t� de
blocs utilis�s pour afficher (Scope) et �crire les donn�es
dans des fichiers pendant la simulation ainsi que des ports
de sortie utilis�s dans les superblocs.\\
Les blocs de cette palette ne poss�dent pas de ports r�guliers
de sortie.
</FILE>

<FILE name='SourceP' type='LATEX'>
Ce composant repr�sente une source thermohydraulique de pression
constante. Ce bloc est d�fini avec sa pression et sa temp�rature.  La
direction positive conventionnelle est quand le fluide sort du bloc.
</FILE>

<FILE name='Sources_pal' type='LATEX'>
La plupart des blocs de la palette source peuvent �tre compris comme
des g�n�rateurs de donn�es.
Cette palette contient aussi des blocs pour lire des donn�es dans des
fichers, ainsi que des ports d'entr�e utilis�s dans les superblocs.\\
Les blocs de cette palette ne poss�dent pas de ports r�guliers d'entr�e.
</FILE>

<FILE name='Switch' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
    <DESCRIPTION_ITEM>
    <P>
This is a non-ideal two-pole switch. If the explicit input become
positive, two pins are connected via a resistor of resistance
RON). Otherwise, two pins are connected via ROFF resistance.  Note
that using this block may result in a stiff model, so try to choose
proper error tolerances.

    </P>
    </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='TANBLK_f' type='LATEX'>
$$y={\rm tan}(u)$$
</FILE>

<FILE name='TCLSS' type='LATEX'>
Ce bloc r�alise un syst�me d'�quations d'etat en temporel continu avec
la possibilit�s de r�aliser des sauts dans l'�tat.
Le nombre d'entr�es de ce bloc est deux.
La premi�re entr�e est l'entr�e r�guli�re du syst�me lin�aire.
La seconde fournie la valeur du nouvel �tat qui est copi� dans l'�tat du syst�me lorsque le bloc est activ� par un �v�nement sur son unique port d'entr�e �v�nementiel.
Cela signifique que l'�tat du syst�me saute � la valeur pr�sente sur le deuxi�me port d'entr�e (de taille �gale � l'�tat du syst�me).
Le syst�me est d�fini par les matrices $(A,B,C,D)$
et par l'�tat initial $x_0$.
Les dimensions des matrices et de l'�tat initial doivent �tre appropri�es.
Les tailles des entr�es et des sorties sont ajust�es automatiquement.
</FILE>

<FILE name='TCLSS_f' type='LATEX'>
Ce bloc r�alise un syst�me d'�quations d'etat en temporel continu avec
la possibilit�s de r�aliser des sauts dans l'�tat.
Le nombre d'entr�es de ce bloc est deux.
La premi�re entr�e est l'entr�e r�guli�re du syst�me lin�aire.
La seconde fournie la valeur du nouvel �tat qui est copi� dans l'�tat du syst�me lorsque le bloc est activ� par un �v�nement sur son unique port d'entr�e �v�nementiel.
Cela signifique que l'�tat du syst�me saute � la valeur pr�sente sur le deuxi�me port d'entr�e (de taille �gale � l'�tat du syst�me).
Le syst�me est d�fini par les matrices $(A,B,C,D)$
et par l'�tat initial $x_0$.
Les dimensions des matrices et de l'�tat initial doivent �tre appropri�es.
Les tailles des entr�es et des sorties sont ajust�es automatiquement.
</FILE>

<FILE name='TEXT_f' type='LATEX'>
Ce bloc sp�cial est utilis� pour ajouter du texte dans un diagramme scicos.
Il n'affecte pas la simulation.
</FILE>

<FILE name='TIME_DELAY' type='LATEX'>
Ce bloc retarde l'entr�e par un laps de temps sp�cifi�.
Il peut �tre utilis� pour la simulation d'un retad temporel.
Au d�but de la simulation, le bloc d�livre la valeur du param�tre
{\bf Initial input} jusqu'� ce que le temps de la simulation d�passe
le param�tre {\bf Time delay}, auquel cas, le bloc commence � r�aliser
le retard.\\
La valeur du param�tre {\bf Time delay} doit �tre non-n�gative.
</FILE>

<FILE name='TIME_f' type='LATEX'>
Ce bloc est un g�n�rateur de temps.\\
La seule sortie r�guli�re de ce bloc donne le temps courant de la
simulation.
</FILE>

<FILE name='TKSCALE' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
    <DESCRIPTION_ITEM>
    <P>
    Ce bloc g�n�re une sortie constante par morceaux dont la valeur est
d�finie interactivement par un widget TK au cours de la simulation. La
valeur de sortie est �gale � la valeure enti�re affich�e sur le
widget divis�e par le param�tre de normalisation. On peut augmenter la
pr�cisition de la sortie en augmentant proportionnellement tous les
parm�tres du bloc.
    </P>
    </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='TOWS_c' type='LATEX'>
Ce bloc est utilis� pour transf�rer des donn�es simul�es dans
l'environnement Scilab.\\
A chaque instants d'�chantillonnage, aussi bien les dates que les valeurs
de l'entr�e sont enregistr�es.
</FILE>

<FILE name='TRASH_f' type='XML'>
<DESCRIPTION>
 <DESCRIPTION_INDENT>
  <DESCRIPTION_ITEM>
  <P>
  Ce bloc est un bloc de terminaison.
  Il ne fait rien.
  </P>
  </DESCRIPTION_ITEM>
 </DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='ThermoHydraulics_pal' type='LATEX'>
La bo�te � outils de thermohydraulique contient certains composants
thermohydrauliques tels que la source de pression, le tuyau, les vannes
r�glantes, etc.
</FILE>

<FILE name='Threshold_pal' type='LATEX'>
Les blocs de cette palette sont utilis�s pour d�tecter des passages �
certaines valeurs des variables d'�tat pendant la simulation.
Ces blocs utilisent les solveurs (EDO ou EAD) pour r�aliser cette
op�ration.
</FILE>

<FILE name='TrigFun' type='LATEX'>
The Trigonometric Function block performs numerous common
trigonometric functions. You can select one of these functions from
the Function list: sin, cos, tan, asin, acos, atan, atan2, sinh, cosh,
and tanh. The block output is the result of the operation of the
function on the input or inputs. 
</FILE>

<FILE name='VARIABLE_DELAY' type='LATEX'>
The Variable Transport Delay block can be used to simulate a variable
time delay. The block might be used to model a system with a pipe
where the speed of a motor pumping fluid in the pipe is variable. The
block accepts two inputs: the first input is the signal that passes
through the block; the second input is the time delay. 
</FILE>

<FILE name='VVsourceAC' type='LATEX'>
Ce bloc est un mod�le pour une source de tension CA contr�lable. Ce
composant fournit une tension sinusoidale entre ses
ports. L'amplitude de la tension de sortie est d�finie par une entr�e
explicite et la fr�quence est d�finie par l'utilisateur. La r�sistance
ohmique de ce bloc est z�ro.
</FILE>

<FILE name='VanneReglante' type='LATEX'>
Le bloc de VanneReglante repr�sente une Vanne Reglante ou une vanne �
orifice variable. Le d�bit du fluide passe par la vanne et est
proportionnel � l'ouverture de vanne, {\it c.-�-d.},

\[
  \Delta P \times h\times\left| h \right| = k\times Q\times \left|Q\right|
\]

l� o� $h$ est l'ouverture de vanne, $\delta P$ est la diff�rence de
pression, et $Q$ est le d�bit. Ce mod�le est seulement employ� pour
les r�gimes laminaires d'�coulement. $k$ est une constante qui d�pend
de la g�om�trie de la vanne et de la masse volumique de fluide.
</FILE>

<FILE name='VariableResistor' type='LATEX'>
Ce composant repr�sente une r�sistance ohmique variable. La r�sistance
est command�e par le port d'entr�e explicite.  \[ R_x = \frac {V}{I}
\]
</FILE>

<FILE name='VoltageSensor' type='LATEX'>
Ce composant est employ� pour mesurer la diff�rence de tension entre
deux noeuds dans un circuit �lectrique. Le signal de sortie est la
diff�rence entre la tension du port noir et celle du port blanc.
La conductance ohmique de ce bloc est z�ro.
</FILE>

<FILE name='VsourceAC' type='LATEX'>
Ce composant est une source de tension CA avec une tension de sortie
sinusoidale. L'amplitude et la fr�quence de la tension de sortie
sont d�finies par l'utilisateur. La r�sistance ohmique de ce bloc est
z�ro.
</FILE>

<FILE name='WFILE' type='LATEX'>
Ce bloc permet � l'utilisateur de sauvegarder des donn�es dans un fichier.
Ces donn�es peuvent �tre format�es ou binaires.
Chaque appel au bloc correspond � un enregistrement.
Chaque enregistrement � la forme suivante :  $[t,V1,...,Vn]$ o� $t$ est la valeur du temps lorsque le bloc est appel� et $V_i$ est la $i^{\rm\grave{e}me}$ valeur d'entr�e.
Ce bloc fonctionne de paire avec le bloc \htmladdnormallink{RFILE}{RFILE.htm}.
</FILE>

<FILE name='WFILE_f' type='LATEX'>
Ce bloc permet � l'utilisateur de sauvegarder des donn�es dans un fichier.
Ces donn�es peuvent �tre format�es ou binaires.
Chaque appel au bloc correspond � un enregistrement.
Chaque enregistrement � la forme suivante :  $[t,V1,...,Vn]$ o� $t$ est la valeur du temps lorsque le bloc est appel� et $V_i$ est la $i^{\rm\grave{e}me}$ valeur d'entr�e.\\
Ce bloc fonctionne de paire avec le bloc \htmladdnormallink{RFILE\_f}{RFILE_f.htm}.
</FILE>

<FILE name='WRITEAU_f' type='LATEX'>
Ce bloc �crit un fichier son de type 'au'.
Les donn�es doivent �tre rang�es avec un canal par colonne.
Les valeurs en dehors de l'�chelle [-1 +1] seront coup�es � l'�criture.
L'�criture 'au' supporte les donn�es multi-canaux pour les formats
'8-bit mu-law' et '8-,16-bit linear'.
</FILE>

<FILE name='WRITEC_f' type='LATEX'>
Ce bloc permet d'�crire des donn�es dans un fichier C au format binaire.
</FILE>

<FILE name='ZCROSS_f' type='LATEX'>
Un �v�nement est g�n�r� lorsque toutes les entr�es traverse la valeur
z�ro simultan�ment.
</FILE>

<FILE name='block_type' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
    <DESCRIPTION_ITEM>
    <P>
    Ajoutez ici un paragraphe pour la description de la fonction
    </P>
    </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='buildouttb' type='LATEX'>
Construit une liste "outtb" initialis�e.
</FILE>

<FILE name='c_block' type='LATEX'>
Ce bloc cr�e une fonction de calcul squelette en C.
Il cr�e aussi une librairie et un fichier objet � la compilation.
</FILE>

<FILE name='create_palette' type='XML'>
  <DESCRIPTION>
     <DESCRIPTION_INDENT>
     <DESCRIPTION_ITEM>
     <P>
      Cette fonction g�n�re une palette si Path est une cha�ne de caract�res
      indiquant un r�pertoire o� se trouvent des fonctions d'interfa�ages de
      blocs scicos.
      Si Path est absent ou bien si celui est �gal � %t, les palettes
      standards de Scicos sont construites.
      Si Path est �gal � %f, alors seul le param�tre IntFunc est retourn�
      (le param�tre routines est vide dans ce cas).
     </P>
     </DESCRIPTION_ITEM>
     </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='curblock' type='XML'>
  <DESCRIPTION>

  </DESCRIPTION>
</FILE>

<FILE name='data_type' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
    <DESCRIPTION_ITEM>
    <P>
    Ajoutez ici un paragraphe pour la description de la fonction
    </P>
    </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='fortran_block' type='LATEX'>
Ce bloc cr�e une fonction de calcul squelette en fortran.
Il cr�e aussi une librairie et un fichier objet � la compilation.
</FILE>

<FILE name='freq_div' type='LATEX'>
Ce bloc est un superbloc.
L'entr�e �v�nementielle est redirig�e une fois parmi n � la sortie.
</FILE>

<FILE name='func_block' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='generic_block' type='LATEX'>

</FILE>

<FILE name='generic_block2' type='LATEX'>
The block provides a generic interfacing function but the
computational function needs to be defined separately, either as a
Scilab function or  a Fortran or a C function. Besides the name of the
function, user should specify information such as the type, whether or
not the block contains a direct feed-through term. The function
realising computational functions of generic blocks of a scicos
diagram must be saved along with the diagram and loaded or dynamically
linked before simulation. 
</FILE>

<FILE name='generic_block3' type='LATEX'>
The block provides a generic interfacing function but the
computational function needs to be defined separately, either as a
Scilab function or  a Fortran or a C function. Besides the name of the
function, user should specify information such as the type, whether or
not the block contains a direct feed-through term. The function
realising computational functions of generic blocks of a scicos
diagram must be saved along with the diagram and loaded or dynamically
linked before simulation. 
</FILE>

<FILE name='get_scicos_version' type='XML'>
  <DESCRIPTION>
     <DESCRIPTION_INDENT>
     <DESCRIPTION_ITEM>
     <P>
     Cette fonction retourne le num�ro de version courant de Scicos.
     </P>
     </DESCRIPTION_ITEM>
     </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='getblocklabel' type='XML'>
  <DESCRIPTION>

  </DESCRIPTION>
</FILE>

<FILE name='getscicosvars' type='XML'>
  <DESCRIPTION>
    <P>
    Cette fonction utilitaire est utilis�e pour retrouver les tableaux de travail du
    compilateur et du simulateur scicos pendant la simulation.
    </P>
    <P>
      Elle peut-�tre utilis�e dans un bloc scilab pour retourner des informations de
      tous types de blocs. Cette fonction est tr�s utile pour d�bugger les diagrammes
      et pour prototyper des simulations.
    </P>
  </DESCRIPTION>
</FILE>

<FILE name='lincos' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  Construct a linear state-space system by linearizing a model
	  given as a Scicos diagram.
	</P>
      </DESCRIPTION_ITEM>
      <DESCRIPTION_ITEM>
	<P>
	  The output is a Scilab data structure of type continuous-time state-space
          linear system.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='phase_simulation' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  Cette fonction permet de savoir si le simulateur scicos est dans sa phase
          d'int�gration temporelle.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='pointer_xproperty' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
    <DESCRIPTION_ITEM>
    <P>
    Cette fonction retourne un vecteur indiquant le type (alg�brique ou diff�rentiel)
    des variables d'�tats continues utilis�es dans un bloc.
    </P>
    </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='sci_struct' type='LATEX'>

A Scicos computational function of type 5 can be realized by the use of a Scilab function.
That function doesn't really differs from all other scilab function : one can use all functions and
instructions of the scilab language inside that function to do the computation.

Such a function must be written in a file with extension .sci, must be loaded inside scilab by the
common loading scilab function ({\tt exec}, {\tt getf}, {\tt getd}, {\tt genlib},...) and must have
two right hand side arguments and one left hand side argument, as the following calling sequence :

{\tt
function block=myblock(block,flag)\\
...\\
//your computational instructions \\
...\\
endfunction\\
}

When the simulator is calling such a computational function, it build a scilab structure (in the previous exemple this is the named {\tt block} rhs/lhs arguments) from his own internal C reprensation of a block structure (see \htmladdnormallink{C\_struct} {C_struct.htm} for more details about the C structure of scicos
blocks).

That scilab structure is a scilab typed list variable that have the following fields :

{\tt
!scicos\_block  nevprt  funpt  type  scsptr  nz  z  noz  ozsz  oztyp  !\\
!oz  nx  x  xd  res  nin  insz  inptr  nout  outsz  outptr  nevout  !\\
!evout  nrpar  rpar  nipar  ipar  nopar  oparsz  opartyp  opar  ng  g  !\\
!ztyp  jroot  label  work  nmode  mode  !
}

Each fields are then accessible inside the scilab computational function by the use of :

{\tt
 block.field
}

\subsection{Inputs/outputs}

\begin{itemize}
 \item {\bf block.nin :} a scalar that gives the number of regular input ports.
                         This is a read only data.

 \item {\bf block.insz :} a vector of size {\tt 3*nin}, that gives the dimensions and types of the regular input ports.
                          \begin{itemize}
                              \item{\bf {\tt block.insz(1:nin)} :} are the first dimensions.
                              \item{\bf {\tt block.insz(nin+1:2*nin)} :} are the second dimensions.
                              \item{\bf {\tt block.insz(2*nin+1:3*nin)} :} are the type of data (C coding).
                          \end{itemize}
                          This is a read only data.

 \item {\bf block.inptr :} a list of size {\tt nin} that enclosed typed matrices for regular input ports.
                           Each element correspond to only one regular input port. Then {i-th} matrix
                           of the block.inptr list will have the dimensions [{\tt block.insz(i)}, {\tt block.insz(nin+i)}] and
                           the type {\tt block.insz(2*nin+i)}.\\
                           The data type that can be provided by regular input ports are :
                           \begin{itemize}
                             \item {\bf 1 :} matrix of real numbers,
                             \item {\bf 2 :} matrix of complex numbers,
                             \item {\bf 3 :} matrix of int32 numbers,
                             \item {\bf 4 :} matrix of int16 numbers,
                             \item {\bf 5 :} matrix of int8 numbers,
                             \item {\bf 6 :} matrix of uint32 numbers,
                             \item {\bf 7 :} matrix of uint16 numbers,
                             \item {\bf 8 :} matrix of uint8 numbers.
                           \end{itemize}
                          This is a read only data.

 \item {\bf block.nout :} a scalar that gives the number of regular output ports.
                          This is a read only data.

 \item {\bf block.outsz :} a vector of size {\tt 3*nout}, that gives the dimensions and types of the regular output ports.
                          \begin{itemize}
                              \item{\bf {\tt block.outsz(1:nout)} :} are the first dimensions.
                              \item{\bf {\tt block.outsz(nout+1:2*nout)} :} are the second dimensions.
                              \item{\bf {\tt block.outsz(2*nout+1:3*nout)} :} are the type of data (C coding).
                          \end{itemize}
                          This is a read only data.

 \item {\bf block.outptr :} a list of size {\tt nout} that enclosed typed matrices for regular output ports.
                            Each element correspond to only one regular output port. Then {i-th} matrix
                            of the block.outptr list will have the dimensions [{\tt block.outsz(i)}, {\tt block.outsz(nin+i)}] and
                            the type {\tt block.outsz(2*nin+i)}.\\
                            The data type that can be provided by regular output ports are :
                            \begin{itemize}
                              \item {\bf 1 :} matrix of real numbers,
                              \item {\bf 2 :} matrix of complex numbers,
                              \item {\bf 3 :} matrix of int32 numbers,
                              \item {\bf 4 :} matrix of int16 numbers,
                              \item {\bf 5 :} matrix of int8 numbers,
                              \item {\bf 6 :} matrix of uint32 numbers,
                              \item {\bf 7 :} matrix of uint16 numbers,
                              \item {\bf 8 :} matrix of uint8 numbers.
                            \end{itemize}
                            Values of regular output ports will be saved in the \htmladdnormallink{C structure}{C_struct.htm} of
                            the block only for {\tt flag}=6 and {\tt flag}=1.
\end{itemize}

\subsection{Events}

\begin{itemize}
 \item {\bf block.nevprt :} a scalar given the event input port number (binary coding)
                            which have activated the block. This is a read only data.

 \item {\bf block.nevout :} a scalar given the number of output event port of the block.
                            This is a read only data.

 \item {\bf block.evout :} a vector of size {\tt nevout} corresponding to the register
                           of output event.
                           Values of  output event register will be saved in the \htmladdnormallink{C structure}{C_struct.htm} of
                           the block only for {\tt flag}=3.
\end{itemize}

\subsection{Parameters}

\begin{itemize}
 \item {\bf block.nrpar :} a scalar given the number of real parameters.
                           This is a read only data.

 \item {\bf block.rpar :} a vector of size {\tt nrpar} corresponding to the real parameter register.
                          This is a read only data.

 \item {\bf block.nipar :} a scalar given the number of integer parameters.
                           This is a read only data.

 \item {\bf block.ipar :} a vector of size {\tt nipar} correspondig to the integer parameter register.
                          This is a read only data.

 \item {\bf block.nopar :} a scalar given the number of object parameters.
                           This is a read only data.

 \item {\bf block.oparsz :} a matrix of size {\tt nopar,2}, that respectively gives the first and the second
                            dimension of object parameters. This is a read only data.

 \item {\bf block.opartyp :} a vector of size {\tt nopar} given the C coding type of data.
                            This is a read only data.

 \item {\bf block.opar :} a list of size {\tt nopar} given the values of object parameters.
                          Each element of {\tt opar} can be either a typed matrix or a list.
                          Only matrix that encloses numbers of type real, complex, int32, int16, int8,
                          uint32, uint16 and uint8 are allowed, all other types of scilab data will
                          be enclosed in a sub-list. This is a read only data.
\end{itemize}

\subsection{States}

\begin{itemize}
 \item {\bf block.nz :} a scalar given the number of discrete state for the block.
                        This is a read only data.

 \item {\bf block.z :} a vector of size {\tt nz} corresponding to the discrete state register.
                       Values of discrete state register will be saved in the \htmladdnormallink{C structure}{C_struct.htm} of
                       the block only for {\tt flag}=4, {\tt flag}=6, {\tt flag}=2 and {\tt flag}=5.

 \item {\bf block.noz :} a scalar that gives the number of discrete object state.
                         This is a read only data.

 \item {\bf block.ozsz :} a matrix of size {\tt noz,2}, that respectively gives the first and the second
                          dimension of discrete object state. This is a read only data.

 \item {\bf block.oztyp :} a vector of size {\tt noz} given the C coding type of data.

 \item {\bf block.oz :} a list of size {\tt noz} given the values of discrete object states.
                          Each element of {\tt oz} can be either a typed matrix or a list.
                          Only matrix that encloses numbers of type real, complex, int32, int16, int8,
                          uint32, uint16 and uint8 are allowed, all other types of scilab data will
                          be enclosed in a sub-list.
                          Values of discrete object state will be saved in the \htmladdnormallink{C structure}{C_struct.htm} of
                          the block only for {\tt flag}=4, {\tt flag}=6, {\tt flag}=2 and {\tt flag}=5.

 \item {\bf block.nx :} a scalar given the number of continuous state for the block.
                        This is a read only data.

 \item {\bf block.x :} a vector of size {\tt nx} given the value of the continuous state register.
                       Values of the continuous state register will be saved in the \htmladdnormallink{C structure}{C_struct.htm} of
                       the block only for {\tt flag}=4, {\tt flag}=6 and {\tt flag}=2.

 \item {\bf block.xd :} a vector of size {\tt nx} given the value of the derivative continuous state register.
                       Values of the derivative continuous state register will be saved in the \htmladdnormallink{C structure}{C_struct.htm} of
                       the block only for {\tt flag}=4, {\tt flag}=6, {\tt flag}=0 and {\tt flag}=2.

 \item {\bf block.res :} a vector of size {\tt nx} corresponding to the Differential Algebraic Equation (DAE) residual.
                       Values of that register will be saved in the \htmladdnormallink{C structure}{C_struct.htm} of
                       the block only for {\tt flag}=0, and {\tt flag}=10.
 %\item {\bf block.work:}
\end{itemize}

\subsection{Zero crossing surfaces and modes}

\begin{itemize}
 \item {\bf block.ng :} a scalar given the number of zero crossing surfaces for the block.
                        This is a read only data.

 \item {\bf block.g :} a vector of size {\tt ng} corresponding to the zero crossing register.
                       Values of that register will be saved in the \htmladdnormallink{C structure}{C_struct.htm} of
                       the block only for {\tt flag}=9.

% \item {\bf block.jroot :}
 \item {\bf block.nmode :} a scalar given the number of mode for the block.
                           This is a read only data.

 \item {\bf block.mode :} a vector of size {\tt mode} that corresponds to the mode register.
                       Values of that register will be saved in the \htmladdnormallink{C structure}{C_struct.htm} of
                       the block only for {\tt flag}=9, with {\tt \htmladdnormallink{phase\_simulation}{phase_simulation.htm}}=1.

\end{itemize}

\subsection{Miscallaneous}

\begin{itemize}
% \item {\bf : funpt}
 \item {\bf block.type :} a scalar given the type of the block.
                          This is a read only data.
% \item {\bf block.ztyp :}
 \item {\bf block.label :} a string given the label of the block.
                          This is a read only data.
 %\item {\bf scsptr :}
\end{itemize}

</FILE>

<FILE name='scicos' type='LATEX'>
Scicos est un �diteur graphique pour construire des mod�les
de syst�mes dynamiques hybrides.\\
L'appel � Scicos sans argument ouvre une fen�tre vierge de l'�diteur.
Les mod�les peuvent alors �tre assembl�s, charg�s, sauvegard�s,
compil�s, simul�s en utilisant les diff�rentes interfaces utilisateur
graphiques (GUI) de l'�diteur.
Scicos est en fait une interface pour la compilation et le
simulateur 'scicosim'.
Des arguments en entr�e et en sortie de la commande scicos peuvent
aussi �tre utilis�es pour r�aliser des op�rations de d�bogage.
</FILE>

<FILE name='scicos_block' type='XML'>
  <DESCRIPTION>

  </DESCRIPTION>
</FILE>

<FILE name='scicos_block4_rout' type='XML'>
  <DESCRIPTION>

  </DESCRIPTION>
</FILE>

<FILE name='scicos_cpr' type='XML'>
  <DESCRIPTION>

  </DESCRIPTION>
</FILE>

<FILE name='scicos_debug' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  Cette fonction sert � param�trer le niveau de d�bogage de la simulation
          scicos.
	</P>
	<P>
	  Elle peut �tre utilis�e soit en mode "Calc" dans l'�diteur Scicos ou en tant
          qu'instruction dans un bloc scilab et encore dans une fonction d'interfa�age.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='scicos_diagram' type='XML'>
  <DESCRIPTION>

  </DESCRIPTION>
</FILE>

<FILE name='scicos_graphics' type='XML'>
  <DESCRIPTION>

  </DESCRIPTION>
</FILE>

<FILE name='scicos_link' type='XML'>
  <DESCRIPTION>

  </DESCRIPTION>
</FILE>

<FILE name='scicos_model' type='XML'>
  <DESCRIPTION>

  </DESCRIPTION>
</FILE>

<FILE name='scicos_params' type='XML'>
  <DESCRIPTION>

  </DESCRIPTION>
</FILE>

<FILE name='scicos_sim' type='XML'>
  <DESCRIPTION>

  </DESCRIPTION>
</FILE>

<FILE name='scicos_simulate' type='XML'>
  <DESCRIPTION>
    <P>
      This function is used to simulate scicos diagrams in batch
      mode. It requires the scs_m structure which can be obtained by
      loading in Scilab the .cos file (e.g. load
      mydiagram.cos).
    </P>
    <P>
      Contrary to the function <LINK> scicosim</LINK>, the diagram
      need not be compiled before being saved.
    </P>
  </DESCRIPTION>
</FILE>

<FILE name='scicos_state' type='XML'>
  <DESCRIPTION>

  </DESCRIPTION>
</FILE>

<FILE name='scicos_time' type='XML'>
<DESCRIPTION>

</DESCRIPTION>
</FILE>

<FILE name='scicosim' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  Simulator for Scicos compiled diagram.
	</P>
	<P>
	  Usually scicosim is called by scicos to perform simulation of
	  a diagram.
	</P>
	<P>
	  But scicosim may also be called outside Scicos. Typical usage
	  in such a case may be :
	</P>
      </DESCRIPTION_ITEM>
      <DESCRIPTION_ITEM>
	<DESCRIPTION_ITEM>
	  <P>
	    1- Use Scicos to define a block diagram, compile it.
	  </P>
	  <P>
	    2- Save the compiled diagram using Save,SaveAs Scicos menus.
	  </P>
	  <P>
	    3- In Scilab, load saved file using load function. You get
	       variables scicos_ver, scs_m, %cpr scs_m is the diagram Scicos
               main data structure.
	  </P>
	  <P>
	    %cpr is the data structure containing (state,sim,cor,corinv)
	    if the diagram had been compiled before saved, else %cpr=list().
	  </P>
	  <P>
	    4- Extract state, sim out of cpr.
	  </P>
	  <P>
	    5- Execute [state,t]=scicosim(state,0,tf,sim,'start',tol) for
               initialisation.
	  </P>
	  <P>
	    6- Execute [state,t]=scicosim(state,0,tf,sim,'run',tol) for
	       simulation from 0 to tf.
	  </P>
	  <P>
	    Many successives such calls may be
	    performed changing initial and final time.
	  </P>
	  <P>
	    7- Execute [state,t]=scicosim(state,0,tf,sim,'finish',tol) at
	       the very end of the simulation to close files,...
	  </P>
	</DESCRIPTION_ITEM>
      </DESCRIPTION_ITEM>
      <DESCRIPTION_ITEM>
	<P>
	  For advanced user it is possible to "manually"
	  change some parameters or state values.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='scifunc_block' type='LATEX'>
This block can realize any type of Scicos block. The function of the
block is defined interactively using dialogue boxes and in Scilab
language. During simulation, these instructions are interpreted by
Scilab; the simulation of diagrams that include these types of blocks
is slower. For more information see Scicos reference manual. 
</FILE>

<FILE name='scifunc_block_m' type='LATEX'>
This block can realize any type of Scicos block. The function of the
block is defined interactively using dialogue boxes and in Scilab
language. During simulation, these instructions are interpreted by
Scilab; the simulation of diagrams that include these types of blocks
is slower. For more information see Scicos reference manual. 
</FILE>

<FILE name='set_blockerror' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
    <DESCRIPTION_ITEM>
    <P>
    Cette fonction permet de d�finir une erreur sp�cifique en cours de simulation pour le
    bloc courant. Si c'est fonction est utilis�e, alors � l'issue de l'�xecution de la fonction
    de calcul du bloc, le simulateur s'arr�tera et retournera un message d'erreur associ� au
    num�ro donn� en argument.
    </P>
    </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='set_xproperty' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
    <DESCRIPTION_ITEM>
    <P>
    Cette fonction permet de d�finir un vecteur indiquant le type (alg�brique ou diff�rentiel)
    des variables d'�tats continues utilis�es dans un bloc.
    </P>
    </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='steadycos' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  This function finds the steady state for a given system described
	  by a Scicos diagram. The diagram consists in general of a Super
	  block with input and output port blocks. The steady state
	  concerns only the continuous-time dynamics.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='use_flag' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
    <DESCRIPTION_ITEM>
    <P>
    Ajoutez ici un paragraphe pour la description de la fonction
    </P>
    </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='var2vec' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  Les fonctions var2vec / vec2var sont utilis�es dans les fonctions
          d'interfa�ages des blocs scilab pour donner la possibilit� � l'utilisateur de
          manipuler des objets scilab avec le registre des param�tres r�els (rpar) et
          avec le registre des �tats discrets (z).
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='vec2var' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  Les fonctions var2vec / vec2var sont utilis�es dans les fonctions
          d'interfa�ages des blocs scilab pour donner la possibilit� � l'utilisateur de
          manipuler des objets scilab avec le registre des param�tres r�els (rpar) et
          avec le registre des �tats discrets (z).
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>


</DATA>
