<?xml version="1.0" encoding="ISO-8859-1" standalone="no"?>
<DATA flag="desc">

<FILE name='ABS_VALUE' type='LATEX'>
Le bloc Abs calcule à la sortie, la valeur absolue de l'entrée.
</FILE>

<FILE name='AFFICH_f' type='LATEX'>
Peandant la simulation, ce bloc affiche sur le diagramme 
la valeur lue sur son unique port d'entrée événementiel.\\
{\bf Attention :} a  fois que le bloc est déplacé, l'utilisateur
doit cliquer sur celui-ci pour éditer ses paramètres. La position
d'affichage est alors automatiquement ajustée.
</FILE>

<FILE name='ANDBLK' type='LATEX'>
TODO
</FILE>

<FILE name='ANDLOG_f' type='LATEX'>
Ce bloc possédant deux entrées événementielles et une sortie régulière,
délivre +1 ou -1 sur sa sortie régulière suivant ses entrées événementielles.
\begin{enumerate}
\item[+1]: Lorsque les événements sont synchrones (même événement présent sur les deux ports événementiels simultanément),

\item[-1]: Lorsqu'un seul événement est présent.
 \end{enumerate}
</FILE>

<FILE name='ANIMXY_f' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='BACKLASH' type='LATEX'>
The Backlash block implements a system in which a change in input
causes an equal change in output. However, when the input changes
direction, an initial change in input has no effect on the output. The
amount of side-to-side play in the system is referred to as the
{\em deadband or gap}.
</FILE>

<FILE name='Bache' type='LATEX'>
Ce composant représente une bache thermo-hydraulique qui consiste en
deux ports d'entrée et deux ports de sortie.  Conventionnellement, la
direction positive pour la rentrée est quand le fluide {\bf entre}
dans le port d'entree (ports noirs) et la direction positive pour les
ports de sortie est quand le fluide {\bf sort} des port de sortie
(ports blancs).  La surface de la bache, la température initiale et
l'altitude initiale du fluide peuvent être definies par l'utilisateur.
Si un port reste non-utilisé, il doit être bouché par le bloc {\bf
Bouchon}.
</FILE>

<FILE name='Branching_pal' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='CBLOCK' type='LATEX'>
Ce bloc crée une fonction de calcul squelette en C.
Il crée aussi une librairie et un fichier objet à la compilation.
</FILE>

<FILE name='CLINDUMMY_f' type='LATEX'>
Ce bloc peut être placé dans tous diagrammes qui contient un ou
des blocs 'zero-crossing' et qui ne dispose pas de blocs contenant
des états continus (x) temps dépendant (dep\_t=\%t).
Grâce à cela, le simulateur utilisera le solveur ode pour la détection
de surfaces des blocs 'zero-crossing'.
</FILE>

<FILE name='CLKINV_f' type='LATEX'>
Ce bloc doit seulement être utilisé à l'intérieur des superblocs.
Il est utilisé pour représenter un port d'entrée événementiel.
Dans un superbloc, les ports doivent être numérotés à partir de 1
jusqu'au nombre de ports.  
</FILE>

<FILE name='CLKOUTV_f' type='LATEX'>
Ce bloc doit seulement être utilisé à l'intérieur des superblocs.
Il est utilisé pour représenter un port de sortie événementiel.
Dans un superbloc, les ports doivent être numérotés à partir de 1
jusqu'au nombre de ports.  
</FILE>

<FILE name='CLKSOMV_f' type='LATEX'>
Ce bloc est un bloc d'addition d'événement à trois entrées.
La sortie reproduit les événements de tous les ports d'entrées.
A proprement parler, CLKSOMV n'est pas un vrai bloc scicos, car
il est ignoré pendant la phase de compilation.\\
Les sorties et les entrées de ce bloc sont synchronisées.
</FILE>

<FILE name='CLOCK_f' type='LATEX'>
Ce bloc est un super-bloc construit grâce au bloc \htmladdnormallink{EVTDLY\_f}{EVTDLY_f.htm} qui est rebouclé sur lui-même.\\
L'unique sortie de ce bloc génère des événements à des dates précises, qui sont déterminées par le paramètre {\bf Period} de la boîte de dialogue.
</FILE>

<FILE name='CLR_f' type='LATEX'>
Ce bloc réalise un système linéaire SISO (Single Input Single Output) 
représenté par une fonction de transfert rationnelle.
La fonction rationnelle doit être une fonction propre.
</FILE>

<FILE name='CLSS_f' type='LATEX'>
Ce bloc réalise un système linéaire d'équations d'état en temporel continu.
\begin{align}
\dot x&=Ax+Bu\\
  y   &=C*x+D*u
\end{align}
Le système est défini par les matrices $(A,B,C,D)$
et par l'état initial $x_0$.
Les dimensions des matrices et de l'état initial doivent être appropriées.
</FILE>

<FILE name='CMSCOPE' type='LATEX'>
Au début de la simulation, ce bloc ouvre une fenêtre  pour afficher
l'évolution temporelle des données qui seront lues sur les ports
d'entrées réguliers.
Ce bloc est donc similaire à un oscilloscope.
Il permet l'affichage de multiple abscisses (une par entrée).
Ces abscisses peuvent avoir des échelles temporelles différentes
qui seront définies par le paramètre {\bf Refresh period}.
</FILE>

<FILE name='CONSTRAINT_f' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  Ce bloc définit des relations algébriques implicites.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='CONST_f' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
          Ce bloc est un générateur de valeurs constantes.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='CSCOPE' type='LATEX'>
Au début de la simulation, ce bloc ouvre une fenêtre  pour afficher
l'évolution temporelle des données qui seront lues sur le ports
d'entrée régulier.
Ce bloc est donc similaire à un oscilloscope.
Il permet d'afficher sur une même figure l'évolution des
éléments d'un vecteur.
Ce bloc ne possède qu'une seule échelle temporelle.
</FILE>

<FILE name='CURV_f' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  Ce bloc définit une fonction tabulée en fonction du temps.
	  Entre chaque point des mailles, ce bloc réalise une interpolation
	  linéaire. En dehors des points tabulés, il fournit les derniers
          points rencontrés.
          L'utilisateur peut définir les différents points
          en utilisant un éditeur graphique de courbes.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='Capacitor' type='LATEX'>
Un condensateur est un composant électrique ou électronique dont
l'intérêt de base est d'avoir une capacité électrique. Son
comportement électrique idéal est:
      \[  I = C{dV\over dt}\]
où:
\begin{itemize}
\item $I$ est le courant qui traverse le composant.
\item $V$ est la tension aux bornes du composant.
\item $C$ est la capacité électrique du condensateur.
\item $\textstyle{{dV\over dt}}$ est la variation de tension avec le temps.
\end{itemize}

Le condensateur peut être utilisé pour distinguer les signaux
haute-fréquences et basse-fréquence. Cette faculté est très utile
dans la conception des filtres.
</FILE>

<FILE name='ConstantVoltage' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ce composant est un modèle pour n'importe quel dispositif ou système
qui produit une force électromotrice constante entre ses terminaux. La
tension aux bornes de cette source est C. C est définie par
l'utilisateur. Le port noir indique la tension positive. La résistance
ohmique de ce composant est zéro.

</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='CurrentSensor' type='LATEX'>

Ce bloc est inséré en série dans un circuit électrique pour mesurer le
courant qui passe à travers. Si le courant positif {\bf entre} par le
port noir, il est consideré positif. La résistance ohmique de ce
composant est zéro.

</FILE>

<FILE name='DEADBAND' type='LATEX'>
Fournit une zone où la sortie est égale à zéro.
</FILE>

<FILE name='DEBUG_SCICOS' type='LATEX'>

</FILE>

<FILE name='DEMUX' type='LATEX'>
En fournissant un vecteur sur le port d'entrée régulier, ce bloc
peut séparer les éléments de l'entrée par des vecteurs sur les ports
de sortie.
L'entrée est donc définie $u=[y_1;y_2,\cdots;y_n]$, où  $y_i$ sont
numérotés dans un ordre décroissant.
Les tailles des ports d'entrée et de sortie sont déterminées par le contexte.
</FILE>

<FILE name='DERIV' type='LATEX'>
Le bloc dérivée fait l'approximation de la dérivée de son entrée en calculant:
$$\frac{\Delta u}{\Delta t}$$.
</FILE>

<FILE name='DLR_f' type='LATEX'>
Ce bloc réalise un système linéaire SISO (Single Input Single Output) 
représenté par une fonction de transfert rationnelle
dans l'espace de la transformée en z.
La fonction rationnelle doit être une fonction propre.
</FILE>

<FILE name='DLSS_f' type='LATEX'>
Ce bloc réalise un système d'équations d'état temporel discret.
Le système est défini par les matrices $(A,B,C,D)$
et par l'état initial $x_0$.
Les dimensions des matrices et de l'état initial doivent être appropriées.
Lorsque qu'un événement active le bloc (par son unique port événementiel) l'état est alors mis à jour.
</FILE>

<FILE name='DOLLAR_f' type='LATEX'>
Le bloc retard retarde ses entrées de la période spécifiée au niveau du port
d'entrée événementiel.
Ce bloc est équivalent à l'opérateur discret $z^{-1}$.
Il accepte une seule entrée et génére une seule sortie qui peuvent être
aussi bien un scalaire qu'un vecteur.
Si l'entrée est un vecteur alors tous les éléments du vecteur sont
retardés par la même période.
</FILE>

<FILE name='Diode' type='LATEX'>

Ce composant consiste en une diode simple mise en parallèle avec une résistance
ohmique $R$. Le courant qui passe dans la diode est défini en
fonction de la tension aux bornes de le diode, {\it c.-à-d.},

\[I = I_{ds} (\exp^{v/V_t} - 1) + \frac {v} {R} \]

où $I_{ds}$ et $V_t$ sont le courant de saturation et la tension
équivalente de la température, respectivement. Si la valeur de $v/V_t$
atteint une certaine limite ($Maxexp$), la courbe caractéristique de
la diode devient linéaire pour éviter un dépassement numérique.
</FILE>

<FILE name='EDGE_TRIGGER' type='LATEX'>

</FILE>

<FILE name='ESELECT_f' type='LATEX'>
Un bloc selecteur accepte sur son entrée aussi bien un vecteur qu'une matrice.
Vous pouvez définir le paramètre {\bf Input Type} au type de signal que vous
utilisez dans votre modèle (matrice ou vecteur).
Les paramètres de la boîte de dialogue et l'aspect du bloc changent en accord
avec le type de l'entrée, ainsi que la manière dont il détermine les éléments 
à sélectionner.
</FILE>

<FILE name='EVENTSCOPE_f' type='LATEX'>
This block realizes the visualization of the input event signals. 
</FILE>

<FILE name='EVTDLY_f' type='LATEX'>
Ce bloc génére à la sortie des événements retardés par rapport aux
événements qui arrivent à l'entrée.
Le retard est définit par la valeur du paramètre {\bf Delay}.
Ce bloc peut aussi généré un événement à une date initiale.
</FILE>

<FILE name='EVTGEN_f' type='LATEX'>
Un événement est généré sur le port unique de sortie événementiel
si la valeur du paramètre {\bf Event time} est plus grand ou égal à
zéro.
Si cette valeur est négative alors aucun événement ne sera généré.
</FILE>

<FILE name='EVTVARDLY' type='LATEX'>
Ce bloc génére à la sortie des événements retardés par rapport aux
événements qui arrivent à l'entrée.
Le retard est définit par la valeur qui est lu sur le port d'entrée
régulier.
Ce bloc peut aussi généré un événement à une date initiale.
</FILE>

<FILE name='EXPBLK_f' type='LATEX'>
Ce bloc calcule $y(i)=a^u(i)$. 
Les tailles des ports d'entrée et de sortie sont déterminées par
le compilateur.
</FILE>

<FILE name='EXPRESSION' type='LATEX'>
Le bloc EXPRESSION applique à son entrée les fonctions Scilab spécifiées
en paramètre.
</FILE>

<FILE name='EXTRACTOR' type='LATEX'>
Extrait ou sélectionne une entrée régulière parmi plusieurs entrées régulières.
</FILE>

<FILE name='Electrical_pal' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
La boîte à outils électrique contient les composants basiques
électriques tels que la source de tension, la diode, le condensateur,
etc.
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='Events_pal' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='Extract_Activation' type='LATEX'>

</FILE>

<FILE name='FSCOPE_f' type='LATEX'>
This  is  a floating scope block. 
</FILE>

<FILE name='GAINBLK' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  Le bloc GAINBLK calcule le produit d'une matrice carré A par une matrice d'entrée U, où le nombre de lignes/colonnes de A est égal au nombre de lignes de U. Les types de données des entrées/sorties sont définis par le type de donnée de la matrice gain A.
	  <P>Lorsqu'un dépassement intervient, le résulat peut prendre des valeurs différentes suivant le paramètre "DO ON OVERFLOW":</P>
	  <P>1- Un résulat non saturé.</P>
	  <P>2- Un résultat saturé.</P>
	  <P>3- Un message d'erreur est signalé lorsqu'un dépassement intervient.</P>
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='GENSIN_f' type='LATEX'>
Ce bloc est un générateur de sinusoïde : $M*\sin(F*t+P)$
</FILE>

<FILE name='GENSQR_f' type='LATEX'>
Ce bloc est un générateur de signal carré : la sortie prend des valeurs
entre -M et M.
Pour chaque événement reçu, la sortie saute d'une valeur -M à M 
ou de M à -M.
</FILE>

<FILE name='Ground' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Cet élément est un composant électrique simple fournissant une tension
de référence dans des circuits électriques. Le potentiel au noeud de
Terre est zéro. Chaque circuit électrique doit contenir au moins un
élément Terre.
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='HALT_f' type='LATEX'>
Ce bloc a un unique port d'entrée événementiel.
Lorsqu'un événement se présente sur ce port, alors la simulation
est arrêtée et la main est rendue à la fenêtre principale de Scicos.
La simulation peut être redémarrée ou continuée grâce au bouton Run.
</FILE>

<FILE name='HYSTHERESIS' type='LATEX'>
Permutte la valeur de la sortie entre deux constantes.
TODO
</FILE>

<FILE name='IFTHEL_f' type='LATEX'>
Ce bloc génére un événement sur l'une ses deux sorties événementielles
lorsqu'un événement en entrée active celui-ci.
Suivant le signe de la valeur lue sur le port d'entrée régulier,
l'événement est généré soit sur la branche 'then' ou bien sur la branche
'else'.
Ce bloc est un bloc synchrone, ce qui signifie que les événements en entrée
et en sortie sont générés exactement à la même date et simultanément.
</FILE>

<FILE name='INIMPL_f' type='LATEX'>
Les ports d'entrée INIMPL\_f sont des liens qui permettent de connecter
l'intérieur d'un système vers l'extérieur.
</FILE>

<FILE name='INTEGRAL' type='LATEX'>
Ce bloc est un intégrateur. La sortie est l'intégrale de l'entrée.
</FILE>

<FILE name='INTRP2BLK_f' type='LATEX'>
La sortie de ce bloc est fonction de l'entrée obtenue par interpolation
bilinéaire.
Ce bloc a deux entrées scalaires et une seule sortie scalaire.
Les grandeurs $X(i)$ et $Y(i)$ donnent respectivement les coordonnées
$X,Y$ du $i^{\rm \grave{e}me}$ point de donnée et $Z(Y(i),X(i))$
sa valeur.
</FILE>

<FILE name='INTRPLBLK_f' type='LATEX'>
La sortie de ce bloc est fonction de l'entrée obtenue par interpolation
linéaire.
Ce bloc a une seule entrée scalaire et une seule sortie scalaire.
Les grandeurs $X$ et $Y$ donnent respectivement les coordonnées
$X,Y$ des points de données qui seront interpolés.
$X$ doit être strictement croissant.
</FILE>

<FILE name='INVBLK_f' type='LATEX'>
Ce bloc calcule $y(i)=1/u(i)$.
La taille de l'entrée/sortie est déterminée par le contexte.
</FILE>

<FILE name='IN_f' type='LATEX'>
Ce bloc doit être utilisé dans un superbloc pour représenter un port
d'entrée régulier. La taille de ce port est automatiquement ajustée.
Dans un superbloc, les ports d'entrée réguliers doivent être numérotés
de 1 jusqu'au nombre de ports d'entrée réguliers composant le superbloc.
</FILE>

<FILE name='ISELECT_f' type='LATEX'>
Sélectionne des signaux suivant les événements d'entrée.
Ce bloc a un seul port régulier d'entrée.
</FILE>

<FILE name='Inductor' type='LATEX'>

Une bobine est un composant électrique qui peut stocker l'énergie
dans des circuits électriques.  Le rapport entre la tension $v$ aux
borne d'une bobine d'inductance $L$ et le courant $I$ passant à
travers le composant est donné par :

\[v = L \frac{dI}{dt}\]

 Des inductances peuvent également être utilisées pour distinguer les
 signaux haute fréquence des signaux de basse fréquence et ceci
 rend les inductances utiles dans la conception des filtres. Une
 inductance présente une forte impédance pour les signaux haute
 fréquence et est passante pour les signaux DC.
</FILE>

<FILE name='LOGBLK_f' type='LATEX'>
Ce bloc calcule $y(i)=log(u(i))/log(a)$. 
Les tailles des ports d'entrée/sortie sont déterminés par le contexte.
</FILE>

<FILE name='LOGICAL_OP' type='LATEX'>
Le bloc Opérateur Logique réalise une opération logique
sur ses entrées qui est spécifiée en paramètre.
Une valeur d'entrée est VRAI (1), si elle est différente de zéro, et
elle est FAUSSE (0) si elle est égale zéro.
</FILE>

<FILE name='LOOKUP_f' type='LATEX'>
Ce bloc réalise une fonction non-linéaire qui est défini grâce à un
éditeur graphique.
</FILE>

<FILE name='Linear_pal' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='MAXMIN' type='LATEX'>
Ce bloc peut trouver aussi bien le maximum que le minimum dans les
éléments de ses entrées.
La fonction min ou max peut être choisie dans les paramètres de la
boîte de dialogue.
</FILE>

<FILE name='MUX' type='LATEX'>
Ce bloc regroupe $n$ vecteurs d'entrée en un seul vecteur à la sortie.
La sortie est $y=[u_1;u_2;\cdots;u_n]$ , où les $u_i$ numérotées dans
un ordre croissant correspondent aux ports réguliers d'entrée du haut
vers le bas.
Les tailles d'entrée/sortie sont soit déterminées automatiquement
à la compilation ou alors déterminées par le paramètre
{\bf number of input ports or vector of sizes}.
</FILE>

<FILE name='M_SWITCH' type='LATEX'>
The Multi-Port Switch block chooses between a number of inputs. The
first (top) input is called the control input, while the rest of the
inputs are called data inputs. The value of the control input
determines which data input is passed through to the output port.
</FILE>

<FILE name='Modulo_Count' type='LATEX'>
Ce bloc est un bloc discret.
Il délivre un signal scalaire périodique qui a une forme déterminée
par les choix de l'utilisateur.
</FILE>

<FILE name='NEGTOPOS_f' type='LATEX'>
Un événement est généré lorsque l'unique entrée de ce bloc traverse
la valeur zéro lors d'un front montant.
</FILE>

<FILE name='NRMSOM_f' type='LATEX'>
The Merge block combines its inputs into a single output line whose
value at any time is equal to the most recently computed output of its
driving blocks. You can specify any number of inputs by setting the
block's Number of inputs parameter.  
</FILE>

<FILE name='Non_linear_pal' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='OUTIMPL_f' type='LATEX'>
Les ports de sortie OUTIMPL\_f sont des liens qui permettent de connecter
l'extérieur d'un système vers l'intérieur.
</FILE>

<FILE name='OUT_f' type='LATEX'>
Ce bloc doit être utilisé dans un superbloc pour représenter un port
de sortie régulier. La taille de ce port est ajustée automatiquement.
Dans un superbloc, les ports de sortie réguliers doivent être numérotés
de 1 jusqu'au nombre de ports de sortie réguliers composant le superbloc.
</FILE>

<FILE name='Others_pal' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='PDE' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='POSTONEG_f' type='LATEX'>
Un événement est généré lorsque l'unique entrée de ce bloc traverse
la valeur zéro lors d'un front descendant.
</FILE>

<FILE name='POWBLK_f' type='LATEX'>
Ce bloc réalise $y(i)=u(i)^a$.
Les tailles des ports d'entrée/sortie sont déterminées par le
compilateur.
</FILE>

<FILE name='PRODUCT' type='LATEX'>
The Product block performs multiplication or division of its
inputs. This block produces outputs using either element-wise or
matrix multiplication, depending on the value of the Multiplication
parameter. You specify the operations with the Number of inputs
parameter. Multiply(+1) and divide (-1) characters indicate the
operations to be performed on the inputs.
</FILE>

<FILE name='PROD_f' type='LATEX'>
La sortie de ce bloc est le produit élément par élément des entrées.
</FILE>

<FILE name='PerteDP' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  Un bloc de PertDP représente un tuyau hydraulique avec des pertes de
	  charge. Ce composant représente une perte de charge hydraulique où la
	  perte de pression est directement proportionnelle au débit, état
	  laminaire.  Ce bloc a une direction; c.-à-d. la direction positive est
	  quand le fluide entre par le port d'entrée (le noir). Ceci signifie
	  que ce bloc suppose que le débit est positif si le fluide découle du
	  port noir vers le port blanc.  Les paramètres importants de ce composant
	  sont la longueur, le diamètre du tuyau, les altitudes des ports
	  d'entrée et de sortie, et quelques autres coefficients
	  thermo-hydrauliques.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='PotentialSensor' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  Ce bloc est employé pour mesurer la tension d'un noeud par rapport à
	  celle de terre (zero) dans un circuit électrique. La tension est
	  donnée à la partie explicite du modèle par un port explicite.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='PuitsP' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  Ce composant représente un puit thermo-hydraulique de
	  pression constante. Ce bloc est défini avec sa pression 
          et sa température. La direction positive est quand le 
          fluide coule dans le bloc.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='QUANT_f' type='LATEX'>
Ce bloc quantifie le signal d'entrée suivant les méthodes choisies :
\begin{enumerate}   
\item méthode 'Round' :  
\begin{align*}
 y(i)&={\rm Step}*({\rm int}(u(i)/{\rm Step}+0.5)-0.5) &\texttt{si} \; u(i)<0 .\\  
 y(i)&={\rm Step}*({\rm int}(u(i)/{\rm Step}-0.5)+0.5) &\texttt{si} \; u(i)>=0 .  
 \end{align*}
\item méthode 'Truncation' :
\begin{align*}
 y(i)&={\rm Step}*({\rm int}(u(i)/{\rm Step}+0.5)) &\texttt{si} \; u(i)<0 .  \\
 y(i)&={\rm Step}*({\rm int}(u(i)/{\rm Step}-0.5)) &\texttt{si} \; u(i)>=0 .  
\end{align*}
\item méthode 'Floor' :  
\begin{align*}
 y(i)&={\rm Step}*({\rm int}(u(i)/{\rm Step}+0.5))  .  
 \end{align*}
\item  méthode 'Ceil' :  
\begin{align*}
 y(i)&={\rm Step}*({\rm int}(u(i)/{\rm Step}-0.5)) \end{align*}
\end{enumerate}

</FILE>

<FILE name='RAMP' type='LATEX'>
Le bloc RAMP génére un signal qui commence à une date et à une valeur
spécifiées et évolue suivant une pente donnée.
Les paramètres {\bf Slope , Start time} et {\bf Initial output} déterminent
les caractéristiques du signal de sortie.
Ces paramètres doivent avoir des dimensions identiques.
</FILE>

<FILE name='RAND_f' type='LATEX'>
Ce bloc est un générateur de nombres aléatoires : chaque composante de sortie
prend des valeurs constantes aléatoires par morceaux. Pour chaque événement les
sorties prennent des nouvelles valeurs indépendantes.\\
La taille du port de sortie est déterminée par la taille des vecteurs {\bf A} et {\bf B}.
</FILE>

<FILE name='RATELIMITER' type='LATEX'>
The Rate Limiter block limits the first derivative of the signal
passing through it. The output changes no faster than the specified
limit.
</FILE>

<FILE name='READAU_f' type='LATEX'>
Charge un son enregistré dans un fichier 'au'.
Les données échantillonnées seront écrites sur la sortie y du bloc.
Si l'extension du fichier n'est pas spécifiée alors l'extension '.au' est
automatiquement ajoutée.
Les valeurs d'amplitude sont comprises entre [-1,+1].
La lecture 'au' supporte les données multi-canaux sous les formats suivants :
\begin{itemize}
   \item 8-bit mu-law 
   \item 8-, 16-, and 32-bit linear
   \item Floating-point
\end{itemize}
</FILE>

<FILE name='READC_f' type='LATEX'>
Ce bloc permet de lire des données dans un fichier C.
Les paramètres {\bf Output record selection] et {\bf Time record Selection}
permettent de sélectionner des données dans les enregistrements du fichier.
Chaque appel au bloc, fait avancer d'un enregistrement dans le fichier.
</FILE>

<FILE name='REGISTER_f' type='LATEX'>
Ce bloc réalise un registre à décalage.
Pour chaque événement d'entrée, le registre est décalé d'un élément.
</FILE>

<FILE name='RELATIONALOP' type='XML'>
Ce bloc fait une comparaison logique de ses entrées.
</FILE>

<FILE name='RELAY_f' type='LATEX'>
This block routes one of the regular inputs to the unique regular
output. the choice of which input is to be routed is done, initially
by the "initial connected input" parameter. Then, every time an input
event arrives on the i-th input event port, the i-th regular input
port is routed to the regular output.
</FILE>

<FILE name='RFILE_f' type='LATEX'>
Ce bloc permet à l'utilisateur de lire des données dans un fichier.
Ces données peuvent être formatées ou binaires.
Les paramètres {\bf  Output record selection} et {\bf Time record selection}
permettent de selectionner des données parmi les enregistrements du fichier.
Chaque appel au bloc avance d'un enregistrement.\\
Ce bloc fonctionne de paire avec le bloc \htmladdnormallink{WFILE\_f}{WFILE_f.htm}
</FILE>

<FILE name='Resistor' type='LATEX'>
Une résistance est un composant électrique à deux ports qui résiste à
un courant électrique en produisant une chute de tension ($V$) : la loi
d'Ohm.

 \[ R = \frac {V}{I}\] 

  La résistance électrique ($R$) est égale à la chute de tension entre
les ports de la résistance divisée par le courant qui passe au travers
($I$).

</FILE>

<FILE name='SAMPLEHOLD_f' type='LATEX'>
A chaque fois qu'un événement est reçu, ce bloc copie la valeur de son
entrée sur sa sortie et maintient cette valeur jusqu'au prochain
événement.
Pour réaliser un échantillonneur bloqueur périodique, l'entrée
événementielle doit être connectée à une horloge {\bf Clock}.
</FILE>

<FILE name='SATURATION' type='LATEX'>
Le bloc saturation impose des limites maximale et minimale sur un signal.
Lorsque le signal est compris dans l'échelle définie par les paramètres
{\bf Upper limit} et {\bf Lower limit}, celui ci est reporté à la sortie
sans modifications.
Lorsque le signal sort de ces limites, alors le signal sature à la sortie
du bloc.
</FILE>

<FILE name='SAWTOOTH_f' type='LATEX'>
Ce bloc est un générateur de dents de scie : 
la sortie de ce bloc est calculée par $(t-t_i)$ de $t_i$ jusqu'à $t_{i+1}$
où $t_i$ et $t_{i+1}$ sont les instants de deux événements d'entrée successifs.
</FILE>

<FILE name='SCALAR2VECTOR' type='LATEX'>
Ce bloc convertit une valeur scalaire en un vecteur.
Lorsque des blocs avec plus d'un port régulier son utilisés (comme Somme
ou le bloc Relational Operator), vous pouvez mixer des entrées scalaires
et vectorielles.
Lorsque vous faites cela, les entrées scalaires sont étendues à des vecteurs
dont les tailles sont égales aux tailles des vecteurs d'entrée.
Si plus d'un port d'entrée est vectoriel, alors ils doivent avoir la même taille.
</FILE>

<FILE name='SCOPXY_f' type='LATEX'>
This block realizes the visualization of the evolution of the two
regular input signals by drawing the second input as a function of the
first at instants of events on the event input port.
</FILE>

<FILE name='SELECT_f' type='LATEX'>
Ce bloc redirige l'une de ses entrées régulières sur l'unique
sortie régulière.
Le choix qui est fait pour savoir quel est le port d'entrée redirigé
est initalement fait par le paramètre {\bf initial connected input}.
Pendant la simulation, à chaque fois que ce bloc est activé par son
entrée événementielle $i$, alors la valeur présente sur le
 $i^{\rm \grave{e}me}$ port régulier est recopiée sur la sortie. 
</FILE>

<FILE name='SIGNUM' type='XML'>
Le bloc Signe indique le signe de l'entrée :
\begin{itemize}
\item Lorsque que l'entrée est positive alors la sortie est égale à 1.
\item Lorsque que l'entrée est égale à 0 alors la sortie est égale à 0.
\item Lorsque que l'entrée est négative alors la sortie est égale à -1.   
\end{itemize}
</FILE>

<FILE name='STEP_FUNCTION' type='LATEX'>
Le bloc 'Step' réalise un saut entre deux niveaux définis à un temps
spécifié.
Si le temps de simulation est inférieur au paramètre {\bf Step time}, la 
sortie est égale à la valeur du paramètre {\bf Initial value}.
Pour les temps de simulation supérieurs, la sortie est égale à la valeur
du paramètre {\bf Final value}.
</FILE>

<FILE name='SUMMATION' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P> Ce bloc fait l'addition ou la soustraction de ses entrées. Ce bloc
	peut additioner et soustraire des grandeurs scalaires, vectorielles et
	matricielles. Il peut aussi faire la somme cumulative d'une seule entrée
	vectorielle.</P>
	<P> Le nombre d'entrée est donné par le second paramètre de la boite de dialogue. Ce paramètre peut être un vecteur de nombre +1 et -1 ou bien
	il peut être une seule valeur positive. Dans le premier cas le vecteur donne le nombre d'entrée et le signe indique si c'est une addition ou une soustraction. Pour le second choix, ce bloc est un additionneur dont le nombre d'entrée est déterminée par la valeur de ce paramètre.</P>
	<P>Lorsqu'un dépassement intervient, le résulat peut prendre des valeurs différentes suivant le troisième paramètre "DO ON OVERFLOW":</P>
	<P>1- Un résulat non saturé.</P>
	<P>2- Un résultat saturé.</P>
	<P>3- Un message d'erreur est signalé lorsqu'un dépassement intervient.</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='SUM_f' type='LATEX'>
Le bloc somme réalise l'addition de ses entrées.
Ce bloc peut additionner des scalaires ou des vecteurs d'entrée.
</FILE>

<FILE name='SUPER_f' type='LATEX'>
This block opens up a new Scicos window for editing a new block
diagram. This diagram describes the internal functions of the super
block.  

Super block inputs and outputs (regular or event) are
designated by special (input or output) blocks.  

Regular input blocks
must be numbered from 1 to the number of regular input ports. Regular
input ports of the super block are numbered from the top of the block
shape to the bottom.  Regular output portss must be numbered from 1 to
the number of regular output ports. Regular output ports of the super
block are numbered from the top of the block shape to the bottom.
Event input blocks must be numbered from 1 to the number of event
input ports. Event input ports of the super block are numbered from
the left of the block shape to the right.  Event output ports must be
numbered from 1 to the number of event output ports. Event output
ports of the super block are numbered from the left of the block shape
to the right.
</FILE>

<FILE name='SWITCH2' type='LATEX'>
The Switch block passes through the first (top) input or the third
(bottom) input based on the value of the second (middle) input. The
first and third inputs are called data inputs. The second input is
called the control input. You select the conditions under which the
first input is passed with the Criteria for passing first input
parameter. You can make the block check whether the control input is
greater than or equal to the threshold value, purely greater than the
threshold value, or nonzero. If the control input meets the condition
set in the Criteria for passing first input parameter, then the first
input is passed. Otherwise, the third input is passed. 
</FILE>

<FILE name='SWITCH_f' type='LATEX'>
Ce bloc est un 'interrupteur' manuel.
Il sélectionne une de ses entrées pour la rédigirer vers sa sortie.
Les entrées non sélectionnées ne sont donc pas propagées.
</FILE>

<FILE name='Sinks_pal' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='SourceP' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ce composant représente une source thermohydraulique de pression
constante. Ce bloc est défini avec sa pression et sa température.  La
direction positive conventionnelle est quand le fluide sort du bloc.
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='Sources_pal' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='TCLSS_f' type='LATEX'>
Ce bloc réalise un système d'équations d'etat en temporel continu avec
la possibilités de réaliser des sauts dans l'état.
Le nombre d'entrées de ce bloc est deux.
La première entrée est l'entrée régulière du système linéaire.
La seconde fournie la valeur du nouvel état qui est copié dans l'état du système lorsque le bloc est activé par un événement sur son unique port d'entrée événementiel.
Cela signifique que l'état du système saute à la valeur présente sur le deuxième port d'entrée (de taille égale à l'état du système).
Le système est défini par les matrices $(A,B,C,D)$
et par l'état initial $x_0$.
Les dimensions des matrices et de l'état initial doivent être appropriées.
Les tailles des entrées et des sorties sont ajustées automatiquement.
</FILE>

<FILE name='TEXT_f' type='LATEX'>
Ce bloc spécial est utilisée pour ajouter du texte dans un diagramme scicos.
Il n'affecte pas la simulation.
</FILE>

<FILE name='TIME_DELAY' type='LATEX'>
Ce bloc retarde l'entrée par un laps de temps spécifié.
Il peut être utilisé pour la simulation d'un retad temporel.
Au début de la simulation, le bloc délivre la valeur du paramètre
{\bf Initial input} jusqu'à ce que le temps de la simulation dépasse
le paramètre {\bf Time delay}, auquel cas, le bloc commence à réaliser
le retard.\\
La valeur du paramètre {\bf Time delay} doit être non-négative.
</FILE>

<FILE name='TIME_f' type='LATEX'>
Ce bloc est un générateur de temps.\\
La seule sortie régulière de ce bloc donne le temps courant de la
simulation.
</FILE>

<FILE name='ThermoHydraulics_pal' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
La boîte à outils de thermohydraulique contient certains composants
thermohydrauliques tels que la source de pression, le tuyau, les vannes
réglantes, etc.

</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='Threshold_pal' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='TrigFun' type='LATEX'>
The Trigonometric Function block performs numerous common
trigonometric functions. You can select one of these functions from
the Function list: sin, cos, tan, asin, acos, atan, atan2, sinh, cosh,
and tanh. The block output is the result of the operation of the
function on the input or inputs. 
</FILE>

<FILE name='VARIABLE_DELAY' type='LATEX'>
The Variable Transport Delay block can be used to simulate a variable
time delay. The block might be used to model a system with a pipe
where the speed of a motor pumping fluid in the pipe is variable. The
block accepts two inputs: the first input is the signal that passes
through the block; the second input is the time delay. 
</FILE>

<FILE name='VVsourceAC' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ce bloc est un modèle pour une source de tension CA contrôlable. Ce
composant fournit une tension sinusoidale entre ses
ports. L'amplitude de la tension de sortie est définie par une entrée
explicite et la fréquence est définie par l'utilisateur. La résistance
ohmique de ce bloc est zéro.

</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='VanneReglante' type='LATEX'>

Le bloc de VanneReglante représente une Vanne Reglante ou une vanne à
orifice variable. Le débit du fluide passe par la vanne et est
proportionnel à l'ouverture de vanne, {\it c.-à-d.},

\[
  \Delta P \times h\times\left| h \right| = k\times Q\times \left|Q\right|
\]

là où $h$ est l'ouverture de vanne, $\delta P$ est la différence de
pression, et $Q$ est le débit. Ce modèle est seulement employé pour
les régimes laminaires d'écoulement. $k$ est une constante qui dépend
de la géométrie de la vanne et de la masse volumique de fluide.
</FILE>

<FILE name='VariableResistor' type='LATEX'>
Ce composant représente une résistance ohmique variable. La résistance
est commandée par le port d'entrée explicite.  \[ R_x = \frac {V}{I}
\]

</FILE>

<FILE name='VoltageSensor' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ce composant est employé pour mesurer la différence de tension entre
deux noeuds dans un circuit électrique. Le signal de sortie est la
différence entre la tension du port noir et celle du port blanc.
La conductance ohmique de ce bloc est zéro.
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='VsourceAC' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ce composant est une source de tension CA avec une tension de sortie
sinusoidale. L'amplitude et la fréquence de la tension de sortie
sont définies par l'utilisateur. La résistance ohmique de ce bloc est
zéro.
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='WFILE_f' type='LATEX'>
Ce bloc permet à l'utilisateur de sauvegarder des données dans un fichier.
Ces données peuvent être formatées ou binaires.
Chaque appel au bloc correspond à un enregistrement.
Chaque enregistrement à la forme suivante :  $[t,V1,...,Vn]$ où $t$ est la valeur du temps lorsque le bloc est appelé et $V_i$ est la $i^{\rm\grave{e}me}$ valeur d'entrée.\\
Ce bloc fonctionne de paire avec le bloc \htmladdnormallink{RFILE\_f}{RFILE_f.htm}.
</FILE>

<FILE name='WRITEAU_f' type='LATEX'>
Ce bloc écrit un fichier son de type 'au'.
Les données doivent être rangées avec un canal par colonne.
Les valeurs en dehors de l'échelle [-1 +1] seront coupées à l'écriture.
L'écriture 'au' supporte les données multi-canaux pour les formats
'8-bit mu-law' et '8-,16-bit linear'.
</FILE>

<FILE name='WRITEC_f' type='LATEX'>
Ce bloc permet d'écrire des données dans un fichier C au format binaire.
</FILE>

<FILE name='ZCROSS_f' type='LATEX'>
Un événement est généré lorsque toutes les entrées traverse la valeur
zéro simultanément.
</FILE>

<FILE name='buildouttb' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  Construit une liste "outtb" initialisée.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='c_block' type='LATEX'>
Ce bloc crée une fonction de calcul squelette en C.
Il crée aussi une librairie et un fichier objet à la compilation.
</FILE>

<FILE name='curblock' type='XML'>

</FILE>

<FILE name='fortran_block' type='LATEX'>
Ce bloc crée une fonction de calcul squelette en fortran.
Il crée aussi une librairie et un fichier objet à la compilation.
</FILE>

<FILE name='freq_div' type='LATEX'>
Ce bloc est un super bloc.
L'entrée événementielle est redirigée une fois parmi n à la sortie.
</FILE>

<FILE name='generic_block2' type='LATEX'>
The block provides a generic interfacing function but the
computational function needs to be defined separately, either as a
Scilab function or  a Fortran or a C function. Besides the name of the
function, user should specify information such as the type, whether or
not the block contains a direct feed-through term. The function
realising computational functions of generic blocks of a scicos
diagram must be saved along with the diagram and loaded or dynamically
linked before simulation. 
</FILE>

<FILE name='generic_block3' type='LATEX'>
The block provides a generic interfacing function but the
computational function needs to be defined separately, either as a
Scilab function or  a Fortran or a C function. Besides the name of the
function, user should specify information such as the type, whether or
not the block contains a direct feed-through term. The function
realising computational functions of generic blocks of a scicos
diagram must be saved along with the diagram and loaded or dynamically
linked before simulation. 
</FILE>

<FILE name='getscicosvars' type='XML'>
  <DESCRIPTION>
    <P>
    Cette fonction utilitaire est utilisée pour retrouver les tableaux de travail du compilateur et du simulateur scicos pendant la simulation.
    </P>
    <P>
      Elle peut-être utilisée dans un bloc scilab pour retourner des informations de tous types de blocs. Cette fonction est très utile pour débugger les diagrammes et pour prototyper des simulations.
    </P>
  </DESCRIPTION>
</FILE>

<FILE name='lincos' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  Construct a linear state-space system by linearizing a model
	  given as a Scicos diagram.
	</P>
      </DESCRIPTION_ITEM>
      <DESCRIPTION_ITEM>
	<P>
	  The output is a Scilab data structure of type continuous-time state-space linear system.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='scicos' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  Scicos is a visual editor for constructing models of hybrid
	  dynamical systems. Invoking Scicos with no argument opens up an
	  empty Scicos window. Models can then be assembled, loaded,
	  saved, compiled, simulated, using GUI of Scicos.  Scicos
	  serves as an interface to the various block diagram compilers
	  and the hybrid simulator scicosim.
	</P>
      </DESCRIPTION_ITEM>
      <DESCRIPTION_ITEM>
	<P>
	  The input and output arguments are useful for debugging purposes.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='scicos_debug' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  Cette fonction sert à paramétrer le niveau de débogage de la simulation scicos.
	</P>
	<P>
	  Elle peut être utilisée soit en mode "Calc" dans l'éditeur Scicos ou en tant qu' instruction dans un bloc scilab ou bien dans une fonction d'interfaçage.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='scicos_simulate' type='XML'>
  <DESCRIPTION>
    <P>
      This function is used to simulate scicos diagrams in batch
      mode. It requires the scs_m structure which can be obtained by
      loading in Scilab the .cos file (e.g. load
      mydiagram.cos).
    </P>
    <P>
      Contrary to the function <LINK> scicosim</LINK>, the diagram
      need not be compiled before being saved.
    </P>
  </DESCRIPTION>
</FILE>

<FILE name='scicos_time' type='XML'>
<DESCRIPTION>

</DESCRIPTION>
</FILE>

<FILE name='scicosim' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  Simulator for Scicos compiled diagram.
	</P>
	<P>
	  Usually scicosim is called by scicos to perform simulation of
	  a diagram.
	</P>
	<P>
	  But scicosim may also be called outside Scicos. Typical usage
	  in such a case may be :
	</P>
      </DESCRIPTION_ITEM>
      <DESCRIPTION_ITEM>
	<DESCRIPTION_ITEM>
	  <P>
	    1- Use Scicos to define a block diagram, compile it.
	  </P>
	  <P>
	    2- Save the compiled diagram using Save,SaveAs Scicos menus.
	  </P>
	  <P>
	    3- In Scilab, load saved file using load function. You get
	    variables scicos_ver, scs_m, %cpr scs_m is the diagram Scicos main data structure.
	  </P>
	  <P>
	    %cpr is the data structure containing (state,sim,cor,corinv)
	    if the diagram had been compiled before saved, else %cpr=list().
	  </P>
	  <P>
	    4- Extract state, sim out of cpr.
	  </P>
	  <P>
	    5- Execute [state,t]=scicosim(state,0,tf,sim,'start',tol) for initialisation.
	  </P>
	  <P>
	    6- Execute [state,t]=scicosim(state,0,tf,sim,'run',tol) for
	    simulation from 0 to tf.
	  </P>
	  <P>
	    Many successives such calls may be
	    performed changing initial and final time.
	  </P>
	  <P>
	    7- Execute [state,t]=scicosim(state,0,tf,sim,'finish',tol) at
	    the very end of the simulation to close files,...
	  </P>
	</DESCRIPTION_ITEM>
      </DESCRIPTION_ITEM>
      <DESCRIPTION_ITEM>
	<P>
	  For advanced user it is possible to "manually"
	  change some parameters or state values.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='scifunc_block' type='LATEX'>
This block can realize any type of Scicos block. The function of the
block is defined interactively using dialogue boxes and in Scilab
language. During simulation, these instructions are interpreted by
Scilab; the simulation of diagrams that include these types of blocks
is slower. For more information see Scicos reference manual. 
</FILE>

<FILE name='steadycos' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  This function finds the steady state for a given system described
	  by a Scicos diagram. The diagram consists in general of a Super
	  block with input and output port blocks. The steady states
	  concerns only the continuous-time dynamics.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='var2vec' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  Les fonctions var2vec / vec2var sont utilisées dans les fonctions d'interfaçages des blocs scilab pour donner la possibilité à l'utilisateur de manipuler des objets scilab avec le registre des paramètres réels (rpar) et avec le registre des états discrets (z).
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='vec2var' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  Les fonctions var2vec / vec2var sont utilisées dans les fonctions d'interfaçages des blocs scilab pour donner la possibilité à l'utilisateur de manipuler des objets scilab avec le registre des paramètres réels (rpar) et avec le registre des états discrets (z).
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='CUMSUM' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  The CUMSUM block sums the element of an input m*n matrix u along either the rows, the columns or the first non singleton dimension. When the "Sum along" parameter is set to "1", the block sums across the elements of each row. The result will be displayed as a m*1 matrix.
	</P>
	<P>
	  When the "Sum along" parameter is set to "2", the block sums across the elements of each column. The result will be display as a 1*n matrix.
	</P>
	<P>
	  When the "Sum along" parameter is set to "0", the block sums across the first non singleton dimension. The result will be displayed as one element.
	  This block is equivalent to cumsum in scilab.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='EXTTRI' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='MATBKSL' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='MATCATH' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='MATCATV' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='MATDET' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='MATDIAG' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='MATDIV' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='MATEIG' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='MATEXPM' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='MATINV' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='MATLU' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='MATMAGPHI' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='MATMUL' type='XML'>
<DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  Le bloc MATMUL fait la multiplication matricielle de ses deux entrées. Le nombre de lignes de la seconde matrice doit être égal au nombre de colonnes de la première. La sortie est une matrice où le nombre de lignes est égal à celui de la première matrice d'entrée et où le nombre de colonnes est égal à celui de la deuxième matrice d'entrée.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='MATPINV' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='MATRESH' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='MATSING' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='Matrix_pal' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='ABSBLK_f' type='LATEX'>
Le bloc Abs calcule à la sortie, la valeur absolue de l'entrée.
</FILE>

<FILE name='AFFICH_m' type='LATEX'>
Peandant la simulation, ce bloc affiche sur le diagramme 
la valeur lue sur son unique port d'entrée événementiel.\\
{\bf Attention :} a  fois que le bloc est déplacé, l'utilisateur
doit cliquer sur celui-ci pour éditer ses paramètres. La position
d'affichage est alors automatiquement ajustée.
</FILE>

<FILE name='BIGSOM_f' type='LATEX'>
Le bloc somme réalise l'addition de ses entrées.
Ce bloc peut additionner des scalaires ou des vecteurs d'entrée.
</FILE>

<FILE name='CANIMXY' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  This block realizes the visualization of the evolution of the two regular input signals by drawing the second input as a function of the first at instants of events on the event input port.  When a point is drawn on screen it stays until the buffer length is reached. This scope is useful to make simple animations.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='CANIMXY3D' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  This block realizes the visualization of the evolution of the two regular input signals by drawing the third input as a function of the two others at instants of events on the event input port. When a point is drawn on screen it stays until the buffer length is reached. This scope is useful to make simple animations.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='CEVENTSCOPE' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  This block realizes the visualization of the input event signals.  
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='CFSCOPE' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  This is a floating scope block. 
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='CLKIN_f' type='LATEX'>
Ce bloc doit seulement être utilisé à l'intérieur des superblocs.
Il est utilisé pour représenter un port d'entrée événementiel.
Dans un superbloc, les ports doivent être numérotés à partir de 1
jusqu'au nombre de ports.  
</FILE>

<FILE name='CLKOUT_f' type='LATEX'>
Ce bloc doit seulement être utilisé à l'intérieur des superblocs.
Il est utilisé pour représenter un port de sortie événementiel.
Dans un superbloc, les ports doivent être numérotés à partir de 1
jusqu'au nombre de ports.
</FILE>

<FILE name='CLKSOM_f' type='LATEX'>
Ce bloc est un bloc d'addition d'événement à trois entrées.
La sortie reproduit les événements de tous les ports d'entrées.
A proprement parler, CLKSOM\_f n'est pas un vrai bloc scicos, car
il est ignoré pendant la phase de compilation.\\
Les sorties et les entrées de ce bloc sont synchronisées.
</FILE>

<FILE name='CLKSPLIT_f' type='XML'>
<DESCRIPTION>

</DESCRIPTION>
</FILE>

<FILE name='CLR' type='LATEX'>
Ce bloc réalise un système linéaire SISO (Single Input Single Output) 
représenté par une fonction de transfert rationnelle.
La fonction rationnelle doit être une fonction propre.
</FILE>

<FILE name='CLSS' type='LATEX'>
Ce bloc réalise un système linéaire d'équations d'état en temporel continu.
\begin{align}
\dot x&=Ax+Bu\\
  y   &=C*x+D*u
\end{align}
Le système est défini par les matrices $(A,B,C,D)$
et par l'état initial $x_0$.
Les dimensions des matrices et de l'état initial doivent être appropriées.
</FILE>

<FILE name='CMATVIEW' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  CMATVIEW is a scope that shows matrix values on a colormapped grid.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='CONST' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
          Ce bloc est un générateur de valeurs constantes.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='CONST_m' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
          Ce bloc est un générateur de valeurs constantes.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='COSBLK_f' type='LATEX'>
$$y=\cos(u)$$
</FILE>

<FILE name='CSCOPXY' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  This block realizes the visualization of the evolution of the two regular inputs signals by drawing the second input as a function of the first at instants of events on the event input port. When a point is drawn on screen it stays until the simulation is finished.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='CSCOPXY3D' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  This block realizes the visualization of the evolution of the three regular inputs signals by drawing the third input as a function of the two others at instants of events on the event input port. When a point is drawn on screen it stays until the simulation is finished.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='DELAYV_f' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='DELAY_f' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
          Ce super-bloc compilé réalise un retard discret.
          Il est construit avec un registre à décalage et une horloge.
          La valeur du retard est donnée par la pas temporel discret multiplié
          par le nombre-1 d'état du registre.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='DEMUX_f' type='LATEX'>
Given a vector valued input this block splits inputs over vector
valued outputs. So $ u=[y_1;y_2,\cdots;y_n]$ , where  $y_i$  are
numbered from top to bottom. Input and Output port sizes are
determined by the context.
</FILE>

<FILE name='DIFF_f' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='DLR' type='LATEX'>
Ce bloc réalise un système linéaire SISO (Single Input Single Output) 
représenté par une fonction de transfert rationnelle
dans l'espace de la transformée en z.
La fonction rationnelle doit être une fonction propre.
</FILE>

<FILE name='DLRADAPT_f' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='DLSS' type='LATEX'>
Ce bloc réalise un système d'équations d'état temporel discret.
Le système est défini par les matrices $(A,B,C,D)$
et par l'état initial $x_0$.
Les dimensions des matrices et de l'état initial doivent être appropriées.
Lorsque qu'un événement active le bloc (par son unique port événementiel) l'état est alors mis à jour.
</FILE>

<FILE name='FSV_f' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='GAINBLK_f' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  Le bloc GAINBLK calcule le produit d'une matrice carré A par une matrice d'entrée U, où le nombre de lignes/colonnes de A est égal au nombre de lignes de U.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='GAIN_f' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  Ce bloc calcule le produit d'une matrice carré A par une matrice d'entrée U, où le nombre de lignes/colonnes de A est égal au nombre de lignes de U.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='GENERAL_f' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='INTEGRAL_f' type='LATEX'>
Ce bloc est un intégrateur. La sortie est l'intégrale de l'entrée.
</FILE>

<FILE name='INTEGRAL_m' type='LATEX'>
Ce bloc est un intégrateur. La sortie est l'intégrale de l'entrée.
</FILE>

<FILE name='INVBLK' type='LATEX'>
Ce bloc calcule $y(i)=1/u(i)$.
La taille de l'entrée/sortie est déterminée par le contexte.
</FILE>

<FILE name='ISELECT_m' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='MATSUM' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  The MATSUM block returns the sum of the element of an input matrix/vector.
	  When the Sum along is set to all the block outputs the sum of all the elements of the matrix. The output is then a scalar.
	  When the Sum along is set to lines the block is a rowwise sum. The output is a row vector.
	  When the Sum along is set to Columns the block is a columnwise sum. The output is a column vector.
	  The equivalent function of this block in scilab is: "sum".
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='MATTRAN' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  Ce bloc fait la transposition d'une matrice de taille MxN en matrice de taille NxM. Pour les données de type complexe, celui-ci utilise une transposition Hermitienne. L'instruction scilab équivalente de ce bloc est y=u'.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='MATZCONJ' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='MATZREIM' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='MAX_f' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  Ce bloc trouve la valeur maximale dans les éléments
          de son vecteur d'entrée.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='MCLOCK_f' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='MEMORY_f' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='MFCLCK_f' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='MIN_f' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  Ce bloc trouve la valeur minimale dans les éléments
          de son vecteur d'entrée.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='MOTOR' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='MUX_f' type='LATEX'>
Ce bloc regroupe $n$ vecteurs d'entrée en un seul vecteur à la sortie.
La sortie est $y=[u_1;u_2;\cdots;u_n]$ , où les $u_i$ numérotées dans
un ordre croissant correspondent aux ports réguliers d'entrée du haut
vers le bas.
Les tailles d'entrée/sortie sont soit déterminées automatiquement
à la compilation ou alors déterminées par le paramètre
{\bf number of input ports or vector of sizes}.
</FILE>

<FILE name='NPN' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='OldBlocks_pal' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='PNP' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='REGISTER' type='LATEX'>
Ce bloc réalise un registre à décalage.
Pour chaque événement d'entrée, le registre est décalé d'un élément.
</FILE>

<FILE name='RFILE' type='LATEX'>
Ce bloc permet à l'utilisateur de lire des données dans un fichier.
Ces données peuvent être formatées ou binaires.
Les paramètres {\bf  Output record selection} et {\bf Time record selection}
permettent de selectionner des données parmi les enregistrements du fichier.
Chaque appel au bloc avance d'un enregistrement.\\
Ce bloc fonctionne de paire avec le bloc \htmladdnormallink{WFILE}{WFILE.htm}.
</FILE>

<FILE name='SAMPHOLD' type='LATEX'>
A chaque fois qu'un événement est reçu, ce bloc copie la valeur de son
entrée sur sa sortie et maintient cette valeur jusqu'au prochain
événement.
Pour réaliser un échantillonneur bloqueur périodique, l'entrée
événementielle doit être connectée à une horloge {\bf Clock}.
</FILE>

<FILE name='SAT_f' type='LATEX'>
Le bloc saturation impose des limites maximale et minimale sur un signal.
Lorsque le signal est compris dans l'échelle définie par les paramètres
{\bf Upper limit} et {\bf Lower limit}, celui ci est reporté à la sortie
sans modifications.
Lorsque le signal sort de ces limites, alors le signal sature à la sortie
du bloc.
</FILE>

<FILE name='SELECT_m' type='LATEX'>
Ce bloc redirige l'une de ses entrées régulières sur l'unique
sortie régulière.
Le choix qui est fait pour savoir quel est le port d'entrée redirigé
est initalement fait par le paramètre {\bf initial connected input}.
Pendant la simulation, à chaque fois que ce bloc est activé par son
entrée événementielle $i$, alors la valeur présente sur le
 $i^{\rm \grave{e}me}$ port régulier est recopiée sur la sortie.
</FILE>

<FILE name='SINBLK_f' type='LATEX'>
$$y={\rm sin}(u)$$
</FILE>

<FILE name='SLIDER_f' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='STEP' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='SUBMAT' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='SWITCH2_m' type='LATEX'>
The Switch block passes through the first (top) input or the third
(bottom) input based on the value of the second (middle) input. The
first and third inputs are called data inputs. The second input is
called the control input. You select the conditions under which the
first input is passed with the Criteria for passing first input
parameter. You can make the block check whether the control input is
greater than or equal to the threshold value, purely greater than the
threshold value, or nonzero. If the control input meets the condition
set in the Criteria for passing first input parameter, then the first
input is passed. Otherwise, the third input is passed. 
</FILE>

<FILE name='SineVoltage' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='TANBLK_f' type='LATEX'>
$$y={\rm tan}(u)$$
</FILE>

<FILE name='TCLSS' type='LATEX'>
Ce bloc réalise un système d'équations d'etat en temporel continu avec
la possibilités de réaliser des sauts dans l'état.
Le nombre d'entrées de ce bloc est deux.
La première entrée est l'entrée régulière du système linéaire.
La seconde fournie la valeur du nouvel état qui est copié dans l'état du système lorsque le bloc est activé par un événement sur son unique port d'entrée événementiel.
Cela signifique que l'état du système saute à la valeur présente sur le deuxième port d'entrée (de taille égale à l'état du système).
Le système est défini par les matrices $(A,B,C,D)$
et par l'état initial $x_0$.
Les dimensions des matrices et de l'état initial doivent être appropriées.
Les tailles des entrées et des sorties sont ajustées automatiquement.
</FILE>

<FILE name='TRASH_f' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='WFILE' type='LATEX'>
Ce bloc permet à l'utilisateur de sauvegarder des données dans un fichier.
Ces données peuvent être formatées ou binaires.
Chaque appel au bloc correspond à un enregistrement.
Chaque enregistrement à la forme suivante :  $[t,V1,...,Vn]$ où $t$ est la valeur du temps lorsque le bloc est appelé et $V_i$ est la $i^{\rm\grave{e}me}$ valeur d'entrée.
Ce bloc fonctionne de paire avec le bloc \htmladdnormallink{RFILE}{RFILE.htm}.
</FILE>

<FILE name='DOLLAR' type='LATEX'>
Le bloc retard retarde ses entrées de la période spécifiée au niveau du port
d'entrée événementiel.
Ce bloc est équivalent à l'opérateur discret $z^{-1}$.
Il accepte une seule entrée et génére une seule sortie qui peuvent être
aussi bien un scalaire qu'un vecteur.
Si l'entrée est un vecteur alors tous les éléments du vecteur sont
retardés par la même période.
</FILE>

<FILE name='DOLLAR_m' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
        Le bloc retard retarde ses entrées de la période spécifiée au niveau du port d'entrée événementiel. Ce bloc est équivalent à l'opérateur discret z-1.
	Il accepte une seule entrée et génére une seule sortie qui peuventt être aussi bien un scalaire qu'un vecteur.
	Si l'entrée est un vecteur alors tous les éléments du vecteur sont retardés par la même période.
	</P>
	<P>
        Ce bloc supporte tous les types de données de scicos.
        Les types de données en entrée/sortie sont hérités du paramètre "initial condition".
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='BITCLEAR' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='BITSET' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='CONVERT' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='EXTRACTBITS' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='INTGAINBLK' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='INTLOGICAL_OP' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='INTMUL' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='INTREGISTER' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='Integer_pal' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='RAND_m' type='LATEX'>
Ce bloc est un générateur de nombres aléatoires : chaque composante de sortie
prend des valeurs constantes aléatoires par morceaux. Pour chaque événement les
sorties prennent des nouvelles valeurs indépendantes.\\
La taille du port de sortie est déterminée par la taille des matrices {\bf A} et {\bf B}.
</FILE>

<FILE name='RELATIONAL_OP' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='RELAY_m' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='SAMPHOLD_m' type='LATEX'>
A chaque fois qu'un événement est reçu, ce bloc copie la valeur de son
entrée sur sa sortie et maintient cette valeur jusqu'au prochain
événement.
Pour réaliser un échantillonneur bloqueur périodique, l'entrée
événementielle doit être connectée à une horloge {\bf Clock}.
</FILE>

<FILE name='SHIFT' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='SQRT' type='LATEX'>
This block computes the square root of each element of the input matrix. It supported real and complex data types.
</FILE>

<FILE name='SUMMATIONI' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='DFLIPFLOP' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='DLATCH' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='DLATCH1' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='EXPBLK_m' type='LATEX'>
Ce bloc calcule $y(i)=a^u(i)$. \\
Les tailles des ports d'entrée et de sortie sont déterminées par
le compilateur.
</FILE>

<FILE name='INVBLK_m' type='LATEX'>
Ce bloc calcule $y(i)=1/u(i)$.
La taille de l'entrée/sortie est déterminée par le contexte.
</FILE>

<FILE name='JKFLIPFLOP' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='JKFLIPFLOP1' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='LOGIC' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='SRFLIPFLOP' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='SRFLIPFLOP1' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='BITCLEAR1' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='BOUNCE' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='BOUNCEXY' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='CLOCK_c' type='LATEX'>
Ce bloc est un super-bloc construit grâce au bloc \htmladdnormallink{EVTDLY\_c}{EVTDLY_c.htm} qui est rebouclé sur lui-même.\\
L'unique sortie de ce bloc génère des événements à des dates précises, qui sont déterminées par le paramètre {\bf Period} de la boîte de dialogue.
</FILE>

<FILE name='DLOGICAL_OP' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='DelayRE' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='Div' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='EDGETRIGGER' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='EVTDLY_c' type='LATEX'>
Chaque événement de sortie est réalisé après l'événement 
d'entrée par un laps de temps {\bf Delay}.\\
La date de l'événement de sortie est donc déterminée par la formule :
\begin{eqnarray}
 t_{i}&=&t_{\rm{init}} + i * T_{\rm{delay}},
\end{eqnarray}
</FILE>

<FILE name='FROM' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='GOTO' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='GotoTagVisibility' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='IMPSPLIT_f' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='Neg' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='PID' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='ROOTCOEF' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='SETW' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='SPLIT_f' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='func_block' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='scifunc_block_m' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='CLKFROM' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='CLKGOTO' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='CLKGotoTagVisibility' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='FROMMO' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='GOTOMO' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='GotoTagVisibilityMO' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='CURVE_c' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='Counter' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
          Ce bloc, suivant la loi choisie, compte à partir d'un minimum vers un maximum ou d'un maximum vers un maximum.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='M_freq' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='SampleCLK' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='Sigbuilder' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='getblocklabel' type='XML'>
  <DESCRIPTION>

  </DESCRIPTION>
</FILE>

<FILE name='phase_simulation' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  Cette fonction permet de savoir si le simulateur scicos est dans sa phase d'intégration temporelle.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='pointer_xproperty' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
    <DESCRIPTION_ITEM>
    <P>
    Ajoutez ici un paragraphe pour la description de la fonction
    </P>
    </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='set_xproperty' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
    <DESCRIPTION_ITEM>
    <P>
    Ajoutez ici un paragraphe pour la description de la fonction
    </P>
    </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

</DATA>
