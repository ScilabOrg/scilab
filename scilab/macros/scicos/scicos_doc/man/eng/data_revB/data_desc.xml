<DATA flag="desc">

<FILE name='ABS_VALUE' type='LATEX'>
The Abs block outputs the absolute value of the input.
</FILE>

<FILE name='AFFICH_f' type='LATEX'>
This block displays the value of its unique input inside the block (in
the diagram) during simulation. The block must be located in the main
Scicos window.\\   
{\bf Warning:} each time the block is moved user must click on it to set its
parameters. The display position is then automatically updated.    
</FILE>

<FILE name='ANDBLK' type='LATEX'>
The Bus Creator block combines a set of signals, i.e., a
group of signals represented by a single line in a block diagram. It
allows you to reduce the number of lines required to route signals
from one part of a diagram to another. This makes your easier to
understand.  
</FILE>

<FILE name='ANDLOG_f' type='LATEX'>
This block, with two event inputs and a regular output, outputs +1 or
-1 on its regular ouput depending on input events.     
\begin{enumerate}
\item[+1]: When events are synchronously present on both event input ports

\item[-1]: When only one event is present.
 \end{enumerate}
</FILE>

<FILE name='ANIMXY_f' type='LATEX'>
This block realizes the visualization of the evolution of the two
regular input signals by drawing the second input as a function of the
first at instants of events on the event input port.  
</FILE>

<FILE name='BACKLASH' type='LATEX'>
The Backlash block implements a system in which a change in input
causes an equal change in output. However, when the input changes
direction, an initial change in input has no effect on the output. The
amount of side-to-side play in the system is referred to as the
{\em deadband or gap}.  
</FILE>

<FILE name='Bache' type='LATEX'>
The {\bf Bache} block represents a thermo-hydraulic tank or reservoir.
This block has two inlets and two outlets whose altitudes can be
changed by the user.  Conventionnally, for input ports (black ports)
flow direction is positive when fluid flows into the tank.  On the
other hand, for output ports (white ports) flow direction is positive
when fluid flows out of the tank. The user can set the surface area of
the tank, the initial temperature and initial level of the fluid in
the tank.  If an input or output port is left unused, it should be
blocked by a {\bf stopper} block.
</FILE>

<FILE name='Branching_pal' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Add here a paragraph of the function description
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='CBLOCK' type='LATEX'>
This block creates skeleton of the C-computing function. It also
creates library file and object files.  
</FILE>

<FILE name='CLINDUMMY_f' type='LATEX'>
This block should be placed in any block diagram that contains a
zero-crossing block but no continuous system with state. The reason
for that is that it is the ode solver that find zero crossing
surfaces.  
</FILE>

<FILE name='CLKINV_f' type='LATEX'>
This block must only be used inside Scicos Super Blocks to represent
an event input port. In a Super Block, the event input ports must be
numbered from 1 to the number of event input ports.    
</FILE>

<FILE name='CLKOUTV_f' type='LATEX'>
This block must only be used inside Scicos Super Blocks to represent 
an event output port. In a Super Block, the event output ports must be
numbered from 1 to the number of event output ports.    
</FILE>

<FILE name='CLKSOMV_f' type='LATEX'>
This block is an event addition block with up to three inputs. The
output reproduces the events on all the input ports. Strictly
speaking, CLKSOMV is not a Scicos block because it is discarded at the
compilation phase. The inputs and output of CLKSOMV are synchronized. 
</FILE>

<FILE name='CLOCK_f' type='LATEX'>

This block is a Super Block constructed by feeding back the output of
an event delay block into its input event port. The unique output of
this block generates a regular train of events. 
 
</FILE>

<FILE name='CLR_f' type='LATEX'>
This block realizes a SISO linear system represented by its rational
transfer function  {\bf Numerator/Denominator}. The rational function must
be proper.   
</FILE>

<FILE name='CLSS_f' type='LATEX'>
This block realizes a continuous-time linear state-space system.  
\begin{align}
\dot x&=Ax+Bu\\
  y   &=C*x+D*u
 \end{align}  
The system is defined by the $(A,B,C,D)$ matrices and the initial state
$x_0$. The dimensions must be compatible.   
</FILE>

<FILE name='CMSCOPE' type='LATEX'>
When you start a simulation, Scicos open Scope windows.  The Scope
block displays its input with respect to simulation time. The Scope
block can have multiple axes (one per port); all axes have a common
time range with independent y-axes. The Scope allows you to adjust the
amount of time and the range of input values displayed. 
</FILE>

<FILE name='CONSTRAINT_f' type='LATEX'>
 Defines implicit algebraic relations.
</FILE>

<FILE name='CONST_f' type='LATEX'>
This block is a constant value(s) generator. 
</FILE>

<FILE name='CSCOPE' type='LATEX'>
The Scope block displays its input with respect to simulation
time. Both axes have a common range.  The Scope allows you to adjust
the amount of time and the range of input values displayed.   
</FILE>

<FILE name='CURV_f' type='LATEX'>
This block defines a tabulated function of time. Between mesh points
block performs a linear interpolation. Outside tabulation block
outputs last tabulated value.  User may define the tabulation of the
function using a curve editor.  
</FILE>

<FILE name='Capacitor' type='LATEX'>

A capacitor is an electrical component that can store energy in
electrical circuits. The relationship between the voltage $V$ across a
capacitor with capacitance $C$ and the current $I$ passing through it
is given by the:
\[
I = C\frac{dV}{dt}     
\]
Capacitors can also be used to differentiate between high-frequency
and low-frequency signals and this makes them useful in electronic
filters. A capacitor has a hight impedence when a signal is low frequency
signals.
</FILE>

<FILE name='ConstantVoltage' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>

This component is a model for any device or system that produces a
constant electromotive force between its port. The output voltage of
this DC volatge source is defined by the user. The black port
indicates the positive voltage. The ohmic resistance of this DC
voltage source is zero.

</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='CurrentSensor' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
This block is inserted in series in an electrical circuit to measure
the current passing through the coponent. The measure is given to the
explicit part of the model via an explicit pout. Conventionally,
current flowing into the black port is consiered positive. The ohmic
resistance of this block is zero.
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='DEADBAND' type='LATEX'>
Provide a region of zero output
</FILE>

<FILE name='DEBUG_SCICOS' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Add here a paragraph of the function description
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='DEMUX' type='LATEX'>
Given a vector valued input this block splits inputs over vector
valued outputs. So $ u=[y_1;y_2,\cdots;y_n]$ , where  $y_i$  are
numbered from top to bottom. Input and Output port sizes are
determined by the context.    
</FILE>

<FILE name='DERIV' type='LATEX'>
The Derivative block approximates the derivative of its input by computing:
$$\frac{\Delta u}{\Delta t}$$ 
</FILE>

<FILE name='DLR_f' type='LATEX'>
This block realizes a SISO linear system represented by its rational
transfer function (in the symbolic variable z). The rational function
must be proper.   
</FILE>

<FILE name='DLSS_f' type='LATEX'>
This block realizes a discrete-time linear state-space system. The
system is defined by the $(A,B,C,D)$ matrices and the initial state
$x_0$. The dimensions must be compatible. At the arrival of an input
event on the unique input event port, the state is updated.   
</FILE>

<FILE name='DOLLAR_f' type='LATEX'>
The Unit Delay block delays its input by the specified sample
period. This block is equivalent to the z-1 discrete-time
operator. The block accepts one input and generates one output, which
can be either both scalar or both vector. If the input is a vector,
all elements of the vector are delayed by the same sample period. 
</FILE>

<FILE name='Diode' type='LATEX'>

This component consists of a simple diode parallel with an ohmic
resistance ($R$). The current passing through this component is
defined as a function of the voltage across the ports, {\it i.e.},

\[ i = I_{ds} ( \exp^{v/V_t}- 1)+\frac{v}{R}\]

where $I_{ds}$ and $V_t$ are the saturation current and the voltage
equivalent of temperature, respectively. If the exponent $v/V_t$
reaches a certain limit ($Maxexp$), the diode characterisic becomes
linear to avoid overflow.
</FILE>

<FILE name='EDGE_TRIGGER' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Add here a paragraph of the function description
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='ESELECT_f' type='LATEX'>

A Selector block accepts either vector or matrix signals as input. Set
the Input Type parameter to the type of signal (vector or matrix) that
the block should accept in your model. The parameter dialog box and
the block's appearance change to reflect the type of input that you
select. The way the block determines the elements to select differs
slightly, depending on the type of input. 
</FILE>

<FILE name='EVENTSCOPE_f' type='LATEX'>
This block realizes the visualization of the input event signals.  
</FILE>

<FILE name='EVTDLY_f' type='LATEX'>
One event is generated  {\bf Delay}  after an event enters the unique
input event port. Block may also generate an initial output event.   
</FILE>

<FILE name='EVTGEN_f' type='LATEX'>
One event is generated on the unique output event port if  Event time
is larger than equal to zero, if not, no event is generated.   
</FILE>

<FILE name='EVTVARDLY' type='LATEX'>
 One event is generated Delay after an event enters the unique input
 event port. Block may also generate an initial output event.  
</FILE>

<FILE name='EXPBLK_f' type='LATEX'>
This block realizes  $y(i)=a^u(i)$. The input and output port sizes are
determined by the compiler.   
</FILE>

<FILE name='EXPRESSION' type='LATEX'>
The Expression block applies the specified Scilab functions to its input. 
</FILE>

<FILE name='EXTRACTOR' type='LATEX'>
Extracts or select a regular input from a muliple regular input.
</FILE>

<FILE name='Electrical_pal' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Electrical toolbox contains very basic electrical components such as
voltage source, diode, capacitor, etc.
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='Events_pal' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Add here a paragraph of the function description
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='Extract_Activation' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Add here a paragraph of the function description
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='FSCOPE_f' type='LATEX'>
 This  is  a floating scope block. 
</FILE>

<FILE name='GAINBLK' type='LATEX'>
This block is a gain block. The output is the Gain times the regular
input (vector). The dimensions of Gain determines the input (number of
columns) and output (number of rows) port sizes.   
</FILE>

<FILE name='GENSIN_f' type='LATEX'>
This block is a sine wave generator: $M*\sin(F*t+P) $ 
</FILE>

<FILE name='GENSQR_f' type='LATEX'>
This block is a square wave generator: output takes values  -M  and  M
. Every time an event is received on the input event port, the output
switches from  -M  to  M , or  M  to  -M .    
</FILE>

<FILE name='Ground' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
The Ground element is a single port component providing a reference
voltage in electrical circuits. The potential at the ground node is
zero. Every electrical circuit has to contain at least one ground
element.
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='HALT_f' type='LATEX'>
This block has a unique input event port. Upon the arrival of an
event, the simulation is stopped and the main Scicos window is
activated. Simulation can be restarted or continued (Run button).   
</FILE>

<FILE name='HYSTHERESIS' type='LATEX'>
Switch output between two constants.The Relay block allows its output
to switch between two specified values. When the relay is on, it
remains on until the input drops below the value of the Switch off
point parameter. When the relay is off, it remains off until the input
exceeds the value of the Switch on point parameter. The block accepts
one input and generates one output. 
</FILE>

<FILE name='IFTHEL_f' type='LATEX'>
One event is generated on one of the output event ports when an input
event arrives. Depending on the sign of the regular input, the event
is generated on the first or second output.  
This is a synchro block, {\em i.e.}, input and output event are synchronized. 
</FILE>

<FILE name='INIMPL_f' type='LATEX'>
Inport blocks are the links from outside a system into the system.
</FILE>

<FILE name='INTEGRAL' type='LATEX'>
This block is an integrator. The output is the integral of the input.   
</FILE>

<FILE name='INTRP2BLK_f' type='LATEX'>
The output of this block is a function of the inputs obtained by
bilinear interpolation. This block has two scalar inputs and a single
scalar output. The $X(i)$ and $Y(i)$ give respectively the $X$ coordinate
and the $Y$ coordinate of the $i$-th data point to be interpolated and
$Z(Y(i),X(i))$ its value.   
</FILE>

<FILE name='INTRPLBLK_f' type='LATEX'>
The output of this block is a function of the input obtained by linear
interpolation. This block has a single scalar input and a single
scalar output port. The $X$ coord. and $Y$ coord. give respectively the $X$
coordinate and the $Y$ coordinate of the data points to be
interpolated. $X$ coord must be strictly increasing.   
</FILE>

<FILE name='INVBLK_f' type='LATEX'>
This block computes  $y(i)=1/u(i)$. The input (output) size is
determined by the context  
</FILE>

<FILE name='IN_f' type='LATEX'>
This block must only be used inside Scicos Super Blocks to represent a
regular input port. The input size is determined by the context.  In a
Super Block, regular input ports must be numbered from 1 to the number
of regular input ports.
</FILE>

<FILE name='ISELECT_f' type='LATEX'>
Select signals from an incoming events. This block has one regular
input port.    
</FILE>

<FILE name='Inductor' type='LATEX'>

 Inductor is an electrical component that can store energy in
electrical circuits.  The relationship between the voltage $v$ across
the ports of an inductor of inductance $L$ and the current $I$ passing
through it is given by:

\[v = L \frac{dI}{dt}\]

Inductors can also be used to differentiate between high-frequency and
low-frequency signals and this makes them useful in electronic
filters. An inductor shows a hight impedence for hight frequency
signals.

</FILE>

<FILE name='LOGBLK_f' type='LATEX'>
This block realizes  $y(i)=log(u(i))/log(a)$ . The input and output port
sizes are determined by the context.  
</FILE>

<FILE name='LOGICAL_OP' type='LATEX'>
The Logical Operator block performs the specified logical operation on
its inputs. An input value is TRUE (1) if it is nonzero and FALSE (0)
if it is zero. 
</FILE>

<FILE name='LOOKUP_f' type='LATEX'>
This block realizes a non-linear function defined using a graphical
editor.    
</FILE>

<FILE name='Linear_pal' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Add here a paragraph of the function description
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='MAXMIN' type='LATEX'>
The MinMax block outputs either the minimum or the maximum element or
elements of the inputs. You can choose the function to apply by
selecting one of the choices from the Function parameter list.  
</FILE>

<FILE name='MUX' type='LATEX'>
Given  $n$  vector valued inputs this block merges inputs in an single
output vector. So  $y=[u_1;u_2;\cdots;u_n]$ , where  $u_i$  are
numbered from top to bottom. Input and Output port sizes are
determined by the context.    
</FILE>

<FILE name='M_SWITCH' type='LATEX'>
The Multi-Port Switch block chooses between a number of inputs. The
first (top) input is called the control input, while the rest of the
inputs are called data inputs. The value of the control input
determines which data input is passed through to the output port. 
</FILE>

<FILE name='Modulo_Count' type='LATEX'>
It is a discrete block. The block outputs a periodic scalar signal
having a waveform that the user specifies.     
</FILE>

<FILE name='NEGTOPOS_f' type='LATEX'>
An output event is generated when the unique input crosses zero with a
positive slope.   
</FILE>

<FILE name='NRMSOM_f' type='LATEX'>
The Merge block combines its inputs into a single output line whose
value at any time is equal to the most recently computed output of its
driving blocks. You can specify any number of inputs by setting the
block's Number of inputs parameter.  
</FILE>

<FILE name='Non_linear_pal' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Add here a paragraph of the function description
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='OUTIMPL_f' type='LATEX'>
Outport blocks are the links from a system to a destination outside
the system.  
</FILE>

<FILE name='OUT_f' type='LATEX'>
This block must only be used inside Scicos Super Blocks to represent a
regular output port. In a Super Block, regular output ports must be
numbered from 1 to the number of regular output ports.  size of the
output is determined by the compiler according to the connected blocks
port sizes.    
</FILE>

<FILE name='Others_pal' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Add here a paragraph of the function description
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='PDE' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Add here a paragraph of the function description
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='POSTONEG_f' type='LATEX'>
An output event is generated when the unique input crosses zero with a
negative slope.  
</FILE>

<FILE name='POWBLK_f' type='LATEX'>
This block realizes  $y(i)=u(i)^a$. The input and output port sizes
are determined by the compiler according to the connected blocks port
sizes.   
</FILE>

<FILE name='PRODUCT' type='LATEX'>
The Product block performs multiplication or division of its
inputs. This block produces outputs using either element-wise or
matrix multiplication, depending on the value of the Multiplication
parameter. You specify the operations with the Number of inputs
parameter. Multiply(+1) and divide (-1) characters indicate the
operations to be performed on the inputs: 
</FILE>

<FILE name='PROD_f' type='LATEX'>
The output is the element wize product of the inputs.   
</FILE>

<FILE name='PerteDP' type='LATEX'>
A {\bf PertDP} block represents a hydraulic pipe with linear
resistance losses. This component represents a hydraulic resistance
and pressure loss is directly proportional to the flow rate.
Conventionally, the flow direction is the positive when fluid flows
from the black port to the white port.  The pressure loss is obtained
with {\[P_{loss}=P_{black}-P_{white}\].  The key parameters of this
block are the pipes' length, the pipe's diameter, inlet and outlet
altitudes, and some other thermo-hydraulic coefficients.
</FILE>

<FILE name='PotentialSensor' type='LATEX'>

This block is used to measure the voltage with respect to the
reference voltage ({\bf Ground} block) in an electircal circuit. The
voltage is given to the explicit part of the model via an explicit
output port.

</FILE>

<FILE name='PuitsP' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
This thermohydraulic component represents a thermo-hydraulic constant
pressure drain (well). This block is specified with its pressure and
temperature.  Conventionally, the flow direction is positive when
fluid flows into the block.
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='QUANT_f' type='LATEX'>
This block outputs the quantization of the input according to a choice
of methods:
\begin{enumerate}   
\item Round  method:  
\begin{align*}
 y(i)&=Step*(int(u(i)/Step+0.5)-0.5)&  \texttt{if}\  u(i)<0 .\\  
 y(i)&=Step*(int(u(i)/Step-0.5)+0.5) & \texttt{if} \ u(i)>=0 .  
 \end{align*}
\item Truncation method:
\begin{align*}
 y(i)&=Step*(int(u(i)/Step+0.5)) &\texttt{ if} \  u(i)<0 .  \\
 y(i)&=Step*(int(u(i)/Step-0.5)) &\texttt{if}  \ u(i)>=0 .  
\end{align*}
 
\item Floor method:  
\begin{align*}
 y(i)&=Step*(int(u(i)/Step+0.5))  .  
 \end{align*}
\item  Ceil method:  
\begin{align*}
 y(i)&=Step*(int(u(i)/Step-0.5)) \end{align*}
\end{enumerate}
</FILE>

<FILE name='RAMP' type='LATEX'>
The Ramp block generates a signal that starts at a specified time and
value and changes by a specified rate. The block's {\bf Slope , Start
  time} and {\bf Initial output} parameters determine the
characteristics of the output signal. All must have the consistent
dimensions after scalar expansion.    
</FILE>

<FILE name='RAND_f' type='LATEX'>

This block is a random wave generator: each output component takes
piecewise constant random values. Every time an event is received on
the input event port, the outputs take new independent random
values. output port size is given by the size of  {\bf A}  and  {\bf
 B}  vectors     
</FILE>

<FILE name='RATELIMITER' type='LATEX'>
The Rate Limiter block limits the first derivative of the signal
passing through it. The output changes no faster than the specified
limit.  
</FILE>

<FILE name='READAU_f' type='LATEX'>
 loads a sound file specified by the string aufile, returning the
 sampled data in y. The .au extension is appended if no extension is
 given. Amplitude values are in the range [-1,+1]. auread supports
 multichannel data in the following formats: 
\begin{itemize}
    \item 8-bit mu-law 
    \item 8-, 16-, and 32-bit linear
    \item Floating-point
\end{itemize}
</FILE>

<FILE name='READC_f' type='LATEX'>
This block allows user to read datas in a C file.  Output record
selection  and  Time record Selection  allows the user to select data
among file records. Each call to the block advance one record in the
file.    
</FILE>

<FILE name='REGISTER_f' type='LATEX'>
This block realizes a shift register. At every input event, the
register is shifted one step.    
</FILE>

<FILE name='RELATIONALOP' type='LATEX'>

It performs logical comparison of its two inputs. 
</FILE>

<FILE name='RELAY_f' type='LATEX'>
This block routes one of the regular inputs to the unique regular
output. the choice of which input is to be routed is done, initially
by the "initial connected input" parameter. Then, every time an input
event arrives on the i-th input event port, the i-th regular input
port is routed to the regular output.   
</FILE>

<FILE name='RFILE_f' type='LATEX'>
This block allows user to read datas in a file, in formatted or binary
mode. {\bf  Output record selection}  and  {\bf Time record Selection}
  allows the user to select data among file records.   Each call to the block
advance one record in the file.   
</FILE>

<FILE name='Resistor' type='LATEX'>
A resistor is a two-port electrical component that resists an electric
current by producing a voltage drop ($V$) between its terminals
according to the Ohm's law.

\[ R = \frac {V}{I}\]

The electrical resistance ($R$) is equal to the voltage drop across
the resistor divided by the current through the resistor ($I$).

</FILE>

<FILE name='SAMPLEHOLD_f' type='LATEX'>
Each time an input event is received block copy its input on the
output and hold it until input event. For periodic Sample and hold,
event input must be generated by a  {\bf Clock}.  
</FILE>

<FILE name='SATURATION' type='LATEX'>
The Saturation block imposes upper and lower bounds on a signal. When
the input signal is within the range specified by the Lower limit and
Upper limit parameters, the input signal passes through
unchanged. When the input signal is outside these bounds, the signal
is clipped to the upper or lower bound. When the Lower limit and Upper
limit parameters are set to the same value, the block outputs that
value. 
</FILE>

<FILE name='SAWTOOTH_f' type='LATEX'>
This block is a sawtooth wave generator: output is $(t-t_i)$ from $t_i$ to
$t_{i+1}$ where $t_i$ and $t_{i+1}$ denote the times of two successive input
events.    
</FILE>

<FILE name='SCALAR2VECTOR' type='LATEX'>
This block  convert a scalar value into a vector of identical
elements.When using blocks with more than one input port (such as the
Sum or Relational Operator block), you can mix vector and scalar
inputs. When you do this, the scalar inputs are expanded into vectors
of identical elements whose widths are equal to the width of the
vector inputs. (If more than one block input is a vector, they must
have the same number of elements.) 
</FILE>

<FILE name='SCOPXY_f' type='LATEX'>
This block realizes the visualization of the evolution of the two
regular input signals by drawing the second input as a function of the
first at instants of events on the event input port.   
</FILE>

<FILE name='SELECT_f' type='LATEX'>
This block routes one of the regular inputs to the unique regular
output. the choice of which input is to be routed is done, initially
by the "initial connected input" parameter. Then, every time the block
is activated through its i-th input activation port, the i-th regular
input value port is put to the regular output.   
</FILE>

<FILE name='SIGNUM' type='LATEX'>
The Sign block indicates the sign of the input: 
\begin{itemize}
\item The output is 1 when the input is greater than zero.
\item The output is 0 when the input is equal to zero.
\item The output is -1 when the input is less than zero.   
\end{itemize}
</FILE>

<FILE name='STEP_FUNCTION' type='LATEX'>
The Step block provides a step between two definable levels at a
specified time. If the simulation time is less than the Step time
parameter value, the block's output is the Initial value parameter
value. For simulation time greater than or equal to the Step time, the
output is the Final value parameter value. 
</FILE>

<FILE name='SUMMATION' type='LATEX'>
The Sum block performs addition or subtraction on its inputs. This
block can add or subtract scalar, vector, or matrix inputs. It can
also collapse the elements of a single input vector. 
</FILE>

<FILE name='SUM_f' type='LATEX'>
The Sum block performs addition  on its inputs. This block can add
scalar, vector, or matrix inputs.   
</FILE>

<FILE name='SUPER_f' type='LATEX'>
This block opens up a new Scicos window for editing a new block
diagram. This diagram describes the internal functions of the super
block.  

Super block inputs and outputs (regular or event) are
designated by special (input or output) blocks.  

Regular input blocks
must be numbered from 1 to the number of regular input ports. Regular
input ports of the super block are numbered from the top of the block
shape to the bottom.  Regular output portss must be numbered from 1 to
the number of regular output ports. Regular output ports of the super
block are numbered from the top of the block shape to the bottom.
Event input blocks must be numbered from 1 to the number of event
input ports. Event input ports of the super block are numbered from
the left of the block shape to the right.  Event output ports must be
numbered from 1 to the number of event output ports. Event output
ports of the super block are numbered from the left of the block shape
to the right.
</FILE>

<FILE name='SWITCH2' type='LATEX'>
The Switch block passes through the first (top) input or the third
(bottom) input based on the value of the second (middle) input. The
first and third inputs are called data inputs. The second input is
called the control input. You select the conditions under which the
first input is passed with the Criteria for passing first input
parameter. You can make the block check whether the control input is
greater than or equal to the threshold value, purely greater than the
threshold value, or nonzero. If the control input meets the condition
set in the Criteria for passing first input parameter, then the first
input is passed. Otherwise, the third input is passed. 
</FILE>

<FILE name='SWITCH_f' type='LATEX'>

This is a  Manual Switch block. It selects one of its  inputs to pass
through to the output. The selected input is propagated to the output,
while the unselected inputs are discarded.  
</FILE>

<FILE name='Sinks_pal' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Add here a paragraph of the function description
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='SourceP' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>

This thermohydraulic component represents a thermo-hydraulic constant
pressure supply. This block is specified with its output pressure and
temperature.  Conventionally, the flow direction is positive when the
fluid flows out of the block.

</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='Sources_pal' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Add here a paragraph of the function description
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='TCLSS_f' type='LATEX'>
This block realizes a continuous-time linear state-space system with
the possibility of jumps in the state. The number of inputs to this
block is two. The first input is the regular input of the linear
system, the second carries the new value of the state which is copied
into the state when an event arrives at the unique event input port of
this block. That means the state of the system jumps to the value
present on the second input (of size equal to that of the state). The
system is defined by the $(A,B,C,D)$ matrices and the initial state
$x_0$. The dimensions must be compatible. The sizes of inputs and outputs
are adjusted automatically.   
</FILE>

<FILE name='TEXT_f' type='LATEX'>
This special block is only use to add text at any point of the diagram
window. It has no effect on the simulation.   
</FILE>

<FILE name='TIME_DELAY' type='LATEX'>
The Transport Delay block delays the input by a specified amount of
time. It can be used to simulate a time delay. At the start of the
simulation, the block outputs the Initial input parameter until the
simulation time exceeds the Time delay parameter, when the block
begins generating the delayed input. The Time delay parameter must be
nonnegative. 
</FILE>

<FILE name='TIME_f' type='LATEX'>
This block is a time generator. The unique regular output is the
current time.   
</FILE>

<FILE name='ThermoHydraulics_pal' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
ThermoHydraulics toolbox contains some basic thermohydraulic
components such as pressure source, pipe, control valves, etc.
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='Threshold_pal' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Add here a paragraph of the function description
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='TrigFun' type='LATEX'>
The Trigonometric Function block performs numerous common
trigonometric functions. You can select one of these functions from
the Function list: sin, cos, tan, asin, acos, atan, atan2, sinh, cosh,
and tanh. The block output is the result of the operation of the
function on the input or inputs. 
</FILE>

<FILE name='VARIABLE_DELAY' type='LATEX'>
The Variable Transport Delay block can be used to simulate a variable
time delay. The block might be used to model a system with a pipe
where the speed of a motor pumping fluid in the pipe is variable. The
block accepts two inputs: the first input is the signal that passes
through the block; the second input is the time delay. 
</FILE>

<FILE name='VVsourceAC' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
The variable voltage source block is a model for a controlled AC
voltage source. This component provides a sinosoid voltage across its
ports. The amplitude of the output voltage is governed by the explicit
input and the frequency is defined by the user. The ohmic resistance
of the block is zero.
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='VanneReglante' type='LATEX'>
The {\bf VanneReglante} block represents a variable orifice control
valve. The flow rate through the valve is proportional to the valve
opening, {\it i.e.},

\[
  \Delta P \times h\times\left| h \right| = k\times Q\times \left|Q\right|
\]

where $h$ is the valve opening, $\Delta P$ is the pressure difference,
and $Q$ is the flow rate. This model is only used for the laminar flow
regimes. $k$ is a constant depending on the valve geometry and
mass density of fluid.
</FILE>

<FILE name='VariableResistor' type='LATEX'>

 This component represents a variable ohmic resistor. The resistance
 ($R_x$) is controlled via an explicit input port.

\[
 R_x = \frac {V}{I}
\]

</FILE>

<FILE name='VoltageSensor' type='LATEX'>

This component is used to measure the voltage difference between two
nodes in an electircal circuit. The output signal is the difference
between the voltages of the black port and the white port, {\it i.e.},

\[V_{output}=V_{black}-V_{white}\]

The ohmic conductance of this block is zero.


</FILE>

<FILE name='VsourceAC' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
This component is an AC voltage source with sinosoid output
voltage. The amplitude and the frequency of the output voltage is set
by the user. The ohmic resistance of this block is zero.
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='WFILE_f' type='LATEX'>
This block allows user to save data in a file, in formatted and binary
mode. Each call to the block corresponds to a record in the file. Each
record has the following form:  $[t,V1,...,Vn]$  where  $t$  is the value
of time when block is called and $ V_i$  is the ith input value.    
</FILE>

<FILE name='WRITEAU_f' type='LATEX'>
This block  writes a sound file specified by the string aufile. The
 data should  be arranged with one channel per column. Amplitude
 values outside the   range [-1,+1] are clipped prior to
 writing. auwrite supports  multichannel data for 8-bit mu-law and 8-
 and 16-bit linear formats.  

</FILE>

<FILE name='WRITEC_f' type='LATEX'>
This block allows user to write datas in a C binary file.  
</FILE>

<FILE name='ZCROSS_f' type='LATEX'>
An output event is generated when all inputs (if more than one) cross
zero simultaneously.    
</FILE>

<FILE name='buildouttb' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Add here a paragraph of the function description
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='c_block' type='LATEX'>
This block creates skeleton of the C computing function. Also it
creates library file and object files.  
</FILE>

<FILE name='curblock' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Add here a paragraph of the function description
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='fortran_block' type='LATEX'>
This block creates skeleton of the fortran computing function. Also it
creates library file and object files.  
</FILE>

<FILE name='freq_div' type='LATEX'>
 This block is a Super Block. The input event is directed once every n
 times to output. The input is  driven by an event clock.
</FILE>

<FILE name='generic_block2' type='LATEX'>
The block provides a generic interfacing function but the
computational function needs to be defined separately, either as a
Scilab function or  a Fortran or a C function. Besides the name of the
function, user should specify information such as the type, whether or
not the block contains a direct feed-through term. The function
realising computational functions of generic blocks of a scicos
diagram must be saved along with the diagram and loaded or dynamically
linked before simulation. 
</FILE>

<FILE name='getscicosvars' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Add here a paragraph of the function description
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='lincos' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Construct a linear state-space system by linearizing a model
given as a Scicos diagram.
</P>
</DESCRIPTION_ITEM>
<DESCRIPTION_ITEM>
<P>
The output is a Scilab data structure of type continuous-time state-space linear system.
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='scicos' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Scicos is a visual editor for constructing models of hybrid
dynamical systems. Invoking Scicos with no argument opens up an
empty Scicos window. Models can then be assembled, loaded,
saved, compiled, simulated, using GUI of Scicos.  Scicos
serves as an interface to the various block diagram compilers
and the hybrid simulator scicosim.
</P>
</DESCRIPTION_ITEM>
<DESCRIPTION_ITEM>
<P>
The input and output arguments are useful for debugging purposes.
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='scicos_debug' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Add here a paragraph of the function description
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='scicos_simulate' type='XML'>
<DESCRIPTION>
<P>
This function is used to simulate scicos diagrams in batch
mode. It requires the scs_m structure which can be obtained by
loading in Scilab the .cos file (e.g. load
mydiagram.cos).
</P>
<P>
Contrary to the function <LINK> scicosim</LINK>, the diagram
need not be compiled before being saved.
</P>
</DESCRIPTION>
</FILE>

<FILE name='scicos_time' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Add here a paragraph of the function description
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='scicosim' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Simulator for Scicos compiled diagram.
</P>
<P>
Usually scicosim is called by scicos to perform simulation of
a diagram.
</P>
<P>
But scicosim may also be called outside Scicos. Typical usage
in such a case may be :
</P>
</DESCRIPTION_ITEM>
<DESCRIPTION_ITEM>
<DESCRIPTION_ITEM>
<P>
1- Use Scicos to define a block diagram, compile it.
</P>
<P>
2- Save the compiled diagram using Save,SaveAs Scicos menus.
</P>
<P>
3- In Scilab, load saved file using load function. You get
variables scicos_ver, scs_m, %cpr scs_m is the diagram Scicos main data structure.
</P>
<P>
%cpr is the data structure containing (state,sim,cor,corinv)
if the diagram had been compiled before saved, else %cpr=list().
</P>
<P>
4- Extract state, sim out of cpr.
</P>
<P>
5- Execute [state,t]=scicosim(state,0,tf,sim,'start',tol) for initialisation.
</P>
<P>
6- Execute [state,t]=scicosim(state,0,tf,sim,'run',tol) for
simulation from 0 to tf.
</P>
<P>
Many successives such calls may be
performed changing initial and final time.
</P>
<P>
7- Execute [state,t]=scicosim(state,0,tf,sim,'finish',tol) at
the very end of the simulation to close files,...
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_ITEM>
<DESCRIPTION_ITEM>
<P>
For advanced user it is possible to "manually"
change some parameters or state values.
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='scifunc_block' type='LATEX'>
This block can realize any type of Scicos block. The function of the
block is defined interactively using dialogue boxes and in Scilab
language. During simulation, these instructions are interpreted by
Scilab; the simulation of diagrams that include these types of blocks
is slower. For more information see Scicos reference manual.   
</FILE>

<FILE name='steadycos' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
This function finds the steady state for a given system described
by a Scicos diagram. The diagram consists in general of a Super
block with input and output port blocks. The steady states
concerns only the continuous-time dynamics.
</P>
</DESCRIPTION_ITEM>

</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='var2vec' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Add here a paragraph of the function description
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='vec2var' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Add here a paragraph of the function description
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>


<FILE name='CUMSUM' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
The CUMSUM block sums the element of an input m*n matrix u along either the rows, the columns or the first non singleton dimension. When the "Sum along" parameter is set to "1", the block sums across the elements of each row. The result will be displayed as a m*1 matrix.
</P>
<P>
When the "Sum along" parameter is set to "2", the block sums across the elements of each column. The result will be display as a 1*n matrix.
</P>
<P>
When the "Sum along" parameter is set to "0", the block sums across the first non singleton dimension. The result will be displayed as one element.
This block is equivalent to cumsum in scilab.
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='EXTRACT' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
The EXTRACT block extracts some elements from the matrix. The size of the output depends on the number of rows and number of columns to extract.
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='EXTTRI' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
The EXTTRI block extracts some elements from the input matrix u.</P>
<P> When the "Extraction type" is set to "1", the block copies the elements on and above the main diagonal to an output matrix of the same size. The elements below the main diagonal are set to zero.</P>
<P> When the "Extraction type" is set to "2", the block copies the elements on and below the main diagonal to an output matrix of the same size. The elements above the main diagonal are set to zero.</P>
<P> When the "Extraction type" is set to "3", the block copies the elements on the main diagonal to an output matrix of the same size. The elements above and below the main diagonal are set to zero.
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='MATBKSL' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
The MATBKSL block outputs the left matrix division. It is a solution to A*x=B. The higher input is the A matrix, the lower one is the B matrix, and the output is x. If A is an M-by-N1 matrix, B must be a M-by-N2 where N1 and N2 can be different or equal.
The output x is a N1-by-N2 matrix.</P>
<P>The equivalent of BACKSLASH is "\" in Scilab.
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='MATCATH' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
The MATCATH Block outputs the horizental concatenation of multiple matrices. It is also called concatenation according to the columns. The inputs U1,U2,...,Un must have the same number of rows. The output is a M-by-(N1+N2+...+Nn) matrix, where N1,N2,...,Nn are the numbers of columns of the inputs matrices, and M is the number of rows.
</P>
<P>The equivalent of MATCATH in Scilab is y=[U1 U2 ... Un].</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='MATCATV' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
The MATCATV Block outputs the vertical concatenation of multiple matrices. It is also called concatenation according to the rows. The inputs U1,U2,...,Un must have the same number of columns. The output is a (M1+M2+...+Mn)-by-N matrix, where M1,M2,...,Mn are the numbers of rows of the inputs matrices, and N is the number of columns.
</P>
<P>The equivalent of MATCATH in Scilab is y=[U1;U2;...;Un]</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='MATDET' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
The MATDET outputs the determinant of a square input matrix. If the input A=[A11 A12 A13;A21 A22 A23;A31 A32 A33] then the output of the block has the form of: y=A11*(A22*A33-A23*A32)-A12*(A21*A33-A23*A31)+A13*(A21*A32-A22*A31).</P>
<P>The equivalent of MATDET in Scilab is "det"</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='MATDIAG' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
The MATDIAG block create a diagonal matrix from a 1D vector. If the input is a M-by-1 vector than the output is an M-by-M matrix.
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='MATDIV' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>The MATDIV block outputs the right matrix division. It is a solution to x*B=A. The higher input is the A matrix, the lower one is the B matrix, and the output is x. If A is an M1-by-N matrix, B must be a M2-by-N where M1 and M2 can be different or equal. The output x is a M1-by-M2 matrix.</P>
<P>The equivalent of BACKSLASH is "/" in Scilab.</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='MATEIG' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
The MATEIG calculate the eigenvalues and the eigenvectors of a square input matrix U.</P>
<P> When the "Decomposition type" is set to 1, the block outputs the eigenvalues in a vector form, if the input is a M-by-M matrix the output is a M-by-1 vector.</P>
<P> When the "Decomposition type" is set to 2, the block outputs two matrices. for an M-by-M input matrix,the first output is a M-by-M diagonal matrix composed by the eigenvalues, and the second is a M-by-M matrices composed by the eigenvectors; the eigenvectors are represented by the columns of the matrix.</P>
<P> The equivalent of the MATEIG block in Scilab is "spec(A)"
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='MATEXPM' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
The MATEXPM outputs the matrix exponential of a square matrix input by the pade's approximants. The output is a square matrix with the same size of the input.The equivalent of this block in Scilab is "expm".
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='MATINV' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
The MATINV Block outputs the inverse of a square input matrix using the LU factorization. A warning message is printed if the input is badly scaled or nearly singular.The equivalent function of this block in Scilab is "inv".
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='MATLU' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
The MATLU Block outputs two matrices L and U, with row pivoting, from the LU factorization of a square input matrix. If A is the input matrix then E*A=L*U where E is the permutation matrix.The equivalent function of this block in Scilab is "[l,u,e]=lu(A)"
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='MATMAGPHI' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>MATMAGPHI Block has two types of decomposotions.</P>
<P>When the type is set to one, the block converts a complex number to the magnitude and the radian angle, in this case the input is complex and the outputs are real double. if the input is real double, the angle will be zero or PI and the magnitude will be equal to the absolute of the input number.</P>
<P>when the type is set to two, the block outputs a complex number given the magnitude and the radian angle. In this case the inputs are real double and the output is complex.
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='MATMUL' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
The MATMUL block computes the matrix multiplication of two inputs matrices.The number of rows of the second matrix must be equal to the number of columns of the first matrix. The output is a matrix where the number of rows is equal to that of the first input matrix and the number of columns is equal to that of the second input matrix.
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='MATPINV' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
The MATPINV Block outputs the inverse of a non square input matrix using the SVD theory.if the SVD decomposition of A is equal to:</P>
<P>A=USV'</P>
<P>The pseudoinverse x of A is given by:</P>
<P>X=VS"U' where S"(i,j)=1/S(i,j) (if S(i,j)~=0),
U' and V are respectivly the transpose of U and V'.</P>
<P>and we have A*X*A=A and X*A*X=X. Both A*X and X*A are Hermitian . A warning message is printed if the input is badly scaled or nearly singular.</P>
<P>When the input is a M-by-N matrix the output is a N-by-M matrix.
The eqivalent function of this block in Scilab is "pinv".
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='MATRESH' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
The RESHAPE block changes the dimensions of a matrix or a vector to another dimensions specified by the user in the "output size desired" label. The output size must be less or equal to the input size.
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='MATSING' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>The MATSING block computes the economy sized SVD of the M-by-N input matrix A by finding U,S and V such that</P>
<P>A=U*S*V'.</P>
<P>When the decomposition type is set to one, the output is a vector composed by the singular values.</P>
<P>When the decomposition type is set to two, we have three outputs: the second output is a diagonal matrix S composed by the singular values and the other two outputs are the unitary matrices U and V.</P>
<P>The equivalent function of this block in Scilab is "svd".
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='Matrix_pal' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Add here a paragraph of the function description
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='ABSBLK_f' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Add here a paragraph of the function description
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='AFFICH_m' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Add here a paragraph of the function description
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='BIGSOM_f' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Add here a paragraph of the function description
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='CANIMXY' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Add here a paragraph of the function description
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='CANIMXY3D' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Add here a paragraph of the function description
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='CEVENTSCOPE' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Add here a paragraph of the function description
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='CFSCOPE' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Add here a paragraph of the function description
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='CLKIN_f' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Add here a paragraph of the function description
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='CLKOUT_f' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Add here a paragraph of the function description
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='CLKSOM_f' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Add here a paragraph of the function description
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='CLKSPLIT_f' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Add here a paragraph of the function description
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='CLR' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Add here a paragraph of the function description
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='CLSS' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Add here a paragraph of the function description
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='CMAT3D' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Add here a paragraph of the function description
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='CMATVIEW' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Add here a paragraph of the function description
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='CONST' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Add here a paragraph of the function description
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='CONST_m' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Add here a paragraph of the function description
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='COSBLK_f' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Add here a paragraph of the function description
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='CSCOPXY' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Add here a paragraph of the function description
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='CSCOPXY3D' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Add here a paragraph of the function description
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='DELAYV_f' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Add here a paragraph of the function description
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='DELAY_f' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Add here a paragraph of the function description
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='DEMUX_f' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Add here a paragraph of the function description
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='DIFF_f' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Add here a paragraph of the function description
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='DLR' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Add here a paragraph of the function description
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='DLRADAPT_f' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Add here a paragraph of the function description
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='DLSS' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Add here a paragraph of the function description
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='FSV_f' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Add here a paragraph of the function description
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='GAINBLK_f' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Add here a paragraph of the function description
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='GAIN_f' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Add here a paragraph of the function description
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='GENERAL_f' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Add here a paragraph of the function description
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='INTEGRAL_f' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Add here a paragraph of the function description
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='INTEGRAL_m' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Add here a paragraph of the function description
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='INVBLK' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Add here a paragraph of the function description
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='ISELECT_m' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Add here a paragraph of the function description
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='MATSUM' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
The MATSUM block returns the sum of the element of an input matrix/vector.
When the Sum along is set to all the block outputs the sum of all the elements of the matrix. The output is then a scalar.
When the Sum along is set to lines the block is a rowwise sum. The output is a row vector.
When the Sum along is set to Columns the block is a columnwise sum. The output is a column vector.
The equivalent function of this block in scilab is: "sum".
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='MATTRAN' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
This Block transposes an MxN matrix to a NxM matrix. For complex data type it uses the hermitian transpose. The equivalent of this block in Scilab is y=u'.
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='MATZCONJ' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
This blocks computes the conjugate of a complex input matrix.
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='MATZREIM' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
This block decomposes a complex number by seperating the real and imaginary parts or compose a comples number by joining the two parts. The user can select even to seperate or to join real and imaginary part by setting the decomposition type to 1 or 2. When it is set to 1, the input is a complex matrix and the outputs are the real and imaginary parts of the input. When it set to 2, The inputs are two real matrices, the output is a complex number with real part the first input and imaginary part the second input.
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='MAX_f' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Add here a paragraph of the function description
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='MCLOCK_f' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Add here a paragraph of the function description
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='MEMORY_f' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Add here a paragraph of the function description
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='MFCLCK_f' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Add here a paragraph of the function description
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='MIN_f' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Add here a paragraph of the function description
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='MOTOR' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Add here a paragraph of the function description
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='MUX_f' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Add here a paragraph of the function description
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='NPN' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Add here a paragraph of the function description
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='OldBlocks_pal' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Add here a paragraph of the function description
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='PNP' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Add here a paragraph of the function description
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='REGISTER' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Add here a paragraph of the function description
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='RFILE' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Add here a paragraph of the function description
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='RICC' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
This block computes the solution of riccati equation using different method and for both case continuous and discrete.</P>
<P> The riccati equation in continuous time is:</P>
<P>     A*X+X*A+C-X*D*X=0 </P>
<P> The riccati equation in discrete time is:</P>
<P>     A*X*(inv(In-D))*A-X+C=0</P>
<P> where A is an NxN matrix, it is the first input of the block, C and D are two NxN symetrics matrices and are respectivly the second and third input of the RICC block. X represent the output of the block, it is also a NxN matrix.</P>
<P>the user can choose between two methods of computation. For the continuous time he can use even the Schur method or the matrix sign function approach method, by setting the Model parameter to 1 or 2. For the discrete time, the models are the Schur method and the inverse free spectral decomposition method.
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='SAMPHOLD' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Add here a paragraph of the function description
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='SAT_f' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Add here a paragraph of the function description
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='SELECT_m' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Add here a paragraph of the function description
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='SINBLK_f' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Add here a paragraph of the function description
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='SLIDER_f' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Add here a paragraph of the function description
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='STEP' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Add here a paragraph of the function description
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='SUBMAT' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
This block outputs a sub matrix of the input matrix. The output matrix will be defining by using the parameters of this block.
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='SWITCH2_m' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Add here a paragraph of the function description
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='SineVoltage' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Add here a paragraph of the function description
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='TANBLK_f' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Add here a paragraph of the function description
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='TCLSS' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Add here a paragraph of the function description
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='TRASH_f' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Add here a paragraph of the function description
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='WFILE' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Add here a paragraph of the function description
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='generic_block' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Add here a paragraph of the function description
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='DOLLAR' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Add here a paragraph of the function description
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='DOLLAR_m' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Add here a paragraph of the function description
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='BITCLEAR' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
This blocks set the specified bit of the integer input to 0. The user can specify the bit in the field:"index of bit". Bit 0 is the least significant bit.
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='BITSET' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
This blocks set the specified bit of the integer input to 1. The user can specify the bit in the field:"index of bit". Bit 0 is the least significant bit.

</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='CONVERT' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
This block converts an input signal of any data type to a specified data type. The input can be real, complex or integer. When the output is an integer and when overflow occurs the block three different forms of results:</P>
<P>1- A normal non saturated result.</P>
<P>2- A saturated result.</P>
<P>3- An error message warning the user about the overflow..</P>
<P> The user can select one of these three forms by setting the "DO ON OVERFLOW" field to 0,1 or 2.</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='EXTRACTBITS' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
This block outputs a contiguous selection of bits from the input integer number.The Bits to extract defines the method by which the user select the output bits.</P>
<P>1- When "Upper Half" is selected the block outputs the half of the input that contain the most significant bit. In this case the third parameter "number of bits or index of bit" is ignored.</P>
<P>2- When "Lower Half" is selected the block outputs the half of the input that contain the least significant bit. In this case the third parameter "number of bits or index of bit" is ignored.</P>
<P>3- When "Range starting with most significant bit" is selected the block outputs certain number of bits of the input that contain the most significant bit. In this case the third parameter "number of bits or index of bit" defines the number of bits to extract.</P>
<P>4- When "Range ending with least significant bit" is selected the block outputs certain number of bits of the input that contain the least significant bit. In this case the third parameter "number of bits or index of bit" defines the number of bits to extract.</P>
<P>5- When "Range of bits" is selected the block outputs a range of bits of the input. In this case the third parameter "number of bits or index of bit" defines the range of bits to extract, it must be a vector with the format [start,end].</P>
<P> The extracted value depends on the forth parameter "Treat bit field as an integer". When it is set to 0 the input scaling is used to determine the output scaling. When it is set to 1, only the extracted bits forms the output number.
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='GAINBLK_m' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Add here a paragraph of the function description
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='INTGAINBLK' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
The INTGAINBLK computes the product of a square matrix A by the input matrix U, where the number of rows/cols of A is equal to the number of rows of U. The input/output datatype is defined by the type of the Gain matrix A, it can take all the integer's datatype.
For double or complex datatype use the GAINBLK in the Linear palette.
On overflow, the result can take different forms:</P>
<P>1- A normal non saturated result.</P>
<P>2- A saturated result.</P>
<P>3- An error message warning the user about the overflow.</P>
<P> The user can select one of these three forms by setting the "DO ON OVERFLOW" field to 0,1 or 2.
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='INTLOGICAL_OP' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
This block computes the logical operations "AND", "OR", "NAND", "NOR", "XOR" and "NOT", for integers inputs. The user can select the operator due to the third arguments "Operator". The user can choose between two outputs forms using the bitwise rule. When it is set to zero the logical operation consider the non zero positif number as logical "1", and the others as logical "0", the output will be a logical number (boolean). Otherwise, the logical operation is done bit by bit. The output will be an integer number.
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='INTMUL' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
The INTMUL block computes the matrix multiplication of two integers inputs matrices.The number of rows of the second matrix must be equal to the number of columns of the first matrix. The output is a matrix where the number of rows is equal to the number of rows of the first input matrix and the number of columns is equal to the number of columns of the second input matrix. This block support all the integer data type.</P>
<P> On overflow, the result can take different forms:</P>
<P>1- A normal non saturated result.</P>
<P>2- A saturated result.</P>
<P>3- An error message warning the user about the overflow.</P>
<P> The user can select one of these three forms by setting the "DO ON OVERFLOW" field to 0,1 or 2.
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='INTREGISTER' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
This block realizes a shift register. At every input event, the register is shifted one step. This block support the integers data types.
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='Integer_pal' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Add here a paragraph of the function description
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='RAND_m' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Add here a paragraph of the function description
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='RELATIONAL_OP' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
This blocks compare two integer input values/matrices. The output is "0" or "1".
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='RELAY_m' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Add here a paragraph of the function description
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='SAMPHOLD_m' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Add here a paragraph of the function description
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='SHIFT' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
This block shifts the bits of the input signal. In this operation the digits are moved to the right or to the left.
The user can choose the rule to shifts the bits. It can be normal or cycle by setting the "Shifttype" parameter to "0" or "1".</P>
<P>When the Shifttype is 0, an arithmetic shift is applied to the input signal. In this case, the bits that are shifted out of either end are discarded. Zeros are shifted in on the right, in the case of left shift; in the case of right shifts, copies of the sign bit is shifted in on the left.</P>
<P>When the "Shifttype" is 1,a circular shift is applied to the input signal. In this case, the bits are rotated as if the left and right ends of the register are joined. The value that is shifted in on the right during a left-shift is whatever values was shifted out on the left, and vice versa.
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='SQRT' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
This block computes the square root of each element of the input matrix. It supported real and complex data types.
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='SUMMATIONI' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
This block computes the matrix summation/substraction of the inputs matrices. The number of inputs is given by the second parameter. This parameter can be a vector of +1 and -1 or it can be a positif value. In the first case the size of the vector indicates the number of inputs and the signs indicates whether it is a summation or a substraction. In the second case, the block is a summation block and the value indicates the number of inputs.</P>
<P>On overflow, the result can take different forms:</P>
<P>1- A normal non saturated result.</P>
<P>2- A saturated result.</P>
<P>3- An error message warning the user about the overflow.</P>
<P> The user can select one of these three forms by setting the "DO ON OVERFLOW" field to 0,1 or 2.
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='DFLIPFLOP' type='LATEX'>
The DFLIPFLOP block outputs the input state when the enable is set and on the rising edge of the clock. The input is D the enable is en and the clock is clk. Q and !Q are the outputs of this block. This block is almostly used with digital number, the input data type is int8.\\

The truth table of this block is
\begin{tabular}{|c|c||c|c|}
\hline
en&
D&
Q&
!Q\\
\hline
0&
0&
0&
1\\
\hline
0&
1&
0&
1\\
\hline
1&
0&
0&
1\\
\hline
1&
1&
1&
0\\
\hline
\end{tabular}
</FILE>

<FILE name='DLATCH' type='LATEX'>
This block outputs the input state when the input gate is high. The input is D the enable is C. Q and !Q are the outputs of this block.
This block is almostly used with digital number, the input data type is int8.\\

The truth table of this block is

\begin{tabular}{|c|c||c|c|}
\hline
C&
D&
Q&
!Q\\
\hline
0&
0&
0&
1\\
\hline 
0&
1&
0&
1\\
\hline 
1&
0&
0&
1\\
\hline 
1&
1&
1&
0\\
\hline
\end{tabular}
</FILE>

<FILE name='DLATCH1' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Add here a paragraph of the function description
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='EXPBLK_m' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Add here a paragraph of the function description
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='INVBLK_m' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Add here a paragraph of the function description
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='JKFLIPFLOP' type='LATEX'>
The JK flip flop is the most versatile of the basic flip-flops. It has two inputs traditionaly labeled J and K. When J and K are different, the output takes the value of J at the next falling edge. When J and K are both low, no change occurs in the output state, when they are both high the output will toggle from one state to other. It can perform the functions of the set/reset flip-flop and has the advantage that there are no ambiguous states. It can also act as a T flip-flop to accomplish toggling action if J and K are tied together. This toggle application finds extensive use in binary counters.This block is almostly used with digital number, the input data type is int8.\\

The truth table of this block is

\begin{tabular}{|c|c||c|c|}
\hline
J&
K&
Q(t)&
!Q(t)\\
\hline
0&
0&
Q(t-1)&
!Q(t-1)\\
\hline
0&
1&
0&
1\\
\hline
1&
0&
1&
0\\
\hline
1&
1&
!Q(t-1)&
Q(t-1)\\
\hline
\end{tabular}
</FILE>

<FILE name='LOGIC' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
This block implements a standard truth table for modeling programming array, digital circuit and any other boolean expressions.
The user can specify a matrix that defines all the possible block output in the Truth table field. Each row of the matrix contains the output of different combination of input elements. The number of rows must be a power of two, it defines the number of inputs using the equation:</P>
<P> nomber of row = 2 ^ (number of input)</P>
<P> The number of outputs is equal to the number of columns of the matrix.</P>
<P> This block support only the int8 data type. When the input is positif, the input is considered as logical 1, When it is negatif or zero it is considered as logical 0.</P>
<P> This block can be activated by an implicit input event or it can herit the clock from the regular input.</P>
<P> This block is used to implement SR and JK flip-flops.
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='SRFLIPFLOP' type='LATEX'>
This block describe the simplest and the most fundamental latch the SR flip flop. Where S and R are the input and Q and !Q are the outputs.If S (Set) is pulsed high while R is held low, then the Q output is forced high, and stays high when S returns low; similarly, if R (Reset) is pulsed high while S is held low, then the Q output is forced low, and stays low when R returns low. When both are low, Q(t) takes the same state as Q(t-1). When they are both high, both Q and !Q take the low values we are in an unstable state. Practicaly we have to avoid this case.This block is almostly used with digital number, the input data type is int8.\\

The truth table of this block is

\begin{tabular}{|c|c||c|c|}
\hline
S&
R&
Q(t)&
!Q(t)\\
\hline
0&
0&
Q(t-1)&
!Q(t-1)\\
\hline
0&
1&
0&
1\\
\hline
1&
0&
1&
0\\
\hline
1&
1&
0&
0\\
\hline --> This case is to avoid
\end{tabular}
</FILE>

<FILE name='BITCLEAR1' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Add here a paragraph of the function description
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='BOUNCE' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Add here a paragraph of the function description
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='BOUNCEXY' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Add here a paragraph of the function description
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='CLOCK_c' type='LATEX'>
This block is a Super Block constructed by feeding back the output of
an event delay block into its input event port. The unique output of
this block generates a regular train of events.
</FILE>

<FILE name='DLOGICAL_OP' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Add here a paragraph of the function description
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='DelayRE' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Add here a paragraph of the function description
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='Div' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Add here a paragraph of the function description
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='EDGETRIGGER' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Add here a paragraph of the function description
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='EVTDLY_c' type='LATEX'>
One event is generated  {\bf Delay}  after an event enters the unique
input event port. Block may also generate an initial output event.
The event date of that block is computed by the formula :
\begin{eqnarray}
 t_{i}&=&t_{\rm{init}} + i * T_{\rm{delay}},
\end{eqnarray}
where $t_{\rm{init}}$ the date of initial output event, $T_{\rm{delay}}$ the delay and $i$ and internal integer discrete counter.
</FILE>

<FILE name='FROM' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
The main role of the GOTO/FROM blocks is to transport signals from a block to another block without connecting them physically.The FROM block transports its received data (from the correponding GOTO) to its output. Multiples FROM blocks can receive data from one GOTO, although a GOTO can send data to multiple FROM.</P>
<P> The GOTO and FROM blocks are connected by the tag parameter.</P>
<P> For information on the visibility and limitation of these blocks please refer to the GOTO documentation.</P>
<P> This block can support all the data types.
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='GOTO' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
The main role of the GOTO/FROM blocks is to transport signals from a block to another block without connecting them physically. The GOTO block transports its input data to its corresponding FROM block. A simple GOTO block can send data to multiple FROM, although a FROM can receive data from only one GOTO.</P>
<P> The GOTO and FROM blocks are connected by the tag parameter.</P>
<P> The "Tag Visibility" parameter indicates if the location of the FROM block is limitted:</P>
<P> - Local : means that the corresponding FROM of that GOTO must be in the same subsystem.</P>
<P> - Scoped: means that the corresponding FROM of that GOTO must be in the same subsystem or in any subsystem below the GotoTagVisibility block in the model hierarchy</P>
<P> - Global: means that the corresponding FROM of that GOTO can be anywhere in the model.</P>
<P> This block can support all the data types.
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='GotoTagVisibility' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
This block defines the accessibility of the GOTO block when it is configure as "scoped". The FROM block corresponding to that GOTO must be in the same subsystem of the GotoTagVisibility or in subsystems below it in the model hierarchy.
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='IMPSPLIT_f' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Add here a paragraph of the function description
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='JKFLIPFLOP1' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Add here a paragraph of the function description
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='Neg' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Add here a paragraph of the function description
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='PID' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Add here a paragraph of the function description
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='ROOTCOEF' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Add here a paragraph of the function description
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='SETW' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Add here a paragraph of the function description
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='SPLIT_f' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Add here a paragraph of the function description
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='SRFLIPFLOP1' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Add here a paragraph of the function description
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='func_block' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Add here a paragraph of the function description
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='scifunc_block_m' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Add here a paragraph of the function description
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='CLKFROM' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
This block is used to connect events ports. For more information on how it works please refer to the documentation of the FROM block by clicking on the link in the "See also" field.
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='CLKGOTO' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
This block is used to connect events ports. For more information on how it works please refer to the documentation of the GOTO block by clicking on the link in the "See also" field.
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='CLKGotoTagVisibility' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
This block is used in the event case. For more information on how it works please refer to the documentation of the GotoTagVisibility block by clicking on the link in the "See also" field.
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='FROMMO' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
This block is used to connect modelica's blocks. For more information on how it works please refer to the documentation of the FROM block by clicking on the link in th "See also" field.
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='GOTOMO' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
This block is used to connect modelica's blocks. For more information on how it works please refer to the documentation of the GOTO block by clicking on the link in the "See also" field.
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='GotoTagVisibilityMO' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
This block is used in case of modelica's connection. For more information on how it works please refer to the GotoTagVisibility block by clicking on the link in the "See also" field.
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='CURVE_c' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Add here a paragraph of the function description
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='Counter' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
This block counts from minimal to maximal or from maximal to minimal depending on the choice of the rule.
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='M_freq' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
This blocks generates events at specific sample time of the simulation time. The sample time is given in the "Sample Time" field and the offset is given in the "Offset" field. This block has one event input, the number of event outputs depends on the number of different sample time. For exemple if the vector of sample time is [1 1 2] and the vector of offset is [0 .5 0] then the block has 7 outputs.</P>
<P> - The first output is activated when the simulation time is equal to a multiple of the first sample time plus the first offset</P>
<P> - The second output is activated when the simulation time is equal to a multiple of the second sample time plus the second offset.</P>
<P> - The third output is activated when we have both cases, first case and second case.</P>
<P> - The fourth output is activated when the simulation time is equal to a multiple of the third sample time plus the third offset.</P>
<P> - The fifth output is activated when we have both cases, first case and forth case.</P>
<P> - The sixth output is activated when we have both cases, second case and fourth case.</P>
<P> - The seventh output is activated when we have both cases, third case and forth case.</P>
<P> etc...</P>
<P> So the number of outputs is equal to 2**number of differents time values. Each of these time values is represented by a binary number associated to the output's number in decimal.</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='SampleCLK' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
The difference between the SampleCLK and the CLOCK_c is that all the SampleCLK blocks in our diagram are synchronous. The synchronism is done due to two differents methods of computation in the compilation phase.</P>
<P>The first method consists of computing a clock that is faster than all the SampleCLK connected to a counter which activate the event select block.</P>
<P> The clock is calculated due to the following rule.</P>
<P> If all the blocks have the same offset then the frequency of the clock is the gcd of the sample time, and the offset of the clock is equal to the offset.</P>
<P> If the offsets are differents, then the frequency of the clock is the gcd of the sample time and the offset, and the offset of the clock is equal to 0.</P>
<P> The Counter counts from one to the least commun multiple of the sample time (lcm).</P>
<P> The number of outputs of the ESELECT_f block is equal to the lcm.</P>
<P>The second method uses the Multifrequency block it generates events only for specific time. Events in this method are not periodicly generated as in the first one.
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='Sigbuilder' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Add here a paragraph of the function description
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='GAINBLK' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
The GAINBLK computes the product of a square matrix A by the input matrix U, where the number of rows/cols of A is equal to the number of rows of U. The input/output datatype is defined by the type of the Gain matrix A, it can take all the integer's datatype.
On overflow, the result can take different forms:</P>
<P>1- A normal non saturated result.</P>
<P>2- A saturated result.</P>
<P>3- An error message warning the user about the overflow.</P>
<P> The user can select one of these three forms by setting the "DO ON OVERFLOW" field to 0,1 or 2.
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='SUMMATION' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
The Sum block performs addition or subtraction on its inputs. This block can add or subtract scalar, vector, or matrix inputs. It can also collapse the elements of a single input vector.</P>
<P>The number of inputs is given by the second parameter. This parameter can be a vector of +1 and -1 or it can be a positif value. In the first case the size of the vector indicates the number of inputs and the signs indicates whether it is a summation or a substraction. In the second case, the block is a summation block and the value indicates the number of inputs.</P>
<P>On overflow, the result can take different forms:</P>
<P>1- A normal non saturated result.</P>
<P>2- A saturated result.</P>
<P>3- An error message warning the user about the overflow.</P>
<P> The user can select one of these three forms by setting the "DO ON OVERFLOW" field to 0,1 or 2.
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

</DATA>
