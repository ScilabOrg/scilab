<?xml version="1.0" encoding="UTF-8"?>
<!--
 * Scilab ( http://www.scilab.org/ ) - This file is part of Scilab
 * Copyright (C) 2008 - INRIA
 * 
 * This file must be used under the terms of the CeCILL.
 * This source file is licensed as described in the file COPYING, which
 * you should have received as part of this distribution.  The terms
 * are also available at    
 * http://www.cecill.info/licences/Licence_CeCILL_V2-en.txt
 *
 -->
<refentry xmlns="http://docbook.org/ns/docbook" 
	  xmlns:xlink="http://www.w3.org/1999/xlink" 
	  xmlns:svg="http://www.w3.org/2000/svg" 
	  xmlns:mml="http://www.w3.org/1998/Math/MathML" 
	  xmlns:db="http://docbook.org/ns/docbook" 
	  version="5.0-subset Scilab" xml:lang="fr" xml:id="grand">

  <refnamediv>
    <refname>grand</refname>
    <refpurpose> Générateur(s) de nombres pseudo-aléatoires</refpurpose>
  </refnamediv>
  <refsynopsisdiv>
    <title>Séquence d'appel</title>
    <synopsis>Y=grand(m, n, dist_type [,p1,...,pk])
      Y=grand(X, dist_type [,p1,...,pk])
      Y=grand(n, dist_type [,p1,...,pk])
      S=grand(action [,q1,....,ql])</synopsis>
  </refsynopsisdiv>
  <refsection>
    <title>Paramètres</title>
    <variablelist>
      <varlistentry>
	<term>m, n</term>
	<listitem>
	  <para>entiers, dimensions de la matrice de nombres aléatoires à obtenir <literal>Y</literal>
          </para>
	</listitem>
      </varlistentry>
      <varlistentry>
	<term>X </term>
	<listitem>
	  <para>une matrice (ou un vecteur) dont seules les dimensions (<literal>m x n</literal>) sont utilisées
          </para>
	</listitem>
      </varlistentry>
      <varlistentry>
	<term>dist_type</term>
	<listitem>
	  <para>chaîne de caractères donnant la loi de distribution des nombres aléatoires ('bin', 'nor', 'poi', etc ...)
          </para>
	</listitem>
      </varlistentry>
      <varlistentry>
	<term>p1, ..., pk</term>
	<listitem>
	  <para>les (éventuels) paramètres de la distribution <literal>dist_type</literal>
          </para>
	</listitem>
      </varlistentry>
      <varlistentry>
	<term>Y</term>
	<listitem>
	  <para>la matrice de nombres aléatoires <literal>m x n</literal>
          </para>
	</listitem>
      </varlistentry>
      <varlistentry>
	<term>action</term>
	<listitem>
	  <para>chaîne de caractères spécifiant l'action à entreprendre sur le générateur de base ('setgen' pour changer
            le générateur courant, 'getgen' pour obtenir le nom du générateur courant, 'getsd' pour obtenir l'état
            du générateur courant, etc...).
          </para>
	</listitem>
      </varlistentry>
      <varlistentry>
	<term>q1, ..., ql</term>
	<listitem>
	  <para>les paramètres	(éventuels) de l'action à effectuer sur le générateur de base.
          </para>
	</listitem>
      </varlistentry>
      <varlistentry>
	<term>S</term>
	<listitem>
	  <para>résultat de l'action (en général une chaîne ou un vecteur colonne)
          </para>
	</listitem>
      </varlistentry>
    </variablelist>
  </refsection>
  <refsection>
    <title>Description</title>

    <para>Attention: sans souche, la séquence générée restera la même
      d'une session à l'autre.</para>
    <para>Au début de chaque script utilisant la fonction rand, vous
    devriez utiliser:</para>
    <programlisting role="example"><![CDATA[rand('seed',getdate('s'))]]></programlisting>

    <para>
      Cette fonction peut être utilisée pour générer des nombres pseudo-aléatoires à partir
      d'une loi de distribution donnée (binomiale, uniforme, normale,...) : ces nombres peuvent
      être considérés comme des réalisations de variables aléatoires indépendantes qui suivent
      la loi donnée. Dans ce cas vous devez appliquer l'une des <emphasis>trois premières séquences 
        d'appel</emphasis> pour obtenir une matrice <literal>m x n</literal> de tels nombres. La deuxième 
      séquence est équivalente à la première si <literal>X</literal> est une matrice <literal>m x n</literal> 
      et la troisième forme s'applique lorsque la loi est vectorielle (comme la loi multinomiale) :
      une réalisation correspond alors à un vecteur colonne (de dimension <literal>m</literal>) et 
      l'on obtient ainsi <literal>n</literal> réalisations sous la forme d'une matrice
      <literal>m x n</literal>. 
      
    </para>
    <para><emphasis>La dernière forme d'appel</emphasis> s'utilise pour entreprendre diverses actions sur 
      le générateur de base (depuis la version 2.7 vous pouvez choisir parmi plusieurs 
      générateurs comme Mersenne-Twister, KISS, clcg4, ...). Ces générateurs fournissent 
      des entiers selon une loi uniforme sur un intervalle très grand (distribution lgi), 
      les autres types de lois s'obtenant à partir de ces générateurs de base 
      (en général suivant un schéma lgi -&gt; U([0,1)) -&gt; distribution cherchée).
    </para>
  </refsection>
  <refsection>
    <title>Générer des nombres aléatoires selon une loi donnée</title>
    <variablelist>
      <varlistentry>
	<term>beta</term>
	<listitem>
	  <para>   : <literal>Y=grand(m,n,'bet',A,B)</literal> génère des nombres aléatoires suivant 
            la loi beta de paramètres <literal>A</literal> and <literal>B</literal>. 
            La densité de cette loi est (<literal>0 &lt; x &lt; 1</literal>) :</para>
	  <programlisting role=""><![CDATA[ 
 A-1	B-1
x   (1-x)   / beta(A,B)	 ( beta(A,B) = gamma(A+B) / (gamma(A) gamma(B)) )
 ]]></programlisting>
	  <para><literal>A</literal> et <literal>B</literal> devant être des réels &gt; 10^(-37).
            Fonction(s) associée(s) : <link linkend="cdfbet">cdfbet</link>.</para>
	</listitem>
      </varlistentry>
      <varlistentry>
	<term>binomiale</term>
	<listitem>
	  <para>   : <literal>Y=grand(m,n,'bin',N,p)</literal>	génère des nombres aléatoires suivant la loi
            binomiale de paramètres <literal>N</literal> (entier str. positif) et <literal>p</literal>
            (réel de [0,1]) : nombre de succès au cours de <literal>N</literal> épreuves de Bernouilli
            de probabilité de succès <literal>p</literal>.
            Fonction(s) associée(s) : <link linkend="binomial">binomial</link>, <link linkend="cdfbin">cdfbin</link>.</para>
	</listitem>
      </varlistentry>
      <varlistentry>
	<term>binomiale négative</term>
	<listitem>
	  <para>   : <literal>Y=grand(m,n,'nbn',N,p)</literal> génère des nombres aléatoires suivant la loi binomiale
            négative de paramètres <literal>N</literal> (entier str. positif) et <literal>p</literal> (réel 
            de ]0,1[) : nombre d'échecs avant d'obtenir <literal>N</literal> succès dans des épreuves
            de Bernouilli de probabilité de succès <literal>p</literal>.
            Fonction(s) associée(s) : <link linkend="cdfnbn">cdfnbn</link>.</para>
	</listitem>
      </varlistentry>
      <varlistentry>
	<term>chi 2</term>
	<listitem>
	  <para>   : <literal>Y=grand(m,n,'chi', Df)</literal> génère des nombres aléatoires suivant la loi du chi 2
            à <literal>Df</literal> (réel &gt; 0.0) degrés de liberté. 
            Fonction(s) associée(s) : <link linkend="cdfchi">cdfchi</link>.</para>
	</listitem>
      </varlistentry>
      <varlistentry>
	<term>chi 2 non centrée</term>
	<listitem>
	  <para>   : <literal>Y=grand(m,n,'nch',Df,Xnon)</literal> génère des nombres aléatoires suivant la loi du chi 2
            non centrée à <literal>Df</literal> degrés de liberté (réel &gt;= 1.0) 
            le paramètre de décentrage étant <literal>Xnonc</literal> (réel &gt;= 0.0).
            Fonction(s) associée(s) : <link linkend="cdfchn">cdfchn</link>.</para>
	</listitem>
      </varlistentry>
      <varlistentry>
	<term>exponentielle</term>
	<listitem>
	  <para>   : <literal>Y=grand(m,n,'exp',Av)</literal> génère des nombres aléatoires suivant la loi exponentielle
            de moyenne <literal>Av</literal> (réel &gt;= 0.0).</para>
	</listitem>
      </varlistentry>
      <varlistentry>
	<term>F variance ratio</term>
	<listitem>
	  <para>   : <literal>Y=grand(m,n,'f',Dfn,Dfd)</literal> génère des nombres aléatoires suivant la loi F 
            (variance ratio) à <literal>Dfn</literal> (réel &gt; 0.0) degrés de liberté au numérateur et
            <literal>Dfd</literal> (réel &gt; 0.0) degrés de liberté au dénominateur.
            Fonction(s) associée(s) : <link linkend="cdff">cdff</link>.</para>
	</listitem>
      </varlistentry>
      <varlistentry>
	<term>non central F variance ratio</term>
	<listitem>
	  <para>   : <literal>Y=grand(m,n,'nf',Dfn,Dfd,Xnon)</literal> génère des nombres aléatoires suivant la loi 
            F (variance ratio) non centrée à <literal>Dfn</literal> (réel &gt;= 1) degrés de liberté 
            au numérateur, et <literal>Dfd</literal> (réel &gt; 0) degrés de liberté au dénominateur, 
            <literal>Xnonc</literal> (réel &gt;= 0) étant le paramètre de décentrage. 
            Fonction(s) associée(s) : <link linkend="cdffnc">cdffnc</link>.  </para>
	</listitem>
      </varlistentry>
      <varlistentry>
	<term>gamma</term>
	<listitem>
	  <para>   : <literal>Y=grand(m,n,'gam',shape,scale)</literal> génère des nombres aléatoires suivant la loi
            gamma de paramètres <literal>shape</literal> (réel &gt; 0) et <literal>scale</literal> 
            (réel &gt; 0). La densité est :</para>
	  <programlisting role=""><![CDATA[ 
     shape  (shape-1)	-scale x
scale	    x	       e	  /  gamma(shape)
 ]]></programlisting>
	  <para>Fonction(s) associée(s) : <link linkend="gamma">gamma</link>, <link linkend="cdfgam">cdfgam</link>.</para>
	</listitem>
      </varlistentry>
      <varlistentry>
	<term>Gauss Laplace (normale)</term>
	<listitem>
	  <para>   : <literal>Y=grand(m,n,'nor',Av,Sd)</literal> génère des nombres aléatoires suivant la loi normale 
            de moyenne <literal>Av</literal> (réel) et d'écart type <literal>Sd</literal>
            (réel &gt;= 0).
            Fonction(s) associée(s) : <link linkend="cdfnor">cdfnor</link>, <link linkend="erf">erf</link>.</para>
	</listitem>
      </varlistentry>
      <varlistentry>
	<term>multi normale</term>
	<listitem>
	  <para>   : <literal>Y=grand(n,'mn',Mean,Cov)</literal> génère <literal>n</literal> réalisations indépendantes de la
            loi multi-normale ; <literal>Mean</literal> doit être un vecteur <literal>m x 1</literal> et <literal>Cov</literal> 
            une matrice <literal>m x m</literal> symétrique et définie positive, (<literal>Y</literal> est alors une
            matrice <literal>m x n</literal>).</para>
	</listitem>
      </varlistentry>
      <varlistentry>
	<term>geometrique</term>
	<listitem>
	  <para> : <literal>Y=grand(m,n,'geom', p)</literal>
	    génère des nombres aléatoires suivant la loi
	    geométrique de paramètre <literal>p</literal> : nombre
	    d'épreuves de Bernouilli (de probabilité de succès
	    <literal>p</literal>) jusqu'à obtenir un succès
	    (<literal>p</literal> doit appartenir à l'intervalle
	    <literal>[pmin,1]</literal> (avec <literal>pmin = 1.3
	      10^(-307)</literal>).</para>
	  <para><literal>Y</literal> contient des nombres réels
	    positifs à valeur entière qui sont "le nombre de
	    tentatives nécessaire pour obtenir un succès" pour
	    chaque tirage.</para>
	</listitem>
      </varlistentry>
      <varlistentry>
	<term>markov</term>
	<listitem>
	  <para>   : <literal>Y=grand(n,'markov',P,x0)</literal> génère <literal>n</literal> états successifs d'une chaîne de 
            Markov décrite par la matrice de transition <literal>P</literal>. L'état initial est donné par 
            <literal>x0</literal>. Si <literal>x0</literal> est une matrice de taille 
            <literal>m=size(x0,'*')</literal> 
            alors <literal>Y</literal> est une matrice de taille <literal>m x n</literal>. <literal>Y(i,:)</literal> étant le
            chemin à partir de l'état initial <literal>x0(i)</literal>.</para>
	</listitem>
      </varlistentry>
      <varlistentry>
	<term>multinomiale</term>
	<listitem>
	  <para>   : <literal>Y=grand(n,'mul',nb,P)</literal> génère <literal>n</literal> réalisations indépendantes de la loi
            Multinomiale :  classer <literal>nb</literal> éventualités dans <literal>m</literal> catégories (mettre
            <literal>nb</literal> "boules" dans <literal>m</literal> "boites"). <literal>P(i)</literal> 
            étant la probabilité qu'une éventualité soit de categorie i. <literal>P</literal> le vecteur des
            probabilités est de taille <literal>m-1</literal> (la probabilté de la catégorie <literal>m</literal> 
            étant <literal>1-sum(P)</literal>). <literal>Y</literal> est alors de dimensions <literal>m x n</literal>, 
            chaque colonne <literal>Y(:,j)</literal> étant une réalisation de cette loi : <literal>Y(i,j)</literal> 
            est le nombre d'éventualités classées en catégorie <literal>i</literal> pour la <literal>j</literal> ème
            réalisation (<literal>sum(Y(:,j)) = nb</literal>).</para>
	</listitem>
      </varlistentry>
      <varlistentry>
	<term>Poisson</term>
	<listitem>
	  <para>   : <literal>Y=grand(m,n,'poi',mu)</literal> génère des nombres aléatoires suivant la loi de Poisson 
            de moyenne <literal>mu (réel &gt;= 0.0)</literal>.</para>
	</listitem>
      </varlistentry>
      <varlistentry>
	<term>permutations aléatoires</term>
	<listitem>
	  <para>   : <literal>Y=grand(n,'prm',vect)</literal> génère <literal>n</literal> permutations aléatoire du
            vecteur colonne (<literal>m x 1</literal>) <literal>vect</literal>.</para>
	</listitem>
      </varlistentry>
      <varlistentry>
	<term>uniforme (def)</term>
	<listitem>
	  <para>   : <literal>Y=grand(m,n,'def')</literal> génère des nombres aléatoires suivant la loi uniforme 
            sur <literal>[0,1[</literal> (1 n'est jamais retourné).</para>
	</listitem>
      </varlistentry>
      <varlistentry>
	<term>uniforme (unf)</term>
	<listitem>
	  <para>   : <literal>Y=grand(m,n,'unf',Low,High)</literal> génère des nombres aléatoires suivant la loi 
            uniforme sur <literal>[Low, High[</literal>.</para>
	</listitem>
      </varlistentry>
      <varlistentry>
	<term>uniforme (uin)</term>
	<listitem>
	  <para>   : <literal>Y=grand(m,n,'uin',Low,High)</literal> génère des entiers aléatoires suivant la loi uniforme
            sur <literal>[Low, High]</literal>. <literal>High</literal>
            et <literal>Low</literal> doivent être des entiers tels que <literal>(High-Low+1)
	      &lt; 2147483561</literal>.</para>
	</listitem>
      </varlistentry>
      <varlistentry>
	<term>uniforme (lgi)</term>
	<listitem>
	  <para> : <literal>Y=grand(m,n,'lgi')</literal> retourne la sortie du générateur de base courant : des entiers
            aléatoires suivant une loi uniforme sur :</para>
	  <itemizedlist>
	    <listitem>
	      <para><literal>[0, 2^32 - 1]</literal> for mt, kiss and fsultra</para>
	    </listitem>
	    <listitem>
	      <para><literal>[0, 2147483561]</literal> for clcg2</para>
	    </listitem>
	    <listitem>
	      <para><literal>[0, 2^31 - 2]</literal> for clcg4 </para>
	    </listitem>
	    <listitem>
	      <para><literal>[0, 2^31 - 1]</literal> for urand.</para>
	    </listitem>
	  </itemizedlist>
	</listitem>
      </varlistentry>
    </variablelist>
  </refsection>
  <refsection>
    <title>Actions sur le(s) générateur(s) de base</title>
    <para> Depuis Scilab-2.7 vous avez la possibilité de choisir parmi plusieurs générateurs de base
      (donnant des entiers aléatoires suivant la loi 'lgi') :
    </para>
    <variablelist>
      <varlistentry>
	<term>mt</term>
	<listitem>
	  <para>le Mersenne-Twister de M. Matsumoto and T. Nishimura, période d'environ <literal>2^19937</literal>, 
	    état interne donné par <literal>624</literal> entiers (plus un index); c'est le générateur  
	    par défaut.</para>
	</listitem>
      </varlistentry>
      <varlistentry>
	<term>kiss</term>
	<listitem>
	  <para>Le Keep It Simple Stupid de G. Marsaglia,  période d'environ <literal>2^123</literal>,
	    état interne donné par <literal>4</literal> entiers.</para>
	</listitem>
      </varlistentry>
      <varlistentry>
	<term>clcg2</term>
	<listitem>
	  <para>une combinaison de 2 générateurs linéaires congruentiels de P. L'Ecuyer,
	    période d'environ <literal>2^61</literal>, état interne donné par <literal>2</literal> entiers ; 
	    c'était le seul générateur de base utilisé auparavent par grand (cette
	    version est cependant légèrement différente de l'ancienne).</para>
	</listitem>
      </varlistentry>
      <varlistentry>
	<term>clcg4</term>
	<listitem>
	  <para>une combinaison de 4 générateurs linéaires congruentiels de P. L'Ecuyer,
	    période d'environ <literal>2^121</literal>, état interne donné par 4 entiers ; ce générateur
	    peut être partagé en <literal>101</literal> générateur virtuels (en fait la suite de 
	    longueur <literal>2^121</literal> peut être découpée en <literal>101</literal> sous-suites) ce qui peut
	    être utile dans certains cas (voir 'Actions specifiques à clcg4' et
	    'Exemple d'utilisation de clcg4').</para>
	</listitem>
      </varlistentry>
      <varlistentry>
	<term>urand</term>
	<listitem>
	  <para>le générateur de base (congruentiel affine...) utilisé par la fonction 
	    <link linkend="rand">rand</link>, état interne constitué d'un seul entier, période de 
	    <literal>2^31</literal> (basé sur le vol 2 du Art of Computer Science de Knuth).
	    C'est le plus rapide de cette liste mais il est maintenant dépassé : il est
	    préférable de ne pas l'utiliser pour une simulation sérieuse consommant
	    beaucoup de nombres aléatoires (en particulier ce générateur ne passe 
	    pas certains tests statistiques classiques).</para>
	</listitem>
      </varlistentry>
      <varlistentry>
	<term>fsultra</term>
	<listitem>
	  <para>un générateur SWB (subtract-with-borrow) mixé avec un générator congruentiel 
	    concu par Arif Zaman et George Marsaglia. Sa période est supérieure à <literal>10^356</literal>,
	    et son état interne est constitué d'un tableau de 37 entiers, d'un index sur
	    ce tableau et d'un drapeau (0 ou 1) ainsi qu'un autre entier donnant l'état interne
	    du générateur congruentiel.</para>
	</listitem>
      </varlistentry>
    </variablelist>
  </refsection>
  <refsection>
    <title>Actions</title>
    <variablelist>
      <varlistentry>
	<term>action= 'getgen'</term>
	<listitem>
	  <para>   : <literal>S=grand('getgen')</literal> retourne le nom du générateur de base actuel (<literal>S</literal> est
            l'une des chaînes de caractères 'mt', 'kiss', 'clcg2', 'clcg4', 'urand',
	    'fsultra').</para>
	</listitem>
      </varlistentry>
      <varlistentry>
	<term>action= 'setgen'</term>
	<listitem>
	  <para>   : <literal>grand('setgen',gen)</literal> permet de changer le générateur de base : <literal>gen</literal>
            doit être l'une des chaînes de caractères 'mt', 'kiss', 'clcg2', 'clcg4', 'urand', 'fsultra'.
            En cas de succès la fonction retourne cette même chaîne.</para>
	</listitem>
      </varlistentry>
      <varlistentry>
	<term>action= 'getsd'</term>
	<listitem>
	  <para>   : <literal>S=grand('getsd')</literal> retourne l'état interne actuel (les 'germes' dans l'ancienne 
            appelation quoique ce terme désigne plutôt l'état initial) du générateur de base courant ;
            <literal>S</literal> est un vecteur colonne (d'entiers) de dimension <literal>625</literal> 
            pour mt (la première composante étant un 'index' sur l'état, c-a-d un entier de l'intervalle
            <literal>[1,624]</literal>), <literal>4</literal> 
            pour kiss, <literal>2</literal> pour clcg2 , <literal>40</literal>pour fsultra, <literal>4</literal> pour clcg4 
            (pour ce dernier vous obtenez l'état interne du générateur virtuel courant), et <literal>1</literal> 
            pour urand.</para>
	</listitem>
      </varlistentry>
      <varlistentry>
	<term>action= 'setsd'</term>
	<listitem>
	  <para>   : <literal>grand('setsd',S), grand('setsd',s1[,s2,s3,s4])</literal> impose l'état interne du générateur de
            base courant : </para>
	  <variablelist>
	    <varlistentry>
	      <term>pour mt</term>
	      <listitem>
		<para><literal>S</literal> est un vecteur d'entiers de dimension <literal>625</literal> (la première composante
                  étant un index sur <literal>[1,624]</literal>), les <literal>624</literal> dernières composantes doivent 
                  être dans <literal>[0,2^32[</literal>) (mais ne doivent pas être toutes nulles) ; une initialisation
                  plus simple est possible (et recommandée) en donnant un seul entier <literal>s1</literal> (<literal>s1</literal> appartenant
                  à <literal>[0,2^32[</literal>) ;</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term>pour kiss</term>
	      <listitem>
		<para><literal>4</literal> entiers <literal>s1,s2, s3,s4</literal> dans <literal>[0,2^32[</literal> doivent être
                  fournis ;</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term>pour clcg2</term>
	      <listitem>
		<para><literal>2</literal> entiers <literal>s1</literal> dans <literal>[1,2147483562]</literal> et <literal>s2</literal> 
                  dans <literal>[1,2147483398]</literal> doivent être fournis ;</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term>pour clcg4</term>
	      <listitem>
		<para><literal>4</literal> entiers <literal>s1</literal> dans <literal>[1,2147483646]</literal>, <literal>s2</literal> 
                  dans <literal>[1,2147483542]</literal>, <literal>s3</literal> dans <literal>[1,2147483422]</literal>, 
                  <literal>s4</literal> dans <literal>[1,2147483322]</literal> sont requis ;
                  <literal>ATTENTION</literal> : avec clcg4 vous positionnez l'état interne du générateur virtuel
                  courant mais vous perdez alors la synchronisation avec les autres générateurs virtuels.
                  (=&gt; si vous utilisez clcg4 avec différents générateurs virtuels, il faut utiliser
                  l'option 'setall' qui permet de changer l'état interne (du générateur numéro 0) tout en
                  recalculant l'état initial des 100 autres générateurs virtuels).</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term>pour urand</term>
	      <listitem>
		<para><literal>1</literal> entier <literal>s1</literal> appartenant à
	          <literal>[0,2^31</literal>[ est requis.</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term>for fsultra</term>
	      <listitem>
		<para>	<literal>S</literal> est un vecteur de <literal>40</literal> entiers (son premier élément doit être dans
                  l'intervalle<literal>[0,37]</literal>, son deuxième (drapeau) doit être 0 ou 1, le troisième un
                  entier de [1,2^32[ et les 37 composantes suivantes, des entiers de [0,2^32[) ; il est recommandé
                  d'utiliser l'autre procédure d'initialisation (plus simple) avec deux entiers <literal>s1</literal> et 
                  <literal>s2</literal> de <literal>[0,2^32[</literal>.</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	</listitem>
      </varlistentry>
      <varlistentry>
	<term>action= 'phr2sd'</term>
	<listitem>
	  <para>   : <literal>Sd=grand('phr2sd', phrase)</literal> étant donnée une chaîne de caractères <literal>phrase</literal>
            cet appel retourne un vecteur <literal>1 x 2</literal> qui peut être utilisé comme
            état interne pour un générateur de base (initialement adapté pour clcg2).</para>
	</listitem>
      </varlistentry>
    </variablelist>
  </refsection>
  <refsection>
    <title>Options specifiques à clcg4</title>
    <para>
      Le générateur clcg4 peut être utilisé comme les autres mais il offre l'avantage de pouvoir être
      découpé en (<literal>101</literal>) générateurs virtuels différents, c-a-d avec des séquences sans
      intersection (quand vous utilisez un générateur classique vous pouvez changer l'état initial
      de façon à obtenir une autre séquence mais vous n'êtes pas complètement sûr d'obtenir une
      séquence complètement différente). Chaque générateur virtuel correspond à une séquence de 
      longueur <literal>2^72</literal> qui est de plus découpée en <literal>V=2^31</literal> segments de longueur
      <literal>W=2^41</literal>. Pour un générateur virtuel donné vous pouvez retourner au début de la séquence
      ou au début du segment ou bien au début du segment suivant. 
      Vous pouvez aussi changer l'état initial du générateur <literal>0</literal> avec l'option 
      'setall' qui recalcule l'état initial des autres générateurs virtuels de sorte à obtenir 
      la synchronisation entre les générateurs (c-a-d qu'en fonction du nouvel état initial du générateur
      <literal>0</literal> l'état initial des générateurs <literal>1..100</literal> sont recalculés de façon à
      obtenir <literal>101</literal> séquences qui ne s'intersectent pas).
    </para>
    <variablelist>
      <varlistentry>
	<term>action= 'setcgn'</term>
	<listitem>
	  <para>   : <literal>grand('setcgn',G)</literal> sélectionne le générateur virtuel numéro <literal>G</literal> :
            lorsque le générateur de base courant est clcg4, c'est le générateur virtuel <literal>G</literal>
            qui sera alors utilisé ; les <literal>101</literal> générateurs virtuels sont numérotés 
            <literal>0,1,..,100</literal> (ainsi <literal>G</literal> doit être un entier de l'intervalle
            <literal>[0,100]</literal>) ; par défaut le générateur virtuel courant est celui de numéro
            <literal>0</literal>.</para>
	</listitem>
      </varlistentry>
      <varlistentry>
	<term>action= 'getcgn'</term>
	<listitem>
	  <para>   : <literal>S=grand('getcgn')</literal> retourne le numéro du générateur
	    virtuel courant.</para>
	</listitem>
      </varlistentry>
      <varlistentry>
	<term>action= 'initgn'</term>
	<listitem>
	  <para> : <literal>grand('initgn',I)</literal> réinitialise l'état du générateur virtuel courant :</para>
	  <variablelist>
	    <varlistentry>
	      <term>I = -1</term>
	      <listitem>
		<para>remet l'état à sa valeur initiale</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term>I = 0</term>
	      <listitem>
		<para>remet l'état au début du segment courant</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term>I = 1</term>
	      <listitem>
		<para>positionne l'état au début du segment suivant et met à jour les valeurs définissant
	          le segment courant (vous ne pouvez pas revenir au début du segment précédent).</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	</listitem>
      </varlistentry>
      <varlistentry>
	<term>action= 'setall'</term>
	<listitem>
	  <para>   : <literal>grand('setall',s1,s2,s3,s4)</literal> impose l'état interne du générateur virtuel
            de numéro <literal>0</literal> à <literal>s1,s2,s3,s4</literal>. L'état initial des autres générateurs est
            alors reconstruit (de façon à obtenir 101 séquences qui ne s'intersectent pas). Voir 
            l'action 'setsd' pour les contraintes sur <literal>s1, s2, s3, s4</literal>.</para>
	</listitem>
      </varlistentry>
      <varlistentry>
	<term>action= 'advnst'</term>
	<listitem>
	  <para>   : <literal>grand('advnst',K)</literal> avance l'état du générateur virtuel courant de <literal>2^K</literal> 
            valeurs et réinitialise l'état initial (du générateur virtuel courant) à
	    ce nouvel état.</para>
	</listitem>
      </varlistentry>
    </variablelist>
  </refsection>
  <refsection>
    <title>Exemple d'utilisation de clcg4</title>
    <para>
      On cherche à comparer deux techniques statistiques sur des données de tailles différentes.
      La première, utilisant le 'bootstrapping' est supposée a priori aussi précise que
      la deuxième technique (utilisant uniquement la force brute) tout en utilisant moins 
      de données. Pour la première méthode, un ensemble de données de taille n1, uniformément
      distribuée entre 25 et 50 devra être généré puis analysé par la méthode.  Pour la
      seconde méthode, on procède de même avec une taille n2 à choisir entre 100 et 200. Ce processus
      est répété 1000 fois. Pour la réduction de la variance, on veut que les nombres aléatoires
      utilisés dans les deux méthodes soient les mêmes pour chacune des 1000 comparaisons.
      Comme la deuxième méthode utilise plus de nombres aléatoires, la synchronisation
      peut être difficile si l'on utilise un générateur classique. Avec un générateur 
      comme clcg4 c'est par contre très simple : utilisez le générateur 0 pour obtenir
      la taille n1 du jeux de données et le générateur 1 pour obtenir les données.
      Avec le générateur 0 tirer la taille n2 puis resélectionner le générateur 1 et revenez
      au début du segment courant pour obtenir les n2 données pour la deuxième méthode : ainsi
      les données initiales (les n1 premieres) sont les mêmes pour les deux méthodes.
      Pour la comparaison suivante, il suffit d'avancer le générateur 1 au segment suivant,
      etc, etc.
    </para>
  </refsection>
  <refsection>
    <title>Voir Aussi</title>
    <simplelist type="inline">
      <member>
	<link linkend="rand">rand</link>
      </member>
    </simplelist>
  </refsection>
  <refsection>
    <title>Auteurs</title>
    <variablelist>
      <varlistentry>
	<term>randlib</term>
	<listitem>
	  <para> Les codes qui permettent de générer les lois autres que def, unf, lgi,	 uin et geom 
            proviennent de "Library of Fortran Routines for Random Number  Generation", 
            de Barry W. Brown et James Lovato, Department of Biomathematics, The University of 
            Texas, Houston.</para>
	</listitem>
      </varlistentry>
      <varlistentry>
	<term>mt</term>
	<listitem>
	  <para> Le code est le mt19937int.c par M. Matsumoto and  T. Nishimura, "Mersenne Twister: 
            A 623-dimensionally equidistributed  uniform pseudorandom number generator", 
            ACM Trans. on Modeling and	 Computer Simulation Vol. 8, No. 1, January, pp.3-30 1998.</para>
	</listitem>
      </varlistentry>
      <varlistentry>
	<term>kiss</term>
	<listitem>
	  <para> Ce code a été donné par G. Marsaglia lors d'une discussion concernant la génération
            de nombres aléatoires en langage C dans plusieurs forums usenet (dont sci.math.num-analysis) 
            "My offer of  RNG's for C was an invitation to dance..." seul kiss a été
            inclus dans Scilab (kiss est construit à partir de plusieurs générateurs mais qui ne
            sont accessibles à l'interpréteur scilab).</para>
	</listitem>
      </varlistentry>
      <varlistentry>
	<term>clcg2</term>
	<listitem>
	  <para> Cette méthode est de P. L'Ecuyer mais le code C code provient de la page
            personnelle de Luc	 Devroye (http://cgm.cs.mcgill.ca/~luc/rng.html).</para>
	</listitem>
      </varlistentry>
      <varlistentry>
	<term>clcg4</term>
	<listitem>
	  <para> Ce code est de P. L'Ecuyer et Terry H.Andres et est distribué avec un article
            à partir de la page personnelle de P. L'Ecuyer 
            ( http://www.iro.umontreal.ca/~lecuyer/papers.html). Ce paquetage est le successeur 
            logique d'un plus ancien utilisant le générateur clcg2 (muni d'un mécanisme équivalent
            de générateurs virtuels) : P.  L'Ecuyer and S. Cote. Implementing a Random	  
            Number Package with Splitting Facilities.	ACM Transactions on Mathematical Software 
            17:1,pp 98-111.</para>
	</listitem>
      </varlistentry>
      <varlistentry>
	<term>fsultra</term>
	<listitem>
	  <para> un code d' Arif Zaman (arif@stat.fsu.edu) et de George Marsaglia (geo@stat.fsu.edu)</para>
	</listitem>
      </varlistentry>
      <varlistentry>
	<term>scilab packaging</term>
	<listitem>
	  <para> Par Jean-Philippe Chancelier et Bruno Pinçon</para>
	</listitem>
      </varlistentry>
    </variablelist>
  </refsection>
</refentry>
