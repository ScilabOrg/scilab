// Scilab ( http://www.scilab.org/ ) - This file is part of Scilab
// Copyright (C) 2010 - DIGITEO - Bernard HUGUENEY
//
// This file must be used under the terms of the CeCILL.
// This source file is licensed as described in the file COPYING, which
// you should have received as part of this distribution.  The terms
// are also available at
// http://www.cecill.info/licences/Licence_CeCILL_V2-en.txt
function make_compiled_function(name, ext, code)
filename=name+ext;
mputl(code, filename);
ilib_for_link(fun_name,filename,[],"c");
exec loader.sce;
mdelete(filename);
endfunction
fun_name='test_fun';
c_prog=['#include  <math.h>'
'void '+fun_name+'(void const* const* args, void *const* res) {'
'*((double*)*res)= 2.*(((double*)args[0])[0]);'
'}'];
make_compiled_function(fun_name, '.c',c_prog);
   Generate a loader file
   Generate a Makefile
   ilib_gen_Make: Copy compilation files (Makefile*, libtool...) to TMPDIR
   ilib_gen_Make: Copy test_fun.c to TMPDIR
   ilib_gen_Make: Modification of the Makefile in TMPDIR.
   Running the Makefile
   Generate a cleaner file
Shared archive loaded.
Link done.
args=[1,2];
res=parallel_run(args,fun_name,1);
if res<>[2, 4] then bugmes();quit;end
function a= g(arg1); a=2*arg1; endfunction;
res=parallel_run(args, "g");
if res<>[2, 4] then bugmes();quit;end
fun_name='test_fun_2_1';
c_prog=['#include  <math.h>'
'void '+fun_name+'(double const* const* args, double ** res) {'
'res[0][0]= .5*args[0][0]; res[0][1]= .25*args[0][1];res[1][0]= 2*args[1][0];'
'}'];
make_compiled_function(fun_name, '.c',c_prog);
   Generate a loader file
   Generate a Makefile
   ilib_gen_Make: Copy compilation files (Makefile*, libtool...) to TMPDIR
   ilib_gen_Make: Copy test_fun_2_1.c to TMPDIR
   ilib_gen_Make: Modification of the Makefile in TMPDIR.
   Running the Makefile
   Generate a cleaner file
Shared archive loaded.
Link done.
arg1=[1,2;4,5]; arg2=[2,3];
[res1, res2] =parallel_run(arg1, arg2,fun_name,"constant", [2;1]);
if res1<>[.5,1;1,1.25]  then bugmes();quit;end
if res2 <>[4,6]  then bugmes();quit;end
function [a,b]= f(arg1, arg2); a=arg1'.*[.5,.25]; b=2*arg2; endfunction;
[res1, res2] =parallel_run(arg1, arg2,"f","constant", [2;1]);
if res1<>[.5,1;1,1.25]  then bugmes();quit;end
if res2 <>[4,6]  then bugmes();quit;end
arg1=[1,2;4,5]; arg2=[2];
[res1, res2] =parallel_run(arg1, arg2,fun_name,"constant", [2;1]);
if res1<>[.5,1;1,1.25]  then bugmes();quit;end
if res2 <>[4,4]  then bugmes();quit;end
function [a,b]= f(arg1, arg2); a=arg1'.*[.5,.25]; b=2*arg2; endfunction;
[res1, res2] =parallel_run(arg1, arg2,"f","constant", [2;1]);
if res1<>[.5,1;1,1.25]  then bugmes();quit;end
if res2 <>[4,4]  then bugmes();quit;end
function [r_min, r_med, r_max]= min_med_max(a, b, c)
  r_min=min(a,b,c); r_med=median([a,b,c]); r_max=max(a,b,c);
endfunction
N=10;
A=rand(1:N);B=rand(1:N);C=rand(1:N);
Min=zeros(N); Med=Min; Max=Min;
for i =1:N
  [Min(i), Med(i), Max(i)]= min_med_max(A(i), B(i), C(i));
end;
[Min_mc,Med_mc,Max_mc]=parallel_run(A,B,C,"min_med_max");
if max(max(Min-Min_mc', Med-Med_mc',Max-Max_mc')) > %eps  then bugmes();quit;end
fun_name='min_med_max_cxx';
c_prog=['#include <algorithm>'
'extern ""C""{'
'void '+fun_name+'(void const*const* args, void*const* res) {'
'    double a(((double const*const*)args)[0][0]),b(((double const*const*)args)[1][0]),c(((double const*const*)args)[2][0]);'
'    if(b<a){ std::swap(a,b);}'
'    if(c<a){ std::swap(a,c);}'
'    if(c<b){ std::swap(b,c);}'
'    ((double*const*)res)[0][0]=a; ((double*const*)res)[1][0]=b; ((double*const*)res)[2][0]= c;'
'    return;'
'  }'
'}'];
make_compiled_function(fun_name, '.cxx',c_prog);
   Generate a loader file
   Generate a Makefile
   ilib_gen_Make: Copy compilation files (Makefile*, libtool...) to TMPDIR
   ilib_gen_Make: Copy min_med_max_cxx.cxx to TMPDIR
   ilib_gen_Make: Modification of the Makefile in TMPDIR.
   Running the Makefile
   Generate a cleaner file
Shared archive loaded.
Link done.
[Min_mc,Med_mc,Max_mc]=parallel_run(A,B,C, fun_name);
if max(max(Min-Min_mc', Med-Med_mc',Max-Max_mc')) > %eps  then bugmes();quit;end
function r= quantiles(data, ranks)
  tmp=gsort(data,'g','i');
  r=tmp(ranks);
endfunction
data=matrix(rand(1:N*N),N,N);
R4_6_7=matrix(zeros(1:3*N),N,3);
for i =1:N
  R4_6_7(i,:)= quantiles(data(i,:),[4,6,7]);
end;
R4_6_7_mc=parallel_run(data',[4,6,7]',"quantiles", 3)';
if max(R4_6_7-R4_6_7_mc)  > %eps  then bugmes();quit;end
fun_name='quantiles_cxx';
c_prog=['#include<algorithm>'
'extern ""C""{'
' void '+fun_name+ '(void const*const* args, void*const* res){'
'   double * data(((double *const*)args)[0]);'
'   int data_size(static_cast<int>(((double const*const*)args)[1][0]));'
'   double const* ranks(((double *const*)args)[2]);'
'   int ranks_size(static_cast<int>(((double *const*)args)[3][0]));'
'   std::sort(data,data+data_size);'
'   for(int i(0); i != ranks_size; ++i)'
'     { ((double*const*)res)[0][i]= data[static_cast<int>(ranks[i])-1]; }'
'   return;'
' }'
'}'];
make_compiled_function(fun_name, '.cxx',c_prog);
   Generate a loader file
   Generate a Makefile
   ilib_gen_Make: Copy compilation files (Makefile*, libtool...) to TMPDIR
   ilib_gen_Make: Copy quantiles_cxx.cxx to TMPDIR
   ilib_gen_Make: Modification of the Makefile in TMPDIR.
   Running the Makefile
   Generate a cleaner file
Shared archive loaded.
Link done.
R4_6_7_mc=parallel_run(data',N,[4,6,7]',3,fun_name, 3)';
if max(R4_6_7-R4_6_7_mc)  > %eps  then bugmes();quit;end
N=5; // size of a block
L=10; // number of blocks
data=spzeros(N*L,N*L);
for k=1:L
  kk=(k-1)*N+1:k*N;
  data(kk,kk)=matrix(rand(1:N*N),N,N);
end
function r= quantiles_sparse(indices_i, indices_j, ranks)
  tmp=gsort(full(data(indices_i, indices_j)),'g','i');
  r=tmp(ranks);
endfunction
R3_6_9=matrix(zeros(1:3*L),L,3);
for k=1:L
  kk=(k-1)*N+1:k*N;
  R3_6_9(k,:)=quantiles_sparse(kk,kk, [3,6,9])';
end;
idx=matrix(1:(L*N), N,L);
R3_6_9_mc=parallel_run(idx,idx,[3,6,9]',"quantiles_sparse",3)';
if max(R3_6_9-R3_6_9_mc) > %eps  then bugmes();quit;end
function r=block_invert(indices_i, indices_j)
  r=inv(full(data(indices_i, indices_j)));
endfunction
sp_inv=spones(data);
for k=1:L
  kk=(k-1)*N+1:k*N;
  sp_inv(kk,kk)=block_invert(kk,kk);
end;
sp_inv_1=sp_inv;
function r= invert_one_block(block_size,k)
  kk=(k-1)*block_size+1:k*block_size;
  r=full(inv(data(kk,kk)));// A from global scope
endfunction;
function blocks_to_sparse(blocks)
  s=size(blocks);
  block_size=sqrt(s(1));
  nb_blocks=s(2);
  for k=1:nb_blocks
    kk=(k-1)*block_size+1:k*block_size;
    sp_inv(kk,kk)= matrix(data(1:s(1),k),block_size,block_size);
  end
endfunction
blocks_to_sparse(parallel_run(N,1:L,"invert_one_block",[N,N]));
if max(full(sp_inv-sp_inv_1)) > %eps then bugmes();quit;end
