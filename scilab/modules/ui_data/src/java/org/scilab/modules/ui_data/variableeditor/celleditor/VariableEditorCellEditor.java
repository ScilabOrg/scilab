/*
 * Scilab ( http://www.scilab.org/ ) - This file is part of Scilab
 * Copyright (C) 2010 - DIGITEO - Allan SIMON
 * 
 * This file must be used under the terms of the CeCILL.
 * This source file is licensed as described in the file COPYING, which
 * you should have received as part of this distribution.  The terms
 * are also available at    
 * http://www.cecill.info/licences/Licence_CeCILL_V2-en.txt
 *
 */
package org.scilab.modules.ui_data.variableeditor.celleditor;

import static org.scilab.modules.action_binding.highlevel.ScilabInterpreterManagement.asynchronousScilabExec;
import static org.scilab.modules.action_binding.highlevel.ScilabInterpreterManagement.buildCall;

import java.awt.Component;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.KeyEvent;
import java.text.ParseException;

import javax.swing.AbstractAction;
import javax.swing.DefaultCellEditor;
import javax.swing.JFormattedTextField;
import javax.swing.JTable;
import javax.swing.KeyStroke;

import org.scilab.modules.action_binding.highlevel.ScilabInterpreterManagement.InterpreterException;
import org.scilab.modules.ui_data.variableeditor.ScilabVariableEditor;
import org.scilab.modules.ui_data.variableeditor.renderers.ScilabDoubleRenderer;
import org.scilab.modules.ui_data.variableeditor.renderers.ScilabStringRenderer;

/**
 * class VariableEditorCellEditor
 * Use when editing cells, call Scilab interpreter.
 */
public class VariableEditorCellEditor extends DefaultCellEditor {

	/**
	 * 
	 */
	private static final long serialVersionUID = 3866054279955696250L;

	private int row;
	private int col;
	private JFormattedTextField textField;
	private String type;
	/**
	 * Constructor
	 */
	public VariableEditorCellEditor(Object[][] data) {
		super(new JFormattedTextField());
		// TODO Auto-generated constructor stub

		if (data instanceof String[][]) {
			type = "string";
		} else if (data instanceof Double[][]) {
			type = "double";
		} else if (data instanceof Boolean[][]) {
			type = "boolean";
		}
		
		textField = (JFormattedTextField) getComponent();
		textField.setFocusLostBehavior(JFormattedTextField.COMMIT);

		
		textField.getInputMap().put(KeyStroke .getKeyStroke(KeyEvent.VK_ENTER, 0),"check");
		textField.getInputMap().put(KeyStroke .getKeyStroke(KeyEvent.VK_TAB, 0),"check");
		
		textField.getActionMap().put("check", new CellContentCheck());
	}
	
	
	/**
	 * CellContentCheck
	 * Called when user try to validate current cell content with TAB or ENTER
	 */
	private class CellContentCheck extends AbstractAction {

		public void actionPerformed(ActionEvent e) {
			String request = buildScilabRequest();
			callScilabValidationOfCellContent(request);
		}
		/**
		 * Build the request which encapsulate the content of the cell to be validated/interpreted by scilab
		 * @return the request to be executed by Scilab
		 */
		private String buildScilabRequest(){
			
			final StringBuilder command = new StringBuilder();
			String variableName = ScilabVariableEditor.getVariableEditor().getVariablename();
			String data = String.valueOf(textField.getText());
			
			if (type.equalsIgnoreCase("string")) {
				data = data.replace("\"","\"\"\"\"");
				data = data.replace("'","''''");
				data = "\"\"" + data +"\"\"";
			} else {
				data = data.replace("\"","\"\"");
				data = data.replace("'","''");
			}
			
			String cellInVariable = variableName + "(" + row + "," + col + ")";
			String cmdInExecStr = cellInVariable + " = " + data;
			command.append("temp = " + buildCall("execstr", cmdInExecStr, "errcatch"));
			command.append("updateEditvarValue(\"" + variableName + "\"," + row + "," + col + "," + cellInVariable + ",temp);");
			return command.toString();
		}
		/**
		 * Execute the request generated by buildScilabRequest, it will check and interprete the content of the cell
		 * and return the result back to EditVar
		 * @param request the request to be executed by Scilab
		 */
		private void callScilabValidationOfCellContent(String request){
			final ActionListener action = new ActionListener() {

				public void actionPerformed(ActionEvent e) {

				}
			};

			try {
				asynchronousScilabExec(action, request);
			} catch (InterpreterException e1) {
				System.err.println("An error in the interpreter has been catched: " + e1.getLocalizedMessage()); 
			}

			try {
				textField.commitEdit();
				textField.postActionEvent();
			} catch (ParseException e1) {
				System.err.println("An error in the parser has been catched: " + e1.getLocalizedMessage()); 
			}
		}
	}

	/**
	 * {@inheritDoc}
	 */
	public Component getTableCellEditorComponent(JTable table, Object value,
			boolean isSelected, int row, int col) {
		this.row = row + 1; // +1 because scilab index start at 1
		this.col = col + 1;
		
		Object newValue = value;
		if (value != null && type.equalsIgnoreCase("boolean")) {
			if ((Boolean) value == false) {
				newValue = "%F" ;
			} else {
				newValue = "%T" ;
			}
		}
		
		return super.getTableCellEditorComponent(table, newValue, isSelected, row, col);
	}

}
