<?xml version="1.0" encoding="UTF-8"?>
<!--
 * Scilab ( http://www.scilab.org/ ) - This file is part of Scilab
 * Copyright (C) 2008 - INRIA
 * Copyright (C) 2010 - DIGITEO - Michael Baudin
 * 
 * This file must be used under the terms of the CeCILL.
 * This source file is licensed as described in the file COPYING, which
 * you should have received as part of this distribution.  The terms
 * are also available at    
 * http://www.cecill.info/licences/Licence_CeCILL_V2-en.txt
 *
 -->
<refentry version="5.0-subset Scilab" xml:id="karmarkar" xml:lang="en"
          xmlns="http://docbook.org/ns/docbook"
          xmlns:xlink="http://www.w3.org/1999/xlink"
          xmlns:svg="http://www.w3.org/2000/svg"
          xmlns:ns4="http://www.w3.org/1999/xhtml"
          xmlns:mml="http://www.w3.org/1998/Math/MathML"
          xmlns:db="http://docbook.org/ns/docbook">
  <info>
    <pubdate>$LastChangedDate$</pubdate>
  </info>

  <refnamediv>
    <refname>karmarkar</refname>

    <refpurpose>Solves a linear optimization problem.</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
    <title>Calling Sequence</title>

    <synopsis>
      xopt=karmarkar(Aeq,beq,c,x0)
      xopt=karmarkar(Aeq,beq,c,x0,rtolf)
      xopt=karmarkar(Aeq,beq,c,x0,rtolf,gam)
      xopt=karmarkar(Aeq,beq,c,x0,rtolf,gam,maxiter)
      xopt=karmarkar(Aeq,beq,c,x0,rtolf,gam,maxiter,outfun)
      [xopt,fopt]=karmarkar(...)
      [xopt,fopt,iter]=karmarkar(...)
    </synopsis>
  </refsynopsisdiv>

  <refsection>
    <title>Arguments</title>

    <variablelist>
      <varlistentry>
        <term>Aeq</term>
        <listitem>
          <para>
            a n-by-p matrix of doubles, where <literal>n</literal> is the number
            of linear equality constraints
            and <literal>p</literal> is the number of unknowns,
            the matrix in the linear equality constraints.
          </para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>beq</term>
        <listitem>
          <para>
            a n-by-1 matrix of doubles,
            the right hand side of the linear equality constraint.
          </para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>c</term>
        <listitem>
          <para>
            a p-by-1 matrix of doubles,
            the linear part of the objective function.
          </para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>x0</term>
        <listitem>
          <para>
            a p-by-1 matrix of doubles, the initial guess.
          </para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>rtolf</term>
        <listitem>
          <para>
            a 1-by-1 matrix of doubles,
            a relative tolerance on <literal>f(x)=c'*x</literal> (default rtolf=1.d-5).
          </para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>gam</term>
        <listitem>
          <para>
            a 1-by-1 matrix of doubles, the scaling factor (default gam=0.25).
            The scaling factor must satisfy <literal>0&lt;gam&lt;1</literal>.
          </para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>maxiter</term>
        <listitem>
          <para>
            a 1-by-1 matrix of floating point integers, the maximum number of iterations (default maxiter=200).
            The maximum number of iterations must be greater than 1.
          </para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>outfun</term>
        <listitem>
          <para>
            a function or a list, the output function.
          </para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>xopt</term>
        <listitem>
          <para>a p-by-1 matrix of doubles, the solution.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>fopt</term>
        <listitem>
          <para>
            a 1-by-1 matrix of doubles, the objective function
            value at optimum, i.e. the value of c'*xopt.
          </para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>iter</term>
        <listitem>
          <para>
            a 1-by-1 matrix of floating point integers, the number of iterations.
          </para>
        </listitem>
      </varlistentry>

    </variablelist>
  </refsection>

  <refsection>
    <title>Description</title>

    <para>
      Computes <literal>x</literal> which solves the linear optimization problem:
    </para>

    <para>
      <latex>
        \begin{eqnarray}
        \begin{array}{l}
        \textrm{minimize } c^T \cdot x\\
        A_{eq} x = b_{eq}\\
        x \geq 0
        \end{array}
        \end{eqnarray}
      </latex>
    </para>

    <para>
      Any optional parameter equal to the empty matrix <literal>[]</literal> is replaced by
      its default value.
    </para>

    <para>
      The output function outfun must have header
    </para>

    <programlisting role="example">
      <![CDATA[ 
     stop = outfun ( iter , xopt , fopt , d )
]]>
    </programlisting>

    <para>
      where <literal>iter</literal> is the iteration index,
      <literal>xopt</literal> is the current point,
      <literal>fopt</literal> is the current function value and
      <literal>d</literal> is the current direction.
      Here, <literal>stop</literal> is a boolean,
      which is <literal>%t</literal> if the algorithm must stop.
    </para>

    <para>
      It might happen that the output function requires additionnal arguments to be evaluated.
      In this case, we can use the following feature.
      The function <literal>outfun</literal> can also be the list <literal>(outf,a1,a2,...)</literal>.
      In this case <literal>outf</literal>, the first element in the list, must have the header:
    </para>

    <programlisting role="example">
      <![CDATA[ 
       stop = outf ( iter , xopt , fopt , d , a1 , a2 , ... )
]]>
    </programlisting>

    <para>
      where the input arguments <literal>a1, a2, ...</literal>
      will be automatically be appended at the end of the calling sequence.
    </para>

    <para>
      The implementation is based on the primal affine scaling algorithm, as
      discovered by Dikin in 1967, and then re-discovered by Barnes and Vanderbei et al in 1986.
    </para>

    <para>
      If the scaling factor <literal>gam</literal> is closer to 1 (say <literal>gam=0.99</literal>,
      for example), then the number of iterations may be lower.
      Tsuchiya and Muramatsu proved that if an optimal solution exists, then, for any
      <literal>gam</literal> lower than 2/3, the sequence converges to a point in the interior point of the optimal face.
      Dikin proved convergence with <literal>gam=1/2</literal>.
      Mascarenhas found two examples where the parameter <literal>gam=0.999</literal> lets the
      algorithm converge to a vertex which is not optimal, if the initial guess is chosen
      appropriately.
    </para>

  </refsection>

  <refsection>
    <title>Example #1</title>

    <para>
      In the following example, we solve a linear optimization problem with 2 linear
      equality constraints and 3 unknowns.
      The linear optimization problem is
    </para>

    <para>
      <latex>
        \begin{eqnarray}
        \begin{array}{l}
        \textrm{minimize } -x_1 -x_2\\
        x_1 - x_2 = 0\\
        x_1 + x_2 + x_3 = 2\\
        x \geq 0
        \end{array}
        \end{eqnarray}
      </latex>
    </para>

    <para>
      The following script solves the problem.
    </para>

    <programlisting role="example">
      <![CDATA[ 
    Aeq = [
    1 -1 0
    1  1 1
    ];
    beq = [0;2];
    c = [-1;-1;0];
    x0 = [0.1;0.1;1.8];
    [xopt,fopt,iter]=karmarkar(Aeq,beq,c,x0)
    xstar=[1 1 0]'
]]>
    </programlisting>

    <para>
      The previous script produces the following output.
    </para>

    <programlisting role="example">
      <![CDATA[ 
-->[xopt,fopt,iter]=karmarkar(Aeq,beq,c,x0)
 iter  =
    36.  
 fopt  =
  - 1.9999428  
 xopt  =
    0.9999714  
    0.9999714  
    0.0000572  
-->xstar=[1 1 0]'
 xstar  =
    1.  
    1.  
    0.  
]]>
    </programlisting>

  </refsection>

  <refsection>
    <title>Example #2</title>

    <para>
      In the following example, we solve a linear optimization problem with 10 random linear
      equality constraints and 20 unknowns.
      The initial guess is chosen at random in the [0,1]^p range.
    </para>

    <programlisting role="example">
      <![CDATA[ 
n=10;
p=20;
Aeq=rand(n,p);
c=rand(p,1);
x0=rand(p,1);
beq=Aeq*x0;
xopt=karmarkar(Aeq,beq,c,x0);
// Check constraints
norm(Aeq*xopt-beq)
]]>
    </programlisting>
  </refsection>

  <refsection>
    <title>Introducing slack variables</title>

    <para>
      It may be required to change the problem formulation in order to
      use the current algorithm.
      Consider the following linear program.
    </para>

    <para>
      <latex>
        \begin{eqnarray}
        \begin{array}{l}
        \textrm{maximize } 20 x_1 + 24 x_2\\
        3 x_1 + 6 x_2 \leq 60 \\
        4 x_1 + 2 x_2 \leq 32 \\
        x_1,x_2 \geq 0
        \end{array}
        \end{eqnarray}
      </latex>
    </para>

    <para>
      The solution of this problem is <literal>xopt = [4 8]'</literal>.
      In order to use the <literal>karmarkar</literal> function, we change
      the problem form into the following.
      We introduce the slack variables <literal>x3,x4</literal>
      which turns the inequality constraints into equality constraints.
    </para>

    <para>
      <latex>
        \begin{eqnarray}
        \begin{array}{l}
        \textrm{minimize } -20 x_1 - 24 x_2\\
        3 x_1 + 6 x_2 + x_3 = 60 \\
        4 x_1 + 2 x_2 + x_4 = 32 \\
        x_1,x_2,x_3,x_4 \geq 0
        \end{array}
        \end{eqnarray}
      </latex>
    </para>

    <para>
      Once done, we can use the <literal>karmarkar</literal> function,
      by introducing the additionnal equality constraints.
      The initial guess <literal>x0</literal> is computed so that the slack variables
      automatically solve the linear equalities.
    </para>

    <programlisting role="example">
      <![CDATA[ 
    c = [-20 -24 0 0]';
    Aeq = [
    3 6 1 0
    4 2 0 1
    ];
    beq = [60 32]';
    x0(1:2)=[0.1;0.1];
    x0(3:4)=beq-Aeq(:,1:2)*x0(1:2);
    xopt=karmarkar(Aeq,beq,c,x0)
]]>
    </programlisting>

    <para>
      The previous script produces the following output.
    </para>

    <programlisting role="example">
      <![CDATA[ 
-->xopt=karmarkar(Aeq,beq,c,x0)
 xopt  =
    3.9996804  
    7.999968   
    0.0011506  
    0.0013424  
]]>
    </programlisting>


  </refsection>

  <refsection>
    <title>Configuring a callback</title>

    <para>
      It may be useful to configure a callback, so that we can customize the
      printed messages or create a plot.
      Consider the following linear optimization problem.
    </para>

    <para>
      <latex>
        \begin{eqnarray}
        \begin{array}{l}
        \textrm{maximize } x_1 + x_2\\
        2 p x_1 + x_2 \leq 1+p^2, \quad p=0.0, 0.1, 0.2, ..., 1.0\\
        x_1,x_2 \geq 0
        \end{array}
        \end{eqnarray}
      </latex>
    </para>

    <para>
      In order to be able to solve it, we introduce slack variables.
      This leads to the following problem.
    </para>

    <para>
      <latex>
        \begin{eqnarray}
        \begin{array}{l}
        \textrm{minimize } -x_1 - x_2\\
        x_2 + x_3 = 1\\
        0.2 x_1 + x_2 + x_4 = 1 + 0.1^2 \\
        0.4 x_1 + x_2 + x_5 = 1 + 0.2^2 \\
        0.6 x_1 + x_2 + x_6 = 1 + 0.3^2 \\
        0.8 x_1 + x_2 + x_7 = 1 + 0.4^2 \\
        1.0 x_1 + x_2 + x_8 = 1 + 0.5^2 \\
        1.2 x_1 + x_2 + x_9 = 1 + 0.6^2 \\
        1.4 x_1 + x_2 + x_{10} = 1 + 0.7^2 \\
        1.6 x_1 + x_2 + x_{11} = 1 + 0.8^2 \\
        1.8 x_1 + x_2 + x_{12} = 1 + 0.9^2 \\
        2.0 x_1 + x_2 + x_{13} = 1 + 1.0^2 \\
        x_1 , x_2 , ..., x_{13} \geq 0
        \end{array}
        \end{eqnarray}
      </latex>
    </para>

    <para>
      The following output function plots the current point
      and prints the iteration number, the value of the objective
      function and the norm of the step.
    </para>

    <programlisting role="example">
      <![CDATA[ 
  function stop = myoutputfunction ( iter , xopt , xopt , d )
      plot(xopt(1),xopt(2),"ro")
      norstep = norm(d)
      localmsg = gettext("Iteration #%3.0f, fopt=%f, ||d||=%10.3e\n")
      mprintf(localmsg,iter,fopt,norstep)
      stop = %f
  endfunction
]]>
    </programlisting>

    <para>
      The following script defines the optimization problem and
      runs the optimization.
    </para>

    <programlisting role="example">
      <![CDATA[ 
  n=11;
  Aeq = zeros(n,n+2);
  Aeq(:,1) = 2*linspace(0,1,n)';
  Aeq(:,2) = ones(11,1);
  Aeq(1:n,3:n+2) = eye(n,n);
  beq = 1 + linspace(0,1,n)'.^2;
  c=[-1;-1;zeros(n,1)];
  x0=zeros(n+2,1);
  x0(1:2) = [0.1;0.2];
  x0(3:n+2)=beq-Aeq(:,1:2)*x0(1:2);
  // Plot the constraints
  scf();
  for i = 1 : n
  plot(linspace(0,1,100),beq(i)-Aeq(i,1)*linspace(0,1,100),"b-")
  end
  h=gcf();
  h.children.data_bounds = [
  0 0
  1.1 1.1
  ];
  // Run the optimization
  xopt=karmarkar(Aeq,beq,c,x0,[],0.5,[],myoutputfunction);
  // Plot the starting and ending points
  plot(x0(1),x0(2),"g+")
  plot(xopt(1),xopt(2),"k*")
]]>
    </programlisting>

    <para>
      The previous script produces the following output and creates a graphics.
    </para>

    <programlisting role="example">
      <![CDATA[ 
-->xopt=karmarkar(Aeq,beq,c,x0,[],0.5,[],myoutputfunction);
Iteration #  0, fopt=-0.300000, ||d||=0.000e+000
Iteration #  1, fopt=-0.754262, ||d||=1.565e+000
Iteration #  2, fopt=-0.993957, ||d||=8.336e-001
Iteration #  3, fopt=-1.121978, ||d||=4.799e-001
Iteration #  4, fopt=-1.185989, ||d||=2.485e-001
Iteration #  5, fopt=-1.217995, ||d||=1.240e-001
Iteration #  6, fopt=-1.233997, ||d||=6.256e-002
Iteration #  7, fopt=-1.241999, ||d||=3.220e-002
Iteration #  8, fopt=-1.245999, ||d||=1.662e-002
Iteration #  9, fopt=-1.248000, ||d||=8.446e-003
Iteration # 10, fopt=-1.249000, ||d||=4.238e-003
Iteration # 11, fopt=-1.249500, ||d||=2.117e-003
Iteration # 12, fopt=-1.249750, ||d||=1.058e-003
Iteration # 13, fopt=-1.249875, ||d||=5.283e-004
Iteration # 14, fopt=-1.249937, ||d||=2.640e-004
Iteration # 15, fopt=-1.249969, ||d||=1.320e-004
Iteration # 16, fopt=-1.249984, ||d||=6.599e-005
Iteration # 17, fopt=-1.249992, ||d||=3.299e-005
]]>
    </programlisting>

  </refsection>

  <refsection>
    <title>A counter-example</title>

    <para>
      Mascarenhas created a counter-example showing that the affine scaling algorithm fails for stepsize 0.999.
      The counter-example is based on a particular linear program, with a special
      initial guess.
      It is straightfoward to modify the problem to introduce slack variables
      which allow to manage the problem with the current solver.
    </para>

    <programlisting role="example">
      <![CDATA[ 
alpha=0.39574487;
beta =0.91836049; // beta = sqrt(1-alpha^2)
Aeq = [
-1 alpha  beta -1  0  0
-1  beta alpha  0 -1  0
 0     0     1  0  0 -1
];
beq=[0 0 -1]';
c=[1 0 0]'
s2=2.37387527783187957081587174931;
s3=0.10589678006448334371854506996;
x0=[1 s2 s3]';
c(4:6)=0;
x0(4:6)=Aeq(:,1:3)*x0(1:3)-beq;
gam = 0.999;
rtolf = 1.e-5;
function stop = myoutputfunction ( iter , xopt , fopt , d )
    norstep = norm(d)
    localmsg = gettext("Iteration #%3.0f, fopt=%10.3e\n")
    xstr = strcat(msprintf("%.6f\n",xopt)'," ")
    mprintf(localmsg,iter,fopt)
    plot(xopt(2),xopt(3),"bo")
    stop = %f
endfunction
xopt=karmarkar(Aeq,beq,c,x0,rtolf,gam,[],myoutputfunction)
Aeq*xopt-beq
c'*xopt

// Prints the optimal point
xstar = [-1 0 0]';
xstar(4:6)=Aeq(:,1:3)*xstar(1:3)-beq
Aeq*xstar-beq
c'*xstar
]]>
    </programlisting>

    <para>
      The previous script produces the following output.
    </para>

    <programlisting role="example">
      <![CDATA[ 
-->xopt=karmarkar(Aeq,beq,c,x0,rtolf,gam,[],myoutputfunction)
Iteration #  0, fopt=1.000e+000
Iteration #  1, fopt=3.362e-002
Iteration #  2, fopt=1.261e-003
Iteration #  3, fopt=7.733e-005
Iteration #  4, fopt=1.680e-005
[...]
 xopt  =
    5.36D-164  
    3.459D-08  
    0.0000042  
    0.0000039  
    0.0000017  
    1.0000042  
-->Aeq*xopt-beq
 ans  =
 10^(-14) *
    0.0696042  
    0.1242867  
    0.0555112  
-->c'*xopt
 ans  =
    5.36D-164  
-->xstar(4:6)=Aeq(:,1:3)*xstar(1:3)-beq
 xstar  =
  - 1.  
    0.  
    0.  
    1.  
    1.  
    1.  
-->Aeq*xstar-beq
 ans  =
    0.  
    0.  
    0.  
-->c'*xstar
 ans  =
  - 1.  
]]>
    </programlisting>

  </refsection>



  <refsection>
    <title>References</title>
    <para>
      "A New Polynomial Time Algorithm for Linear Programming",
      Narendra Karmarkar, Combinatorica, Vol 4, nr. 4, p. 373–395, 1984.
    </para>

    <para>
      "A variation on Karmarkar’s algorithm for solving linear programming problems,
      Earl R. Barnes, Mathematical Programming, Volume 36, Number 2, 174-182, 1986.
    </para>

    <para>
      "A modification of karmarkar's linear programming algorithm",
      Robert J. Vanderbei, Marc S. Meketon and Barry A. Freedman,
      Algorithmica, Volume 1, Numbers 1-4, 395-407, 1986.
    </para>

    <para>
      "Practical Optimization: Algorithms and Engineering Applications",
      Andreas Antoniou, Wu-Sheng Lu, Springer, 2007,
      Chapter 12, "Linear Programming Part II: Interior Point Methods".
    </para>

    <para>
      "Global Convergence of a Long-Step Affine Scaling Algorithm for Degenerate Linear Programming Problems",
      Takashi Tsuchiya and Masakazu Muramatsu,
      SIAM J. Optim. Volume 5, Issue 3, pp. 525-551 (August 1995)
    </para>

    <para>
      "The convergence of dual variables", Tech. report, Siberian Energy Institute,
      Russia, 1991
    </para>

    <para>
      "The Affine Scaling Algorithm Fails for Stepsize 0.999",
      Walter F. Mascarenhas, SIAM J. Optim. Volume 7, Issue 1, pp. 34-46 (1997)
    </para>

  </refsection>

</refentry>

