<?xml version="1.0" encoding="UTF-8"?>
<refentry version="5.0-subset Scilab" xml:id="qpsolve" xml:lang="en"
          xmlns="http://docbook.org/ns/docbook"
          xmlns:xlink="http://www.w3.org/1999/xlink"
          xmlns:svg="http://www.w3.org/2000/svg"
          xmlns:ns3="http://www.w3.org/1999/xhtml"
          xmlns:mml="http://www.w3.org/1998/Math/MathML"
          xmlns:db="http://docbook.org/ns/docbook">
  <info>
    <pubdate>March 2008</pubdate>
  </info>

  <refnamediv>
    <refname>qpsolve</refname>

    <refpurpose>linear quadratic programming solver</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
    <title>Calling Sequence</title>

    <synopsis>[x [,iact [,iter [,f]]]]=qpsolve(Q,p,C,b,ci,cs,me)</synopsis>
  </refsynopsisdiv>

  <refsection>
    <title>Parameters</title>

    <variablelist>
      <varlistentry>
        <term>Q</term>

        <listitem>
          <para>real positive definite symmetric matrix (dimension <literal>n
          x n</literal>).</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>p</term>

        <listitem>
          <para>real (column) vector (dimension <literal> n</literal>)</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>C</term>

        <listitem>
          <para>real matrix (dimension <literal> (me + md) x n</literal>).
          This matrix may be stored as either a dense matrix either a sparse
          one.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>b</term>

        <listitem>
          <para>RHS column vector (dimension <literal> (me +
          md)</literal>)</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>ci</term>

        <listitem>
          <para>column vector of lower-bounds (dimension
          <literal>n</literal>). If there are no lower bound constraints, put
          <literal>ci = []</literal>. If some components of
          <literal>x</literal> are bounded from below, set the other
          (unconstrained) values of <literal>ci</literal> to a very large
          negative number (e.g. <literal>ci(j) =
          -number_properties('huge')</literal>.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>cs</term>

        <listitem>
          <para>column vector of upper-bounds. (Same remarks as above).</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>me</term>

        <listitem>
          <para>number of equality constraints (i.e. <literal>C(1:me,:)*x =
          b(1:me)</literal>)</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>x</term>

        <listitem>
          <para>optimal solution found.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>iact</term>

        <listitem>
          <para>vector, indicator of active constraints. The first non zero
          entries give the index of the active constraints</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>iter</term>

        <listitem>
          <para>. 2x1 vector, first component gives the number of "main"
          iterations, the second one says how many constraints were deleted
          after they became active.</para>
        </listitem>
      </varlistentry>
    </variablelist>
  </refsection>

  <refsection>
    <title>Description</title>

    <para>Minimize <literal> 0.5*x'*Q*x + p'*x</literal></para>

    <para>under the constraints</para>

    <programlisting>

 C(j,:) x = b(j),  j=1,...,me
 C(j,:) x &lt;= b(j), j=me+1,...,me+md
 ci &lt;= x &lt;= cs
   
    </programlisting>

    <para>This function requires <literal>Q</literal> to be positive definite,
    if it is not the case, one may use the <link
    linkend="quapro">quapro</link> function.</para>
  </refsection>

  <refsection>
    <title>Examples</title>

    <programlisting role="example">

//Find x in R^6 such that:
//C1*x = b1 (3 equality constraints i.e me=3)
C1= [1,-1,1,0,3,1;
    -1,0,-3,-4,5,6;
     2,5,3,0,1,0];
b1=[1;2;3];
//C2*x &lt;= b2 (2 inequality constraints)
C2=[0,1,0,1,2,-1;
    -1,0,2,1,1,0];
b2=[-1;2.5];
//with  x between ci and cs:
ci=[-1000;-10000;0;-1000;-1000;-1000];cs=[10000;100;1.5;100;100;1000];
//and minimize 0.5*x'*Q*x + p'*x with
p=[1;2;3;4;5;6]; Q=eye(6,6);
//No initial point is given;
C=[C1;C2] ; //
b=[b1;b2] ;  //
me=3;
[x,iact,iter,f]=qpsolve(Q,p,C,b,ci,cs,me)
//Only linear constraints (1 to 4) are active 
 
  </programlisting>
  </refsection>

  <refsection>
    <title>See Also</title>

    <simplelist type="inline">
      <member><link linkend="optim">optim</link></member>
      <member><link linkend="qp_solve">qp_solve</link></member>
      <member><link linkend="qld">qld</link></member>
    </simplelist>
    <para>The contributed toolbox "quapro" may also be of interest, in
    particular for singular <literal>Q</literal>. </para>
  </refsection>

  <refsection>
    <title>Authors</title>

    <variablelist>
      <varlistentry>
        <term>S. Steer</term>

        <listitem>
          <para>, INRIA (Scilab interface)</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>Berwin A. Turlach</term>

        <listitem>
          <para>,School of Mathematics and Statistics (M019), The University
          of Western Australia, Crawley, AUSTRALIA (solver code)</para>
        </listitem>
      </varlistentry>
    </variablelist>
  </refsection>

  <refsection>
    <title>Used Functions</title>

    <para>qpgen1.f (also named QP.solve.f) developped by Berwin A. Turlach
    according to the Goldfarb/Idnani algorithm</para>
  </refsection>
</refentry>
