// =============================================================================
// Scilab ( http://www.scilab.org/ ) - This file is part of Scilab
// Copyright (C) ????-2008 - INRIA - Michael Baudin
//
//  This file is distributed under the same license as the Scilab package.
// =============================================================================
//
// optim.tst --
//   Test the optim command with the Rosenbrock test case
//   in the case where the cost function is provided as a Fortran
//   routine.
//   The "genros" function is defined in optimization/sci_gateway/fortran/Ex-optim.f
//
// This is the precision measured with experiments.
Leps=10^12*%eps;
// n : dimension of the problem
n=3;
bs=10.*ones(n,1);
bi=-bs;
x0=1.2*ones(n,1);
epsx=1.e-15*x0;
xopt=ones(n,1);
// External function written in C (C compiler required)
// write down the C code (Rosenbrock problem)
C=['#include <math.h>'
'double sq(double x)'
'{ return x*x;}'
'void rosenc(int *ind, int *n, double *x, double *f, double *g, '
'                                int *ti, float *tr, double *td)'
'{'
'  double p;'
'  int i;'
'  p=td[0];'
'  if (*ind==2||*ind==4) {'
'    *f=1.0;'
'    for (i=1;i<*n;i++)'
'      *f+=p*sq(x[i]-sq(x[i-1]))+sq(1.0-x[i]);'
'  }'
'  if (*ind==3||*ind==4) {'
'    g[0]=-4.0*p*(x[1]-sq(x[0]))*x[0];'
'    for (i=1;i<*n-1;i++)'
'      g[i]=2.0*p*(x[i]-sq(x[i-1]))-4.0*p*(x[i+1]-sq(x[i]))*x[i]-2.0*(1.0-x[i]);'
'    g[*n-1]=2.0*p*(x[*n-1]-sq(x[*n-2]))-2.0*(1.0-x[*n-1]);'
'  }'
'}'];
mputl(C,TMPDIR+'/rosenc.c')
// compile the C code
libpath=ilib_for_link('rosenc','rosenc.o',[],'c',TMPDIR+'/Makefile');
   Generate a loader file
   Generate a Makefile
   ilib_gen_Make: Copy compilation files (Makefile*, libtool...) to TMPDIR
   ilib_gen_Make: Copy rosenc.o to TMPDIR
   ilib_gen_Make: Modification of the Makefile in TMPDIR.
Executing SCI/modules/dynamic_link/src/scripts/scicompile.sh rosenc  rosenc.o
   Running the Makefile
// incremental linking
linkid=link(libpath,'rosenc','c');
Shared archive loaded.
Link done.
//solve the problem
valtd=100;
// Test with default solver and default settings.
[f,x,g]=optim('rosenc',x0,'td',valtd)
 g  =
 
    0.  
    0.  
    0.  
 x  =
 
    1.  
    1.  
    1.  
 f  =
 
    1.  
if abs(f-1+norm(x-xopt) ) > Leps then bugmes();quit;end
// Test with all solvers
solverlist=["gc" "qn" "nd"]
 solverlist  =
 
!gc  qn  nd  !
for solver=solverlist
  mprintf("Solver=%s\n",solver)
  [f,x,g]=optim('rosenc',x0,solver,'td',valtd);
  if abs(f-1+norm(x-xopt) ) > Leps then bugmes();quit;end
end
Solver=gc
Solver=qn
Solver=nd
// Test all verbose levels with all possible solvers
verboselevels=[0 1 2 3]
 verboselevels  =
 
    0.    1.    2.    3.  
for verbose=verboselevels
  mprintf("Verbose=%d\n",verbose)
  for solver=solverlist
    mprintf("Solver=%s\n",solver)
    [f,x,g]=optim('rosenc',x0,solver,'td',valtd,imp=verbose);
    if abs(f-1+norm(x-xopt) ) > Leps then bugmes();quit;end
  end
end
Verbose=0
Solver=gc
Solver=qn
Solver=nd
Verbose=1
Solver=gc
Optim stops: maximum number of calls to f is reached.

Solver=qn
Norm of projected gradient lower than   0.0000000D+00.

Solver=nd
entry in n1fc1 . n=   3 memax= 10  
minimal array sizes: iz(    22)  rz(    85)  dz(   198)
n1fc1      Incorrect end of fprf2
End of optimization.

Verbose=2
Solver=gc
Optim stops: maximum number of calls to f is reached.

Solver=qn
Norm of projected gradient lower than   0.0000000D+00.

Solver=nd
entry in n1fc1 . n=   3 memax= 10  
minimal array sizes: iz(    22)  rz(    85)  dz(   198)
 n1fc1            diam1= 0.497D+00    eta2= 0.000D+00    ap= 0.201D-28
 n1fc1     10   25   0.1000126D+01   faisceau reduit a  2 gradients
 n1fc1     18   45   0.1000000D+01   faisceau reduit a  3 gradients
n1fc1   eta2 assigned to  0.000D+00
 n1fc1     21   50   0.1000000D+01   convergence a 0.297D-08 pres  (-0.00D+00)
n1fc1      Incorrect end of fprf2
End of optimization.

Verbose=3
Solver=gc
Optim stops: maximum number of calls to f is reached.

Solver=qn
Norm of projected gradient lower than   0.0000000D+00.

Solver=nd
entry in n1fc1 . n=   3 memax= 10  
minimal array sizes: iz(    22)  rz(    85)  dz(   198)
n1fc1      1    1   0.1260000D+02  0.10D+01  0.20D+05  0.00D+00  2
 n1fc1            diam1= 0.497D+00    eta2= 0.000D+00    ap= 0.201D-28
n1fc1      2    3   0.1412656D+01  0.10D+01  0.49D+03  0.00D+00  2
n1fc1      3    7   0.1082768D+01  0.67D+00  0.67D+01  0.00D+00  3
n1fc1      4   10   0.1081042D+01  0.66D-02  0.31D+00  0.00D+00  4
n1fc1      5   13   0.1020070D+01  0.15D+00  0.30D+00  0.00D+00  4
n1fc1      6   15   0.1010168D+01  0.21D-01  0.12D+02  0.20D+03  3
n1fc1      7   16   0.1001164D+01  0.20D-01  0.44D+00  0.69D+01  3
n1fc1      8   18   0.1000717D+01  0.18D-02  0.14D-02  0.36D+00  4
n1fc1      9   20   0.1000191D+01  0.18D-02  0.38D-04  0.56D-01  4
n1fc1     10   23   0.1000169D+01  0.44D-04  0.96D-01  0.19D+03  2
 n1fc1     10   25   0.1000126D+01   faisceau reduit a  2 gradients
n1fc1     11   25   0.1000126D+01  0.87D-04  0.20D-02  0.14D+02  3
n1fc1     12   27   0.1000121D+01  0.99D-05  0.45D-03  0.71D+00  4
n1fc1     13   30   0.1000002D+01  0.24D-03  0.17D-04  0.00D+00  4
n1fc1     14   34   0.1000002D+01  0.38D-06  0.35D-02  0.54D+02  2
n1fc1     15   36   0.1000000D+01  0.30D-05  0.19D-03  0.77D+01  3
n1fc1     16   38   0.1000000D+01  0.40D-06  0.13D-05  0.45D+00  3
n1fc1     17   41   0.1000000D+01  0.40D-08  0.30D-04  0.19D+03  2
n1fc1     18   43   0.1000000D+01  0.20D-07  0.70D-06  0.26D+02  3
 n1fc1     18   45   0.1000000D+01   faisceau reduit a  3 gradients
n1fc1     19   45   0.1000000D+01  0.24D-08  0.55D-06  0.56D+02  3
n1fc1     20   47   0.1000000D+01  0.11D-08  0.35D-07  0.00D+00  4
n1fc1   eta2 assigned to  0.000D+00
 n1fc1     21   50   0.1000000D+01   convergence a 0.297D-08 pres  (-0.00D+00)
n1fc1     21   50   0.1000000D+01  0.30D-09  0.16D-08  0.62D+00  3
n1fc1     22   54   0.1000000D+01  0.19D-10  0.18D-08  0.74D+00  3
n1fc1      Incorrect end of fprf2
End of optimization.

// Clean-up
ulink(linkid)
