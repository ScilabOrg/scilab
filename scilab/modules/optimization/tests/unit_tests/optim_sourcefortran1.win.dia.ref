// =============================================================================
// Scilab ( http://www.scilab.org/ ) - This file is part of Scilab
// Copyright (C) ????-2008 - INRIA - Michael Baudin
//
//  This file is distributed under the same license as the Scilab package.
// =============================================================================
//
// optim.tst --
//   Test the optim command with the Rosenbrock test case
//   in the case where the cost function is provided as a Fortran
//   routine and the parameter is given as a scilab variable, using the "td" option.
//
//   Note : the following source code was copied from optimization/sci_gateway/fortran/Ex-optim.f
//   Thus, the "genros" function from Ex-optim.f is not needed anymore.
//
// This is the precision measured with experiments.
Leps=10^12*%eps;
n=3;
xopt=ones(n,1);
//
// Define a fortran source code and compile it (fortran compiler required)
//
// External function written in Fortran (Fortran compiler required)
// write down the Fortran  code (Rosenbrock problem)
F=[ '      subroutine rosenf(ind, n, x, f, g, ti, tr, td)'
'      integer ind,n,ti(*)'
'      double precision x(n),f,g(n),td(*)'
'      real tr(*)'
'c'
'      double precision y,p'
'      p=td(1)'
'      if (ind.eq.2.or.ind.eq.4) then'
'        f=1.0d0'
'        do i=2,n'
'          f=f+p*(x(i)-x(i-1)**2)**2+(1.0d0-x(i))**2'
'        enddo'
'      endif'
'      if (ind.eq.3.or.ind.eq.4) then'
'        g(1)=-4.0d0*p*(x(2)-x(1)**2)*x(1)'
'        if(n.gt.2) then'
'          do i=2,n-1'
'            g(i)=2.0d0*p*(x(i)-x(i-1)**2)-4.0d0*p*(x(i+1)-x(i)**2)*x(i)'
'     &           -2.0d0*(1.0d0-x(i))'
'          enddo'
'        endif'
'        g(n)=2.0d0*p*(x(n)-x(n-1)**2)-2.0d0*(1.0d0-x(n))'
'      endif'
'      return'
'      end'];
mputl(F,TMPDIR+'/rosenf.f');
// compile the Fortran code
libpath=ilib_for_link('rosenf','rosenf.o',[],'f',TMPDIR+'/Makefile');
   Generate a loader file
   Generate a Makefile
   Running the Makefile
   Compilation of rosenf
   Building shared library (be patient)
// incremental linking
linkid=link(libpath,'rosenf','f');
Shared archive loaded.
Link done.
//solve the problem
x0=1.2*ones(n,1);
valtd=100;
[f,xo,go]=optim('rosenf',x0,'td',valtd);
// Test with all solvers
solverlist=["gc" "qn" "nd"];
for solver=solverlist
  [f,x,g]=optim('rosenf',x0,solver,'td',valtd);
  if abs(f-1+norm(x-xopt) ) > Leps then bugmes();quit;end
end
// Test all verbose levels with all possible solvers
verboselevels=[0 1 2 3];
for verbose=verboselevels
  for solver=solverlist
    [f,x,g]=optim('rosenf',x0,solver,'td',valtd,imp=verbose);
    if abs(f-1+norm(x-xopt) ) > Leps then bugmes();quit;end
  end
end
Optim stops: maximum number of calls to f is reached.

Norm of projected gradient lower than   0.0000000D+00.

entry in n1fc1 . n=   3 memax= 10  
minimal array sizes: iz(    22)  rz(    85)  dz(   198)
n1fc1      Incorrect end of fprf2
End of optimization.

Optim stops: maximum number of calls to f is reached.

Norm of projected gradient lower than   0.0000000D+00.

entry in n1fc1 . n=   3 memax= 10  
minimal array sizes: iz(    22)  rz(    85)  dz(   198)
 n1fc1            diam1= 0.497D+00    eta2= 0.000D+00    ap= 0.201D-28
 n1fc1     10   25   0.1000126D+01   faisceau reduit a  2 gradients
 n1fc1     18   45   0.1000000D+01   faisceau reduit a  3 gradients
n1fc1   eta2 assigned to  0.000D+00
 n1fc1     21   50   0.1000000D+01   convergence a 0.297D-08 pres  ( 0.00D+00)
n1fc1      Incorrect end of fprf2
End of optimization.

Optim stops: maximum number of calls to f is reached.

Norm of projected gradient lower than   0.0000000D+00.

entry in n1fc1 . n=   3 memax= 10  
minimal array sizes: iz(    22)  rz(    85)  dz(   198)
n1fc1      1    1   0.1260000D+02  0.10D+01  0.20D+05  0.00D+00  2
 n1fc1            diam1= 0.497D+00    eta2= 0.000D+00    ap= 0.201D-28
n1fc1      2    3   0.1412656D+01  0.10D+01  0.49D+03  0.00D+00  2
n1fc1      3    7   0.1082768D+01  0.67D+00  0.67D+01  0.00D+00  3
n1fc1      4   10   0.1081042D+01  0.66D-02  0.31D+00  0.00D+00  4
n1fc1      5   13   0.1020070D+01  0.15D+00  0.30D+00  0.00D+00  4
n1fc1      6   15   0.1010168D+01  0.21D-01  0.12D+02  0.20D+03  3
n1fc1      7   16   0.1001164D+01  0.20D-01  0.44D+00  0.69D+01  3
n1fc1      8   18   0.1000717D+01  0.18D-02  0.14D-02  0.36D+00  4
n1fc1      9   20   0.1000191D+01  0.18D-02  0.38D-04  0.56D-01  4
n1fc1     10   23   0.1000169D+01  0.44D-04  0.96D-01  0.19D+03  2
 n1fc1     10   25   0.1000126D+01   faisceau reduit a  2 gradients
n1fc1     11   25   0.1000126D+01  0.87D-04  0.20D-02  0.14D+02  3
n1fc1     12   27   0.1000121D+01  0.99D-05  0.45D-03  0.71D+00  4
n1fc1     13   30   0.1000002D+01  0.24D-03  0.17D-04  0.00D+00  4
n1fc1     14   34   0.1000002D+01  0.38D-06  0.35D-02  0.54D+02  2
n1fc1     15   36   0.1000000D+01  0.30D-05  0.19D-03  0.77D+01  3
n1fc1     16   38   0.1000000D+01  0.40D-06  0.13D-05  0.45D+00  3
n1fc1     17   41   0.1000000D+01  0.40D-08  0.30D-04  0.19D+03  2
n1fc1     18   43   0.1000000D+01  0.20D-07  0.70D-06  0.26D+02  3
 n1fc1     18   45   0.1000000D+01   faisceau reduit a  3 gradients
n1fc1     19   45   0.1000000D+01  0.24D-08  0.55D-06  0.56D+02  3
n1fc1     20   47   0.1000000D+01  0.11D-08  0.35D-07  0.00D+00  4
n1fc1   eta2 assigned to  0.000D+00
 n1fc1     21   50   0.1000000D+01   convergence a 0.297D-08 pres  ( 0.00D+00)
n1fc1     21   50   0.1000000D+01  0.30D-09  0.16D-08  0.62D+00  3
n1fc1     22   54   0.1000000D+01  0.19D-10  0.18D-08  0.74D+00  3
n1fc1      Incorrect end of fprf2
End of optimization.

// Clean-up
ulink(linkid);
