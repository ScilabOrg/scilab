// Scilab ( http://www.scilab.org/ ) - This file is part of Scilab
// Copyright (C) 2008-2009 - INRIA - Michael Baudin
//
// This file must be used under the terms of the CeCILL.
// This source file is licensed as described in the file COPYING, which
// you should have received as part of this distribution.  The terms
// are also available at
// http://www.cecill.info/licences/Licence_CeCILL_V2-en.txt
// <-- ENGLISH IMPOSED -->
//
// assert_close --
//   Returns 1 if the two real matrices computed and expected are close,
//   i.e. if the relative distance between computed and expected is lesser than epsilon.
// Arguments
//   computed, expected : the two matrices to compare
//   epsilon : a small number
//
function flag = assert_close ( computed, expected, epsilon )
  if expected==0.0 then
    shift = norm(computed-expected);
  else
    shift = norm(computed-expected)/norm(expected);
  end
  if shift < epsilon then
    flag = 1;
  else
    flag = 0;
  end
  if flag <> 1 then bugmes();quit;end
endfunction
//
// assert_equal --
//   Returns 1 if the two real matrices computed and expected are equal.
// Arguments
//   computed, expected : the two matrices to compare
//   epsilon : a small number
//
function flag = assert_equal ( computed , expected )
  if computed==expected then
    flag = 1;
  else
    flag = 0;
  end
  if flag <> 1 then bugmes();quit;end
endfunction
function [ y , index ] = rosenbrock ( x , index )
  y = 100*(x(2)-x(1)^2)^2 + (1-x(1))^2;
endfunction
//
// Use output function
//
// outfun --
//   A sample output function
// Arguments, input
//   x : the current point
//   optimValues : a tlist which contains the following fields
//     funccount : the number of function evaluations
//     fval : the current function value
//     iteration : the current iteration
//     procedure : a string containing the current type of step
//  state : the current state of the algorithm
//    "init", "iter", "done"
//
function stop = outfun ( x , optimValues , state )
  plot( x(1),x(2),'.');
  // Unload all fields and check consistent values
  fc = optimValues.funccount;
  fv = optimValues.fval;
  it = optimValues.iteration;
  pr = optimValues.procedure;
  select pr
  case "initial simplex"
    // OK
  case "expand"
    // OK
  case "reflect"
    // OK
  case "shrink"
    // OK
  case "contract inside"
    // OK
  case "contract outside"
    // OK
  case ""
    // OK
  else
    error ( sprintf ( "Unknown procedure %s." , pr ) )
  end
  select state
  case "init"
    // OK
  case "iter"
    // OK
  case "done"
    // OK
  else
    error ( sprintf ( "Unknown state %s." , state ) )
  end
  mprintf ( "%d %s %d -%s- %s\n" , fc , string(fv) , it , pr , state )
  stop = %f
endfunction
opt = optimset ( "OutputFcn" , outfun);
[x fval] = fminsearch ( rosenbrock , [-1.2 1] , opt );
3 24.2 0 -- init
3 20.05 1 -initial simplex- iter
5 5.161796 2 -expand- iter
7 4.497796 3 -reflect- iter
9 4.497796 4 -contract outside- iter
11 4.3813601 5 -contract inside- iter
13 4.2452728 6 -contract inside- iter
15 4.2176247 7 -reflect- iter
17 4.2112906 8 -contract inside- iter
19 4.1355598 9 -expand- iter
21 4.1355598 10 -contract inside- iter
23 4.0127268 11 -expand- iter
25 3.9373812 12 -expand- iter
27 3.602606 13 -expand- iter
28 3.602606 14 -reflect- iter
30 3.4662211 15 -reflect- iter
32 3.2160547 16 -expand- iter
34 3.1649126 17 -reflect- iter
36 2.7068692 18 -expand- iter
37 2.7068692 19 -reflect- iter
39 2.0021824 20 -expand- iter
41 2.0021824 21 -contract inside- iter
43 2.0021824 22 -contract inside- iter
45 1.8154337 23 -expand- iter
47 1.7348144 24 -contract outside- iter
49 1.3169723 25 -expand- iter
50 1.3169723 26 -reflect- iter
51 1.3169723 27 -reflect- iter
53 1.1595038 28 -reflect- iter
55 1.0767387 29 -contract inside- iter
57 0.8834921 30 -reflect- iter
59 0.8834921 31 -contract inside- iter
61 0.6691654 32 -expand- iter
63 0.6691654 33 -contract inside- iter
64 0.6691654 34 -reflect- iter
66 0.5367289 35 -reflect- iter
68 0.5367289 36 -contract inside- iter
70 0.4232940 37 -expand- iter
72 0.4232940 38 -contract outside- iter
74 0.3985272 39 -reflect- iter
76 0.3144704 40 -expand- iter
77 0.3144704 41 -reflect- iter
79 0.1903167 42 -expand- iter
81 0.1903167 43 -contract inside- iter
82 0.1903167 44 -reflect- iter
84 0.1369602 45 -reflect- iter
86 0.1369602 46 -contract outside- iter
88 0.1131281 47 -contract outside- iter
90 0.1105304 48 -contract inside- iter
92 0.1023402 49 -reflect- iter
94 0.1011837 50 -contract inside- iter
96 0.0794969 51 -expand- iter
97 0.0794969 52 -reflect- iter
98 0.0794969 53 -reflect- iter
100 0.0569294 54 -expand- iter
102 0.0569294 55 -contract inside- iter
104 0.0344855 56 -expand- iter
106 0.0179534 57 -expand- iter
108 0.0169469 58 -contract outside- iter
110 0.0040146 59 -reflect- iter
112 0.0040146 60 -contract inside- iter
113 0.0040146 61 -reflect- iter
115 0.0003700 62 -reflect- iter
117 0.0003700 63 -contract inside- iter
118 0.0003700 64 -reflect- iter
120 0.0003700 65 -contract inside- iter
122 0.0000590 66 -contract outside- iter
124 0.0000337 67 -contract inside- iter
126 0.0000337 68 -contract outside- iter
128 0.0000189 69 -contract outside- iter
130 0.0000085 70 -contract inside- iter
132 0.0000029 71 -contract inside- iter
133 0.0000029 72 -reflect- iter
135 0.0000007 73 -contract inside- iter
137 0.0000007 74 -contract inside- iter
139 0.0000006 75 -contract inside- iter
141 0.0000002 76 -contract outside- iter
143 0.0000001 77 -contract inside- iter
145 5.235D-08 78 -contract inside- iter
147 5.035D-08 79 -contract inside- iter
149 2.004D-08 80 -contract inside- iter
151 1.123D-09 81 -contract inside- iter
153 1.123D-09 82 -contract outside- iter
155 1.123D-09 83 -contract inside- iter
157 1.108D-09 84 -contract outside- iter
159 8.178D-10 85 -contract inside- iter
159 8.178D-10 85 -- done
close();
//
// Use several output functions
//
function stop = outfun2 ( x , optimValues , state )
  scf ( fig1 );
  plot( x(1),x(2),'.');
  stop = %f
endfunction
function stop = outfun3 ( x , optimValues , state )
  scf ( fig2 );
  plot( x(1),x(2),'o');
  stop = %f
endfunction
myfunctions = list ( outfun2 , outfun3 );
fig1 = scf(1000);
fig2 = scf(1001);
opt = optimset ( "OutputFcn" , myfunctions );
[x fval] = fminsearch ( rosenbrock , [-1.2 1] , opt );
close(fig1);
close(fig2);
//
// Use plot function
//
//
// plotfun --
//   A sample plot function
// Arguments, input
//   x : the current point
//   optimValues : a tlist which contains the following fields
//     funcCount" : the number of function evaluations
//     fval : the current function value
//     iteration : the current iteration
//     procedure : a string containing the current type of step
//  state : the current state of the algorithm
//    "init", "iter", "done"
//
function plotfun ( x , optimValues , state )
  plot(x(1),x(2),'.');
endfunction
opt = optimset ( "PlotFcns" , plotfun);
[x fval] = fminsearch ( rosenbrock , [-1.2 1] , opt );
close();
//
// Use several plot functions
//
function plotfun2 ( x , optimValues , state )
  scf ( fig1 );
  plot( x(1),x(2),'.');
endfunction
function plotfun3 ( x , optimValues , state )
  scf ( fig2 );
  plot( x(1),x(2),'o');
endfunction
myfunctions = list ( plotfun2 , plotfun3 );
fig1 = scf(1000);
fig2 = scf(1001);
opt = optimset ( "PlotFcns" , myfunctions );
[x fval] = fminsearch ( rosenbrock , [-1.2 1] , opt );
close(fig1);
close(fig2);
//
// Use optimplotfval plot function
//
opt = optimset ( "PlotFcns" , optimplotfval );
[x fval] = fminsearch ( rosenbrock , [-1.2 1] , opt );
close();
//
// Use optimplotx plot function
//
opt = optimset ( "PlotFcns" , optimplotx );
[x fval] = fminsearch ( rosenbrock , [-1.2 1] , opt );
close();
//
// Use optimplotfunccount plot function
//
opt = optimset ( "PlotFcns" , optimplotfunccount );
[x fval] = fminsearch ( rosenbrock , [-1.2 1] , opt );
close();
//
// Use all 3 plot functions
//
myfunctions = list ( optimplotfval , optimplotx , optimplotfunccount );
opt = optimset ( "PlotFcns" , myfunctions );
[x fval] = fminsearch ( rosenbrock , [-1.2 1] , opt );
close();
