/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 1.3.40
 * 
 * This file is not intended to be easily readable and contains a number of 
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG 
 * interface file instead. 
 * ----------------------------------------------------------------------------- */

#define SWIGJAVA

/* -----------------------------------------------------------------------------
 *  This section contains generic SWIG labels for method/variable
 *  declarations/attributes, and other compiler dependent labels.
 * ----------------------------------------------------------------------------- */

/* template workaround for compilers that cannot correctly implement the C++ standard */
#ifndef SWIGTEMPLATEDISAMBIGUATOR
#if defined(__SUNPRO_CC) && (__SUNPRO_CC <= 0x560)
#define SWIGTEMPLATEDISAMBIGUATOR template
#elif defined(__HP_aCC)
/* Needed even with `aCC -AA' when `aCC -V' reports HP ANSI C++ B3910B A.03.55 */
/* If we find a maximum version that requires this, the test would be __HP_aCC <= 35500 for A.03.55 */
#define SWIGTEMPLATEDISAMBIGUATOR template
#else
#define SWIGTEMPLATEDISAMBIGUATOR
#endif
#endif

/* inline attribute */
#ifndef SWIGINLINE
#if defined(__cplusplus) || (defined(__GNUC__) && !defined(__STRICT_ANSI__))
#define SWIGINLINE inline
#else
#define SWIGINLINE
#endif
#endif

/* attribute recognised by some compilers to avoid 'unused' warnings */
#ifndef SWIGUNUSED
#if defined(__GNUC__)
#if !(defined(__cplusplus)) || (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
#define SWIGUNUSED __attribute__ ((__unused__))
#else
#define SWIGUNUSED
#endif
#elif defined(__ICC)
#define SWIGUNUSED __attribute__ ((__unused__))
#else
#define SWIGUNUSED
#endif
#endif

#ifndef SWIG_MSC_UNSUPPRESS_4505
#if defined(_MSC_VER)
#pragma warning(disable : 4505) /* unreferenced local function has been removed */
#endif
#endif

#ifndef SWIGUNUSEDPARM
#ifdef __cplusplus
#define SWIGUNUSEDPARM(p)
#else
#define SWIGUNUSEDPARM(p) p SWIGUNUSED
#endif
#endif

/* internal SWIG method */
#ifndef SWIGINTERN
#define SWIGINTERN static SWIGUNUSED
#endif

/* internal inline SWIG method */
#ifndef SWIGINTERNINLINE
#define SWIGINTERNINLINE SWIGINTERN SWIGINLINE
#endif

/* exporting methods */
#if (__GNUC__ >= 4) || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4)
#ifndef GCC_HASCLASSVISIBILITY
#define GCC_HASCLASSVISIBILITY
#endif
#endif

#ifndef SWIGEXPORT
#if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#if defined(STATIC_LINKED)
#define SWIGEXPORT
#else
#define SWIGEXPORT __declspec(dllexport)
#endif
#else
#if defined(__GNUC__) && defined(GCC_HASCLASSVISIBILITY)
#define SWIGEXPORT __attribute__ ((visibility("default")))
#else
#define SWIGEXPORT
#endif
#endif
#endif

/* calling conventions for Windows */
#ifndef SWIGSTDCALL
#if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#define SWIGSTDCALL __stdcall
#else
#define SWIGSTDCALL
#endif
#endif

/* Deal with Microsoft's attempt at deprecating C standard runtime functions */
#if !defined(SWIG_NO_CRT_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_CRT_SECURE_NO_DEPRECATE)
#define _CRT_SECURE_NO_DEPRECATE
#endif

/* Deal with Microsoft's attempt at deprecating methods in the standard C++ library */
#if !defined(SWIG_NO_SCL_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_SCL_SECURE_NO_DEPRECATE)
#define _SCL_SECURE_NO_DEPRECATE
#endif

/* Fix for jlong on some versions of gcc on Windows */
#if defined(__GNUC__) && !defined(__INTEL_COMPILER)
typedef long long __int64;
#endif

/* Fix for jlong on 64-bit x86 Solaris */
#if defined(__x86_64)
#ifdef _LP64
#undef _LP64
#endif
#endif

#include <jni.h>
#include <stdlib.h>
#include <string.h>

/* Support for throwing Java exceptions */
typedef enum
{
    SWIG_JavaOutOfMemoryError = 1,
    SWIG_JavaIOException,
    SWIG_JavaRuntimeException,
    SWIG_JavaIndexOutOfBoundsException,
    SWIG_JavaArithmeticException,
    SWIG_JavaIllegalArgumentException,
    SWIG_JavaNullPointerException,
    SWIG_JavaDirectorPureVirtual,
    SWIG_JavaUnknownError
} SWIG_JavaExceptionCodes;

typedef struct
{
    SWIG_JavaExceptionCodes code;
    const char *java_exception;
} SWIG_JavaExceptions_t;

static void SWIGUNUSED SWIG_JavaThrowException(JNIEnv * jenv, SWIG_JavaExceptionCodes code, const char *msg)
{
    jclass excep;

    static const SWIG_JavaExceptions_t java_exceptions[] = {
        {SWIG_JavaOutOfMemoryError, "java/lang/OutOfMemoryError"},
        {SWIG_JavaIOException, "java/io/IOException"},
        {SWIG_JavaRuntimeException, "java/lang/RuntimeException"},
        {SWIG_JavaIndexOutOfBoundsException, "java/lang/IndexOutOfBoundsException"},
        {SWIG_JavaArithmeticException, "java/lang/ArithmeticException"},
        {SWIG_JavaIllegalArgumentException, "java/lang/IllegalArgumentException"},
        {SWIG_JavaNullPointerException, "java/lang/NullPointerException"},
        {SWIG_JavaDirectorPureVirtual, "java/lang/RuntimeException"},
        {SWIG_JavaUnknownError, "java/lang/UnknownError"},
        {(SWIG_JavaExceptionCodes) 0, "java/lang/UnknownError"}
    };
    const SWIG_JavaExceptions_t *except_ptr = java_exceptions;

    while (except_ptr->code != code && except_ptr->code)
        except_ptr++;

    (*jenv)->ExceptionClear(jenv);
    excep = (*jenv)->FindClass(jenv, except_ptr->java_exception);
    if (excep)
        (*jenv)->ThrowNew(jenv, excep, msg);
}

/* Contract support */

#define SWIG_contract_assert(nullreturn, expr, msg) if (!(expr)) {SWIG_JavaThrowException(jenv, SWIG_JavaIllegalArgumentException, msg); return nullreturn; } else

#include "BOOL.h"
#define ENABLE_HELPERS
#include "javasci2_helper.h"
#include "MALLOC.h"
#include "../../../call_scilab/includes/call_scilab.h"
#include "../../../call_scilab/includes/fromjava.h"
#include "../../../api_scilab/includes/api_scilab.h"
#include "../../../output_stream/includes/lasterror.h"
#include "../../../modules/graphics/includes/WindowList.h"
#include "../../../core/includes/sci_types.h"

#if defined(SWIG_NOINCLUDE) || defined(SWIG_NOARRAYS)

int SWIG_JavaArrayInSchar(JNIEnv * jenv, jbyte ** jarr, signed char **carr, jbyteArray input);
void SWIG_JavaArrayArgoutSchar(JNIEnv * jenv, jbyte * jarr, signed char *carr, jbyteArray input);
jbyteArray SWIG_JavaArrayOutSchar(JNIEnv * jenv, signed char *result, jsize sz);

int SWIG_JavaArrayInUchar(JNIEnv * jenv, jshort ** jarr, unsigned char **carr, jshortArray input);
void SWIG_JavaArrayArgoutUchar(JNIEnv * jenv, jshort * jarr, unsigned char *carr, jshortArray input);
jshortArray SWIG_JavaArrayOutUchar(JNIEnv * jenv, unsigned char *result, jsize sz);

int SWIG_JavaArrayInShort(JNIEnv * jenv, jshort ** jarr, short **carr, jshortArray input);
void SWIG_JavaArrayArgoutShort(JNIEnv * jenv, jshort * jarr, short *carr, jshortArray input);
jshortArray SWIG_JavaArrayOutShort(JNIEnv * jenv, short *result, jsize sz);

int SWIG_JavaArrayInUshort(JNIEnv * jenv, jint ** jarr, unsigned short **carr, jintArray input);
void SWIG_JavaArrayArgoutUshort(JNIEnv * jenv, jint * jarr, unsigned short *carr, jintArray input);
jintArray SWIG_JavaArrayOutUshort(JNIEnv * jenv, unsigned short *result, jsize sz);

int SWIG_JavaArrayInInt(JNIEnv * jenv, jint ** jarr, int **carr, jintArray input);
void SWIG_JavaArrayArgoutInt(JNIEnv * jenv, jint * jarr, int *carr, jintArray input);
jintArray SWIG_JavaArrayOutInt(JNIEnv * jenv, int *result, jsize sz);

int SWIG_JavaArrayInUint(JNIEnv * jenv, jlong ** jarr, unsigned int **carr, jlongArray input);
void SWIG_JavaArrayArgoutUint(JNIEnv * jenv, jlong * jarr, unsigned int *carr, jlongArray input);
jlongArray SWIG_JavaArrayOutUint(JNIEnv * jenv, unsigned int *result, jsize sz);

int SWIG_JavaArrayInLong(JNIEnv * jenv, jint ** jarr, long **carr, jintArray input);
void SWIG_JavaArrayArgoutLong(JNIEnv * jenv, jint * jarr, long *carr, jintArray input);
jintArray SWIG_JavaArrayOutLong(JNIEnv * jenv, long *result, jsize sz);

int SWIG_JavaArrayInUlong(JNIEnv * jenv, jlong ** jarr, unsigned long **carr, jlongArray input);
void SWIG_JavaArrayArgoutUlong(JNIEnv * jenv, jlong * jarr, unsigned long *carr, jlongArray input);
jlongArray SWIG_JavaArrayOutUlong(JNIEnv * jenv, unsigned long *result, jsize sz);

int SWIG_JavaArrayInLonglong(JNIEnv * jenv, jlong ** jarr, jlong ** carr, jlongArray input);
void SWIG_JavaArrayArgoutLonglong(JNIEnv * jenv, jlong * jarr, jlong * carr, jlongArray input);
jlongArray SWIG_JavaArrayOutLonglong(JNIEnv * jenv, jlong * result, jsize sz);

int SWIG_JavaArrayInFloat(JNIEnv * jenv, jfloat ** jarr, float **carr, jfloatArray input);
void SWIG_JavaArrayArgoutFloat(JNIEnv * jenv, jfloat * jarr, float *carr, jfloatArray input);
jfloatArray SWIG_JavaArrayOutFloat(JNIEnv * jenv, float *result, jsize sz);

int SWIG_JavaArrayInDouble(JNIEnv * jenv, jdouble ** jarr, double **carr, jdoubleArray input);
void SWIG_JavaArrayArgoutDouble(JNIEnv * jenv, jdouble * jarr, double *carr, jdoubleArray input);
jdoubleArray SWIG_JavaArrayOutDouble(JNIEnv * jenv, double *result, jsize sz);

#else

/* signed char[] support */
int SWIG_JavaArrayInSchar(JNIEnv * jenv, jbyte ** jarr, signed char **carr, jbyteArray input)
{
    int i;
    jsize sz;

    if (!input)
    {
        SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null array");
        return 0;
    }
    sz = (*jenv)->GetArrayLength(jenv, input);
    *jarr = (*jenv)->GetByteArrayElements(jenv, input, 0);
    if (!*jarr)
        return 0;
    *carr = (signed char *)calloc(sz, sizeof(signed char));
    if (!*carr)
    {
        SWIG_JavaThrowException(jenv, SWIG_JavaOutOfMemoryError, "array memory allocation failed");
        return 0;
    }
    for (i = 0; i < sz; i++)
        (*carr)[i] = (signed char)(*jarr)[i];
    return 1;
}

void SWIG_JavaArrayArgoutSchar(JNIEnv * jenv, jbyte * jarr, signed char *carr, jbyteArray input)
{
    int i;
    jsize sz = (*jenv)->GetArrayLength(jenv, input);

    for (i = 0; i < sz; i++)
        jarr[i] = (jbyte) carr[i];
    (*jenv)->ReleaseByteArrayElements(jenv, input, jarr, 0);
}

jbyteArray SWIG_JavaArrayOutSchar(JNIEnv * jenv, signed char *result, jsize sz)
{
    jbyte *arr;
    int i;
    jbyteArray jresult = (*jenv)->NewByteArray(jenv, sz);

    if (!jresult)
        return NULL;
    arr = (*jenv)->GetByteArrayElements(jenv, jresult, 0);
    if (!arr)
        return NULL;
    for (i = 0; i < sz; i++)
        arr[i] = (jbyte) result[i];
    (*jenv)->ReleaseByteArrayElements(jenv, jresult, arr, 0);
    return jresult;
}

/* unsigned char[] support */
int SWIG_JavaArrayInUchar(JNIEnv * jenv, jshort ** jarr, unsigned char **carr, jshortArray input)
{
    int i;
    jsize sz;

    if (!input)
    {
        SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null array");
        return 0;
    }
    sz = (*jenv)->GetArrayLength(jenv, input);
    *jarr = (*jenv)->GetShortArrayElements(jenv, input, 0);
    if (!*jarr)
        return 0;
    *carr = (unsigned char *)calloc(sz, sizeof(unsigned char));
    if (!*carr)
    {
        SWIG_JavaThrowException(jenv, SWIG_JavaOutOfMemoryError, "array memory allocation failed");
        return 0;
    }
    for (i = 0; i < sz; i++)
        (*carr)[i] = (unsigned char)(*jarr)[i];
    return 1;
}

void SWIG_JavaArrayArgoutUchar(JNIEnv * jenv, jshort * jarr, unsigned char *carr, jshortArray input)
{
    int i;
    jsize sz = (*jenv)->GetArrayLength(jenv, input);

    for (i = 0; i < sz; i++)
        jarr[i] = (jshort) carr[i];
    (*jenv)->ReleaseShortArrayElements(jenv, input, jarr, 0);
}

jshortArray SWIG_JavaArrayOutUchar(JNIEnv * jenv, unsigned char *result, jsize sz)
{
    jshort *arr;
    int i;
    jshortArray jresult = (*jenv)->NewShortArray(jenv, sz);

    if (!jresult)
        return NULL;
    arr = (*jenv)->GetShortArrayElements(jenv, jresult, 0);
    if (!arr)
        return NULL;
    for (i = 0; i < sz; i++)
        arr[i] = (jshort) result[i];
    (*jenv)->ReleaseShortArrayElements(jenv, jresult, arr, 0);
    return jresult;
}

/* short[] support */
int SWIG_JavaArrayInShort(JNIEnv * jenv, jshort ** jarr, short **carr, jshortArray input)
{
    int i;
    jsize sz;

    if (!input)
    {
        SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null array");
        return 0;
    }
    sz = (*jenv)->GetArrayLength(jenv, input);
    *jarr = (*jenv)->GetShortArrayElements(jenv, input, 0);
    if (!*jarr)
        return 0;
    *carr = (short *)calloc(sz, sizeof(short));
    if (!*carr)
    {
        SWIG_JavaThrowException(jenv, SWIG_JavaOutOfMemoryError, "array memory allocation failed");
        return 0;
    }
    for (i = 0; i < sz; i++)
        (*carr)[i] = (short)(*jarr)[i];
    return 1;
}

void SWIG_JavaArrayArgoutShort(JNIEnv * jenv, jshort * jarr, short *carr, jshortArray input)
{
    int i;
    jsize sz = (*jenv)->GetArrayLength(jenv, input);

    for (i = 0; i < sz; i++)
        jarr[i] = (jshort) carr[i];
    (*jenv)->ReleaseShortArrayElements(jenv, input, jarr, 0);
}

jshortArray SWIG_JavaArrayOutShort(JNIEnv * jenv, short *result, jsize sz)
{
    jshort *arr;
    int i;
    jshortArray jresult = (*jenv)->NewShortArray(jenv, sz);

    if (!jresult)
        return NULL;
    arr = (*jenv)->GetShortArrayElements(jenv, jresult, 0);
    if (!arr)
        return NULL;
    for (i = 0; i < sz; i++)
        arr[i] = (jshort) result[i];
    (*jenv)->ReleaseShortArrayElements(jenv, jresult, arr, 0);
    return jresult;
}

/* unsigned short[] support */
int SWIG_JavaArrayInUshort(JNIEnv * jenv, jint ** jarr, unsigned short **carr, jintArray input)
{
    int i;
    jsize sz;

    if (!input)
    {
        SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null array");
        return 0;
    }
    sz = (*jenv)->GetArrayLength(jenv, input);
    *jarr = (*jenv)->GetIntArrayElements(jenv, input, 0);
    if (!*jarr)
        return 0;
    *carr = (unsigned short *)calloc(sz, sizeof(unsigned short));
    if (!*carr)
    {
        SWIG_JavaThrowException(jenv, SWIG_JavaOutOfMemoryError, "array memory allocation failed");
        return 0;
    }
    for (i = 0; i < sz; i++)
        (*carr)[i] = (unsigned short)(*jarr)[i];
    return 1;
}

void SWIG_JavaArrayArgoutUshort(JNIEnv * jenv, jint * jarr, unsigned short *carr, jintArray input)
{
    int i;
    jsize sz = (*jenv)->GetArrayLength(jenv, input);

    for (i = 0; i < sz; i++)
        jarr[i] = (jint) carr[i];
    (*jenv)->ReleaseIntArrayElements(jenv, input, jarr, 0);
}

jintArray SWIG_JavaArrayOutUshort(JNIEnv * jenv, unsigned short *result, jsize sz)
{
    jint *arr;
    int i;
    jintArray jresult = (*jenv)->NewIntArray(jenv, sz);

    if (!jresult)
        return NULL;
    arr = (*jenv)->GetIntArrayElements(jenv, jresult, 0);
    if (!arr)
        return NULL;
    for (i = 0; i < sz; i++)
        arr[i] = (jint) result[i];
    (*jenv)->ReleaseIntArrayElements(jenv, jresult, arr, 0);
    return jresult;
}

/* int[] support */
int SWIG_JavaArrayInInt(JNIEnv * jenv, jint ** jarr, int **carr, jintArray input)
{
    int i;
    jsize sz;

    if (!input)
    {
        SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null array");
        return 0;
    }
    sz = (*jenv)->GetArrayLength(jenv, input);
    *jarr = (*jenv)->GetIntArrayElements(jenv, input, 0);
    if (!*jarr)
        return 0;
    *carr = (int *)calloc(sz, sizeof(int));
    if (!*carr)
    {
        SWIG_JavaThrowException(jenv, SWIG_JavaOutOfMemoryError, "array memory allocation failed");
        return 0;
    }
    for (i = 0; i < sz; i++)
        (*carr)[i] = (int)(*jarr)[i];
    return 1;
}

void SWIG_JavaArrayArgoutInt(JNIEnv * jenv, jint * jarr, int *carr, jintArray input)
{
    int i;
    jsize sz = (*jenv)->GetArrayLength(jenv, input);

    for (i = 0; i < sz; i++)
        jarr[i] = (jint) carr[i];
    (*jenv)->ReleaseIntArrayElements(jenv, input, jarr, 0);
}

jintArray SWIG_JavaArrayOutInt(JNIEnv * jenv, int *result, jsize sz)
{
    jint *arr;
    int i;
    jintArray jresult = (*jenv)->NewIntArray(jenv, sz);

    if (!jresult)
        return NULL;
    arr = (*jenv)->GetIntArrayElements(jenv, jresult, 0);
    if (!arr)
        return NULL;
    for (i = 0; i < sz; i++)
        arr[i] = (jint) result[i];
    (*jenv)->ReleaseIntArrayElements(jenv, jresult, arr, 0);
    return jresult;
}

/* unsigned int[] support */
int SWIG_JavaArrayInUint(JNIEnv * jenv, jlong ** jarr, unsigned int **carr, jlongArray input)
{
    int i;
    jsize sz;

    if (!input)
    {
        SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null array");
        return 0;
    }
    sz = (*jenv)->GetArrayLength(jenv, input);
    *jarr = (*jenv)->GetLongArrayElements(jenv, input, 0);
    if (!*jarr)
        return 0;
    *carr = (unsigned int *)calloc(sz, sizeof(unsigned int));
    if (!*carr)
    {
        SWIG_JavaThrowException(jenv, SWIG_JavaOutOfMemoryError, "array memory allocation failed");
        return 0;
    }
    for (i = 0; i < sz; i++)
        (*carr)[i] = (unsigned int)(*jarr)[i];
    return 1;
}

void SWIG_JavaArrayArgoutUint(JNIEnv * jenv, jlong * jarr, unsigned int *carr, jlongArray input)
{
    int i;
    jsize sz = (*jenv)->GetArrayLength(jenv, input);

    for (i = 0; i < sz; i++)
        jarr[i] = (jlong) carr[i];
    (*jenv)->ReleaseLongArrayElements(jenv, input, jarr, 0);
}

jlongArray SWIG_JavaArrayOutUint(JNIEnv * jenv, unsigned int *result, jsize sz)
{
    jlong *arr;
    int i;
    jlongArray jresult = (*jenv)->NewLongArray(jenv, sz);

    if (!jresult)
        return NULL;
    arr = (*jenv)->GetLongArrayElements(jenv, jresult, 0);
    if (!arr)
        return NULL;
    for (i = 0; i < sz; i++)
        arr[i] = (jlong) result[i];
    (*jenv)->ReleaseLongArrayElements(jenv, jresult, arr, 0);
    return jresult;
}

/* long[] support */
int SWIG_JavaArrayInLong(JNIEnv * jenv, jint ** jarr, long **carr, jintArray input)
{
    int i;
    jsize sz;

    if (!input)
    {
        SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null array");
        return 0;
    }
    sz = (*jenv)->GetArrayLength(jenv, input);
    *jarr = (*jenv)->GetIntArrayElements(jenv, input, 0);
    if (!*jarr)
        return 0;
    *carr = (long *)calloc(sz, sizeof(long));
    if (!*carr)
    {
        SWIG_JavaThrowException(jenv, SWIG_JavaOutOfMemoryError, "array memory allocation failed");
        return 0;
    }
    for (i = 0; i < sz; i++)
        (*carr)[i] = (long)(*jarr)[i];
    return 1;
}

void SWIG_JavaArrayArgoutLong(JNIEnv * jenv, jint * jarr, long *carr, jintArray input)
{
    int i;
    jsize sz = (*jenv)->GetArrayLength(jenv, input);

    for (i = 0; i < sz; i++)
        jarr[i] = (jint) carr[i];
    (*jenv)->ReleaseIntArrayElements(jenv, input, jarr, 0);
}

jintArray SWIG_JavaArrayOutLong(JNIEnv * jenv, long *result, jsize sz)
{
    jint *arr;
    int i;
    jintArray jresult = (*jenv)->NewIntArray(jenv, sz);

    if (!jresult)
        return NULL;
    arr = (*jenv)->GetIntArrayElements(jenv, jresult, 0);
    if (!arr)
        return NULL;
    for (i = 0; i < sz; i++)
        arr[i] = (jint) result[i];
    (*jenv)->ReleaseIntArrayElements(jenv, jresult, arr, 0);
    return jresult;
}

/* unsigned long[] support */
int SWIG_JavaArrayInUlong(JNIEnv * jenv, jlong ** jarr, unsigned long **carr, jlongArray input)
{
    int i;
    jsize sz;

    if (!input)
    {
        SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null array");
        return 0;
    }
    sz = (*jenv)->GetArrayLength(jenv, input);
    *jarr = (*jenv)->GetLongArrayElements(jenv, input, 0);
    if (!*jarr)
        return 0;
    *carr = (unsigned long *)calloc(sz, sizeof(unsigned long));
    if (!*carr)
    {
        SWIG_JavaThrowException(jenv, SWIG_JavaOutOfMemoryError, "array memory allocation failed");
        return 0;
    }
    for (i = 0; i < sz; i++)
        (*carr)[i] = (unsigned long)(*jarr)[i];
    return 1;
}

void SWIG_JavaArrayArgoutUlong(JNIEnv * jenv, jlong * jarr, unsigned long *carr, jlongArray input)
{
    int i;
    jsize sz = (*jenv)->GetArrayLength(jenv, input);

    for (i = 0; i < sz; i++)
        jarr[i] = (jlong) carr[i];
    (*jenv)->ReleaseLongArrayElements(jenv, input, jarr, 0);
}

jlongArray SWIG_JavaArrayOutUlong(JNIEnv * jenv, unsigned long *result, jsize sz)
{
    jlong *arr;
    int i;
    jlongArray jresult = (*jenv)->NewLongArray(jenv, sz);

    if (!jresult)
        return NULL;
    arr = (*jenv)->GetLongArrayElements(jenv, jresult, 0);
    if (!arr)
        return NULL;
    for (i = 0; i < sz; i++)
        arr[i] = (jlong) result[i];
    (*jenv)->ReleaseLongArrayElements(jenv, jresult, arr, 0);
    return jresult;
}

/* jlong[] support */
int SWIG_JavaArrayInLonglong(JNIEnv * jenv, jlong ** jarr, jlong ** carr, jlongArray input)
{
    int i;
    jsize sz;

    if (!input)
    {
        SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null array");
        return 0;
    }
    sz = (*jenv)->GetArrayLength(jenv, input);
    *jarr = (*jenv)->GetLongArrayElements(jenv, input, 0);
    if (!*jarr)
        return 0;
    *carr = (jlong *) calloc(sz, sizeof(jlong));
    if (!*carr)
    {
        SWIG_JavaThrowException(jenv, SWIG_JavaOutOfMemoryError, "array memory allocation failed");
        return 0;
    }
    for (i = 0; i < sz; i++)
        (*carr)[i] = (jlong) (*jarr)[i];
    return 1;
}

void SWIG_JavaArrayArgoutLonglong(JNIEnv * jenv, jlong * jarr, jlong * carr, jlongArray input)
{
    int i;
    jsize sz = (*jenv)->GetArrayLength(jenv, input);

    for (i = 0; i < sz; i++)
        jarr[i] = (jlong) carr[i];
    (*jenv)->ReleaseLongArrayElements(jenv, input, jarr, 0);
}

jlongArray SWIG_JavaArrayOutLonglong(JNIEnv * jenv, jlong * result, jsize sz)
{
    jlong *arr;
    int i;
    jlongArray jresult = (*jenv)->NewLongArray(jenv, sz);

    if (!jresult)
        return NULL;
    arr = (*jenv)->GetLongArrayElements(jenv, jresult, 0);
    if (!arr)
        return NULL;
    for (i = 0; i < sz; i++)
        arr[i] = (jlong) result[i];
    (*jenv)->ReleaseLongArrayElements(jenv, jresult, arr, 0);
    return jresult;
}

/* float[] support */
int SWIG_JavaArrayInFloat(JNIEnv * jenv, jfloat ** jarr, float **carr, jfloatArray input)
{
    int i;
    jsize sz;

    if (!input)
    {
        SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null array");
        return 0;
    }
    sz = (*jenv)->GetArrayLength(jenv, input);
    *jarr = (*jenv)->GetFloatArrayElements(jenv, input, 0);
    if (!*jarr)
        return 0;
    *carr = (float *)calloc(sz, sizeof(float));
    if (!*carr)
    {
        SWIG_JavaThrowException(jenv, SWIG_JavaOutOfMemoryError, "array memory allocation failed");
        return 0;
    }
    for (i = 0; i < sz; i++)
        (*carr)[i] = (float)(*jarr)[i];
    return 1;
}

void SWIG_JavaArrayArgoutFloat(JNIEnv * jenv, jfloat * jarr, float *carr, jfloatArray input)
{
    int i;
    jsize sz = (*jenv)->GetArrayLength(jenv, input);

    for (i = 0; i < sz; i++)
        jarr[i] = (jfloat) carr[i];
    (*jenv)->ReleaseFloatArrayElements(jenv, input, jarr, 0);
}

jfloatArray SWIG_JavaArrayOutFloat(JNIEnv * jenv, float *result, jsize sz)
{
    jfloat *arr;
    int i;
    jfloatArray jresult = (*jenv)->NewFloatArray(jenv, sz);

    if (!jresult)
        return NULL;
    arr = (*jenv)->GetFloatArrayElements(jenv, jresult, 0);
    if (!arr)
        return NULL;
    for (i = 0; i < sz; i++)
        arr[i] = (jfloat) result[i];
    (*jenv)->ReleaseFloatArrayElements(jenv, jresult, arr, 0);
    return jresult;
}

/* double[] support */
int SWIG_JavaArrayInDouble(JNIEnv * jenv, jdouble ** jarr, double **carr, jdoubleArray input)
{
    int i;
    jsize sz;

    if (!input)
    {
        SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null array");
        return 0;
    }
    sz = (*jenv)->GetArrayLength(jenv, input);
    *jarr = (*jenv)->GetDoubleArrayElements(jenv, input, 0);
    if (!*jarr)
        return 0;
    *carr = (double *)calloc(sz, sizeof(double));
    if (!*carr)
    {
        SWIG_JavaThrowException(jenv, SWIG_JavaOutOfMemoryError, "array memory allocation failed");
        return 0;
    }
    for (i = 0; i < sz; i++)
        (*carr)[i] = (double)(*jarr)[i];
    return 1;
}

void SWIG_JavaArrayArgoutDouble(JNIEnv * jenv, jdouble * jarr, double *carr, jdoubleArray input)
{
    int i;
    jsize sz = (*jenv)->GetArrayLength(jenv, input);

    for (i = 0; i < sz; i++)
        jarr[i] = (jdouble) carr[i];
    (*jenv)->ReleaseDoubleArrayElements(jenv, input, jarr, 0);
}

jdoubleArray SWIG_JavaArrayOutDouble(JNIEnv * jenv, double *result, jsize sz)
{
    jdouble *arr;
    int i;
    jdoubleArray jresult = (*jenv)->NewDoubleArray(jenv, sz);

    if (!jresult)
        return NULL;
    arr = (*jenv)->GetDoubleArrayElements(jenv, jresult, 0);
    if (!arr)
        return NULL;
    for (i = 0; i < sz; i++)
        arr[i] = (jdouble) result[i];
    (*jenv)->ReleaseDoubleArrayElements(jenv, jresult, arr, 0);
    return jresult;
}

#endif

#ifdef __cplusplus
extern "C"
{
#endif

    SWIGEXPORT jint JNICALL Java_org_scilab_modules_javasci_Call_1ScilabJNI_Call_1ScilabOpen(JNIEnv * jenv, jclass jcls, jstring jarg1,
                                                                                             jboolean jarg2, jstring jarg3, jint jarg4)
    {
        jint jresult = 0;
        char *arg1 = (char *)0;
        BOOL arg2;
        char *arg3 = (char *)0;
        int arg4;
        int result;

          (void)jenv;
          (void)jcls;
          arg1 = 0;
        if (jarg1)
        {
            arg1 = (char *)(*jenv)->GetStringUTFChars(jenv, jarg1, 0);
            if (!arg1)
                return 0;
        }
        {
            if (jarg2 == JNI_TRUE)
                arg2 = TRUE;
            else
                arg2 = FALSE;
        }
        arg3 = 0;
        if (jarg3)
        {
            arg3 = (char *)(*jenv)->GetStringUTFChars(jenv, jarg3, 0);
            if (!arg3)
                return 0;
        }
        arg4 = (int)jarg4;
        result = (int)Call_ScilabOpen(arg1, arg2, arg3, arg4);
        jresult = (jint) result;
        if (arg1)
            (*jenv)->ReleaseStringUTFChars(jenv, jarg1, (const char *)arg1);
        if (arg3)
            (*jenv)->ReleaseStringUTFChars(jenv, jarg3, (const char *)arg3);
        return jresult;
    }

    SWIGEXPORT jboolean JNICALL Java_org_scilab_modules_javasci_Call_1ScilabJNI_TerminateScilab(JNIEnv * jenv, jclass jcls, jstring jarg1)
    {
        jboolean jresult = 0;
        char *arg1 = (char *)0;
        BOOL result;

        (void)jenv;
        (void)jcls;
        arg1 = 0;
        if (jarg1)
        {
            arg1 = (char *)(*jenv)->GetStringUTFChars(jenv, jarg1, 0);
            if (!arg1)
                return 0;
        }
        result = TerminateScilab(arg1);
        {
            if (result)
                jresult = JNI_TRUE;
            else
                jresult = JNI_FALSE;
        }
        if (arg1)
            (*jenv)->ReleaseStringUTFChars(jenv, jarg1, (const char *)arg1);
        return jresult;
    }

    SWIGEXPORT jint JNICALL Java_org_scilab_modules_javasci_Call_1ScilabJNI_SendScilabJob(JNIEnv * jenv, jclass jcls, jstring jarg1)
    {
        jint jresult = 0;
        char *arg1 = (char *)0;
        int result;

        (void)jenv;
        (void)jcls;
        arg1 = 0;
        if (jarg1)
        {
            arg1 = (char *)(*jenv)->GetStringUTFChars(jenv, jarg1, 0);
            if (!arg1)
                return 0;
        }
        result = (int)SendScilabJob(arg1);
        jresult = (jint) result;
        if (arg1)
            (*jenv)->ReleaseStringUTFChars(jenv, jarg1, (const char *)arg1);
        return jresult;
    }

    SWIGEXPORT jint JNICALL Java_org_scilab_modules_javasci_Call_1ScilabJNI_SendScilabJobs(JNIEnv * jenv, jclass jcls, jobjectArray jarg1, jint jarg2)
    {
        jint jresult = 0;
        char **arg1 = (char **)0;
        int arg2;
        jint size1;
        int result;

        (void)jenv;
        (void)jcls;
        {
            int i = 0;

            size1 = (*jenv)->GetArrayLength(jenv, jarg1);
            arg1 = (char **)MALLOC((size1 + 1) * sizeof(char *));
            /* make a copy of each string */
            for (i = 0; i < size1; i++)
            {
                jstring j_string = (jstring) (*jenv)->GetObjectArrayElement(jenv, jarg1, i);
                const char *c_string = (*jenv)->GetStringUTFChars(jenv, j_string, 0);

                arg1[i] = MALLOC((strlen(c_string) + 1) * sizeof(const char *));
                strcpy(arg1[i], c_string);
                (*jenv)->ReleaseStringUTFChars(jenv, j_string, c_string);
                (*jenv)->DeleteLocalRef(jenv, j_string);
            }
            arg1[i] = 0;
        }
        arg2 = (int)jarg2;
        result = (int)SendScilabJobs(arg1, arg2);
        jresult = (jint) result;
        {
            int i;

            for (i = 0; i < size1 - 1; i++)
            {
                FREE(arg1[i]);
                arg1[i] = NULL;
            }
            FREE(arg1);
            arg1 = NULL;
        }
        return jresult;
    }

    SWIGEXPORT void JNICALL Java_org_scilab_modules_javasci_Call_1ScilabJNI_SetFromJavaToON(JNIEnv * jenv, jclass jcls)
    {
        (void)jenv;
        (void)jcls;
        SetFromJavaToON();
    }

    SWIGEXPORT jboolean JNICALL Java_org_scilab_modules_javasci_Call_1ScilabJNI_isGraphicOpened(JNIEnv * jenv, jclass jcls)
    {
        jboolean jresult = 0;
        BOOL result;

        (void)jenv;
        (void)jcls;
        result = sciHasFigures();
        {
            if (result)
                jresult = JNI_TRUE;
            else
                jresult = JNI_FALSE;
        }
        return jresult;
    }

    SWIGEXPORT jint JNICALL Java_org_scilab_modules_javasci_Call_1ScilabJNI_GetLastErrorCode(JNIEnv * jenv, jclass jcls)
    {
        jint jresult = 0;
        int result;

        (void)jenv;
        (void)jcls;
        result = (int)getLastErrorValue();
        jresult = (jint) result;
        return jresult;
    }

    SWIGEXPORT jboolean JNICALL Java_org_scilab_modules_javasci_Call_1ScilabJNI_isExistingVariable(JNIEnv * jenv, jclass jcls, jstring jarg1)
    {
        jboolean jresult = 0;
        char *arg1 = (char *)0;
        BOOL result;

        (void)jenv;
        (void)jcls;
        arg1 = 0;
        if (jarg1)
        {
            arg1 = (char *)(*jenv)->GetStringUTFChars(jenv, jarg1, 0);
            if (!arg1)
                return 0;
        }
        result = isExistingVariable(arg1);
        {
            if (result)
                jresult = JNI_TRUE;
            else
                jresult = JNI_FALSE;
        }
        if (arg1)
            (*jenv)->ReleaseStringUTFChars(jenv, jarg1, (const char *)arg1);
        return jresult;
    }

    SWIGEXPORT jstring JNICALL Java_org_scilab_modules_javasci_Call_1ScilabJNI_getLastErrorMessage(JNIEnv * jenv, jclass jcls)
    {
        jstring jresult = 0;
        char *result = 0;

        (void)jenv;
        (void)jcls;
        result = (char *)getLastErrorMessageSingle();
        {
            if (result != NULL)
            {
                jresult = (*jenv)->NewStringUTF(jenv, (const char *)result);
                FREE(result);
                result = NULL;
            }
        }
        return jresult;
    }

    SWIGEXPORT jint JNICALL Java_org_scilab_modules_javasci_Call_1ScilabJNI_getVariableType(JNIEnv * jenv, jclass jcls, jstring jarg1)
    {
        jint jresult = 0;
        char *arg1 = (char *)0;
        sci_types result;

        (void)jenv;
        (void)jcls;
        arg1 = 0;
        if (jarg1)
        {
            arg1 = (char *)(*jenv)->GetStringUTFChars(jenv, jarg1, 0);
            if (!arg1)
                return 0;
        }
        result = (sci_types) getVariableType(arg1);
        jresult = (jint) result;
        if (arg1)
            (*jenv)->ReleaseStringUTFChars(jenv, jarg1, (const char *)arg1);
        return jresult;
    }

    SWIGEXPORT jint JNICALL Java_org_scilab_modules_javasci_Call_1ScilabJNI_getIntegerPrecision(JNIEnv * jenv, jclass jcls, jstring jarg1)
    {
        jint jresult = 0;
        char *arg1 = (char *)0;
        sci_int_types result;

        (void)jenv;
        (void)jcls;
        arg1 = 0;
        if (jarg1)
        {
            arg1 = (char *)(*jenv)->GetStringUTFChars(jenv, jarg1, 0);
            if (!arg1)
                return 0;
        }
        result = (sci_int_types) getIntegerPrecision(arg1);
        jresult = (jint) result;
        if (arg1)
            (*jenv)->ReleaseStringUTFChars(jenv, jarg1, (const char *)arg1);
        return jresult;
    }

    SWIGEXPORT jboolean JNICALL Java_org_scilab_modules_javasci_Call_1ScilabJNI_isComplex(JNIEnv * jenv, jclass jcls, jstring jarg1)
    {
        jboolean jresult = 0;
        char *arg1 = (char *)0;
        BOOL result;

        (void)jenv;
        (void)jcls;
        arg1 = 0;
        if (jarg1)
        {
            arg1 = (char *)(*jenv)->GetStringUTFChars(jenv, jarg1, 0);
            if (!arg1)
                return 0;
        }
        result = isComplexVar(arg1);
        {
            if (result)
                jresult = JNI_TRUE;
            else
                jresult = JNI_FALSE;
        }
        if (arg1)
            (*jenv)->ReleaseStringUTFChars(jenv, jarg1, (const char *)arg1);
        return jresult;
    }

    SWIGEXPORT jobjectArray JNICALL Java_org_scilab_modules_javasci_Call_1ScilabJNI_getString(JNIEnv * jenv, jclass jcls, jstring jarg1)
    {
        jobjectArray jresult = 0;
        char *arg1 = (char *)0;
        int *arg2 = (int *)0;
        int *arg3 = (int *)0;
        int nbRow;
        int nbCol;
        char **result = 0;

        (void)jenv;
        (void)jcls;
        {
            arg2 = &nbRow;
            arg3 = &nbCol;
            arg1 = 0;
            if (jarg1)
            {
                arg1 = (char *)(*jenv)->GetStringUTFChars(jenv, jarg1, 0);
                if (!arg1)
                    return 0;
            }
        }
        result = (char **)getString(arg1, arg2, arg3);
        {
            const jclass clazz = (*jenv)->FindClass(jenv, "java/lang/Object");
            int i = 0, j = 0;

            jresult = (*jenv)->NewObjectArray(jenv, nbRow, clazz, NULL);

            for (i = 0; i < nbRow; i++)
            {
                //      jdouble array[nbCol];
                jobjectArray jarray = (*jenv)->NewObjectArray(jenv, nbCol, clazz, NULL);

                if (jarray == NULL)
                {
                    printf("Could not allocate\n");
                    fflush(NULL);
                }

                for (j = 0; j < nbCol; j++)
                {
                    /* Scilab is storing matrice cols by cols while Java is doing it
                     * row by row. Therefor, we need to convert it */

                    jstring temp_string = (*jenv)->NewStringUTF(jenv, (const char *)result[nbRow * j + i]);

                    (*jenv)->SetObjectArrayElement(jenv, jarray, j, temp_string);
                    (*jenv)->DeleteLocalRef(jenv, temp_string);
                }

                (*jenv)->SetObjectArrayElement(jenv, jresult, i, jarray);

                (*jenv)->DeleteLocalRef(jenv, jarray);

            }

            if (arg1)
                (*jenv)->ReleaseStringUTFChars(jenv, jarg1, (const char *)arg1);
            free(result);

        }
        return jresult;
    }

    SWIGEXPORT jint JNICALL Java_org_scilab_modules_javasci_Call_1ScilabJNI_putString(JNIEnv * jenv, jclass jcls, jstring jarg1, jobjectArray jarg2)
    {
        jint jresult = 0;
        char *arg1 = (char *)0;
        char **arg2 = (char **)0;
        int arg3;
        int arg4;
        int result;

        (void)jenv;
        (void)jcls;
        arg1 = 0;
        if (jarg1)
        {
            arg1 = (char *)(*jenv)->GetStringUTFChars(jenv, jarg1, 0);
            if (!arg1)
                return 0;
        }
        {
            int i = 0, j = 0;

            // Convert the String[][] => char *
            arg3 = (*jenv)->GetArrayLength(jenv, jarg2);
            arg4 = 0;

            for (i = 0; i < arg3; i++)
            {
                jobjectArray oneDim = (jobjectArray) (*jenv)->GetObjectArrayElement(jenv, jarg2, i);

                if (arg4 == 0)
                {
                    /* First time we are here, init + create the array where we store the data */
                    arg4 = (*jenv)->GetArrayLength(jenv, oneDim);
                    arg2 = (char **)malloc(sizeof(char *) * arg3 * arg4);
                }
                //      jstring*element=(*jenv)->GetStringArrayElements(jenv, oneDim, 0);
                for (j = 0; j < arg4; j++)
                {
                    jstring j_string = (jstring) (*jenv)->GetObjectArrayElement(jenv, oneDim, j);
                    char *str = (char *)(*jenv)->GetStringUTFChars(jenv, j_string, 0);

                    arg2[j * arg3 + i] = (char *)malloc(sizeof(char) * (strlen(str) + 1));
                    strcpy(arg2[j * arg3 + i], str);
                    (*jenv)->ReleaseStringUTFChars(jenv, j_string, (const char *)str);

                }
            }

        }
        result = (int)putString(arg1, arg2, arg3, arg4);
        jresult = (jint) result;
        {
            // Specific target because it was freeing the wrong argument
        }
        if (arg1)
            (*jenv)->ReleaseStringUTFChars(jenv, jarg1, (const char *)arg1);
        return jresult;
    }

    SWIGEXPORT jint JNICALL Java_org_scilab_modules_javasci_Call_1ScilabJNI_putDoubleComplex(JNIEnv * jenv, jclass jcls, jstring jarg1,
                                                                                             jdoubleArray jarg2, jint jarg3, jint jarg4)
    {
        jint jresult = 0;
        char *arg1 = (char *)0;
        double *arg2;
        int arg3;
        int arg4;
        jdouble *jarr2;
        int result;

        (void)jenv;
        (void)jcls;
        arg1 = 0;
        if (jarg1)
        {
            arg1 = (char *)(*jenv)->GetStringUTFChars(jenv, jarg1, 0);
            if (!arg1)
                return 0;
        }
        if (!SWIG_JavaArrayInDouble(jenv, &jarr2, &arg2, jarg2))
            return 0;
        arg3 = (int)jarg3;
        arg4 = (int)jarg4;
        result = (int)putDoubleComplex(arg1, arg2, arg3, arg4);
        jresult = (jint) result;
        SWIG_JavaArrayArgoutDouble(jenv, jarr2, arg2, jarg2);
        if (arg1)
            (*jenv)->ReleaseStringUTFChars(jenv, jarg1, (const char *)arg1);
        free(arg2);
        return jresult;
    }

    SWIGEXPORT jobjectArray JNICALL Java_org_scilab_modules_javasci_Call_1ScilabJNI_getDouble(JNIEnv * jenv, jclass jcls, jstring jarg1)
    {
        jobjectArray jresult = 0;
        char *arg1 = (char *)0;
        int *arg2 = (int *)0;
        int *arg3 = (int *)0;
        int nbRow;
        int nbCol;
        double *result = 0;

        (void)jenv;
        (void)jcls;
        {
            arg2 = &nbRow;
            arg3 = &nbCol;
            arg1 = 0;
            if (jarg1)
            {
                arg1 = (char *)(*jenv)->GetStringUTFChars(jenv, jarg1, 0);
                if (!arg1)
                    return 0;
            }
        }
        result = (double *)getDouble(arg1, arg2, arg3);
        {
            jclass doubleArr = (*jenv)->FindClass(jenv, "[D");
            int i = 0, j = 0;

            jresult = (*jenv)->NewObjectArray(jenv, nbRow, doubleArr, NULL);

            for (i = 0; i < nbRow; i++)
            {
                jdouble *array = (jdouble *) malloc(nbCol * sizeof(jdouble));
                jdoubleArray jarray = (*jenv)->NewDoubleArray(jenv, nbCol);

                if (jarray == NULL)
                {
                    printf("Could not allocate\n");
                    fflush(NULL);
                }

                if (array)
                {
                    for (j = 0; j < nbCol; j++)
                    {
                        /* Scilab is storing matrice cols by cols while Java is doing it
                         * row by row. Therefor, we need to convert it */
                        array[j] = result[nbRow * j + i];
                    }
                }

                (*jenv)->SetDoubleArrayRegion(jenv, jarray, 0, nbCol, array);

                (*jenv)->SetObjectArrayElement(jenv, jresult, i, jarray);

                (*jenv)->DeleteLocalRef(jenv, jarray);
                if (array)
                {
                    free(array);
                    array = NULL;
                }
            }

            if (arg1)
                (*jenv)->ReleaseStringUTFChars(jenv, jarg1, (const char *)arg1);
            free(result);

        }
        return jresult;
    }

    SWIGEXPORT jint JNICALL Java_org_scilab_modules_javasci_Call_1ScilabJNI_putDouble(JNIEnv * jenv, jclass jcls, jstring jarg1, jobjectArray jarg2)
    {
        jint jresult = 0;
        char *arg1 = (char *)0;
        double *arg2;
        int arg3;
        int arg4;
        int result;

        (void)jenv;
        (void)jcls;
        arg1 = 0;
        if (jarg1)
        {
            arg1 = (char *)(*jenv)->GetStringUTFChars(jenv, jarg1, 0);
            if (!arg1)
                return 0;
        }
        {
            // Convert the double[][] => double *
            int i = 0, j = 0;

            arg3 = (*jenv)->GetArrayLength(jenv, jarg2);
            arg4 = 0;

            for (i = 0; i < arg3; i++)
            {
                jdouble *element = NULL;
                jdoubleArray oneDim = (jdoubleArray) (*jenv)->GetObjectArrayElement(jenv, jarg2, i);

                if (arg4 == 0)
                {
                    /* First time we are here, init + create the array where we store the data */
                    arg4 = (*jenv)->GetArrayLength(jenv, oneDim);
                    arg2 = (double *)malloc(sizeof(double) * arg3 * arg4);
                }
                element = (*jenv)->GetDoubleArrayElements(jenv, oneDim, 0);

                for (j = 0; j < arg4; j++)
                {
                    arg2[j * arg3 + i] = element[j];
                }
            }

        }
        result = (int)putDouble(arg1, arg2, arg3, arg4);
        jresult = (jint) result;
        {
            // Specific target because it was freeing the wrong argument
        }
        if (arg1)
            (*jenv)->ReleaseStringUTFChars(jenv, jarg1, (const char *)arg1);
        return jresult;
    }

    SWIGEXPORT jobjectArray JNICALL Java_org_scilab_modules_javasci_Call_1ScilabJNI_getBoolean(JNIEnv * jenv, jclass jcls, jstring jarg1)
    {
        jobjectArray jresult = 0;
        char *arg1 = (char *)0;
        int *arg2 = (int *)0;
        int *arg3 = (int *)0;
        int nbRow;
        int nbCol;
        BOOL *result = 0;

        (void)jenv;
        (void)jcls;
        {
            arg2 = &nbRow;
            arg3 = &nbCol;
            arg1 = 0;
            if (jarg1)
            {
                arg1 = (char *)(*jenv)->GetStringUTFChars(jenv, jarg1, 0);
                if (!arg1)
                    return 0;
            }
        }
        result = (BOOL *) getBoolean(arg1, arg2, arg3);
        {
            jclass booleanArr = (*jenv)->FindClass(jenv, "[Z");
            int i = 0, j = 0;

            jresult = (*jenv)->NewObjectArray(jenv, nbRow, booleanArr, NULL);

            for (i = 0; i < nbRow; i++)
            {
                jboolean *array = (jboolean *) malloc(nbCol * sizeof(jboolean));
                jbooleanArray jarray = (*jenv)->NewBooleanArray(jenv, nbCol);

                if (jarray == NULL)
                {
                    printf("Could not allocate\n");
                    fflush(NULL);
                }

                if (array)
                {
                    for (j = 0; j < nbCol; j++)
                    {
                        /* Scilab is storing matrice cols by cols while Java is doing it
                         * row by row. Therefor, we need to convert it */
                        array[j] = result[nbRow * j + i];
                    }
                }

                (*jenv)->SetBooleanArrayRegion(jenv, jarray, 0, nbCol, array);

                (*jenv)->SetObjectArrayElement(jenv, jresult, i, jarray);

                (*jenv)->DeleteLocalRef(jenv, jarray);
                if (array)
                {
                    free(array);
                    array = NULL;
                }
            }

            if (arg1)
                (*jenv)->ReleaseStringUTFChars(jenv, jarg1, (const char *)arg1);
            free(result);

        }
        return jresult;
    }

    SWIGEXPORT jint JNICALL Java_org_scilab_modules_javasci_Call_1ScilabJNI_putBoolean(JNIEnv * jenv, jclass jcls, jstring jarg1, jobjectArray jarg2)
    {
        jint jresult = 0;
        char *arg1 = (char *)0;
        BOOL *arg2;
        int arg3;
        int arg4;
        int result;

        (void)jenv;
        (void)jcls;
        arg1 = 0;
        if (jarg1)
        {
            arg1 = (char *)(*jenv)->GetStringUTFChars(jenv, jarg1, 0);
            if (!arg1)
                return 0;
        }
        {
            // Convert the BOOL[][] => BOOL *
            int i = 0, j = 0;

            arg3 = (*jenv)->GetArrayLength(jenv, jarg2);
            arg4 = 0;

            for (i = 0; i < arg3; i++)
            {
                jboolean *element = NULL;
                jbooleanArray oneDim = (jbooleanArray) (*jenv)->GetObjectArrayElement(jenv, jarg2, i);

                if (arg4 == 0)
                {
                    /* First time we are here, init + create the array where we store the data */
                    arg4 = (*jenv)->GetArrayLength(jenv, oneDim);
                    arg2 = (BOOL *) malloc(sizeof(BOOL) * arg3 * arg4);
                }
                element = (*jenv)->GetBooleanArrayElements(jenv, oneDim, 0);

                for (j = 0; j < arg4; j++)
                {
                    arg2[j * arg3 + i] = element[j];
                }
            }

        }
        result = (int)putBoolean(arg1, arg2, arg3, arg4);
        jresult = (jint) result;
        {
            // Specific target because it was freeing the wrong argument
        }
        if (arg1)
            (*jenv)->ReleaseStringUTFChars(jenv, jarg1, (const char *)arg1);
        return jresult;
    }

    SWIGEXPORT jobjectArray JNICALL Java_org_scilab_modules_javasci_Call_1ScilabJNI_getByte(JNIEnv * jenv, jclass jcls, jstring jarg1)
    {
        jobjectArray jresult = 0;
        char *arg1 = (char *)0;
        int *arg2 = (int *)0;
        int *arg3 = (int *)0;
        int nbRow;
        int nbCol;
        byte *result = 0;

        (void)jenv;
        (void)jcls;
        {
            arg2 = &nbRow;
            arg3 = &nbCol;
            arg1 = 0;
            if (jarg1)
            {
                arg1 = (char *)(*jenv)->GetStringUTFChars(jenv, jarg1, 0);
                if (!arg1)
                    return 0;
            }
        }
        result = (byte *) getByte(arg1, arg2, arg3);
        {
            jclass byteArr = (*jenv)->FindClass(jenv, "[B");
            int i = 0, j = 0;

            jresult = (*jenv)->NewObjectArray(jenv, nbRow, byteArr, NULL);

            for (i = 0; i < nbRow; i++)
            {
                jbyte *array = (jbyte *) malloc(nbCol * sizeof(jbyte));
                jbyteArray jarray = (*jenv)->NewByteArray(jenv, nbCol);

                if (jarray == NULL)
                {
                    printf("Could not allocate\n");
                    fflush(NULL);
                }

                if (array)
                {
                    for (j = 0; j < nbCol; j++)
                    {
                        /* Scilab is storing matrice cols by cols while Java is doing it
                         * row by row. Therefor, we need to convert it */
                        array[j] = result[nbRow * j + i];
                    }
                }

                (*jenv)->SetByteArrayRegion(jenv, jarray, 0, nbCol, array);

                (*jenv)->SetObjectArrayElement(jenv, jresult, i, jarray);

                (*jenv)->DeleteLocalRef(jenv, jarray);
                if (array)
                {
                    free(array);
                    array = NULL;
                }
            }

            if (arg1)
                (*jenv)->ReleaseStringUTFChars(jenv, jarg1, (const char *)arg1);
            free(result);

        }
        return jresult;
    }

    SWIGEXPORT jint JNICALL Java_org_scilab_modules_javasci_Call_1ScilabJNI_putByte(JNIEnv * jenv, jclass jcls, jstring jarg1, jobjectArray jarg2)
    {
        jint jresult = 0;
        char *arg1 = (char *)0;
        byte *arg2;
        int arg3;
        int arg4;
        int result;

        (void)jenv;
        (void)jcls;
        arg1 = 0;
        if (jarg1)
        {
            arg1 = (char *)(*jenv)->GetStringUTFChars(jenv, jarg1, 0);
            if (!arg1)
                return 0;
        }
        {
            // Convert the byte[][] => byte *
            int i = 0, j = 0;

            arg3 = (*jenv)->GetArrayLength(jenv, jarg2);
            arg4 = 0;

            for (i = 0; i < arg3; i++)
            {
                jbyte *element = NULL;
                jbyteArray oneDim = (jbyteArray) (*jenv)->GetObjectArrayElement(jenv, jarg2, i);

                if (arg4 == 0)
                {
                    /* First time we are here, init + create the array where we store the data */
                    arg4 = (*jenv)->GetArrayLength(jenv, oneDim);
                    arg2 = (byte *) malloc(sizeof(byte) * arg3 * arg4);
                }
                element = (*jenv)->GetByteArrayElements(jenv, oneDim, 0);

                for (j = 0; j < arg4; j++)
                {
                    arg2[j * arg3 + i] = element[j];
                }
            }

        }
        result = (int)putByte(arg1, arg2, arg3, arg4);
        jresult = (jint) result;
        {
            // Specific target because it was freeing the wrong argument
        }
        if (arg1)
            (*jenv)->ReleaseStringUTFChars(jenv, jarg1, (const char *)arg1);
        return jresult;
    }

    SWIGEXPORT jobjectArray JNICALL Java_org_scilab_modules_javasci_Call_1ScilabJNI_getUnsignedByte(JNIEnv * jenv, jclass jcls, jstring jarg1)
    {
        jobjectArray jresult = 0;
        char *arg1 = (char *)0;
        int *arg2 = (int *)0;
        int *arg3 = (int *)0;
        int nbRow;
        int nbCol;
        byte *result = 0;

        (void)jenv;
        (void)jcls;
        {
            arg2 = &nbRow;
            arg3 = &nbCol;
            arg1 = 0;
            if (jarg1)
            {
                arg1 = (char *)(*jenv)->GetStringUTFChars(jenv, jarg1, 0);
                if (!arg1)
                    return 0;
            }
        }
        result = (byte *) getUnsignedByte(arg1, arg2, arg3);
        {
            jclass byteArr = (*jenv)->FindClass(jenv, "[B");
            int i = 0, j = 0;

            jresult = (*jenv)->NewObjectArray(jenv, nbRow, byteArr, NULL);

            for (i = 0; i < nbRow; i++)
            {
                jbyte *array = (jbyte *) malloc(nbCol * sizeof(jbyte));
                jbyteArray jarray = (*jenv)->NewByteArray(jenv, nbCol);

                if (jarray == NULL)
                {
                    printf("Could not allocate\n");
                    fflush(NULL);
                }

                if (array)
                {
                    for (j = 0; j < nbCol; j++)
                    {
                        /* Scilab is storing matrice cols by cols while Java is doing it
                         * row by row. Therefor, we need to convert it */
                        array[j] = result[nbRow * j + i];
                    }
                }

                (*jenv)->SetByteArrayRegion(jenv, jarray, 0, nbCol, array);

                (*jenv)->SetObjectArrayElement(jenv, jresult, i, jarray);

                (*jenv)->DeleteLocalRef(jenv, jarray);
                if (array)
                {
                    free(array);
                    array = NULL;
                }
            }

            if (arg1)
                (*jenv)->ReleaseStringUTFChars(jenv, jarg1, (const char *)arg1);
            free(result);

        }
        return jresult;
    }

    SWIGEXPORT jint JNICALL Java_org_scilab_modules_javasci_Call_1ScilabJNI_putUnsignedByte(JNIEnv * jenv, jclass jcls, jstring jarg1,
                                                                                            jobjectArray jarg2)
    {
        jint jresult = 0;
        char *arg1 = (char *)0;
        byte *arg2;
        int arg3;
        int arg4;
        int result;

        (void)jenv;
        (void)jcls;
        arg1 = 0;
        if (jarg1)
        {
            arg1 = (char *)(*jenv)->GetStringUTFChars(jenv, jarg1, 0);
            if (!arg1)
                return 0;
        }
        {
            // Convert the byte[][] => byte *
            int i = 0, j = 0;

            arg3 = (*jenv)->GetArrayLength(jenv, jarg2);
            arg4 = 0;

            for (i = 0; i < arg3; i++)
            {
                jbyte *element = NULL;
                jbyteArray oneDim = (jbyteArray) (*jenv)->GetObjectArrayElement(jenv, jarg2, i);

                if (arg4 == 0)
                {
                    /* First time we are here, init + create the array where we store the data */
                    arg4 = (*jenv)->GetArrayLength(jenv, oneDim);
                    arg2 = (byte *) malloc(sizeof(byte) * arg3 * arg4);
                }
                element = (*jenv)->GetByteArrayElements(jenv, oneDim, 0);

                for (j = 0; j < arg4; j++)
                {
                    arg2[j * arg3 + i] = element[j];
                }
            }

        }
        result = (int)putUnsignedByte(arg1, arg2, arg3, arg4);
        jresult = (jint) result;
        {
            // Specific target because it was freeing the wrong argument
        }
        if (arg1)
            (*jenv)->ReleaseStringUTFChars(jenv, jarg1, (const char *)arg1);
        return jresult;
    }

    SWIGEXPORT jobjectArray JNICALL Java_org_scilab_modules_javasci_Call_1ScilabJNI_getShort(JNIEnv * jenv, jclass jcls, jstring jarg1)
    {
        jobjectArray jresult = 0;
        char *arg1 = (char *)0;
        int *arg2 = (int *)0;
        int *arg3 = (int *)0;
        int nbRow;
        int nbCol;
        short *result = 0;

        (void)jenv;
        (void)jcls;
        {
            arg2 = &nbRow;
            arg3 = &nbCol;
            arg1 = 0;
            if (jarg1)
            {
                arg1 = (char *)(*jenv)->GetStringUTFChars(jenv, jarg1, 0);
                if (!arg1)
                    return 0;
            }
        }
        result = (short *)getShort(arg1, arg2, arg3);
        {
            jclass shortArr = (*jenv)->FindClass(jenv, "[S");
            int i = 0, j = 0;

            jresult = (*jenv)->NewObjectArray(jenv, nbRow, shortArr, NULL);

            for (i = 0; i < nbRow; i++)
            {
                jshort *array = (jshort *) malloc(nbCol * sizeof(jshort));
                jshortArray jarray = (*jenv)->NewShortArray(jenv, nbCol);

                if (jarray == NULL)
                {
                    printf("Could not allocate\n");
                    fflush(NULL);
                }

                if (array)
                {
                    for (j = 0; j < nbCol; j++)
                    {
                        /* Scilab is storing matrice cols by cols while Java is doing it
                         * row by row. Therefor, we need to convert it */
                        array[j] = result[nbRow * j + i];
                    }
                }

                (*jenv)->SetShortArrayRegion(jenv, jarray, 0, nbCol, array);

                (*jenv)->SetObjectArrayElement(jenv, jresult, i, jarray);

                (*jenv)->DeleteLocalRef(jenv, jarray);
                if (array)
                {
                    free(array);
                    array = NULL;
                }
            }

            if (arg1)
                (*jenv)->ReleaseStringUTFChars(jenv, jarg1, (const char *)arg1);
            free(result);

        }
        return jresult;
    }

    SWIGEXPORT jint JNICALL Java_org_scilab_modules_javasci_Call_1ScilabJNI_putShort(JNIEnv * jenv, jclass jcls, jstring jarg1, jobjectArray jarg2)
    {
        jint jresult = 0;
        char *arg1 = (char *)0;
        short *arg2;
        int arg3;
        int arg4;
        int result;

        (void)jenv;
        (void)jcls;
        arg1 = 0;
        if (jarg1)
        {
            arg1 = (char *)(*jenv)->GetStringUTFChars(jenv, jarg1, 0);
            if (!arg1)
                return 0;
        }
        {
            // Convert the short[][] => short *
            int i = 0, j = 0;

            arg3 = (*jenv)->GetArrayLength(jenv, jarg2);
            arg4 = 0;

            for (i = 0; i < arg3; i++)
            {
                jshort *element = NULL;
                jshortArray oneDim = (jshortArray) (*jenv)->GetObjectArrayElement(jenv, jarg2, i);

                if (arg4 == 0)
                {
                    /* First time we are here, init + create the array where we store the data */
                    arg4 = (*jenv)->GetArrayLength(jenv, oneDim);
                    arg2 = (short *)malloc(sizeof(short) * arg3 * arg4);
                }
                element = (*jenv)->GetShortArrayElements(jenv, oneDim, 0);

                for (j = 0; j < arg4; j++)
                {
                    arg2[j * arg3 + i] = element[j];
                }
            }

        }
        result = (int)putShort(arg1, arg2, arg3, arg4);
        jresult = (jint) result;
        {
            // Specific target because it was freeing the wrong argument
        }
        if (arg1)
            (*jenv)->ReleaseStringUTFChars(jenv, jarg1, (const char *)arg1);
        return jresult;
    }

    SWIGEXPORT jobjectArray JNICALL Java_org_scilab_modules_javasci_Call_1ScilabJNI_getUnsignedShort(JNIEnv * jenv, jclass jcls, jstring jarg1)
    {
        jobjectArray jresult = 0;
        char *arg1 = (char *)0;
        int *arg2 = (int *)0;
        int *arg3 = (int *)0;
        int nbRow;
        int nbCol;
        unsigned short *result = 0;

        (void)jenv;
        (void)jcls;
        {
            arg2 = &nbRow;
            arg3 = &nbCol;
            arg1 = 0;
            if (jarg1)
            {
                arg1 = (char *)(*jenv)->GetStringUTFChars(jenv, jarg1, 0);
                if (!arg1)
                    return 0;
            }
        }
        result = (unsigned short *)getUnsignedShort(arg1, arg2, arg3);
        {
            jclass shortArr = (*jenv)->FindClass(jenv, "[C");
            int i = 0, j = 0;

            jresult = (*jenv)->NewObjectArray(jenv, nbRow, shortArr, NULL);

            for (i = 0; i < nbRow; i++)
            {
                jchar *array = (jchar *) malloc(nbCol * sizeof(jchar));
                jcharArray jarray = (*jenv)->NewCharArray(jenv, nbCol);

                if (jarray == NULL)
                {
                    printf("Could not allocate\n");
                    fflush(NULL);
                }

                if (array)
                {
                    for (j = 0; j < nbCol; j++)
                    {
                        /* Scilab is storing matrice cols by cols while Java is doing it
                         * row by row. Therefor, we need to convert it */
                        array[j] = result[nbRow * j + i];
                    }
                }

                (*jenv)->SetCharArrayRegion(jenv, jarray, 0, nbCol, array);

                (*jenv)->SetObjectArrayElement(jenv, jresult, i, jarray);

                (*jenv)->DeleteLocalRef(jenv, jarray);
                if (array)
                {
                    free(array);
                    array = NULL;
                }
            }

            if (arg1)
                (*jenv)->ReleaseStringUTFChars(jenv, jarg1, (const char *)arg1);
            free(result);

        }
        return jresult;
    }

    SWIGEXPORT jint JNICALL Java_org_scilab_modules_javasci_Call_1ScilabJNI_putUnsignedShort(JNIEnv * jenv, jclass jcls, jstring jarg1,
                                                                                             jobjectArray jarg2)
    {
        jint jresult = 0;
        char *arg1 = (char *)0;
        unsigned short *arg2;
        int arg3;
        int arg4;
        int result;

        (void)jenv;
        (void)jcls;
        arg1 = 0;
        if (jarg1)
        {
            arg1 = (char *)(*jenv)->GetStringUTFChars(jenv, jarg1, 0);
            if (!arg1)
                return 0;
        }
        {
            // Convert the unsigned short[][] => unsigned short *
            int i = 0, j = 0;

            arg3 = (*jenv)->GetArrayLength(jenv, jarg2);
            arg4 = 0;

            for (i = 0; i < arg3; i++)
            {
                jchar *element = NULL;
                jcharArray oneDim = (jcharArray) (*jenv)->GetObjectArrayElement(jenv, jarg2, i);

                if (arg4 == 0)
                {
                    /* First time we are here, init + create the array where we store the data */
                    arg4 = (*jenv)->GetArrayLength(jenv, oneDim);
                    arg2 = (unsigned short *)malloc(sizeof(unsigned short) * arg3 * arg4);
                }
                element = (*jenv)->GetCharArrayElements(jenv, oneDim, 0);

                for (j = 0; j < arg4; j++)
                {
                    arg2[j * arg3 + i] = element[j];
                }
            }

        }
        result = (int)putUnsignedShort(arg1, arg2, arg3, arg4);
        jresult = (jint) result;
        {
            // Specific target because it was freeing the wrong argument
        }
        if (arg1)
            (*jenv)->ReleaseStringUTFChars(jenv, jarg1, (const char *)arg1);
        return jresult;
    }

    SWIGEXPORT jobjectArray JNICALL Java_org_scilab_modules_javasci_Call_1ScilabJNI_getInt(JNIEnv * jenv, jclass jcls, jstring jarg1)
    {
        jobjectArray jresult = 0;
        char *arg1 = (char *)0;
        int *arg2 = (int *)0;
        int *arg3 = (int *)0;
        int nbRow;
        int nbCol;
        int *result = 0;

        (void)jenv;
        (void)jcls;
        {
            arg2 = &nbRow;
            arg3 = &nbCol;
            arg1 = 0;
            if (jarg1)
            {
                arg1 = (char *)(*jenv)->GetStringUTFChars(jenv, jarg1, 0);
                if (!arg1)
                    return 0;
            }
        }
        result = (int *)getInt(arg1, arg2, arg3);
        {
            jclass intArr = (*jenv)->FindClass(jenv, "[I");
            int i = 0, j = 0;

            jresult = (*jenv)->NewObjectArray(jenv, nbRow, intArr, NULL);

            for (i = 0; i < nbRow; i++)
            {
                jint *array = (jint *) malloc(nbCol * sizeof(jint));
                jintArray jarray = (*jenv)->NewIntArray(jenv, nbCol);

                if (jarray == NULL)
                {
                    printf("Could not allocate\n");
                    fflush(NULL);
                }

                if (array)
                {
                    for (j = 0; j < nbCol; j++)
                    {
                        /* Scilab is storing matrice cols by cols while Java is doing it
                         * row by row. Therefor, we need to convert it */
                        array[j] = result[nbRow * j + i];
                    }
                }

                (*jenv)->SetIntArrayRegion(jenv, jarray, 0, nbCol, array);

                (*jenv)->SetObjectArrayElement(jenv, jresult, i, jarray);

                (*jenv)->DeleteLocalRef(jenv, jarray);
                if (array)
                {
                    free(array);
                    array = NULL;
                }
            }

            if (arg1)
                (*jenv)->ReleaseStringUTFChars(jenv, jarg1, (const char *)arg1);
            free(result);

        }
        return jresult;
    }

    SWIGEXPORT jint JNICALL Java_org_scilab_modules_javasci_Call_1ScilabJNI_putInt(JNIEnv * jenv, jclass jcls, jstring jarg1, jobjectArray jarg2)
    {
        jint jresult = 0;
        char *arg1 = (char *)0;
        int *arg2;
        int arg3;
        int arg4;
        int result;

        (void)jenv;
        (void)jcls;
        arg1 = 0;
        if (jarg1)
        {
            arg1 = (char *)(*jenv)->GetStringUTFChars(jenv, jarg1, 0);
            if (!arg1)
                return 0;
        }
        {
            // Convert the int[][] => int *
            int i = 0, j = 0;

            arg3 = (*jenv)->GetArrayLength(jenv, jarg2);
            arg4 = 0;

            for (i = 0; i < arg3; i++)
            {
                jint *element = NULL;
                jintArray oneDim = (jintArray) (*jenv)->GetObjectArrayElement(jenv, jarg2, i);

                if (arg4 == 0)
                {
                    /* First time we are here, init + create the array where we store the data */
                    arg4 = (*jenv)->GetArrayLength(jenv, oneDim);
                    arg2 = (int *)malloc(sizeof(int) * arg3 * arg4);
                }
                element = (*jenv)->GetIntArrayElements(jenv, oneDim, 0);

                for (j = 0; j < arg4; j++)
                {
                    arg2[j * arg3 + i] = element[j];
                }
            }

        }
        result = (int)putInt(arg1, arg2, arg3, arg4);
        jresult = (jint) result;
        {
            // Specific target because it was freeing the wrong argument
        }
        if (arg1)
            (*jenv)->ReleaseStringUTFChars(jenv, jarg1, (const char *)arg1);
        return jresult;
    }

    SWIGEXPORT jobjectArray JNICALL Java_org_scilab_modules_javasci_Call_1ScilabJNI_getUnsignedInt(JNIEnv * jenv, jclass jcls, jstring jarg1)
    {
        jobjectArray jresult = 0;
        char *arg1 = (char *)0;
        int *arg2 = (int *)0;
        int *arg3 = (int *)0;
        int nbRow;
        int nbCol;
        unsigned int *result = 0;

        (void)jenv;
        (void)jcls;
        {
            arg2 = &nbRow;
            arg3 = &nbCol;
            arg1 = 0;
            if (jarg1)
            {
                arg1 = (char *)(*jenv)->GetStringUTFChars(jenv, jarg1, 0);
                if (!arg1)
                    return 0;
            }
        }
        result = (unsigned int *)getUnsignedInt(arg1, arg2, arg3);
        {
            jclass intArr = (*jenv)->FindClass(jenv, "[I");
            int i = 0, j = 0;

            jresult = (*jenv)->NewObjectArray(jenv, nbRow, intArr, NULL);

            for (i = 0; i < nbRow; i++)
            {
                jint *array = (jint *) malloc(nbCol * sizeof(jint));
                jintArray jarray = (*jenv)->NewIntArray(jenv, nbCol);

                if (jarray == NULL)
                {
                    printf("Could not allocate\n");
                    fflush(NULL);
                }

                if (array)
                {
                    for (j = 0; j < nbCol; j++)
                    {
                        /* Scilab is storing matrice cols by cols while Java is doing it
                         * row by row. Therefor, we need to convert it */
                        array[j] = result[nbRow * j + i];
                    }
                }

                (*jenv)->SetIntArrayRegion(jenv, jarray, 0, nbCol, array);

                (*jenv)->SetObjectArrayElement(jenv, jresult, i, jarray);

                (*jenv)->DeleteLocalRef(jenv, jarray);
                if (array)
                {
                    free(array);
                    array = NULL;
                }
            }

            if (arg1)
                (*jenv)->ReleaseStringUTFChars(jenv, jarg1, (const char *)arg1);
            free(result);

        }
        return jresult;
    }

    SWIGEXPORT jint JNICALL Java_org_scilab_modules_javasci_Call_1ScilabJNI_putUnsignedInt(JNIEnv * jenv, jclass jcls, jstring jarg1,
                                                                                           jobjectArray jarg2)
    {
        jint jresult = 0;
        char *arg1 = (char *)0;
        unsigned int *arg2;
        int arg3;
        int arg4;
        int result;

        (void)jenv;
        (void)jcls;
        arg1 = 0;
        if (jarg1)
        {
            arg1 = (char *)(*jenv)->GetStringUTFChars(jenv, jarg1, 0);
            if (!arg1)
                return 0;
        }
        {
            // Convert the unsigned int[][] => unsigned int *
            int i = 0, j = 0;

            arg3 = (*jenv)->GetArrayLength(jenv, jarg2);
            arg4 = 0;

            for (i = 0; i < arg3; i++)
            {
                jint *element = NULL;
                jintArray oneDim = (jintArray) (*jenv)->GetObjectArrayElement(jenv, jarg2, i);

                if (arg4 == 0)
                {
                    /* First time we are here, init + create the array where we store the data */
                    arg4 = (*jenv)->GetArrayLength(jenv, oneDim);
                    arg2 = (unsigned int *)malloc(sizeof(unsigned int) * arg3 * arg4);
                }
                element = (*jenv)->GetIntArrayElements(jenv, oneDim, 0);

                for (j = 0; j < arg4; j++)
                {
                    arg2[j * arg3 + i] = element[j];
                }
            }

        }
        result = (int)putUnsignedInt(arg1, arg2, arg3, arg4);
        jresult = (jint) result;
        {
            // Specific target because it was freeing the wrong argument
        }
        if (arg1)
            (*jenv)->ReleaseStringUTFChars(jenv, jarg1, (const char *)arg1);
        return jresult;
    }

    SWIGEXPORT jobjectArray JNICALL Java_org_scilab_modules_javasci_Call_1ScilabJNI_getDoubleComplexReal(JNIEnv * jenv, jclass jcls, jstring jarg1)
    {
        jobjectArray jresult = 0;
        char *arg1 = (char *)0;
        int *arg2 = (int *)0;
        int *arg3 = (int *)0;
        int nbRow;
        int nbCol;
        double *result = 0;

        (void)jenv;
        (void)jcls;
        {
            arg2 = &nbRow;
            arg3 = &nbCol;
            arg1 = 0;
            if (jarg1)
            {
                arg1 = (char *)(*jenv)->GetStringUTFChars(jenv, jarg1, 0);
                if (!arg1)
                    return 0;
            }
        }
        result = (double *)getDoubleComplexReal(arg1, arg2, arg3);
        {
            jclass doubleArr = (*jenv)->FindClass(jenv, "[D");
            int i = 0, j = 0;

            jresult = (*jenv)->NewObjectArray(jenv, nbRow, doubleArr, NULL);

            for (i = 0; i < nbRow; i++)
            {
                jdouble *array = (jdouble *) malloc(nbCol * sizeof(jdouble));
                jdoubleArray jarray = (*jenv)->NewDoubleArray(jenv, nbCol);

                if (jarray == NULL)
                {
                    printf("Could not allocate\n");
                    fflush(NULL);
                }

                if (array)
                {
                    for (j = 0; j < nbCol; j++)
                    {
                        /* Scilab is storing matrice cols by cols while Java is doing it
                         * row by row. Therefor, we need to convert it */
                        array[j] = result[nbRow * j + i];
                    }
                }

                (*jenv)->SetDoubleArrayRegion(jenv, jarray, 0, nbCol, array);

                (*jenv)->SetObjectArrayElement(jenv, jresult, i, jarray);

                (*jenv)->DeleteLocalRef(jenv, jarray);
                if (array)
                {
                    free(array);
                    array = NULL;
                }
            }

            if (arg1)
                (*jenv)->ReleaseStringUTFChars(jenv, jarg1, (const char *)arg1);
            free(result);

        }
        return jresult;
    }

    SWIGEXPORT jobjectArray JNICALL Java_org_scilab_modules_javasci_Call_1ScilabJNI_getDoubleComplexImg(JNIEnv * jenv, jclass jcls, jstring jarg1)
    {
        jobjectArray jresult = 0;
        char *arg1 = (char *)0;
        int *arg2 = (int *)0;
        int *arg3 = (int *)0;
        int nbRow;
        int nbCol;
        double *result = 0;

        (void)jenv;
        (void)jcls;
        {
            arg2 = &nbRow;
            arg3 = &nbCol;
            arg1 = 0;
            if (jarg1)
            {
                arg1 = (char *)(*jenv)->GetStringUTFChars(jenv, jarg1, 0);
                if (!arg1)
                    return 0;
            }
        }
        result = (double *)getDoubleComplexImg(arg1, arg2, arg3);
        {
            jclass doubleArr = (*jenv)->FindClass(jenv, "[D");
            int i = 0, j = 0;

            jresult = (*jenv)->NewObjectArray(jenv, nbRow, doubleArr, NULL);

            for (i = 0; i < nbRow; i++)
            {
                jdouble *array = (jdouble *) malloc(nbCol * sizeof(jdouble));
                jdoubleArray jarray = (*jenv)->NewDoubleArray(jenv, nbCol);

                if (jarray == NULL)
                {
                    printf("Could not allocate\n");
                    fflush(NULL);
                }

                if (array)
                {
                    for (j = 0; j < nbCol; j++)
                    {
                        /* Scilab is storing matrice cols by cols while Java is doing it
                         * row by row. Therefor, we need to convert it */
                        array[j] = result[nbRow * j + i];
                    }
                }

                (*jenv)->SetDoubleArrayRegion(jenv, jarray, 0, nbCol, array);

                (*jenv)->SetObjectArrayElement(jenv, jresult, i, jarray);

                (*jenv)->DeleteLocalRef(jenv, jarray);
                if (array)
                {
                    free(array);
                    array = NULL;
                }
            }

            if (arg1)
                (*jenv)->ReleaseStringUTFChars(jenv, jarg1, (const char *)arg1);
            free(result);

        }
        return jresult;
    }

#ifdef __cplusplus
}
#endif
