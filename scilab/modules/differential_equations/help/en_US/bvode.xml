<?xml version="1.0" encoding="UTF-8"?>
<refentry version="5.0-subset Scilab" xml:id="bvode" xml:lang="en"
          xmlns="http://docbook.org/ns/docbook"
          xmlns:xlink="http://www.w3.org/1999/xlink"
          xmlns:svg="http://www.w3.org/2000/svg"
          xmlns:ns4="http://www.w3.org/1999/xhtml"
          xmlns:mml="http://www.w3.org/1998/Math/MathML"
          xmlns:db="http://docbook.org/ns/docbook">
  <info>
    <pubdate>$LastChangedDate$</pubdate>
  </info>

  <refnamediv>
    <refname>bvode</refname>

    <refpurpose>boundary value problems for ODE using collocation
    method</refpurpose>
  </refnamediv>

  <refnamediv xml:id="bvodeS">
    <refname>bvodeS</refname>

    <refpurpose>Simplified call to bvode</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
    <title>Calling Sequence</title>
    <synopsis>
zu=bvode(xpoints,N,m,x_low,x_up,zeta,ipar,ltol,tol,fixpnt,fsub,dfsub,gsub,dgsub,guess)
zu=bvodeS(xpoints,m,N,x_low,x_up,fsub,gsub,zeta, &lt;optional_args&gt;)
    </synopsis>
  </refsynopsisdiv>

  <refsection>
    <title>Parameters</title>

    <variablelist>
      <varlistentry>
        <term>zu</term>

        <listitem>
          <para>a column vector of size M. The solution of the ode evaluated
          on the mesh given by points. It contains z(u(x)) for each requested
          points.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>xpoints</term>

        <listitem>
          <para>an array which gives the points for which we want to observe
          the solution.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>N</term>

        <listitem>
          <para>a scalar with integer value,number of differential equations
          (N &lt;= 20).</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>m</term>

        <listitem>
          <para>a vector of size <literal>N</literal> with integer elements.
          <literal>It is the vector of order of each differential equation:
          m(i)</literal> gives the order of the i-th differential equation. In
          the following, <literal>M</literal> will represent the sum of the
          elements of <literal>m</literal>.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>x_low</term>

        <listitem>
          <para>a scalar: left end of interval</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>x_up</term>

        <listitem>
          <para>a scalar: right end of interval</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>zeta</term>

        <listitem>
          <para><literal>a vector of size M,zeta(j)</literal> gives j-th side
          condition point (boundary point). One must have x_low&lt;=zeta(j)
          &lt;= zeta(j+1)<literal>&lt;=x_up</literal></para>

          <para>All side condition points must be mesh points in all meshes
          used, see description of <literal>ipar(11)</literal> and
          <literal>fixpnt</literal> below.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>ipar</term>

        <listitem>
          <para>an array with 11 integer elements:</para>

          <para>[<literal>nonlin, collpnt, subint, ntol, ndimf, ndimi, iprint,
          iread, iguess, rstart,nfxpnt]</literal></para>

          <variablelist>
            <varlistentry>
              <term>nonlin: ipar(1)</term>

              <listitem>
                <para>0 if the problem is linear, 1 if the problem is
                nonlinear</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>collpnt: ipar(2)</term>

              <listitem>
                <para>Gives the number of collocation points per subinterval
                where max(m(j)) &lt;= collpnt &lt;= 7</para>

                <para>if <literal>ipar(2)=0</literal> then
                <literal>collpnt</literal> is set to max ( max(m(j))+1 ,
                5-max(m(j)) )</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>subint: ipar(3)</term>

              <listitem>
                <para>Gives the number of subintervals in the initial mesh. if
                <literal>ipar(3) = 0</literal> then bvode arbitrarily sets
                <literal>subint = 5</literal>.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>ntol: ipar(4)</term>

              <listitem>
                <para>Gives the number of solution and derivative tolerances.
                We require 0 &lt; ntol &lt;= M. <literal>ipar(4)</literal>
                must be set to the dimension of the <literal>tol</literal>
                argument or to <literal>0</literal>. In the latter case the
                actual value will automatically be set to
                <literal>size(tol,'*')</literal>.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>ndimf: ipar(5)</term>

              <listitem>
                <para>Gives the dimension of <literal>fspace</literal> (a real
                work array). its value provides a constraint on nmax the
                maximum number of subintervals.</para>

                <para>The ipar(5) value must respect the constraint
                ipar(5)&gt;=nmax*nsizef where</para>

                <para><literal>nsizef=4+3*M+(5+collpnt*N)*(collpnt*N+M)+(2*M-nrec)*2*M</literal>
                (<literal>nrec</literal> is the number of right end boundary
                conditions).</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>ndimi: ipar(6)</term>

              <listitem>
                <para>Gives the dimension of ispace (an integer work array).
                its value provides a constraint on nmax, the maximum number of
                subintervals.</para>

                <para>The ipar(6) value must respect the constraint
                ipar(6)&gt;=nmax*nsizei where</para>

                <para><literal>nsizei=3 +
                </literal><literal>collpnt*N+M</literal>.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>iprint: ipar(7)</term>

              <listitem>
                <para>output control, make take the following values:</para>

                <variablelist>
                  <varlistentry>
                    <term>-1</term>

                    <listitem>
                      <para>for full diagnostic printout</para>
                    </listitem>
                  </varlistentry>

                  <varlistentry>
                    <term>0</term>

                    <listitem>
                      <para>for selected printout</para>
                    </listitem>
                  </varlistentry>

                  <varlistentry>
                    <term>1</term>

                    <listitem>
                      <para>for no printout</para>
                    </listitem>
                  </varlistentry>
                </variablelist>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>iread: ipar(8)</term>

              <listitem>
                <variablelist>
                  <varlistentry>
                    <term>= 0</term>

                    <listitem>
                      <para>causes bvode to generate a uniform initial
                      mesh.</para>
                    </listitem>
                  </varlistentry>

                  <varlistentry>
                    <term>= xx</term>

                    <listitem>
                      <para>Other values are not implemented yet in
                      Scilab</para>

                      <variablelist>
                        <varlistentry>
                          <term>= 1</term>

                          <listitem>
                            <para>if the initial mesh is provided by the user.
                            it is defined in fspace as follows: the mesh</para>

                            <para>will occupy <literal>fspace(1), ...,
                            fspace(n+1)</literal>. the user needs to supply only
                            the interior mesh points <literal>fspace(j) = x(j),
                            j = 2, ..., n.</literal></para>
                          </listitem>
                        </varlistentry>

                        <varlistentry>
                          <term>= 2 if the initial mesh is supplied by the
                          user</term>

                          <listitem>
                            <para>as with <literal>ipar(8)=1</literal>, and in
                            addition no adaptive mesh selection is to be
                            done.</para>
                          </listitem>
                        </varlistentry>
                      </variablelist>
                    </listitem>
                  </varlistentry>
                </variablelist>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>iguess: ipar(9)</term>

              <listitem>
                <variablelist>
                  <varlistentry>
                    <term>= 0</term>

                    <listitem>
                      <para>if no initial guess for the solution is
                      provided.</para>
                    </listitem>
                  </varlistentry>

                  <varlistentry>
                    <term>= 1</term>

                    <listitem>
                      <para>if an initial guess is provided by the user
                      trought the argument <literal>guess</literal>.</para>
                    </listitem>
                  </varlistentry>

                  <varlistentry>
                    <term>= 2</term>

                    <listitem>
                      <para>if an initial mesh and approximate solution
                      coefficients are provided by the user in fspace. (the
                      former and new mesh are the same).</para>
                    </listitem>
                  </varlistentry>

                  <varlistentry>
                    <term>= 3</term>

                    <listitem>
                      <para>if a former mesh and approximate solution
                      coefficients are provided by the user in fspace, and the
                      new mesh is to be taken twice as coarse; i.e.,every
                      second point from the former mesh.</para>
                    </listitem>
                  </varlistentry>

                  <varlistentry>
                    <term>= 4</term>

                    <listitem>
                      <para>if in addition to a former initial mesh and
                      approximate solution coefficients, a new mesh is
                      provided in fspace as well. (see description of output
                      for further details on iguess = 2, 3, and 4.)</para>
                    </listitem>
                  </varlistentry>
                </variablelist>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>ireg: ipar(10)</term>

              <listitem>
                <variablelist>
                  <varlistentry>
                    <term>= 0</term>

                    <listitem>
                      <para>if the problem is regular</para>
                    </listitem>
                  </varlistentry>

                  <varlistentry>
                    <term>= 1</term>

                    <listitem>
                      <para>if the first relax factor is equal to ireg, and
                      the nonlinear iteration does not rely on past covergence
                      (use for an extra sensitive nonlinear problem
                      only).</para>
                    </listitem>
                  </varlistentry>

                  <varlistentry>
                    <term>= 2</term>

                    <listitem>
                      <para>if we are to return immediately upon (a) two
                      successive nonconvergences, or (b) after obtaining error
                      estimate for the first time.</para>
                    </listitem>
                  </varlistentry>
                </variablelist>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>nfxpnt: ipar(11)</term>

              <listitem>
                <para>Gives the number of fixed points in the mesh other than
                <literal>x_low</literal> and <literal>x_up</literal> (the
                dimension of <literal>fixpnt</literal>).
                <literal>ipar(11)</literal> must be set to the dimension of
                the <literal>fixpnt</literal> argument or to
                <literal>0</literal>. In the latter case the actual value will
                automatically be set to
                <literal>size(fixpnt,'*')</literal>.</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>ltol</term>

        <listitem>
          <para>an array of dimension <literal>ntol</literal>=ipar(4).
          <literal>ltol(j) = l</literal> specifies that the j-th tolerance in
          the tol array controls the error in the <literal>l</literal>-th
          component of <inlinemediaobject>
              <imageobject>
                <imagedata>
                  <mml:math>
                  <mml:semantics> <mml:mi>z</mml:mi> <mml:mrow>
                  <mml:mo mml:stretchy="false">(</mml:mo> <mml:mi>u</mml:mi>
                  <mml:mo mml:stretchy="false">)</mml:mo>
                  </mml:mrow></mml:semantics></mml:math>
                </imagedata>
              </imageobject>
            </inlinemediaobject>. It is also required that:</para>

          <para><literal>1 &lt;= ltol(1) &lt; ltol(2) &lt; ... &lt; ltol(ntol)
          &lt;= M</literal></para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>tol</term>

        <listitem>
          <para>an array of dimension <literal>ntol=ipar(4)</literal>.</para>

          <para><literal>tol(j)</literal> is the error tolerance on the
          <literal>ltol(j)</literal> -th component of <inlinemediaobject>
              <imageobject>
                <imagedata>
                  <mml:math>
                  <mml:semantics> <mml:mi>z</mml:mi> <mml:mrow>
                  <mml:mo mml:stretchy="false">(</mml:mo> <mml:mi>u</mml:mi>
                  <mml:mo mml:stretchy="false">)</mml:mo> </mml:mrow>
                  </mml:semantics></mml:math>
                </imagedata>
              </imageobject>
            </inlinemediaobject>. Thus, the code attempts to satisfy
          <inlinemediaobject>
                <imageobject>
                  <imagedata>
                    <mml:math>
                      <mml:semantics>
                        <mml:mrow>
                          <mml:mrow>
                            <mml:mfenced mml:close="∣" mml:open="∣">
                              <mml:msub>
                                <mml:mrow>
                                  <mml:mo mml:stretchy="false">(</mml:mo>

                                  <mml:mrow>
                                    <mml:mi>z</mml:mi>

                                    <mml:mrow>
                                      <mml:mrow>
                                        <mml:mo mml:stretchy="false">(</mml:mo>

                                        <mml:mi>v</mml:mi>

                                        <mml:mo mml:stretchy="false">)</mml:mo>
                                      </mml:mrow>

                                      <mml:mo mml:stretchy="false">−</mml:mo>

                                      <mml:mi>z</mml:mi>
                                    </mml:mrow>

                                    <mml:mrow>
                                      <mml:mo mml:stretchy="false">(</mml:mo>

                                      <mml:mi>u</mml:mi>

                                      <mml:mo mml:stretchy="false">)</mml:mo>
                                    </mml:mrow>
                                  </mml:mrow>

                                  <mml:mo mml:stretchy="false">)</mml:mo>
                                </mml:mrow>

                                <mml:mrow>
                                  <mml:mi mml:fontstyle="italic">ltol</mml:mi>

                                  <mml:mrow>
                                    <mml:mo mml:stretchy="false">(</mml:mo>

                                    <mml:mi>j</mml:mi>

                                    <mml:mo mml:stretchy="false">)</mml:mo>
                                  </mml:mrow>
                                </mml:mrow>
                              </mml:msub>
                            </mml:mfenced>

                            <mml:mo mml:stretchy="false">≤</mml:mo>

                            <mml:mi mml:fontstyle="italic">tol</mml:mi>
                          </mml:mrow>

                          <mml:mrow>
                            <mml:mrow>
                              <mml:mrow>
                                <mml:mo mml:stretchy="false">(</mml:mo>

                                <mml:mi>j</mml:mi>

                                <mml:mo mml:stretchy="false">)</mml:mo>
                              </mml:mrow>

                              <mml:mo mml:stretchy="false">⋅</mml:mo>

                              <mml:mfenced mml:close="∣" mml:open="∣">
                                <mml:msub>
                                  <mml:mrow>
                                    <mml:mo mml:stretchy="false">(</mml:mo>

                                    <mml:mrow>
                                      <mml:mi>z</mml:mi>

                                      <mml:mrow>
                                        <mml:mo mml:stretchy="false">(</mml:mo>

                                        <mml:mi>u</mml:mi>

                                        <mml:mo mml:stretchy="false">)</mml:mo>
                                      </mml:mrow>
                                    </mml:mrow>

                                    <mml:mo mml:stretchy="false">)</mml:mo>
                                  </mml:mrow>

                                  <mml:mrow>
                                    <mml:mi mml:fontstyle="italic">ltol</mml:mi>

                                    <mml:mrow>
                                      <mml:mo mml:stretchy="false">(</mml:mo>

                                      <mml:mi>j</mml:mi>

                                      <mml:mo mml:stretchy="false">)</mml:mo>
                                    </mml:mrow>
                                  </mml:mrow>
                                </mml:msub>
                              </mml:mfenced>
                            </mml:mrow>

                            <mml:mo mml:stretchy="false">+</mml:mo>

                            <mml:mi mml:fontstyle="italic">tol</mml:mi>
                          </mml:mrow>

                          <mml:mrow>
                            <mml:mo mml:stretchy="false">(</mml:mo>

                            <mml:mi>j</mml:mi>

                            <mml:mo mml:stretchy="false">)</mml:mo>
                          </mml:mrow>

                          <mml:mi>,</mml:mi>

                          <mml:mi mml:fontstyle="normal">for</mml:mi>

                          <mml:mrow>
                            <mml:mi>j</mml:mi>

                            <mml:mo mml:stretchy="false">=</mml:mo>

                            <mml:mn>1</mml:mn>
                          </mml:mrow>

                          <mml:mi mml:fontstyle="normal">:</mml:mi>

                          <mml:mi mml:fontstyle="normal">ntol</mml:mi>
                        </mml:mrow>

                        <mml:annotation
                        mml:encoding="StarMath 5.0">abs(z(v)-z(u))_{ltol(j)}
                        &lt;= tol(j) cdot abs(z(u))_{ltol(j)} + tol(j), for
                        j=1:ntol</mml:annotation>
                      </mml:semantics>
                    </mml:math>
                  </imagedata>
                </imageobject>
            </inlinemediaobject> on each subinterval</para>

          <para>if <inlinemediaobject>
              <imageobject>
                <imagedata>
                  <mml:math>
                  <mml:semantics> <mml:mi>v</mml:mi>
                  </mml:semantics></mml:math>
                </imagedata>
              </imageobject>
            </inlinemediaobject> is the approximate solution vector an u the
          exact solution (unknown).</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>fixpnt</term>

        <listitem>
          <para>an array of dimension <literal>nfxpnt=ipar(11)</literal>. it
          contains the points, other than <literal>x_low</literal> and
          <literal>x_up</literal>, which are to be included in every mesh. The
          code requires that all side condition points other than
          <literal>x_low</literal> and <literal>x_up</literal> (see
          description of zeta ) be included as fixed points in
          <literal>fixpnt</literal>.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>fsub</term>

        <listitem>
          <para>an <link linkend="external">external</link> used to evaluate
          the column vector <literal>f=</literal> <inlinemediaobject>
                <imageobject>
                  <imagedata>
                    <mml:math>
                      <mml:semantics>
                        <mml:mrow>
                          <mml:mo mml:stretchy="false">[</mml:mo>

                          <mml:mrow>
                            <mml:msub>
                              <mml:mi>f</mml:mi>

                              <mml:mn>1</mml:mn>
                            </mml:msub>

                            <mml:mrow>
                              <mml:mo mml:stretchy="false">(</mml:mo>

                              <mml:mrow>
                                <mml:mi>x</mml:mi>

                                <mml:mi>,</mml:mi>

                                <mml:mi>z</mml:mi>

                                <mml:mrow>
                                  <mml:mo mml:stretchy="false">(</mml:mo>

                                  <mml:mrow>
                                    <mml:mi>u</mml:mi>

                                    <mml:mrow>
                                      <mml:mo mml:stretchy="false">(</mml:mo>

                                      <mml:mi>x</mml:mi>

                                      <mml:mo mml:stretchy="false">)</mml:mo>
                                    </mml:mrow>
                                  </mml:mrow>

                                  <mml:mo mml:stretchy="false">)</mml:mo>
                                </mml:mrow>
                              </mml:mrow>

                              <mml:mo mml:stretchy="false">)</mml:mo>
                            </mml:mrow>

                            <mml:mi>;</mml:mi>

                            <mml:msub>
                              <mml:mi>f</mml:mi>

                              <mml:mn>2</mml:mn>
                            </mml:msub>

                            <mml:mrow>
                              <mml:mo mml:stretchy="false">(</mml:mo>

                              <mml:mrow>
                                <mml:mi>x</mml:mi>

                                <mml:mi>,</mml:mi>

                                <mml:mi>z</mml:mi>

                                <mml:mrow>
                                  <mml:mo mml:stretchy="false">(</mml:mo>

                                  <mml:mrow>
                                    <mml:mi>u</mml:mi>

                                    <mml:mrow>
                                      <mml:mo mml:stretchy="false">(</mml:mo>

                                      <mml:mi>x</mml:mi>

                                      <mml:mo mml:stretchy="false">)</mml:mo>
                                    </mml:mrow>
                                  </mml:mrow>

                                  <mml:mo mml:stretchy="false">)</mml:mo>
                                </mml:mrow>
                              </mml:mrow>

                              <mml:mo mml:stretchy="false">)</mml:mo>
                            </mml:mrow>

                            <mml:mi>,</mml:mi>

                            <mml:mo mml:stretchy="false">⋯</mml:mo>

                            <mml:mi>,</mml:mi>

                            <mml:msub>
                              <mml:mi>f</mml:mi>

                              <mml:mi>N</mml:mi>
                            </mml:msub>

                            <mml:mrow>
                              <mml:mo mml:stretchy="false">(</mml:mo>

                              <mml:mrow>
                                <mml:mi>x</mml:mi>

                                <mml:mi>,</mml:mi>

                                <mml:mi>z</mml:mi>

                                <mml:mrow>
                                  <mml:mo mml:stretchy="false">(</mml:mo>

                                  <mml:mrow>
                                    <mml:mi>u</mml:mi>

                                    <mml:mrow>
                                      <mml:mo mml:stretchy="false">(</mml:mo>

                                      <mml:mi>x</mml:mi>

                                      <mml:mo mml:stretchy="false">)</mml:mo>
                                    </mml:mrow>
                                  </mml:mrow>

                                  <mml:mo mml:stretchy="false">)</mml:mo>
                                </mml:mrow>
                              </mml:mrow>

                              <mml:mo mml:stretchy="false">)</mml:mo>
                            </mml:mrow>
                          </mml:mrow>

                          <mml:mo mml:stretchy="false">]</mml:mo>
                        </mml:mrow>

                        <mml:annotation
                        mml:encoding="StarMath 5.0">[f_1(x,z(u(x)));
                        f_2(x,z(u(x))),dotsaxis,
                        f_N(x,z(u(x)))]</mml:annotation>
                      </mml:semantics>
                    </mml:math>
                  </imagedata>
                </imageobject>
            </inlinemediaobject> for any x such as x_low &lt;= x &lt;= x_up
          and for any z=z(u(x)) (see description below)</para>

          <para>The external must have the headings:</para>

          <itemizedlist>
            <listitem>
              <para>In Fortran the calling sequence must be:</para>

              <programlisting><![CDATA[
subroutine fsub(x,zu,f)
double precision zu(*), f(*),x 
]]></programlisting>
            </listitem>

            <listitem>
              <para>In C the function prototype must be</para>

              <programlisting><![CDATA[
void fsub(double *x, double *zu, double *f)
]]></programlisting>
            </listitem>

            <listitem>
              <para>And in Scilab</para>

              <programlisting><![CDATA[
function f=fsub(x,zu,parameters)
]]></programlisting>

               
            </listitem>
          </itemizedlist>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>dfsub</term>

        <listitem>
          <para>an <link linkend="external">external</link> used to evaluate
          the Jacobian of <literal>f(x,z(u))</literal> at a point x. Where
          <literal>z(u(x))</literal> is defined as for <literal>fsub</literal>
          and the (<literal>N</literal>) by (<literal>M</literal>) array df
          should be filled by the partial derivatives of f:</para>

          <informalequation>
            <mediaobject>
              <imageobject>
                <imagedata align="center">
                  <mml:math>
                  <mml:semantics> <mml:mrow> <mml:mi
                  mml:fontstyle="italic">df</mml:mi> <mml:mrow> <mml:mrow>
                  <mml:mo mml:stretchy="false">(</mml:mo> <mml:mrow>
                  <mml:mi>i</mml:mi> <mml:mi>,</mml:mi> <mml:mi>j</mml:mi>
                  </mml:mrow> <mml:mo mml:stretchy="false">)</mml:mo>
                  </mml:mrow> <mml:mo mml:stretchy="false">=</mml:mo>
                  <mml:mfrac> <mml:mrow> <mml:mo
                  mml:stretchy="false">∂</mml:mo> <mml:msub>
                  <mml:mi>f</mml:mi> <mml:mi>i</mml:mi> </mml:msub>
                  </mml:mrow> <mml:mrow> <mml:mo
                  mml:stretchy="false">∂</mml:mo> <mml:msub>
                  <mml:mi>z</mml:mi> <mml:mi>j</mml:mi> </mml:msub>
                  </mml:mrow> </mml:mfrac> </mml:mrow> <mml:mtext> for
                  </mml:mtext> <mml:mrow> <mml:mo
                  mml:stretchy="true">{</mml:mo> <mml:mtable> <mml:mtr>
                  <mml:mrow> <mml:mrow> <mml:mi>i</mml:mi> <mml:mo
                  mml:stretchy="false">=</mml:mo> <mml:mn>1</mml:mn>
                  </mml:mrow> <mml:mi mml:fontstyle="normal">:</mml:mi>
                  <mml:mi mml:fontstyle="italic">N</mml:mi> </mml:mrow>
                  </mml:mtr> <mml:mtr> <mml:mrow> <mml:mrow>
                  <mml:mi>j</mml:mi> <mml:mo mml:stretchy="false">=</mml:mo>
                  <mml:mn>1</mml:mn> </mml:mrow> <mml:mi
                  mml:fontstyle="normal">:</mml:mi> <mml:mi
                  mml:fontstyle="italic">M</mml:mi> </mml:mrow> </mml:mtr>
                  </mml:mtable> </mml:mrow> </mml:mrow> <mml:annotation
                  mml:encoding="StarMath 5.0">df(i,j)= {partial{f_i}} over
                  {partial{z_j}} ~ for ~ left lbrace binom{i=1:N}{j=1:M} right
                  none</mml:annotation> </mml:semantics></mml:math>
                </imagedata>
              </imageobject>
            </mediaobject>
          </informalequation>

          <para>The external must have the headings:</para>

          <itemizedlist>
            <listitem>
              <para>In Fortran the calling sequence must be:</para>

              <programlisting><![CDATA[
subroutine dfsub(x,zu,df)
double precision zu(*), df(*),x
]]></programlisting>
            </listitem>

            <listitem>
              <para>In C the function prototype must be</para>

              <programlisting><![CDATA[
void dfsub(double *x, double *zu, double *df)
]]></programlisting>
            </listitem>

            <listitem>
              <para>And in Scilab</para>

              <programlisting><![CDATA[
function df=dfsub(x,zu,parameters)
]]></programlisting>

               
            </listitem>
          </itemizedlist>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>gsub</term>

        <listitem>
          <para>an <link linkend="external">external</link> used to evaluate
          <inlinemediaobject>
                <imageobject>
                  <imagedata>
                    <mml:math>
                      <mml:semantics>
                        <mml:mrow>
                          <mml:msub>
                            <mml:mi>g</mml:mi>

                            <mml:mi>i</mml:mi>
                          </mml:msub>

                          <mml:mrow>
                            <mml:mo mml:stretchy="false">(</mml:mo>

                            <mml:mrow>
                              <mml:msub>
                                <mml:mo mml:stretchy="false">ζ</mml:mo>

                                <mml:mi>i</mml:mi>
                              </mml:msub>

                              <mml:mi>,</mml:mi>

                              <mml:mi>z</mml:mi>

                              <mml:mrow>
                                <mml:mo mml:stretchy="false">(</mml:mo>

                                <mml:mrow>
                                  <mml:mi>u</mml:mi>

                                  <mml:mrow>
                                    <mml:mo mml:stretchy="false">(</mml:mo>

                                    <mml:msub>
                                      <mml:mo mml:stretchy="false">ζ</mml:mo>

                                      <mml:mi>i</mml:mi>
                                    </mml:msub>

                                    <mml:mo mml:stretchy="false">)</mml:mo>
                                  </mml:mrow>
                                </mml:mrow>

                                <mml:mo mml:stretchy="false">)</mml:mo>
                              </mml:mrow>
                            </mml:mrow>

                            <mml:mo mml:stretchy="false">)</mml:mo>
                          </mml:mrow>
                        </mml:mrow>

                        <mml:annotation
                        mml:encoding="StarMath 5.0">g_i(%zeta_i,z(u(%zeta_i)))</mml:annotation>
                      </mml:semantics>
                    </mml:math>
                  </imagedata>
                </imageobject>
            </inlinemediaobject> given z=<inlinemediaobject>
                <imageobject>
                  <imagedata>
                    <mml:math>
                      <mml:semantics>
                        <mml:mrow>
                          <mml:mi>z</mml:mi>

                          <mml:mrow>
                            <mml:mo mml:stretchy="false">(</mml:mo>

                            <mml:mrow>
                              <mml:mi>u</mml:mi>

                              <mml:mrow>
                                <mml:mo mml:stretchy="false">(</mml:mo>

                                <mml:msub>
                                  <mml:mo mml:stretchy="false">ζ</mml:mo>

                                  <mml:mi>i</mml:mi>
                                </mml:msub>

                                <mml:mo mml:stretchy="false">)</mml:mo>
                              </mml:mrow>
                            </mml:mrow>

                            <mml:mo mml:stretchy="false">)</mml:mo>
                          </mml:mrow>
                        </mml:mrow>

                        <mml:annotation
                        mml:encoding="StarMath 5.0">z(u(%zeta_i))</mml:annotation>
                      </mml:semantics>
                    </mml:math>
                  </imagedata>
                </imageobject>
            </inlinemediaobject> <literal>z = zeta(i)</literal> for
          <literal>1&lt;=i&lt;=M.</literal></para>

          <para>The external must have the headings:</para>

          <itemizedlist>
             

            <listitem>
              <para>In Fortran the calling sequence must be:</para>

              <programlisting><![CDATA[
subroutine gsub(i,zu,g)
double precision zu(*), g(*)
integer i
]]></programlisting>
            </listitem>

             

            <listitem>
              <para>In C the function prototype must be</para>

              <programlisting><![CDATA[
void gsub(int *i, double *zu, double *g)
]]></programlisting>
            </listitem>

             
            <listitem>
              <para>And in Scilab</para>
              <programlisting><![CDATA[
function g=gsub(i,zu,parameters)
]]></programlisting>
            <para>Note that in contrast to <literal>f</literal> in <literal>fsub</literal>, here only one value per call is returned in <literal>g</literal>.</para>
            </listitem>

          </itemizedlist>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>dgsub</term>

        <listitem>
          <para>an <link linkend="external">external</link> used to evaluate
          the i-th row of the Jacobian of <literal>g(x,u(x))</literal>. Where
          <literal>z(u)</literal> is as for fsub, i as for gsub and the
          M-vector <literal>dg</literal> should be filled with the partial
          derivatives of g, viz, for a particular call one calculates</para>

          <informalequation>
            <mediaobject>
              <imageobject>
                <imagedata align="center">
                  <mml:math>
                  <mml:semantics> <mml:mrow> <mml:mi
                  mml:fontstyle="italic">dg</mml:mi> <mml:mrow> <mml:mrow>
                  <mml:mo mml:stretchy="false">(</mml:mo> <mml:mrow>
                  <mml:mi>i</mml:mi> <mml:mi>,</mml:mi> <mml:mi>j</mml:mi>
                  </mml:mrow> <mml:mo mml:stretchy="false">)</mml:mo>
                  </mml:mrow> <mml:mo mml:stretchy="false">=</mml:mo>
                  <mml:mfrac> <mml:mrow> <mml:mo
                  mml:stretchy="false">∂</mml:mo> <mml:msub>
                  <mml:mi>g</mml:mi> <mml:mi>i</mml:mi> </mml:msub>
                  </mml:mrow> <mml:mrow> <mml:mo
                  mml:stretchy="false">∂</mml:mo> <mml:msub>
                  <mml:mi>z</mml:mi> <mml:mi>j</mml:mi> </mml:msub>
                  </mml:mrow> </mml:mfrac> </mml:mrow> <mml:mtext> for
                  </mml:mtext> <mml:mrow> <mml:mo
                  mml:stretchy="true">{</mml:mo> <mml:mtable> <mml:mtr>
                  <mml:mrow> <mml:mrow> <mml:mi>i</mml:mi> <mml:mo
                  mml:stretchy="false">=</mml:mo> <mml:mn>1</mml:mn>
                  </mml:mrow> <mml:mi mml:fontstyle="normal">:</mml:mi>
                  <mml:mi mml:fontstyle="italic">M</mml:mi> </mml:mrow>
                  </mml:mtr> <mml:mtr> <mml:mrow> <mml:mrow>
                  <mml:mi>j</mml:mi> <mml:mo mml:stretchy="false">=</mml:mo>
                  <mml:mn>1</mml:mn> </mml:mrow> <mml:mi
                  mml:fontstyle="normal">:</mml:mi> <mml:mi
                  mml:fontstyle="italic">M</mml:mi> </mml:mrow> </mml:mtr>
                  </mml:mtable> </mml:mrow> </mml:mrow> <mml:annotation
                  mml:encoding="StarMath 5.0">dg(i,j)= {partial{g_i}} over
                  {partial{z_j}} ~ for ~ left lbrace binom{i=1:M}{j=1:M} right
                  none</mml:annotation> </mml:semantics></mml:math>
                </imagedata>
              </imageobject>
            </mediaobject>
          </informalequation>

          <para>The external must have the headings:</para>

          <itemizedlist>
            <listitem>
              <para>In Fortran the calling sequence must be:</para>

              <programlisting><![CDATA[
subroutine dgsub(i,zu,dg)
double precision zu(*), dg(*)
]]></programlisting>
            </listitem>

            <listitem>
              <para>In C the function prototype must be</para>

              <programlisting><![CDATA[
void dgsub(int *i, double *zu, double *dg)
]]></programlisting>
            </listitem>

            <listitem>
              <para>And in Scilab </para>

              <programlisting><![CDATA[
function dg=dgsub(i,zu,parameters)
]]></programlisting>

               
            </listitem>
          </itemizedlist>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>guess</term>

        <listitem>
          <para>An <link linkend="external">external</link> used to evaluate
          the initial approximation for <literal>z(u(x))</literal> and
          <literal>dmval(u(x))</literal> the vector of the mj-th derivatives
          of <literal>u(x)</literal>. Note that this subroutine is used only
          if <literal>ipar(9) = 1</literal>, and then all <literal>M</literal>
          components of zu and N components of dmval should be computed for
          any x such as x_low &lt;= x &lt;= x_up.</para>

          <para>The external must have the headings:</para>

          <itemizedlist>
            <listitem>
              <para>In Fortran the calling sequence must be:</para>

              <programlisting><![CDATA[
subroutine guess(x,zu,dmval)
double precision x,z(*), dmval(*)
]]></programlisting>
            </listitem>

            <listitem>
              <para>In C the function prototype must be</para>

              <programlisting><![CDATA[
void fsub(double *x, double *zu, double *dmval)
]]></programlisting>
            </listitem>

            <listitem>
              <para>And in Scilab </para>

              <programlisting><![CDATA[
function [dmval,zu]=fsub(x,parameters)
]]></programlisting>

               
            </listitem>
          </itemizedlist>

        </listitem>
      </varlistentry>

      <varlistentry>
        <term>&lt;optional_args&gt;</term>


        <listitem>
         <para>It should be either:</para>
        <itemizedlist>
         <listitem><para>any left part of the ordered sequence of values:
              <literal>guess, dfsub, dgsub, fixpnt, ndimf, ndimi, ltol, tol,
              ntol,nonlin, collpnt, subint, iprint, ireg, ifail</literal>
            </para></listitem>

          <listitem><para>or any sequence of <literal>arg_name=argvalue</literal>
          with <literal>arg_name</literal> in: <literal>guess</literal>,
          <literal>dfsub</literal>, <literal>dgsub</literal>,
          <literal>fixpnt</literal>, <literal>ndimf</literal>,
          <literal>ndimi</literal>, <literal>ltol</literal>,
          <literal>tol</literal>, <literal>ntol</literal>,
          <literal>nonlin</literal>, <literal>collpnt</literal>,
          <literal>subint</literal>, <literal>iprint</literal>,
          <literal>ireg</literal>, <literal>ifail</literal></para></listitem>
        </itemizedlist>

        <para>Where all these arguments excepted <literal>ifail</literal> are
        described above. <literal>ifail</literal> can be used to display the
        bvode call corresonding to the selected optional arguments. If
        <literal>guess</literal> is given <literal>iguess</literal> is set to
        1</para>
        </listitem>
      </varlistentry>
    </variablelist>
  </refsection>

  <refsection>
    <title>Description</title>

    <para>These functions solves a multi-point boundary value problem for a
    mixed order system of ode-s given by</para>

    <informalequation>
      <mediaobject>
        <imageobject>
          <imagedata align="left">
            <mml:math>
              <mml:semantics>
                <mml:mrow>
                  <mml:mo mml:stretchy="true">{</mml:mo>

                  <mml:mtable>
                    <mml:mtr>
                      <mml:mrow>
                        <mml:mrow>
                          <mml:msubsup>
                            <mml:mi>u</mml:mi>

                            <mml:mi>i</mml:mi>

                            <mml:mrow>
                              <mml:mo mml:stretchy="false">(</mml:mo>

                              <mml:msub>
                                <mml:mi>m</mml:mi>

                                <mml:mi>i</mml:mi>
                              </mml:msub>

                              <mml:mo mml:stretchy="false">)</mml:mo>
                            </mml:mrow>
                          </mml:msubsup>

                          <mml:mo mml:stretchy="false">=</mml:mo>

                          <mml:msub>
                            <mml:mi>f</mml:mi>

                            <mml:mi>i</mml:mi>
                          </mml:msub>
                        </mml:mrow>

                        <mml:mrow>
                          <mml:mo mml:stretchy="false">(</mml:mo>

                          <mml:mrow>
                            <mml:mi>x</mml:mi>

                            <mml:mi>,</mml:mi>

                            <mml:mi>z</mml:mi>

                            <mml:mrow>
                              <mml:mo mml:stretchy="false">(</mml:mo>

                              <mml:mrow>
                                <mml:mi>u</mml:mi>

                                <mml:mrow>
                                  <mml:mo mml:stretchy="false">(</mml:mo>

                                  <mml:mi>x</mml:mi>

                                  <mml:mo mml:stretchy="false">)</mml:mo>
                                </mml:mrow>
                              </mml:mrow>

                              <mml:mo mml:stretchy="false">)</mml:mo>
                            </mml:mrow>
                          </mml:mrow>

                          <mml:mo mml:stretchy="false">)</mml:mo>
                        </mml:mrow>

                        <mml:mi />

                        <mml:mrow>
                          <mml:mo mml:stretchy="true">{</mml:mo>

                          <mml:mtable>
                            <mml:mtr>
                              <mml:mrow>
                                <mml:mrow>
                                  <mml:mi>i</mml:mi>

                                  <mml:mo mml:stretchy="false">=</mml:mo>

                                  <mml:mn>1</mml:mn>
                                </mml:mrow>

                                <mml:mi mml:fontstyle="normal">:</mml:mi>

                                <mml:mi>N</mml:mi>
                              </mml:mrow>
                            </mml:mtr>

                            <mml:mtr>
                              <mml:mrow>
                                <mml:mi>x</mml:mi>

                                <mml:mo mml:stretchy="false">∈</mml:mo>

                                <mml:mfenced mml:close="[" mml:open="]">
                                  <mml:mrow>
                                    <mml:msub>
                                      <mml:mi>x</mml:mi>

                                      <mml:mi>l</mml:mi>
                                    </mml:msub>

                                    <mml:mi>,</mml:mi>

                                    <mml:msub>
                                      <mml:mi>x</mml:mi>

                                      <mml:mi>u</mml:mi>
                                    </mml:msub>
                                  </mml:mrow>
                                </mml:mfenced>
                              </mml:mrow>
                            </mml:mtr>
                          </mml:mtable>
                        </mml:mrow>
                      </mml:mrow>
                    </mml:mtr>

                    <mml:mtr>
                      <mml:mi />
                    </mml:mtr>

                    <mml:mtr>
                      <mml:mrow>
                        <mml:msub>
                          <mml:mi>g</mml:mi>

                          <mml:mi>j</mml:mi>
                        </mml:msub>

                        <mml:mrow>
                          <mml:mrow>
                            <mml:mo mml:stretchy="false">(</mml:mo>

                            <mml:mrow>
                              <mml:msub>
                                <mml:mo mml:stretchy="false">ζ</mml:mo>

                                <mml:mi>j</mml:mi>
                              </mml:msub>

                              <mml:mi>,</mml:mi>

                              <mml:mi>z</mml:mi>

                              <mml:mrow>
                                <mml:mo mml:stretchy="false">(</mml:mo>

                                <mml:mrow>
                                  <mml:mi>u</mml:mi>

                                  <mml:mrow>
                                    <mml:mo mml:stretchy="false">(</mml:mo>

                                    <mml:msub>
                                      <mml:mo mml:stretchy="false">ζ</mml:mo>

                                      <mml:mi>j</mml:mi>
                                    </mml:msub>

                                    <mml:mo mml:stretchy="false">)</mml:mo>
                                  </mml:mrow>
                                </mml:mrow>

                                <mml:mo mml:stretchy="false">)</mml:mo>
                              </mml:mrow>
                            </mml:mrow>

                            <mml:mo mml:stretchy="false">)</mml:mo>
                          </mml:mrow>

                          <mml:mo mml:stretchy="false">=</mml:mo>

                          <mml:mn>0</mml:mn>
                        </mml:mrow>

                        <mml:mi />

                        <mml:mrow>
                          <mml:mtext>,</mml:mtext>

                          <mml:mi>j</mml:mi>

                          <mml:mo mml:stretchy="false">=</mml:mo>

                          <mml:mn>1</mml:mn>
                        </mml:mrow>

                        <mml:mi mml:fontstyle="normal">:</mml:mi>

                        <mml:mi>M</mml:mi>
                      </mml:mrow>
                    </mml:mtr>
                  </mml:mtable>
                </mml:mrow>

                <mml:annotation mml:encoding="StarMath 5.0">left lbrace
                stack{u_i^(m_i)=f_i(x,z(u(x))) ~~left lbrace { binom{i=1:N}{x
                in left ] a_l, a_u right [} } right none# `#
                g_j(%zeta_j,z(u(%zeta_j))) = 0~~j=1:M} right
                none</mml:annotation>
              </mml:semantics>
            </mml:math>
          </imagedata>
        </imageobject>
      </mediaobject>
    </informalequation>

    <para>Where</para>

    <mediaobject>
        <imageobject>
          <imagedata align="left">
            <mml:math>
              <mml:semantics>
                <mml:mrow>
                  <mml:mo mml:stretchy="true">{</mml:mo>

                  <mml:mtable>
                    <mml:mtr>
                      <mml:mrow>
                        <mml:mi>M</mml:mi>

                        <mml:mo mml:stretchy="false">=</mml:mo>

                        <mml:mrow>
                          <mml:munderover>
                            <mml:mo mml:stretchy="false">∑</mml:mo>

                            <mml:mrow>
                              <mml:mi>i</mml:mi>

                              <mml:mo mml:stretchy="false">=</mml:mo>

                              <mml:mn>1</mml:mn>
                            </mml:mrow>

                            <mml:mi>N</mml:mi>
                          </mml:munderover>

                          <mml:msub>
                            <mml:mi>m</mml:mi>

                            <mml:mi>i</mml:mi>
                          </mml:msub>
                        </mml:mrow>
                      </mml:mrow>
                    </mml:mtr>

                    <mml:mtr>
                      <mml:mi />
                    </mml:mtr>

                    <mml:mtr>
                      <mml:mrow>
                        <mml:mi>z</mml:mi>

                        <mml:mrow>
                          <mml:mrow>
                            <mml:mo mml:stretchy="false">(</mml:mo>

                            <mml:mrow>
                              <mml:mi>u</mml:mi>

                              <mml:mrow>
                                <mml:mo mml:stretchy="false">(</mml:mo>

                                <mml:mi>x</mml:mi>

                                <mml:mo mml:stretchy="false">)</mml:mo>
                              </mml:mrow>
                            </mml:mrow>

                            <mml:mo mml:stretchy="false">)</mml:mo>
                          </mml:mrow>

                          <mml:mo mml:stretchy="false">=</mml:mo>

                          <mml:mrow>
                            <mml:mo mml:stretchy="false">[</mml:mo>

                            <mml:mrow>
                              <mml:msub>
                                <mml:mi>u</mml:mi>

                                <mml:mn>1</mml:mn>
                              </mml:msub>

                              <mml:mrow>
                                <mml:mo mml:stretchy="false">(</mml:mo>

                                <mml:mi>x</mml:mi>

                                <mml:mo mml:stretchy="false">)</mml:mo>
                              </mml:mrow>

                              <mml:mi>;</mml:mi>

                              <mml:msubsup>
                                <mml:mi>u</mml:mi>

                                <mml:mn>1</mml:mn>

                                <mml:mn>1</mml:mn>
                              </mml:msubsup>

                              <mml:mrow>
                                <mml:mo mml:stretchy="false">(</mml:mo>

                                <mml:mi>x</mml:mi>

                                <mml:mo mml:stretchy="false">)</mml:mo>
                              </mml:mrow>

                              <mml:mi>;</mml:mi>

                              <mml:mo mml:stretchy="false">⋯</mml:mo>

                              <mml:msubsup>
                                <mml:mi>u</mml:mi>

                                <mml:mn>1</mml:mn>

                                <mml:mrow>
                                  <mml:mo mml:stretchy="false">(</mml:mo>

                                  <mml:mrow>
                                    <mml:msub>
                                      <mml:mi>m</mml:mi>

                                      <mml:mn>1</mml:mn>
                                    </mml:msub>

                                    <mml:mo mml:stretchy="false">−</mml:mo>

                                    <mml:mn>1</mml:mn>
                                  </mml:mrow>

                                  <mml:mo mml:stretchy="false">)</mml:mo>
                                </mml:mrow>
                              </mml:msubsup>

                              <mml:mrow>
                                <mml:mo mml:stretchy="false">(</mml:mo>

                                <mml:mi>x</mml:mi>

                                <mml:mo mml:stretchy="false">)</mml:mo>
                              </mml:mrow>

                              <mml:mi>;</mml:mi>

                              <mml:mi />

                              <mml:mo mml:stretchy="false">⋯</mml:mo>

                              <mml:mi>;</mml:mi>

                              <mml:mi />

                              <mml:msub>
                                <mml:mi>u</mml:mi>

                                <mml:mi>N</mml:mi>
                              </mml:msub>

                              <mml:mrow>
                                <mml:mo mml:stretchy="false">(</mml:mo>

                                <mml:mi>x</mml:mi>

                                <mml:mo mml:stretchy="false">)</mml:mo>
                              </mml:mrow>

                              <mml:mi>;</mml:mi>

                              <mml:msubsup>
                                <mml:mi>u</mml:mi>

                                <mml:mi>N</mml:mi>

                                <mml:mn>1</mml:mn>
                              </mml:msubsup>

                              <mml:mrow>
                                <mml:mo mml:stretchy="false">(</mml:mo>

                                <mml:mi>x</mml:mi>

                                <mml:mo mml:stretchy="false">)</mml:mo>
                              </mml:mrow>

                              <mml:mi>;</mml:mi>

                              <mml:mo mml:stretchy="false">⋯</mml:mo>

                              <mml:mi>;</mml:mi>

                              <mml:msubsup>
                                <mml:mi>u</mml:mi>

                                <mml:mi>N</mml:mi>

                                <mml:mrow>
                                  <mml:mo mml:stretchy="false">(</mml:mo>

                                  <mml:mrow>
                                    <mml:msub>
                                      <mml:mi>m</mml:mi>

                                      <mml:mi>N</mml:mi>
                                    </mml:msub>

                                    <mml:mo mml:stretchy="false">−</mml:mo>

                                    <mml:mn>1</mml:mn>
                                  </mml:mrow>

                                  <mml:mo mml:stretchy="false">)</mml:mo>
                                </mml:mrow>
                              </mml:msubsup>

                              <mml:mrow>
                                <mml:mo mml:stretchy="false">(</mml:mo>

                                <mml:mi>x</mml:mi>

                                <mml:mo mml:stretchy="false">)</mml:mo>
                              </mml:mrow>
                            </mml:mrow>

                            <mml:mo mml:stretchy="false">]</mml:mo>
                          </mml:mrow>
                        </mml:mrow>
                      </mml:mrow>
                    </mml:mtr>

                    <mml:mtr>
                      <mml:mi />
                    </mml:mtr>

                    <mml:mtr>
                      <mml:mrow>
                        <mml:mrow>
                          <mml:mrow>
                            <mml:mrow>
                              <mml:msub>
                                <mml:mi>x</mml:mi>

                                <mml:mi>l</mml:mi>
                              </mml:msub>

                              <mml:mo mml:stretchy="false">≤</mml:mo>

                              <mml:msub>
                                <mml:mo mml:stretchy="false">ζ</mml:mo>

                                <mml:mn>1</mml:mn>
                              </mml:msub>
                            </mml:mrow>

                            <mml:mo mml:stretchy="false">≤</mml:mo>

                            <mml:mo mml:stretchy="false">⋯</mml:mo>
                          </mml:mrow>

                          <mml:mo mml:stretchy="false">≤</mml:mo>

                          <mml:msub>
                            <mml:mo mml:stretchy="false">ζ</mml:mo>

                            <mml:mi>M</mml:mi>
                          </mml:msub>
                        </mml:mrow>

                        <mml:mo mml:stretchy="false">≤</mml:mo>

                        <mml:msub>
                          <mml:mi>x</mml:mi>

                          <mml:mi>u</mml:mi>
                        </mml:msub>
                      </mml:mrow>
                    </mml:mtr>
                  </mml:mtable>
                </mml:mrow>

                <mml:annotation mml:encoding="StarMath 5.0">left lbrace stack
                { M= sum from {i=1} to {N} m_i # ~# z(u(x)) =
                [u_1(x);u_1^{1}(x);dotsaxis u_1^(m_1-1)(x);~ dotsaxis;
                ~u_N(x);u_N^{1}(x);dotsaxis; u_N^(m_N-1)(x)]# ~# x_l &lt;=
                %zeta_1 &lt;= dotsaxis &lt;= %zeta_M &lt;=x_u}right
                none</mml:annotation>
              </mml:semantics>
            </mml:math>
          </imagedata>
        </imageobject>
    </mediaobject>

    <para>The argument <literal>zu</literal> used by the external functions
    and returned by <literal>bvode</literal> is the column vector formed by
    the components of z(u(x)) for a given <literal>x</literal>.</para>

    <para>The method used to approximate the solution u is collocation at
    gaussian points, requiring m(i)-1 continuous derivatives in the i-th
    component, i = 1:N. here, k is the number of collocation points (stages)
    per subinterval and is chosen such that k .ge. max m(i). a
    runge-kutta-monomial solution representation is utilized.</para>
  </refsection>

  <refsection>
    <title>Examples</title>

    <para>The first two problems below are taken from the paper [1] of the
    Bibliography.</para>

    <itemizedlist>
      <listitem>
        <para><emphasis role="bold">The problem 1</emphasis> describes a
        uniformy loaded beam of variable stifness, simply supported at both
        end.</para>

        <para>It may be defined as follow :</para>

        <para>Solve the fourth order differential equation:</para>

        <mediaobject>
            <imageobject>
              <imagedata align="left">
                <mml:math>
                  <mml:semantics>
                    <mml:mrow>
                      <mml:mfrac>
                        <mml:msup>
                          <mml:mi>d</mml:mi>

                          <mml:mn>4</mml:mn>
                        </mml:msup>

                        <mml:mrow>
                          <mml:mi>d</mml:mi>

                          <mml:msup>
                            <mml:mi>x</mml:mi>

                            <mml:mn>4</mml:mn>
                          </mml:msup>
                        </mml:mrow>
                      </mml:mfrac>

                      <mml:mi>u</mml:mi>

                      <mml:mrow>
                        <mml:mrow>
                          <mml:mo mml:stretchy="false">(</mml:mo>

                          <mml:mi>x</mml:mi>

                          <mml:mo mml:stretchy="false">)</mml:mo>
                        </mml:mrow>

                        <mml:mo mml:stretchy="false">=</mml:mo>

                        <mml:mfrac>
                          <mml:mrow>
                            <mml:mrow>
                              <mml:mn>1</mml:mn>

                              <mml:mo mml:stretchy="false">−</mml:mo>

                              <mml:mrow>
                                <mml:mrow>
                                  <mml:mn>6</mml:mn>

                                  <mml:mo mml:stretchy="false">.</mml:mo>

                                  <mml:msup>
                                    <mml:mi>x</mml:mi>

                                    <mml:mn>2</mml:mn>
                                  </mml:msup>
                                </mml:mrow>

                                <mml:mo mml:stretchy="false">.</mml:mo>

                                <mml:mfrac>
                                  <mml:msup>
                                    <mml:mi>d</mml:mi>

                                    <mml:mn>3</mml:mn>
                                  </mml:msup>

                                  <mml:mrow>
                                    <mml:mi>d</mml:mi>

                                    <mml:msup>
                                      <mml:mi>x</mml:mi>

                                      <mml:mn>3</mml:mn>
                                    </mml:msup>
                                  </mml:mrow>
                                </mml:mfrac>
                              </mml:mrow>
                            </mml:mrow>

                            <mml:mi>u</mml:mi>

                            <mml:mrow>
                              <mml:mrow>
                                <mml:mo mml:stretchy="false">(</mml:mo>

                                <mml:mi>x</mml:mi>

                                <mml:mo mml:stretchy="false">)</mml:mo>
                              </mml:mrow>

                              <mml:mo mml:stretchy="false">−</mml:mo>

                              <mml:mrow>
                                <mml:mrow>
                                  <mml:mn>6</mml:mn>

                                  <mml:mo mml:stretchy="false">.</mml:mo>

                                  <mml:mi>x</mml:mi>
                                </mml:mrow>

                                <mml:mo mml:stretchy="false">.</mml:mo>

                                <mml:mfrac>
                                  <mml:msup>
                                    <mml:mi>d</mml:mi>

                                    <mml:mn>2</mml:mn>
                                  </mml:msup>

                                  <mml:mrow>
                                    <mml:mi>d</mml:mi>

                                    <mml:msup>
                                      <mml:mi>x</mml:mi>

                                      <mml:mn>2</mml:mn>
                                    </mml:msup>
                                  </mml:mrow>
                                </mml:mfrac>
                              </mml:mrow>
                            </mml:mrow>

                            <mml:mi>u</mml:mi>

                            <mml:mrow>
                              <mml:mo mml:stretchy="false">(</mml:mo>

                              <mml:mi>x</mml:mi>

                              <mml:mo mml:stretchy="false">)</mml:mo>
                            </mml:mrow>
                          </mml:mrow>

                          <mml:msup>
                            <mml:mi>x</mml:mi>

                            <mml:mn>3</mml:mn>
                          </mml:msup>
                        </mml:mfrac>
                      </mml:mrow>
                    </mml:mrow>

                    <mml:annotation mml:encoding="StarMath 5.0">d^4 over {d
                    x^4} u(x)={1 -6*x^2*{{d^3} over {d x^3}} u(x)-6*x*{{d^2}
                    over {d x^2}} u(x)} over x^3</mml:annotation>
                  </mml:semantics>
                </mml:math>
              </imagedata>
            </imageobject>
        </mediaobject>

        <para>Subjected to the boundary conditions:</para>

        <mediaobject>
            <imageobject>
              <imagedata align="left">
                <mml:math>
                  <mml:semantics>
                    <mml:mrow>
                      <mml:mo mml:stretchy="true">{</mml:mo>

                      <mml:mtable>
                        <mml:mtr>
                          <mml:mrow>
                            <mml:mi>u</mml:mi>

                            <mml:mrow>
                              <mml:mrow>
                                <mml:mo mml:stretchy="false">(</mml:mo>

                                <mml:mn>1</mml:mn>

                                <mml:mo mml:stretchy="false">)</mml:mo>
                              </mml:mrow>

                              <mml:mo mml:stretchy="false">=</mml:mo>

                              <mml:mn>0</mml:mn>
                            </mml:mrow>
                          </mml:mrow>
                        </mml:mtr>

                        <mml:mtr>
                          <mml:mrow>
                            <mml:mfrac>
                              <mml:msup>
                                <mml:mi>d</mml:mi>

                                <mml:mn>2</mml:mn>
                              </mml:msup>

                              <mml:mrow>
                                <mml:mi>d</mml:mi>

                                <mml:msup>
                                  <mml:mi>x</mml:mi>

                                  <mml:mn>2</mml:mn>
                                </mml:msup>
                              </mml:mrow>
                            </mml:mfrac>

                            <mml:mi>u</mml:mi>

                            <mml:mrow>
                              <mml:mo mml:stretchy="false">(</mml:mo>

                              <mml:mi>x</mml:mi>

                              <mml:mo mml:stretchy="false">)</mml:mo>
                            </mml:mrow>

                            <mml:mrow>
                              <mml:mrow>
                                <mml:mo mml:stretchy="false">(</mml:mo>

                                <mml:mn>1</mml:mn>

                                <mml:mo mml:stretchy="false">)</mml:mo>
                              </mml:mrow>

                              <mml:mo mml:stretchy="false">=</mml:mo>

                              <mml:mn>0</mml:mn>
                            </mml:mrow>
                          </mml:mrow>
                        </mml:mtr>

                        <mml:mtr>
                          <mml:mrow>
                            <mml:mi>u</mml:mi>

                            <mml:mrow>
                              <mml:mrow>
                                <mml:mo mml:stretchy="false">(</mml:mo>

                                <mml:mn>2</mml:mn>

                                <mml:mo mml:stretchy="false">)</mml:mo>
                              </mml:mrow>

                              <mml:mo mml:stretchy="false">=</mml:mo>

                              <mml:mn>0</mml:mn>
                            </mml:mrow>
                          </mml:mrow>
                        </mml:mtr>

                        <mml:mtr>
                          <mml:mrow>
                            <mml:mfrac>
                              <mml:msup>
                                <mml:mi>d</mml:mi>

                                <mml:mn>2</mml:mn>
                              </mml:msup>

                              <mml:mrow>
                                <mml:mi>d</mml:mi>

                                <mml:msup>
                                  <mml:mi>x</mml:mi>

                                  <mml:mn>2</mml:mn>
                                </mml:msup>
                              </mml:mrow>
                            </mml:mfrac>

                            <mml:mi>u</mml:mi>

                            <mml:mrow>
                              <mml:mo mml:stretchy="false">(</mml:mo>

                              <mml:mi>x</mml:mi>

                              <mml:mo mml:stretchy="false">)</mml:mo>
                            </mml:mrow>

                            <mml:mrow>
                              <mml:mrow>
                                <mml:mo mml:stretchy="false">(</mml:mo>

                                <mml:mn>2</mml:mn>

                                <mml:mo mml:stretchy="false">)</mml:mo>
                              </mml:mrow>

                              <mml:mo mml:stretchy="false">=</mml:mo>

                              <mml:mn>0</mml:mn>
                            </mml:mrow>
                          </mml:mrow>
                        </mml:mtr>
                      </mml:mtable>
                    </mml:mrow>

                    <mml:annotation mml:encoding="StarMath 5.0">left lbrace
                    stack{ u(1)=0# {{d^2} over {d x^2}} u(x)(1)=0# u(2)=0#
                    {{d^2} over {d x^2}} u(x)(2)=0} right
                    none</mml:annotation>
                  </mml:semantics>
                </mml:math>
              </imagedata>
            </imageobject>
        </mediaobject>

        <para>The exact solution of this problem is known to be:</para>

        <mediaobject>
            <imageobject>
              <imagedata align="left">
                <mml:math>
                  <mml:semantics>
                    <mml:mrow>
                      <mml:mi>u</mml:mi>

                      <mml:mrow>
                        <mml:mrow>
                          <mml:mo mml:stretchy="false">(</mml:mo>

                          <mml:mi>x</mml:mi>

                          <mml:mo mml:stretchy="false">)</mml:mo>
                        </mml:mrow>

                        <mml:mo mml:stretchy="false">=</mml:mo>

                        <mml:mfrac>
                          <mml:mn>1</mml:mn>

                          <mml:mn>4</mml:mn>
                        </mml:mfrac>
                      </mml:mrow>

                      <mml:mrow>
                        <mml:mo mml:stretchy="false">(</mml:mo>

                        <mml:mrow>
                          <mml:mn>10</mml:mn>

                          <mml:mi />

                          <mml:mi>log</mml:mi>

                          <mml:mrow>
                            <mml:mrow>
                              <mml:mo mml:stretchy="false">(</mml:mo>

                              <mml:mn>2</mml:mn>

                              <mml:mo mml:stretchy="false">)</mml:mo>
                            </mml:mrow>

                            <mml:mo mml:stretchy="false">−</mml:mo>

                            <mml:mn>3</mml:mn>
                          </mml:mrow>
                        </mml:mrow>

                        <mml:mo mml:stretchy="false">)</mml:mo>
                      </mml:mrow>

                      <mml:mi />

                      <mml:mrow>
                        <mml:mrow>
                          <mml:mo mml:stretchy="false">(</mml:mo>

                          <mml:mrow>
                            <mml:mn>1</mml:mn>

                            <mml:mo mml:stretchy="false">−</mml:mo>

                            <mml:mi>x</mml:mi>
                          </mml:mrow>

                          <mml:mo mml:stretchy="false">)</mml:mo>
                        </mml:mrow>

                        <mml:mo mml:stretchy="false">+</mml:mo>

                        <mml:mfrac>
                          <mml:mn>1</mml:mn>

                          <mml:mn>2</mml:mn>
                        </mml:mfrac>
                      </mml:mrow>

                      <mml:mrow>
                        <mml:mo mml:stretchy="false">[</mml:mo>

                        <mml:mrow>
                          <mml:mfrac>
                            <mml:mn>1</mml:mn>

                            <mml:mi>x</mml:mi>
                          </mml:mfrac>

                          <mml:mo mml:stretchy="false">+</mml:mo>

                          <mml:mrow>
                            <mml:mrow>
                              <mml:mo mml:stretchy="false">(</mml:mo>

                              <mml:mrow>
                                <mml:mn>3</mml:mn>

                                <mml:mo mml:stretchy="false">+</mml:mo>

                                <mml:mi>x</mml:mi>
                              </mml:mrow>

                              <mml:mo mml:stretchy="false">)</mml:mo>
                            </mml:mrow>

                            <mml:mi />

                            <mml:mi>log</mml:mi>

                            <mml:mrow>
                              <mml:mrow>
                                <mml:mo mml:stretchy="false">(</mml:mo>

                                <mml:mi>x</mml:mi>

                                <mml:mo mml:stretchy="false">)</mml:mo>
                              </mml:mrow>

                              <mml:mo mml:stretchy="false">−</mml:mo>

                              <mml:mi>x</mml:mi>
                            </mml:mrow>
                          </mml:mrow>
                        </mml:mrow>

                        <mml:mo mml:stretchy="false">]</mml:mo>
                      </mml:mrow>
                    </mml:mrow>

                    <mml:annotation mml:encoding="StarMath 5.0">u(x)=1 over 4
                    (10`log(2)-3)`(1-x)+ {1 over 2} [ {1 over x} + {(3+x) `
                    log(x)-x}]</mml:annotation>
                  </mml:semantics>
                </mml:math>
              </imagedata>
            </imageobject>
        </mediaobject>

        <programlisting role="example"><![CDATA[ 
N=1;// just one differential equation
m=4;//a fourth order  differential equation
M=sum(m);

x_low=1;x_up=2; // the x limits
zeta=[x_low,x_low,x_up,x_up]; //two constraints (on the value of u and its second derivative) on each bound.


//The external functions
//Theses functions are called by the solver with zu=[u(x);u'(x);u''(x);u'''(x)]


// - The function which computes the right hand side of the differential equation
function f=fsub(x,zu),f=(1-6*x^2*zu(4)-6*x*zu(3))/x^3,endfunction

// - The function which computes the derivative of fsub with respect to zu
function df=dfsub(x,zu),df=[0,0,-6/x^2,-6/x],endfunction

// - The function which computes the ith constraint for a given i
function g=gsub(i,zu),
  select i
  case 1 then  //x=zeta(1)=1
    g=zu(1) //u(1)=0
  case 2 then //x=zeta(2)=1
    g=zu(3) //u''(1)=0
  case 3 then //x=zeta(3)=2
    g=zu(1) //u(2)=0
  case 4 then  //x=zeta(4)=2
    g=zu(3) //u''(2)=0
  end
endfunction

// - The function which computes the derivative of gsub with respect to z
function dg=dgsub(i,z)
  select i
  case 1 then  //x=zeta(1)=1
    dg=[1,0,0,0]
  case 2 then //x=zeta(2)=1
    dg=[0,0,1,0]
  case 3 then //x=zeta(3)=2
     dg=[1,0,0,0]
  case 4 then  //x=zeta(4)=2
    dg=[0,0,1,0]
  end
endfunction

// - The function which computes the initial guess, unused here
function [zu,mpar]=guess(x),zu=0;mpar=0,endfunction 

 //define the function which computes the exact value of u for a given x ( for testing purposes)
function zu=trusol(x)
  zu=0*ones(4,1)
  zu(1) =  0.25*(10*log(2)-3)*(1-x) + 0.5 *( 1/x   + (3+x)*log(x) - x)
  zu(2) = -0.25*(10*log(2)-3)       + 0.5 *(-1/x^2 + (3+x)/x      + log(x) - 1)
  zu(3) = 0.5*( 2/x^3 + 1/x   - 3/x^2)
  zu(4) = 0.5*(-6/x^4 - 1/x/x + 6/x^3)
endfunction


fixpnt=[ ];//All boundary conditions are located at x_low and x_up

//    nonlin  collpnt n ntol ndimf  ndimi iprint iread iguess rstart nfxpnt
ipar=[0       0       1 2    2000   200   1      0     0      0      0     ]

ltol=[1,3];//set tolerance control on zu(1) and zu(3)
tol=[1.e-11,1.e-11];//set tolreance values for these two controls
xpoints=x_low:0.01:x_up;

zu=bvode(xpoints,N,m,x_low,x_up,zeta,ipar,ltol,tol,fixpnt,...
        fsub,dfsub,gsub,dgsub,guess)
//check the constraints
zu([1,3],[1 $]) //should be zero
plot(xpoints,zu(1,:)) // the evolution of the solution u
zu1=[];for x=xpoints,zu1=[zu1,trusol(x)]; end;  
norm(zu-zu1)
	]]></programlisting>
      </listitem>

      <listitem>
        <para>Same problem using <literal>bvodeS</literal> and an initial guess </para>
        <programlisting role="example"><![CDATA[ 
function [z,lhS]=zstart(x)
  z=zeros(5,1);z(5)=1;
  lhS=[0;1];
endfunction
zu=bvode(xpoints,N,m,x_low,x_up,zeta,ltol=ltol,tol=tol,guess=zstart)
	  ]]></programlisting>

         
      </listitem>

      <listitem>
        <para><emphasis role="bold">The problem 2</emphasis> describes the
        small finite deformation of a thin shallow spherical cap of constant
        thickness subject to a quadratically varying axisymmetric external
        pressure distribution. Here phi is the meridian angle change of the
        deformed shell and psi is a stress function. For eps=mu=1e-3 two
        different solutions may found depending on the starting point</para>

        <mediaobject>
            <imageobject>
              <imagedata align="left">
                <mml:math>
                  <mml:semantics>
                    <mml:mrow>
                      <mml:mo mml:stretchy="true">{</mml:mo>

                      <mml:mtable>
                        <mml:mtr>
                          <mml:mrow>
                            <mml:mfrac>
                              <mml:msup>
                                <mml:mo mml:stretchy="false">ε</mml:mo>

                                <mml:mn>4</mml:mn>
                              </mml:msup>

                              <mml:mo mml:stretchy="false">μ</mml:mo>
                            </mml:mfrac>

                            <mml:mrow>
                              <mml:mrow>
                                <mml:mo mml:stretchy="false">(</mml:mo>

                                <mml:mrow>
                                  <mml:mo mml:stretchy="false">φ</mml:mo>

                                  <mml:mi>'</mml:mi>

                                  <mml:mrow>
                                    <mml:mrow>
                                      <mml:mi>'</mml:mi>

                                      <mml:mo mml:stretchy="false">+</mml:mo>

                                      <mml:mfrac>
                                        <mml:mrow>
                                          <mml:mo mml:stretchy="false">φ</mml:mo>

                                          <mml:mi>'</mml:mi>
                                        </mml:mrow>

                                        <mml:mi>x</mml:mi>
                                      </mml:mfrac>
                                    </mml:mrow>

                                    <mml:mo mml:stretchy="false">−</mml:mo>

                                    <mml:mfrac>
                                      <mml:mo mml:stretchy="false">φ</mml:mo>

                                      <mml:msup>
                                        <mml:mi>x</mml:mi>

                                        <mml:mn>2</mml:mn>
                                      </mml:msup>
                                    </mml:mfrac>
                                  </mml:mrow>
                                </mml:mrow>

                                <mml:mo mml:stretchy="false">)</mml:mo>
                              </mml:mrow>

                              <mml:mo mml:stretchy="false">+</mml:mo>

                              <mml:mo mml:stretchy="false">ψ</mml:mo>
                            </mml:mrow>

                            <mml:mrow>
                              <mml:mrow>
                                <mml:mrow>
                                  <mml:mo mml:stretchy="false">(</mml:mo>

                                  <mml:mrow>
                                    <mml:mn>1</mml:mn>

                                    <mml:mo mml:stretchy="false">−</mml:mo>

                                    <mml:mfrac>
                                      <mml:mo mml:stretchy="false">φ</mml:mo>

                                      <mml:mi>x</mml:mi>
                                    </mml:mfrac>
                                  </mml:mrow>

                                  <mml:mo mml:stretchy="false">)</mml:mo>
                                </mml:mrow>

                                <mml:mo mml:stretchy="false">−</mml:mo>

                                <mml:mo mml:stretchy="false">φ</mml:mo>
                              </mml:mrow>

                              <mml:mo mml:stretchy="false">+</mml:mo>

                              <mml:mo mml:stretchy="false">γ</mml:mo>
                            </mml:mrow>

                            <mml:mi>x</mml:mi>

                            <mml:mrow>
                              <mml:mrow>
                                <mml:mo mml:stretchy="false">(</mml:mo>

                                <mml:mrow>
                                  <mml:mn>1</mml:mn>

                                  <mml:mo mml:stretchy="false">−</mml:mo>

                                  <mml:mfrac>
                                    <mml:msup>
                                      <mml:mi>x</mml:mi>

                                      <mml:mn>2</mml:mn>
                                    </mml:msup>

                                    <mml:mn>2</mml:mn>
                                  </mml:mfrac>
                                </mml:mrow>

                                <mml:mo mml:stretchy="false">)</mml:mo>
                              </mml:mrow>

                              <mml:mo mml:stretchy="false">=</mml:mo>

                              <mml:mn>0</mml:mn>
                            </mml:mrow>
                          </mml:mrow>
                        </mml:mtr>

                        <mml:mtr>
                          <mml:mrow>
                            <mml:mo mml:stretchy="false">μ</mml:mo>

                            <mml:mrow>
                              <mml:mrow>
                                <mml:mo mml:stretchy="false">(</mml:mo>

                                <mml:mrow>
                                  <mml:mo mml:stretchy="false">ψ</mml:mo>

                                  <mml:mi>'</mml:mi>

                                  <mml:mrow>
                                    <mml:mrow>
                                      <mml:mi>'</mml:mi>

                                      <mml:mo mml:stretchy="false">+</mml:mo>

                                      <mml:mfrac>
                                        <mml:mrow>
                                          <mml:mo mml:stretchy="false">ψ</mml:mo>

                                          <mml:mi>'</mml:mi>
                                        </mml:mrow>

                                        <mml:mi>x</mml:mi>
                                      </mml:mfrac>
                                    </mml:mrow>

                                    <mml:mo mml:stretchy="false">−</mml:mo>

                                    <mml:mfrac>
                                      <mml:mo mml:stretchy="false">ψ</mml:mo>

                                      <mml:msup>
                                        <mml:mi>x</mml:mi>

                                        <mml:mn>2</mml:mn>
                                      </mml:msup>
                                    </mml:mfrac>
                                  </mml:mrow>
                                </mml:mrow>

                                <mml:mo mml:stretchy="false">)</mml:mo>
                              </mml:mrow>

                              <mml:mo mml:stretchy="false">−</mml:mo>

                              <mml:mo mml:stretchy="false">φ</mml:mo>
                            </mml:mrow>

                            <mml:mrow>
                              <mml:mrow>
                                <mml:mo mml:stretchy="false">(</mml:mo>

                                <mml:mrow>
                                  <mml:mn>1</mml:mn>

                                  <mml:mo mml:stretchy="false">−</mml:mo>

                                  <mml:mfrac>
                                    <mml:mo mml:stretchy="false">φ</mml:mo>

                                    <mml:mn>2x</mml:mn>
                                  </mml:mfrac>
                                </mml:mrow>

                                <mml:mo mml:stretchy="false">)</mml:mo>
                              </mml:mrow>

                              <mml:mo mml:stretchy="false">=</mml:mo>

                              <mml:mn>0</mml:mn>
                            </mml:mrow>
                          </mml:mrow>
                        </mml:mtr>

                        <mml:mtr>
                          <mml:mrow>
                            <mml:mrow>
                              <mml:mn>0</mml:mn>

                              <mml:mo mml:stretchy="false">&lt;</mml:mo>

                              <mml:mi>x</mml:mi>
                            </mml:mrow>

                            <mml:mo mml:stretchy="false">&lt;</mml:mo>

                            <mml:mn>1</mml:mn>
                          </mml:mrow>
                        </mml:mtr>
                      </mml:mtable>
                    </mml:mrow>

                    <mml:annotation mml:encoding="StarMath 5.0">left lbrace
                    stack{{%epsilon^4} over %mu (%phi''+ {%phi'} over x
                    -{%phi} over {x^2} ) +%psi (1- %phi over x ) -%phi+%gamma
                    x(1-{x^2} over 2)=0# %mu(%psi''+{%psi'} over x-%psi over
                    {x^2})-%phi(1-%phi over{2x})=0 # 0&lt;x&lt;1} right
                    none</mml:annotation>
                  </mml:semantics>
                </mml:math>
              </imagedata>
            </imageobject>
        </mediaobject>

        <para>Subject to the boundary conditions</para>

        <mediaobject>
            <imageobject>
              <imagedata align="left">
                <mml:math>
                  <mml:semantics>
                    <mml:mrow>
                      <mml:mo mml:stretchy="true">{</mml:mo>

                      <mml:mtable>
                        <mml:mtr>
                          <mml:mrow>
                            <mml:mo mml:stretchy="false">φ</mml:mo>

                            <mml:mo mml:stretchy="false">=</mml:mo>

                            <mml:mn>0</mml:mn>
                          </mml:mrow>
                        </mml:mtr>

                        <mml:mtr>
                          <mml:mrow>
                            <mml:mi>x</mml:mi>

                            <mml:mi />

                            <mml:mo mml:stretchy="false">ψ</mml:mo>

                            <mml:mrow>
                              <mml:mi>'</mml:mi>

                              <mml:mo mml:stretchy="false">−</mml:mo>

                              <mml:mn>0.3</mml:mn>
                            </mml:mrow>

                            <mml:mrow>
                              <mml:mrow>
                                <mml:mo mml:stretchy="false">ψ</mml:mo>

                                <mml:mo mml:stretchy="false">+</mml:mo>

                                <mml:mn>0.7x</mml:mn>
                              </mml:mrow>

                              <mml:mo mml:stretchy="false">=</mml:mo>

                              <mml:mn>0</mml:mn>
                            </mml:mrow>
                          </mml:mrow>
                        </mml:mtr>
                      </mml:mtable>
                    </mml:mrow>

                    <mml:annotation mml:encoding="StarMath 5.0">left lbrace
                    stack{ %phi=0# x`%psi'-0.3%psi+0.7x=0} right
                    none</mml:annotation>
                  </mml:semantics>
                </mml:math>
              </imagedata>
            </imageobject>
        </mediaobject>

        <para>for <literal>x=0</literal> and <literal>x=1</literal></para>

        <programlisting role="example"><![CDATA[ 
N=2;// two differential equations
m=[2 2];//each differential equation is of second  order
M=sum(m);

x_low=0;x_up=1; // the x limits
zeta=[x_low,x_low, x_up x_up]; //two  constraints on each bound.


//The external functions
//Theses functions are called by the solver with zu=[u1(x);u1'(x);u2(x);u2'(x)]


// - The function which computes the right hand side of the differential equation
function f=fsub2(x,zu,eps,dmu,eps4mu,gam,xt),
   f=[zu(1)/x^2-zu(2)/x+(zu(1)-zu(3)*(1-zu(1)/x)-gam*x*(1-x^2/2))/eps4mu //phi''
      zu(3)/x^2-zu(4)/x+zu(1)*(1-zu(1)/(2*x))/dmu];//psi''
endfunction

// - The function which computes the derivative of fsub with respect to zu
function df=dfsub2(x,zu,eps,dmu,eps4mu,gam,xt),
  df=[1/x^2+(1+zu(3)/x)/eps4mu, -1/x, -(1-zu(1)/x)/eps4mu, 0
      (1-zu(1)/x)/dmu             0    1/x^2              -1/x];
endfunction

// - The function which computes the ith constraint for a given i
function g=gsub2(i,zu),
  select i
  case 1 then  //x=zeta(1)=0
    g=zu(1) //u(0)=0
  case 2 then //x=zeta(2)=0
    g=-0.3*zu(3) //x*psi'-0.3*psi+0.7x=0
  case 3 then //x=zeta(3)=1
    g=zu(1) //u(1)=0
  case 4 then  //x=zeta(4)=1
    g=1*zu(4)-0.3*zu(3)+0.7*1 //x*psi'-0.3*psi+0.7x=0
  end
endfunction

// - The function which computes the derivative of gsub with respect to z
function dg=dgsub2(i,z)
  select i
  case 1 then  //x=zeta(1)=1
    dg=[1,0,0,0]
  case 2 then //x=zeta(2)=1
    dg=[0,0,-0.3,0]
  case 3 then //x=zeta(3)=2
     dg=[1,0,0,0]
  case 4 then  //x=zeta(4)=2
    dg=[0,0,-0.3,1]
  end
endfunction


gam=1.1
eps=1d-3
dmu=eps
eps4mu=eps^4/dmu
xt=sqrt(2*(gam-1)/gam)

fixpnt=[ ];//All boundary conditions are located at x_low and x_up
collpnt=4;
nsizef=4+3*M+(5+collpnt*N)*(collpnt*N+M)+(2*M-2)*2*M ;
nsizei=3 + collpnt*N+M;;
nmax=200;
//    nonlin  collpnt n  ntol ndimf        ndimi        iprint iread iguess rstart nfxpnt
ipar=[1       k       10 4    nmax*nsizef  nmax*nsizei   -1      0     0      0      0     ]

ltol=1:4;//set tolerance control on zu(1) zu(2 ) zu(3) and zu(4)
tol=[1.e-5,1.e-5,1.e-5,1.e-5];//set tolreance values for these four controls
xpoints=x_low:0.01:x_up;

zu=bvode(xpoints,N,m,x_low,x_up,zeta,ipar,ltol,tol,fixpnt,...
        fsub2,dfsub2,gsub2,dgsub2,guess2);
scf(1);clf();plot(xpoints,zu([1 3],:)) // the evolution of the solution phi and psi

//using an initial guess
// - The function which computes the initial guess, unused here
function [zu,dmval]=guess2(x,gam),
   cons=gam*x*(1-x^2/2)
   dcons=gam*(1-3*x^2/2)
   d2cons=-3*gam*x
   dmval=zeros(2,1)
   if x&gt;xt then
     zu=[0 0 -cons -dcons]
     dmval(2)=-d2cons
   else
     zu=[2*x;2;-2*x+cons;-2*dcons]
     dmval(2)=d2cons
   end
endfunction 
ipar(9)=1;//iguess

zu2=bvode(xpoints,N,m,x_low,x_up,zeta,ipar,ltol,tol,fixpnt,...
        fsub2,dfsub2,gsub2,dgsub2,guess2);
scf(2);clf();plot(xpoints,zu2([1 3],:)) // the evolution of the solution phi and psi
]]></programlisting>
      </listitem>

      <listitem>
        <para>An eigenvalue problem:</para>

        <programlisting role="example"><![CDATA[
// y''(x)=-la*y(x)
// BV: y(0)=y'(0); y(1)=0
// Eigenfunctions and eigenvalues are y(x,n)=sin(s(n)*(1-x)), la(n)=s(n)^2,
// where s(n) are the zeros of f(s,n)=s+atan(s)-(n+1)*pi, n=0,1,2,...
// To get a third boundary condition, we choose y(0)=1
// (With y(x) also c*y(x) is a solution for each constant c.)
// We solve the following ode system:
// y''=-la*y
// la'=0
// BV: y(0)=y'(0), y(0)=1; y(1)=0
// z=[y(x) ; y'(x) ; la]

function rhs=fsub(x,z)
  rhs=[-z(3)*z(1);0]
endfunction

function g=gsub(i,z)
  g=[z(1)-z(2) z(1)-1 z(1)]
  g=g(i)
endfunction

// The following start function is good for the first 8 eigenfunctions.
function [z,lhs]=ystart(x,z,la0)
  z=[1;0;la0]
  lhs=[0;0]
endfunction

a=0;b=1;
m=[2;1];
n=2;
zeta=[a a b];
N=101;
x=linspace(a,b,N)';

// We have s(n)-(n+1/2)*pi -&gt; 0 for n to infinity.
la0=input('n-th eigenvalue: n= ?');la0=(%pi/2+la0*%pi)^2;

z=bvodeS(x,m,n,a,b,fsub,gsub,zeta,ystart=list(ystart,la0));

clf()
plot(x,[z(1,:)' z(2,:)']) 
xtitle(['Startvalue =  '+string(la0);'Eigenvalue = '+string(z(3,1))],'x',' ')
legend(['y(x)';'y''(x)'])
      ]]></programlisting>
      </listitem>

      <listitem>
         <para>A boundary value problem with more than one solution.</para>

        <programlisting role="example"><![CDATA[
// DE: y''(x)=-exp(y(x))
// BV: y(0)=0; y(1)=0
// This boundary value problem has more than one solution.
// It is demonstrated how to find two of them with the help of
// some preinformation of the solutions y(x) to build the function ystart.
// z=[y(x);y'(x)]

a=0;b=1;m=2;n=1;
zeta=[a b];
N=101;
tol=1e-8*[1 1];
x=linspace(a,b,N);

function rhs=fsub(x,z),rhs=-exp(z(1));endfunction

function g=gsub(i,z)
  g=[z(1) z(1)]
  g=g(i)
endfunction

function [z,lhs]=ystart(x,z,M) 
  //z=[4*x*(1-x)*M ; 4*(1-2*x)*M]
  z=[M;0]
  //lhs=[-exp(4*x*(1-x)*M)]
  lhs=0
endfunction

for M=[1 4]
   if M==1
      z=bvodeS(x,m,n,a,b,fsub,gsub,zeta,ystart=list(ystart,M),tol=tol);
   else
      z1=bvodeS(x,m,n,a,b,fsub,gsub,zeta,ystart=list(ystart,M),tol=tol);
   end
end

// Integrating the ode yield e.g. the two solutions yex and yex1. 

function y=f(c),y=c.*(1-tanh(sqrt(c)/4).^2)-2;endfunction 
c=fsolve(2,f);

function y=yex(x,c)
  y=log(c/2*(1-tanh(sqrt(c)*(1/4-x/2)).^2))
endfunction 

function y=f1(c1), y=2*c1^2+tanh(1/4/c1)^2-1;endfunction
c1=fsolve(0.1,f1);

function y=yex1(x,c1)
  y=log((1-tanh((2*x-1)/4/c1).^2)/2/c1/c1)
endfunction 

disp(norm(z(1,:)-yex(x)),'norm(yex(x)-z(1,:))= ')
disp(norm(z1(1,:)-yex1(x)),'norm(yex1(x)-z1(1,:))= ')
clf();
subplot(2,1,1)
plot2d(x,z(1,:),style=[5])
xtitle('Two different solutions','x',' ') 
subplot(2,1,2)
plot2d(x,z1(1,:),style=[5])
xtitle(' ','x',' ')
      ]]></programlisting>

         
      </listitem>

      <listitem>
        <para>A multi-point boundary value problem.</para>

        <programlisting role="example"><![CDATA[
// DE y'''(x)=1
// z=[y(x);y'(x);y''(x)]
// BV: y(-1)=2 y(1)=2
// Side condition: y(0)=1 

a=-1;b=1;c=0;
// The side condition point c must be included in the array fixpnt.
n=1;
m=[3];

function rhs=fsub(x,z)
  rhs=1
endfunction

function g=gsub(i,z)
  g=[z(1)-2 z(1)-1 z(1)-2]
  g=g(i)
endfunction

N=10;
zeta=[a c b];
x=linspace(a,b,N);

z=bvodeS(x,m,n,a,b,fsub,gsub,zeta,fixpnt=c);
          
function y=yex(x)
y=x.^3/6+x.^2-x./6+1
endfunction

disp(norm(yex(x)-z(1,:)),'norm(yex(x)-z(1,:))= ')
      ]]></programlisting>
      </listitem>
    </itemizedlist>
  </refsection>

  <refsection>
    <title>See Also</title>

    <simplelist type="inline">
      <member><link linkend="link">link</link></member>

      <member><link linkend="external">external</link></member>

      <member><link linkend="ode">ode</link></member>

      <member><link linkend="dassl">dassl</link></member>
    </simplelist>
  </refsection>

  <refsection>
    <title>Used Functions</title>

    <para>This function is based on the Fortran routine
    <literal>colnew</literal> developped by</para>

    <para>U. Ascher, Department of Computer Science, University of British
    Columbia, Vancouver, B.C. V6T 1W5, Canada</para>

    <para>G. Bader, institut f. Angewandte mathematik university of
    Heidelberg; im Neuenheimer feld 294d-6900 Heidelberg 1</para>
  </refsection>

  <refsection>
    <title>Authors</title>

    <para>This help is based on the original colnew.f comments, adapted to
    Scilab by J.P Chancelier ENPC, on the bvodeS help page due to Rainer von
    Seggern, both merged and revised by S. Steer INRIA</para>
  </refsection>

  <refsection>
    <title>Bibliography</title>

    <orderedlist>
      <listitem>
        <para>U. Ascher, J. Christiansen and R.D. Russell, collocation
        software for boundary-value ODEs, acm trans. math software 7 (1981),
        209-222. this paper contains EXAMPLES where use of the code is
        demonstrated.</para>
      </listitem>

      <listitem>
        <para>G. Bader and U. Ascher, a new basis implementation for a mixed
        order boundary value ode solver, siam j. scient. stat. comput.
        (1987).</para>
      </listitem>

      <listitem>
        <para>U. Ascher, J. Christiansen and R.D. Russell, a collocation
        solver for mixed order systems of boundary value problems, math. comp.
        33 (1979), 659-679.</para>
      </listitem>

      <listitem>
        <para>U. Ascher, J. Christiansen and R.D. russell, colsys - a
        collocation code for boundary value problems, lecture notes comp.sc.
        76, springer verlag, b. childs et. al. (eds.) (1979), 164-185.</para>
      </listitem>

      <listitem>
        <para>C. Deboor and R. Weiss, solveblok: a package for solving almost
        block diagonal linear systems, acm trans. math. software 6 (1980),
        80-87.</para>
      </listitem>
    </orderedlist>
  </refsection>
</refentry>
