//
// Scilab ( http://www.scilab.org/ ) - This file is part of Scilab
// Copyright (C) 2012 - DIGITEO - Antoine ELIAS
// Copyright (C) 2012 - Scilab Enterprises - Cedric Delamarre
//
// This file must be used under the terms of the CeCILL.
// This source file is licensed as described in the file COPYING, which
// you should have received as part of this distribution.  The terms
// are also available at
// http://www.cecill.info/licences/Licence_CeCILL_V2-en.txt
//
//
// <-- CLI SHELL MODE -->
// sparse function
//from dense form
s=[ 1,0,0,0,0,0,0;
    0,1,0,0,0,0,0;
    0,0,1,0,0,0,0;
    0,0,1,1,0,0,0;
    0,0,1,1,1,0,0;
    0,0,1,1,0,1,0;
    0,0,1,1,0,1,1];
sp=sparse(s);
assert_checkequal(size(s), size(sp));
assert_checkequal(full(sp), s);
//from coord
sp = sparse([1 1;2 2;3 3;4 3;4 4;5 3;5 4;5 5;6 3;6 4;6 6;7 3;7 4;7 6;7 7], [1 1 1 1 1 1 1 1 1 1 1 1 1 1 1]);
assert_checkequal(size(s), size(sp));
assert_checkequal(full(sp), s);
//with size
newsp = sparse([], [], [10,20]);
assert_checkequal(size(newsp), [10,20]);
//concatenation
spc = [sp [1; 0; 1; 0; 1; 0; 1]];
sc = [s [1; 0; 1; 0; 1; 0; 1]];
assert_checkequal(full(spc), sc);
spc = [sp ;[1 0 1 0 1 0 1]];
sc = [s ;[1 0 1 0 1 0 1]];
assert_checkequal(full(spc), sc);
spc = [[1; 0; 1; 0; 1; 0; 1] sp];
sc = [[1; 0; 1; 0; 1; 0; 1] s];
assert_checkequal(full(spc), sc);
spc = [[1 0 1 0 1 0 1]; sp];
sc = [[1 0 1 0 1 0 1]; s];
assert_checkequal(full(spc), sc);
sc = [s s];
spc = [sp sp];
assert_checkequal(full(spc), sc);
sc = [s; s];
spc = [sp; sp];
assert_checkequal(full(spc), sc);
sc = [s s];
spc = [sp sp];
assert_checkequal(full(spc), sc);
A = sparse(1);
A = [A 0];
A = [A 0];
A = [A 0];
assert_checkequal(full(A), [1 0 0 0]);
assert_checkequal(size(A, 'c'), 4);
//extraction
assert_checkequal(full(sp(:)), s(:));
assert_checkequal(size(sp(:)), size(s(:)));
assert_checkequal(full(sp(1:7, 1:7)), s(1:7, 1:7));
assert_checkequal(size(sp(1:7, 1:7)), size(s(1:7, 1:7)));
assert_checkequal(full(sp(1:4, :)), s(1:4, :));
assert_checkequal(size(sp(1:4, :)), size(s(1:4, :)));
assert_checkequal(full(sp(:, 2:6)), s(:, 2:6));
assert_checkequal(size(sp(:, 2:6)), size(s(:, 2:6)));
assert_checkequal(full(sp(:, $)), s(:, $));
assert_checkequal(size(sp(:, $)), size(s(:, $)));
//next tests get from old module sparse (Scilab 5.4)
ij=[1 6;1 5;1 3;2 4;2 1;4 4;4 3;5 1;6 6];
v=[1;2;3;4;5;6;7;8;9];
ij1=[1 6;1 2;6 5];
v1=[-1;-1;-1];
vc=v+%i*(21:29)';
v1c=v1+%i*[0;0.3;-1.2];
zer=sparse([],[],[6,6]);
a=sparse([1 6;1 5;1 3;2 4;2 1;4 4;4 3;5 1;6 6],1:9,[6 6]);
b=sparse([1 6;1 2;6 5],[-1;-1;-1],[6 6]);
ma=sparse([1 6;1 5;1 3;2 4;2 1;4 4;4 3;5 1;6 6],-(1:9),[6 6]);
mb=sparse([1 6;1 2;6 5],-[-1;-1;-1],[6 6]);
ac=sparse([1 6;1 5;1 3;2 4;2 1;4 4;4 3;5 1;6 6],(1:9)+%i*(21:29),[6 6]);
bc=sparse([1 6;1 2;6 5],[-1;-1;-1]+%i*[0;0.3;-1.2],[6 6]);
mac=sparse([1 6;1 5;1 3;2 4;2 1;4 4;4 3;5 1;6 6],-(1:9)-%i*(21:29),[6 6]);
mbc=sparse([1 6;1 2;6 5],[1;1;1]+%i*[0;-0.3;1.2],[6 6]);
//-------------------------------------------------------------
//test des primitives sparse, full
//--------------------------------------------------------------
//  -- for real matrix
assert_checkequal(full(sparse(0.3)), 0.3);
v=0*ones(1,3);v(3)=5;v(1)=1;
assert_checkequal(full(sparse([1 1;1 3],[1 5])), v);
v=0*ones(1,300);v(300)=5;v(1)=1;
assert_checkequal(full(sparse([1 1;1 300],[1 5])), v);
v=0*ones(3,1);v(3)=5;v(1)=1;
assert_checkequal(full(sparse([1 1;3 1],[1 5])), v);
v=0*ones(300,1);v(300)=5;v(1)=1;
assert_checkequal(full(sparse([1 1;300 1],[1 5])), v);
sp=sparse([1 6;1 5;1 3;2 4;2 1;4 4;4 3;5 1;6 6],1:9,[6 6]);
a=[0,0,3,0,2,1;;5,0,0,4,0,0;0,0,0,0,0,0;0,0,7,6,0,0;8,0,0,0,0,0;0,0,0,0,0,9];
assert_checkequal(full(sp), a);
sp=sparse([1 6;1 5;1 3;2 4;2 1;4 4;4 3;5 1;6 6],1:9,[8 6]);a(8,6)=0;
assert_checkequal(full(sp), a);
assert_checkequal(full(sparse([],[],[4 10])), 0*ones(4,10));
v=sparse([2 1;3 1;4 1;6 1],[10;11;12;13],[6,1]);
a=[0;10;11;12;0;13];
assert_checkequal(full(v), a);
v=sparse([1 2;1 3;1 4;1 6],[10;11;12;13],[1,6]);
a=[0,10,11,12,0,13];
assert_checkequal(full(v), a);
//  -- for complex matrix
sp=sparse([1 6;1 5;1 3;2 4;2 1;4 4;4 3;5 1;6 6],(1:9)+%i*(21:29),[6 6]);
a=[0,0,3+%i*23,0,2+%i*22,1+%i*21
   5+%i*25,0,0,4+%i*24,0,0
   0,0,0,0,0,0
   0,0,7+%i*27,6+%i*26,0,0
   8+%i*28,0,0,0,0,0
   0,0,0,0,0,9+%i*29];
assert_checkequal(full(sp), a);
sp=sparse([1 6;1 5;1 3;2 4;2 1;4 4;4 3;5 1;6 6],(1:9)+%i*(21:29),[8 6]);
a(8,6)=0;
assert_checkequal(full(sp), a);
v=sparse([2 1;3 1;4 1;6 1],[10-3*%i;11;12+5*%i;13+0.5*%i],[6,1]);
a=[0;10-%i*3;11;12+%i*5;0;13+%i*0.5];
assert_checkequal(full(v), a);
v=sparse([1 2;1 3;1 4;1 6],[10-3*%i;11;12+5*%i;13+0.5*%i],[1,6]);
a=[0,10-%i*3,11,12+%i*5,0,13+%i*0.5];
assert_checkequal(full(v), a);
//-----------------------------------------------
// addition and substraction tests
//-----------------------------------------------
// -- real real
a=sparse([1 6;1 5;1 3;2 4;2 1;4 4;4 3;5 1;6 6],1:9,[6 6]);
b=sparse([1 6;1 2;6 5],[-1;-1;-1],[6 6]);
v=sparse([2 1;3 1;4 1;6 1],[10;11;12;13],[6,1]);
vt=sparse([1 2;1 3;1 4;1 6],[10;11;12;13],[1,6]);
ma=sparse([1 6;1 5;1 3;2 4;2 1;4 4;4 3;5 1;6 6],-(1:9),[6 6]);
mb=sparse([1 6;1 2;6 5],-[-1;-1;-1],[6 6]);
zer=sparse([],[],[6,6]);
ac=sparse([1 6;1 5;1 3;2 4;2 1;4 4;4 3;5 1;6 6],(1:9)+%i*(21:29),[6 6]);
bc=sparse([1 6;1 2;6 5],[-1;-1;-1]+%i*[0;0.3;-1.2],[6 6]);
vc=sparse([2 1;3 1;4 1;6 1],[10-3*%i;11;12+5*%i;13+0.5*%i],[6,1]);
vct=sparse([1 2;1 3;1 4;1 6],[10-3*%i;11;12+5*%i;13+0.5*%i],[1,6]);
mac=sparse([1 6;1 5;1 3;2 4;2 1;4 4;4 3;5 1;6 6],-(1:9)-%i*(21:29),[6 6]);
mbc=sparse([1 6;1 2;6 5],[1;1;1]+%i*[0;-0.3;1.2],[6 6]);
assert_checkequal(full(v+sparse([],[],[6,1])), full(v));
assert_checkequal(full(sparse([],[],[6,1])+v), full(v));
assert_checkequal(full(v+v), full(v)+full(v));
assert_checkequal(full(v-v), full(v)-full(v));
assert_checkequal(full(vt+sparse([],[],[1,6])), full(vt));
assert_checkequal(full(vt+vt), full(vt)+full(vt));
assert_checkequal(full(vt-vt), full(vt)-full(vt));
assert_checkequal(full(zer+zer), 0*ones(6,6));
assert_checkequal(full(a+a), full(a)+full(a));
assert_checkequal(full(b+b), full(b)+full(b));
assert_checkequal(full(a+zer), full(a));
assert_checkequal(full(zer+a), full(a));
assert_checkequal(full(b+a), full(b)+full(a));
assert_checkequal(full(a+b), full(b)+full(a));
assert_checkequal(full(a+ma), full(a)+full(ma));
assert_checkequal(full(a-a), full(a)-full(a));
assert_checkequal(full(a-ma), full(a)-full(ma));
assert_checkequal(full(b-mb), full(b)-full(mb));
assert_checkequal(full(a-zer), full(a));
assert_checkequal(full(zer-a), -full(a));
assert_checkequal(full(a-mb), full(a)-full(mb));
//  -- real complex
assert_checkequal(full(sparse([],[],[6,1])+vc), full(vc));
assert_checkequal(full(v+vc), full(v)+full(vc));
assert_checkequal(full(v-vc), full(v)-full(vc));
assert_checkequal(full(vt+vct), full(vt)+full(vct));
assert_checkequal(full(vt-vct), full(vt)-full(vct));
assert_checkequal(full(a+ac), full(a)+full(ac));
assert_checkequal(full(b+bc), full(b)+full(bc));
assert_checkequal(full(a+bc), full(a)+full(bc));
assert_checkequal(full(zer+ac), full(zer)+full(ac));
assert_checkequal(full(b+ac), full(b)+full(ac));
assert_checkequal(full(a-ac), full(a)-full(ac));
assert_checkequal(full(b-bc), full(b)-full(bc));
assert_checkequal(full(a-bc), full(a)-full(bc));
assert_checkequal(full(zer-ac), full(zer)-full(ac));
assert_checkequal(full(b-ac), full(b)-full(ac));
// -- complex real
assert_checkequal(full(vc+v), full(vc)+full(v));
assert_checkequal(full(vc-v), full(vc)-full(v));
assert_checkequal(full(vct+vt), full(vct)+full(vt));
assert_checkequal(full(vct-vt), full(vct)-full(vt));
assert_checkequal(full(ac+a), full(ac)+full(a));
assert_checkequal(full(bc+b), full(bc)+full(b));
assert_checkequal(full(ac+b), full(ac)+full(b));
assert_checkequal(full(ac+zer), full(zer)+full(ac));
assert_checkequal(full(bc+a), full(bc)+full(a));
assert_checkequal(full(ac-a), full(ac)-full(a));
assert_checkequal(full(bc-b), full(bc)-full(b));
assert_checkequal(full(ac-b), full(ac)-full(b));
assert_checkequal(full(ac-zer), -full(zer)+full(ac));
assert_checkequal(full(bc-a), full(bc)-full(a));
// -- complex complex
assert_checkequal(full(vc+vc), full(vc)+full(vc));
assert_checkequal(full(vc-vc), full(vc)-full(vc));
assert_checkequal(full(vct+vct), full(vct)+full(vct));
assert_checkequal(full(vct-vct), full(vct)-full(vct));
assert_checkequal(full(ac+ac), full(ac)+full(ac));
assert_checkequal(full(bc+bc), full(bc)+full(bc));
assert_checkequal(full(ac+bc), full(ac)+full(bc));
assert_checkequal(full(bc+ac), full(bc)+full(ac));
assert_checkequal(real(full(ac-ac)), full(zer));
assert_checkequal(imag(full(ac-ac)), full(zer));
assert_checkequal(real(full(bc-bc)), full(zer));
assert_checkequal(imag(full(bc-bc)), full(zer));
assert_checkequal(full(ac-bc), full(ac)-full(bc));
assert_checkequal(full(bc-ac), full(bc)-full(ac));
// sparse full and full sparse operation (soft coded apoerations)
assert_checkequal(full(a+1), full(a)+1);
assert_checkequal(full(1+a), full(a)+1);
assert_checkequal(full(a+ones(6,6)), full(a)+ones(6,6));
assert_checkequal(full(ones(6,6)+a), full(a)+ones(6,6));
assert_checkequal(full(a+2*eye()), full(a)+2*eye());
assert_checkequal(full(2*eye()+a), full(a)+2*eye());
assert_checkequal(full(a-1), full(a)-1);
assert_checkequal(full(1-a), 1-full(a));
assert_checkequal(full(a-ones(6,6)), full(a)-ones(6,6));
assert_checkequal(full(ones(6,6)-a), ones(6,6)-full(a));
assert_checkequal(full(a-2*eye()), full(a)-2*eye());
assert_checkequal(full(2*eye()-a), 2*eye()-full(a));
assert_checkequal(full(ac+1), full(ac)+1);
assert_checkequal(full(1+ac), full(ac)+1);
assert_checkequal(full(ac+ones(6,6)), full(ac)+ones(6,6));
assert_checkequal(full(ones(6,6)+ac), full(ac)+ones(6,6));
assert_checkequal(full(ac+2*eye()), full(ac)+2*eye());
assert_checkequal(full(2*eye()+ac), full(ac)+2*eye());
assert_checkequal(full(ac-1), full(ac)-1);
assert_checkequal(full(1-ac), 1-full(ac));
assert_checkequal(full(ac-ones(6,6)), full(ac)-ones(6,6));
assert_checkequal(full(ones(6,6)-ac), ones(6,6)-full(ac));
assert_checkequal(full(ac-2*eye()), full(ac)-2*eye());
assert_checkequal(full(2*eye()-ac), 2*eye()-full(ac));
assert_checkequal(full(ac+full(bc)), full(ac)+full(bc));
assert_checkequal(full(ac-full(bc)), full(ac)-full(bc));
assert_checkequal(full(full(ac)+full(bc)), full(ac)+full(bc));
//-----------------------------------------------
// multiplication tests
//-----------------------------------------------
// real x real
// sparse scalar , saclar sparse
assert_checkequal(full(a*2), full(a)*2);
assert_checkequal(full(2*a), full(a)*2);
assert_checkequal(a*[], []);
assert_checkequal([]*a, []);
c=rand(6,6);
assert_checkequal(a*c, full(a)*c);
assert_checkequal(c*a, c*full(a));
// sparse sparse
assert_checkequal(full(zer*zer), full(zer));
assert_checkequal(full(a*zer), full(zer));
assert_checkequal(full(zer*a), full(zer));
assert_checkequal(full(a*a), full(a)*full(a));
assert_checkequal(full(b*b), full(b)*full(b));
assert_checkequal(full(a*b), full(a)*full(b));
assert_checkequal(full(b*a), full(b)*full(a));
// complex x real real x complex
// sparse scalar , scalar sparse
assert_checkequal(full(ac*2), full(ac)*2);
assert_checkequal(full(2*ac), full(ac)*2);
assert_checkequal(full((2+%i)*a), (2+%i)*full(a));
assert_checkequal(full(a*(2+%i)), (2+%i)*full(a));
assert_checkequal(ac*[], []);
assert_checkequal([]*ac, []);
c=rand(6,6);
cc=c+rand(6,6)*%i;
assert_checkequal(ac*c, full(ac)*c);
assert_checkequal(cc*a, cc*full(a));
// sparse sparse
assert_checkequal(real(full(ac*zer)), full(zer));
assert_checkequal(imag(full(ac*zer)), full(zer));
assert_checkequal(real(full(zer*ac)), full(zer));
assert_checkequal(imag(full(zer*ac)), full(zer));
assert_checkequal(full(ac*a), full(ac)*full(a));
assert_checkequal(full(ac*a), full(ac)*full(a));
assert_checkequal(full(bc*b), full(bc)*full(b));
assert_checkequal(full(a*bc), full(a)*full(bc));
assert_checkequal(full(b*ac), full(b)*full(ac));
// // complex x complex
assert_checkequal(ac*cc, full(ac)*cc);
assert_checkequal(cc*ac, cc*full(ac));
// sparse sparse
assert_checkequal(full(ac*ac), full(ac)*full(ac));
assert_checkequal(full(bc*bc), full(bc)*full(bc));
assert_checkequal(full(bc*ac), full(bc)*full(ac));
//----------------------------------------------------------
// element wise multiplication tests
//----------------------------------------------------------
assert_checkequal(full(ac.*2), full(ac)*2);
assert_checkequal(full((2).*ac), full(ac)*2);
assert_checkequal(a.*[], []);
assert_checkequal([].*a, []);
c=rand(6,6);
//if norm(a*c-full(a)*c) >100*%eps then bugmes();quit;end
//if norm(c*a-c*full(a)) >100*%eps then bugmes();quit;end
// sparse sparse
assert_checkequal(full(zer.*zer), full(zer));
assert_checkequal(full(a.*zer), full(zer));
assert_checkequal(full(zer.*a), full(zer));
assert_checkequal(full(a.*a), full(a).*full(a));
assert_checkequal(full(b.*b), full(b).*full(b));
assert_checkequal(full(a.*b), full(a).*full(b));
assert_checkequal(full(b.*a), full(b).*full(a));
// complex x real real x complex
// sparse scalar , scalar sparse
assert_checkequal(full((2+%i).*a), (2+%i).*full(a));
assert_checkequal(full(a.*(2+%i)), (2+%i).*full(a));
assert_checkequal(ac.*[], []);
assert_checkequal([].*ac, []);
c=rand(6,6);
cc=c+rand(6,6)*%i;
assert_checkequal(full(ac.*c), full(ac).*c);
assert_checkequal(full(cc.*a), cc.*full(a));
// sparse sparse
assert_checkequal(full(ac.*zer), full(zer));
assert_checkequal : L'objet calculé est de type complexe, cependant il aurait dû être réel.
at line    86 of function assert_checkequal called by :
assert_checkequal(full((ac .* zer)), full(zer))
at line   355 of exec file called by :
