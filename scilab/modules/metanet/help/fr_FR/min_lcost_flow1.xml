<?xml version="1.0" encoding="UTF-8"?>
<!--
 * Scilab ( http://www.scilab.org/ ) - This file is part of Scilab
 * Copyright (C) 2008 - INRIA
 * 
 * This file must be used under the terms of the CeCILL.
 * This source file is licensed as described in the file COPYING, which
 * you should have received as part of this distribution.  The terms
 * are also available at    
 * http://www.cecill.info/licences/Licence_CeCILL_V2-en.txt
 *
 -->
<refentry xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:svg="http://www.w3.org/2000/svg" xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:db="http://docbook.org/ns/docbook" version="5.0-subset Scilab" xml:lang="fr" xml:id="min_lcost_flow1">
  <info>
    <pubdate>$LastChangedDate$</pubdate>
  </info>
  <refnamediv>
    <refname>min_lcost_flow1</refname>
    <refpurpose> flot de coût linéaire minimum  </refpurpose>
  </refnamediv>
  <refsynopsisdiv>
    <title>Séquence d'appel</title>
    <synopsis>[c,phi,flag] = min_lcost_flow1(g)</synopsis>
  </refsynopsisdiv>
  <refsection>
    <title>Paramètres</title>
    <variablelist>
      <varlistentry>
        <term>g  </term>
        <listitem>
          <para>graphe (liste)
</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>c  </term>
        <listitem>
          <para>valeur du coût
</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>phi  </term>
        <listitem>
          <para>vecteur ligne des valeurs des flots sur les arcs
</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>flag  </term>
        <listitem>
          <para>problème soluble ou pas (0 ou 1)
</para>
        </listitem>
      </varlistentry>
    </variablelist>
  </refsection>
  <refsection>
    <title>Description</title>
    <para>
      <literal>min_lcost_flow1</literal> calcule flot de coût linéaire
      minimum dans un réseau <literal>g</literal>. Elle renvoie le
      coût total du flot sur les arcs <literal>c</literal> et le
      vecteur ligne des flots sur les arcs <literal>phi</literal>. Si
      le problème n'est pas soluble (impossible de trouver un flot
      compatible), <literal>flag</literal> est égal à 0, sinon il est
      égal à 1.
    </para>
    <para>
      Les bornes sur les flots sont données par les éléments
      <literal>g.edges.data.min_cap</literal> et
      <literal>g.edges.data.max_cap</literal> du graphe.  
   </para>
    <para>
      Les valeurs des capacités maximum et minimum doivent être
      entières et positives.  La valeur de la capacité maximum doit
      être supérieure ou égale à la valeur de la capacité minimum.  Si
      la valeur de <literal>min_cap</literal> ou de
      <literal>max_cap</literal> n'est pas donnée elle est supposé
      nulle sur chaque arête.
    </para>
    <para>
      Les coûts sur les arêtes sont donnés par les éléments
      <literal>g.edges.data.cost</literal> du graphe.  Les coûts
      doivent être non négatifs.  Si la valeur de
      <literal>cost</literal> n'est pas donnée, elle est supposé nulle
      sur chaque arête.
    </para>
   <para>
      Si les champs de donnée <literal>min_cap</literal> ou
      <literal>max_cap</literal> ou <literal>cost</literal> ne sont
      pas présents dans la structure du graphe, ils peuvent être
      ajoutés et affectés en utilisant la fonction  <link
      linkend="add_edge_data">add_edge_data</link>.
    </para>
    <para>
      Cette fonction utilise l'algorithme out-of-kilter.
    </para>
  </refsection>
  <refsection>
    <title>Exemples</title>
    <programlisting role="example"><![CDATA[

ta=[1,1,2,2,2,3,4,4,5,6,6,6,7,7,7,8,9,10,12,12,13,13,13,14,15,14,9,11,10,1,8];
he=[2,6,3,4,5,1,3,5,1,7,10,11,5,8,9,5,8,11,10,11,9,11,15,13,14,4,6,9,1,12,14];
g=make_graph('foo',1,15,ta,he);
g.nodes.graphics.x=[155,153,85,155,237,244,244,334,338,346,442,440,439,333,438];
g.nodes.graphics.y=[45,145,221,222,221,82,139,225,142,69,140,72,232,318,319];
show_graph(g);

g=add_edge_data(g,'min_cap',[3,7,1,3,6,15,11,3,5,3,12,5,0,5,15,6,2,3,16,7,7,2,8,4,1,7,5,17,20,1,9]);
g=add_edge_data(g,'max_cap',[44,55,49,42,42,63,50,46,38,52,55,46,51,52,67,..
                              57,51,38,57,46,45,52,46,42,52,49,47,58,66,38,46]);
g=add_edge_data(g,'cost',[4,6,6,3,8,2,3,3,3,5,10,4,9,5,4,3,11,8,5,4,8,4,6,10,8,7,6,2,5,9,6]);
[c,phi,flag]=min_lcost_flow1(g);flag

g.edges.graphics.foreground(find(phi<>0))=color('red');
g=add_edge_data(g,'flow',phi)
g.edges.graphics.display='flow';
show_graph(g);
  ]]></programlisting>
  </refsection>
  <refsection>
    <title>Voir Aussi</title>
    <simplelist type="inline">
      <member>
        <link linkend="min_lcost_cflow">min_lcost_cflow</link>
      </member>
      <member>
        <link linkend="min_lcost_flow2">min_lcost_flow2</link>
      </member>
      <member>
        <link linkend="min_qcost_flow">min_qcost_flow</link>
      </member>
    </simplelist>
  </refsection>
</refentry>
