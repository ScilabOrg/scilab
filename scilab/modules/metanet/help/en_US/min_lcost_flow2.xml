<?xml version="1.0" encoding="UTF-8"?>
<!--
 * Scilab ( http://www.scilab.org/ ) - This file is part of Scilab
 * Copyright (C) 2008 - INRIA
 * 
 * This file must be used under the terms of the CeCILL.
 * This source file is licensed as described in the file COPYING, which
 * you should have received as part of this distribution.  The terms
 * are also available at    
 * http://www.cecill.info/licences/Licence_CeCILL_V2-en.txt
 *
 -->
<refentry xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:svg="http://www.w3.org/2000/svg" xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:db="http://docbook.org/ns/docbook" version="5.0-subset Scilab" xml:lang="en" xml:id="min_lcost_flow2">
  <info>
    <pubdate>$LastChangedDate$</pubdate>
  </info>
  <refnamediv>
    <refname>min_lcost_flow2</refname>
    <refpurpose> minimum linear cost flow</refpurpose>
  </refnamediv>
  <refsynopsisdiv>
    <title>Calling Sequence</title>
    <synopsis>[c,phi,flag] = min_lcost_flow2(g)</synopsis>
  </refsynopsisdiv>
  <refsection>
    <title>Parameters</title>
    <variablelist>
      <varlistentry>
        <term>g</term>
        <listitem>
          <para> a <link linkend="graph_data_structure">graph_data_structure</link>.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>c</term>
        <listitem>
          <para>value of cost</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>phi</term>
        <listitem>
          <para>row vector of the value of flow on the arcs</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>flag</term>
        <listitem>
          <para>feasible problem flag (0 or 1)</para>
        </listitem>
      </varlistentry>
    </variablelist>
  </refsection>
  <refsection>
    <title>Description</title>
    <para>
      <literal>min_lcost_flow2</literal> computes the minimum linear
      cost flow in the network <literal>g</literal>. It returns the
      total cost of the flows on the arcs <literal>c</literal> and the
      row vector of the flows on the arcs <literal>phi</literal>. If
      the problem is not feasible (impossible to find a compatible
      flow for instance), <literal>flag</literal> is equal to 0,
      otherwise it is equal to 1.
    </para>
   <para>
      The bounds of the flow are given by the
      <literal>g.edges.data.min_cap</literal> and
      <literal>g.edges.data.max_cap</literal> fields of the graph.
    </para>
    <para>
      The value of the minimum capacity and of the maximum capacity
      must be non negative and must be integer numbers.  The value of
      the maximum capacity must be greater than or equal to the value
      of the minimum capacity. 
    </para>
    <para> 
      If the value of
      <literal>min_cap</literal> or <literal>max_cap</literal> is not
      given it is assumed to be equal to 0 on each edge.</para>
    <para>
      The costs on the edges are given by the element
      <literal>g.edges.data.cost</literal> of the fields of the graph.  The
      costs must be non negative.  If the value of
      <literal>cost</literal> is not given, it is assumed to be equal
      to 0 on each edge.
    </para>
    <para>
      The demand on the nodes are given by the
      <literal>g.edges.data.demand</literal> field of the graph.  The
      demands must be integer numbers. Note that the sum of the
      demands must be equal to zero for the problem to be feasible.
      If the value of <literal>demand</literal> is not given, it is
      assumed to be equal to 0 on each node.
    </para>
    <para>
      If the <literal>min_cap</literal> or <literal>max_cap</literal>
      or <literal>cost</literal> data
      fields are not present in the graph structure they can be added
      and set using the <link linkend="add_edge_data">add_edge_data</link> function.
      If the <literal>demand</literal>  data
      field is not present in the graph structure it can be added
      and set using the <link linkend="add_node_data">add_node_data</link> function.

    </para>
    <para>
      This functions uses a relaxation algorithm due to D. Bertsekas.
    </para>
  </refsection>
  <refsection>
    <title>Examples</title>
    <programlisting role="example"><![CDATA[

ta=[1 1 2 2 2 3 4 4 5 6 6 6 7 7 7 8 9 10 12 12 13 13 13 14 15 14 9 11 10 1 8];
he=[2 6 3 4 5 1 3 5 1 7 10 11 5 8 9 5 8 11 10 11 9 11 15 13 14 4 6 9 1 12 14];
g=make_graph('foo',1,15,ta,he);
g.nodes.graphics.x=[194 191 106 194 296 305 305 418 422 432 552 550 549 416 548];
g.nodes.graphics.y=[56 221 316 318 316 143 214 321 217 126 215 80 330 437 439];
show_graph(g);

g=add_edge_data(g,'max_cap',[37,24,23,30,25,27,27,24,34,40,21,38,35,23,38,28,26,..
                       22,40,22,28,24,31,25,26,24,23,30,22,24,35]);
g=add_edge_data(g,'cost',[10,6,3,8,10,8,11,1,2,6,5,6,5,3,4,2,4,4,8,2,4,5,4,8,8,3,4,3,7,10,10]);
g=add_node_data(g,'demand',[22,-29,18,-3,-16,20,-9,7,-6,17,21,-6,-8,-37,9]);

[c,phi,flag]=min_lcost_flow2(g);flag

g.edges.graphics.foreground(find(phi<>0))=color('red');
g=add_edge_data(g,'flow',phi)
g.edges.graphics.display='flow';
g.nodes.graphics.display='demand';

show_graph(g);

 
  ]]></programlisting>
  </refsection>
  <refsection>
    <title>See Also</title>
    <simplelist type="inline">
      <member>
        <link linkend="min_lcost_cflow">min_lcost_cflow</link>
      </member>
      <member>
        <link linkend="min_lcost_flow1">min_lcost_flow1</link>
      </member>
      <member>
        <link linkend="min_qcost_flow">min_qcost_flow</link>
      </member>
      <member>
        <link linkend="edges_data_structure">edges_data_structure</link>
      </member>
      <member>
        <link linkend="add_edge_data">add_edge_data</link>
      </member>
      <member>
        <link linkend="nodes_data_structure">nodes_data_structure</link>
      </member>
      <member>
        <link linkend="add_node_data">add_node_data</link>
      </member>
    </simplelist>
  </refsection>
</refentry>
