<?xml version="1.0" encoding="UTF-8"?>
<!--
 * Scilab ( http://www.scilab.org/ ) - This file is part of Scilab
 * Copyright (C) 2008 - INRIA
 * 
 * This file must be used under the terms of the CeCILL.
 * This source file is licensed as described in the file COPYING, which
 * you should have received as part of this distribution.  The terms
 * are also available at    
 * http://www.cecill.info/licences/Licence_CeCILL_V2-en.txt
 *
 -->
<refentry xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:svg="http://www.w3.org/2000/svg" xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:db="http://docbook.org/ns/docbook" version="5.0-subset Scilab" xml:lang="en" xml:id="min_lcost_flow1">
  <info>
    <pubdate>$LastChangedDate$</pubdate>
  </info>
  <refnamediv>
    <refname>min_lcost_flow1</refname>
    <refpurpose> minimum linear cost flow</refpurpose>
  </refnamediv>
  <refsynopsisdiv>
    <title>Calling Sequence</title>
    <synopsis>[c,phi,flag] = min_lcost_flow1(g)</synopsis>
  </refsynopsisdiv>
  <refsection>
    <title>Parameters</title>
    <variablelist>
      <varlistentry>
        <term>g</term>
        <listitem>
          <para> a <link linkend="graph_data_structure">graph_data_structure</link>.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>c</term>
        <listitem>
          <para>value of cost</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>phi</term>
        <listitem>
          <para>row vector of the value of flow on the arcs</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>flag</term>
        <listitem>
          <para>feasible problem flag (0 or 1)</para>
        </listitem>
      </varlistentry>
    </variablelist>
  </refsection>
  <refsection>
    <title>Description</title>
    <para>
      <literal>min_lcost_flow1</literal> computes the minimum linear
      cost flow in the network <literal>g</literal>. It returns the
      total cost of the flows on the arcs <literal>c</literal> and the
      row vector of the flows on the arcs <literal>phi</literal>. If
      the problem is not feasible (impossible to find a compatible
      flow for instance), <literal>flag</literal> is equal to 0,
      otherwise it is equal to 1.
    </para>
    <para>
      The bounds of the flow are given by the
      <literal>g.edges.data.min_cap</literal> and
      <literal>g.edges.data.max_cap</literal> fields of the graph.
    </para>
    <para>
      The value of the minimum capacity and of the maximum capacity
      must be non negative and must be integer numbers.  The value of
      the maximum capacity must be greater than or equal to the value
      of the minimum capacity. 
    </para>
    <para> 
      If the value of
      <literal>min_cap</literal> or <literal>max_cap</literal> is not
      given it is assumed to be equal to 0 on each edge.</para>
    <para>
      The costs on the edges are given by the element
      <literal>g.edges.data.cost</literal> of the fields of the graph.  The
      costs must be non negative.  If the value of
      <literal>cost</literal> is not given, it is assumed to be equal
      to 0 on each edge.
    </para>
    <para>
      If the <literal>min_cap</literal> or <literal>max_cap</literal>
      or <literal>cost</literal> data fields are not present in the
      graph structure they can be added and set using the <link
      linkend="add_edge_data">add_edge_data</link> function.
    </para>
  
    <para>
      This function uses the out-of-kilter algorithm.
    </para>
  </refsection>
  <refsection>
    <title>Examples</title>
    <programlisting role="example"><![CDATA[

ta=[1,1,2,2,2,3,4,4,5,6,6,6,7,7,7,8,9,10,12,12,13,13,13,14,15,14,9,11,10,1,8];
he=[2,6,3,4,5,1,3,5,1,7,10,11,5,8,9,5,8,11,10,11,9,11,15,13,14,4,6,9,1,12,14];
g=make_graph('foo',1,15,ta,he);
g.nodes.graphics.x=[155,153,85,155,237,244,244,334,338,346,442,440,439,333,438];
g.nodes.graphics.y=[45,145,221,222,221,82,139,225,142,69,140,72,232,318,319];
show_graph(g);

g=add_edge_data(g,'min_cap',[3,7,1,3,6,15,11,3,5,3,12,5,0,5,15,6,2,3,16,7,7,2,8,4,1,7,5,17,20,1,9]);
g=add_edge_data(g,'max_cap',[44,55,49,42,42,63,50,46,38,52,55,46,51,52,67,..
                              57,51,38,57,46,45,52,46,42,52,49,47,58,66,38,46]);
g=add_edge_data(g,'cost',[4,6,6,3,8,2,3,3,3,5,10,4,9,5,4,3,11,8,5,4,8,4,6,10,8,7,6,2,5,9,6]);
[c,phi,flag]=min_lcost_flow1(g);flag

g.edges.graphics.foreground(find(phi<>0))=color('red');
g=add_edge_data(g,'flow',phi)
g.edges.graphics.display='flow';
show_graph(g);

 
  ]]></programlisting>
  </refsection>
  <refsection>
    <title>See Also</title>
    <simplelist type="inline">
      <member>
        <link linkend="min_lcost_cflow">min_lcost_cflow</link>
      </member>
      <member>
        <link linkend="min_lcost_flow2">min_lcost_flow2</link>
      </member>
      <member>
        <link linkend="min_qcost_flow">min_qcost_flow</link>
      </member>
      <member>
        <link linkend="edges_data_structure">edges_data_structure</link>
      </member>
      <member>
        <link linkend="add_edge_data">add_edge_data</link>
      </member>
    </simplelist>
  </refsection>
</refentry>
