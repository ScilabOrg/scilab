// Scilab ( http://www.scilab.org/ ) - This file is part of Scilab
// Copyright (C) 2008 - Yann COLLETTE <yann.collette@renault.com>
// Copyright (C) 2010-2011 - DIGITEO - Michael Baudin
//
// This file must be used under the terms of the CeCILL.
// This source file is licensed as described in the file COPYING, which
// you should have received as part of this distribution.  The terms
// are also available at
// http://www.cecill.info/licences/Licence_CeCILL_V2.1-en.txt
// <-- CLI SHELL MODE -->
// <-- ENGLISH IMPOSED -->
// Test that we can run with default values for parameters
function y=test_func(x)
  y=x^2
endfunction
rand("seed",0);
x0 = 10;
ItExt = 30;
ItInt = 50;
Log = %f;
ItMX = 100;
T_init = compute_initial_temp(x0, test_func, 0.8, ItMX);
[x_best, f_best, mean_list, var_list, temp_list, f_history, x_history,iter] = optim_sa(x0, test_func, ItExt, ItInt, T_init, Log);
assert_checkalmostequal ( x_best , 0.0 , [] , 1.e-1 );
assert_checkalmostequal ( f_best , 0.0 , [] , 1.e-1 );
assert_checkequal ( size(mean_list) , [1 ItExt] );
assert_checkequal ( size(var_list) , [1 ItExt] );
assert_checkequal ( size(temp_list) , [1 ItExt] );
assert_checkequal ( size(f_history) , ItExt );
assert_checkequal ( size(x_history) , ItExt );
assert_checkequal ( iter>0 , %t );
///////////////////////////////////////////
// Test that we can configure our own neighbour function
function f = quad ( x )
  p = [4 3];
  f = (x(1) - p(1))^2 + (x(2) - p(2))^2
endfunction
// We produce a neighbor by adding some noise to each component of a given vector
function x_neigh = myneigh_func ( x_current, T , param)
  nxrow = size(x_current,"r")
  nxcol = size(x_current,"c")
  sa_min_delta = -0.1*ones(nxrow,nxcol);
  sa_max_delta = 0.1*ones(nxrow,nxcol);
  x_neigh = x_current + (sa_max_delta - sa_min_delta).*rand(nxrow,nxcol) + sa_min_delta;
endfunction
rand("seed",0);
x0          = [2 2];
Proba_start = 0.7;
It_Pre      = 100;
It_extern   = 50;
It_intern   = 50;
saparams = init_param();
saparams = add_param(saparams,"neigh_func", myneigh_func);
T0 = compute_initial_temp(x0, quad, Proba_start, It_Pre, saparams);
Log = %f;
[x_opt, f_opt] = optim_sa(x0, quad, It_extern, It_intern, T0, Log,saparams);
assert_checkalmostequal ( x_opt , [4 3] ,  1.e-1 );
assert_checkalmostequal ( f_opt , 0 ,  [] , 1.e-1 );
///////////////////////////////////////////
// Test that an additional parameter can be passed to the cost function
function f = quadp ( x , p )
  f = (x(1) - p(1))^2 + (x(2) - p(2))^2
endfunction
rand("seed",0);
x0 = [-1 -1];
p = [4 3];
T0 = compute_initial_temp(x0, list(quadp,p) , Proba_start, It_Pre);
[x_opt, f_opt] = optim_sa(x0, list(quadp,p) , 30, 30, T0, %f);
assert_checkalmostequal ( x_opt , [4 3] ,  1.e-1 );
assert_checkalmostequal ( f_opt , 0 ,  [] , 1.e-1 );
///////////////////////////////////////////
// Test with a plot function, which serves also as a stop function.
function f = quad ( x )
  p = [4 3];
  f = (x(1) - p(1))^2 + (x(2) - p(2))^2
endfunction
// See that the stop variable becomes true when the function value is near zero.
// The threshold is rather loose.
function stop = outfunc ( itExt , x_best , f_best , T , saparams )
  [mythreshold,err] = get_param(saparams,"mythreshold",0);
  v = format()
  format("e",10)
  sxbest = string(x_best)
  mprintf ( "Iter = #%-4d, \t x_best=[%12s %12s], f_best = %12s, T = %12s\n", itExt , sxbest(1), sxbest(2) , string(f_best) , string(T) )
  if ( v(1) == 0 ) then
    format("e",v(2))
  else
    format("v",v(2))
  end
  stop = ( abs(f_best) < mythreshold )
endfunction
rand("seed",0);
x0 = [-1 -1];
saparams = init_param();
saparams = add_param(saparams,"output_func", outfunc );
saparams = add_param(saparams,"mythreshold", 1.e-1 );
T0 = compute_initial_temp(x0, quad , 0.7, 100, saparams);
// Notice that the number of external iterations is %inf, so 
// that the external loop never stops.
// This allows to check that the output function really allows to 
// stop the algorithm.
[x_best, f_best, mean_list, var_list, temp_list, f_history, x_history , iter ] = optim_sa(x0, quad , 1e6, 100, T0, %f, saparams);
Iter = #1   , 	 x_best=[  -1.000D+00   -1.000D+00], f_best =    4.100D+01, T =    1.608D+00
Iter = #2   , 	 x_best=[   1.078D-01    1.127D-01], f_best =    2.349D+01, T =    1.447D+00
Iter = #3   , 	 x_best=[   6.984D-01    4.624D-01], f_best =    1.734D+01, T =    1.302D+00
Iter = #4   , 	 x_best=[   8.860D-01    8.590D-01], f_best =    1.428D+01, T =    1.172D+00
Iter = #5   , 	 x_best=[   1.012D+00    1.526D+00], f_best =    1.110D+01, T =    1.055D+00
Iter = #6   , 	 x_best=[   2.233D+00    1.673D+00], f_best =    4.883D+00, T =    9.493D-01
Iter = #7   , 	 x_best=[   2.884D+00    2.775D+00], f_best =    1.295D+00, T =    8.543D-01
Iter = #8   , 	 x_best=[   3.356D+00    2.657D+00], f_best =    5.322D-01, T =    7.689D-01
Iter = #9   , 	 x_best=[   3.356D+00    2.657D+00], f_best =    5.322D-01, T =    6.920D-01
Iter = #10  , 	 x_best=[   3.356D+00    2.657D+00], f_best =    5.322D-01, T =    6.228D-01
Iter = #11  , 	 x_best=[   3.985D+00    2.319D+00], f_best =    4.644D-01, T =    5.605D-01
Iter = #12  , 	 x_best=[   4.048D+00    2.653D+00], f_best =    1.230D-01, T =    5.045D-01
Iter = #13  , 	 x_best=[   4.048D+00    2.653D+00], f_best =    1.230D-01, T =    4.540D-01
Iter = #14  , 	 x_best=[   3.942D+00    2.813D+00], f_best =    3.844D-02, T =    4.086D-01
assert_checkalmostequal ( x_best , [4 3] ,  1.e-1 );
assert_checkalmostequal ( f_best , 0 ,  [] , 1.e-1 );
assert_checkequal ( iter > 0 , %t );
