<?xml version="1.0" encoding="UTF-8"?>
<!--
* Scilab ( http://www.scilab.org/ ) - This file is part of Scilab
* Copyright (C) 2012 - Scilab Enterprises - Sylvestre LEDRU
* 
* This file must be used under the terms of the CeCILL.
* This source file is licensed as described in the file COPYING, which
* you should have received as part of this distribution.  The terms
* are also available at    
* http://www.cecill.info/licences/Licence_CeCILL_V2-en.txt
*
-->
<refentry xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:svg="http://www.w3.org/2000/svg" xmlns:ns5="http://www.w3.org/1999/xhtml" xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:db="http://docbook.org/ns/docbook" version="5.0-subset Scilab" xml:id="api_scilab_getting_started" xml:lang="en">
  <info>
    <pubdate>$LastChangedDate$</pubdate>
  </info>
  <refnamediv>
    <refname>Getting started with API_Scilab</refname>
    <refpurpose>How to load a C, C++ or fortran code in the Scilab engine as a new function</refpurpose>
  </refnamediv>
  <refsection>
    <title>Description</title>
    <para>
      As described in the <link linkend="api_scilab">api_scilab presentation</link>, Scilab offers an API to extend the language with C, C++ or Fortran code (sources or libraries).
    </para>
    <para>
      The link between the Scilab engine and the application code is called <literal>gateway</literal>.
    </para>
    <para>Most of the time, the process is always the same: 
      <itemizedlist>
        <listitem>
          <para>1. Check the number of arguments (both input and output) provided by the user.</para>
          <para>
            For example, if the function <literal>foo(x)</literal> is called with <literal>foo()</literal> or <literal>foo(2,3)</literal>, the user must get an answer.
          </para>
          <para>
            More: <link linkend="CheckInputArgument">CheckInputArgument</link> and <link linkend="CheckOutputArgument">CheckOutputArgument</link> 
          </para>
        </listitem>
        <listitem>
          <para>2. Manage input arguments</para>
          <para>Several tasks are performed:
            <itemizedlist>
              <listitem>
                <para>Get the address to the variable for input argument X</para>
                <para>
                  Function <literal>SciErr getVarAddressFromPosition(void* context, int positionOfTheVariable, int** address);</literal>
                </para>
              </listitem>
              <listitem>
                <para>Check the type of the variable: matrix of double (complex or not), string, etc</para>
                <para> SciErr getVarType(void* context, int* positionOfTheVariable, int* Type);</para>
              </listitem>
              <listitem>
                <para>Check the size of the variable: square matrix, scalar, etc</para>
                <para>
                  The retrieval of the size information will be done with the same functions used to retrieve the actual data. For example, for a matrix of double, the function call <literal>SciErr getMatrixOfDouble(void* context, int* address, int* nbRows, int* nbCols, double** theActualData)</literal> will provide the dimension of the matrix.
                </para>
                <para>Almost all Scilab datatypes have an equivalent C function to perform such task.</para>
              </listitem>
              <listitem>
                <para>Other checks can be done like specific values expected, consitency between the first and second input arguments, etc.</para>
              </listitem>
              <listitem>
                <para>Data transformation (optional).</para>
                <para>Depending on the code or library targeted, some transformations can be applied to the data. A classical example is changing the storage of a matrix from column-stored to line-stored.</para>
                <para>Please note that it is usually a performance killer.</para>
              </listitem>
              
            </itemizedlist>
          </para>
        </listitem>
        <listitem>
          <para>3. Application code</para>
          <para>Once all the checks and data retrieval have been performed, the actual core code can be called. The actual intelligence (processes, data transformations, etc) will be performed here.</para>
          <para>
            This can be done through a thirdparty code stored and built in <literal>src/c</literal>, <literal>src/cpp</literal> or <literal>src/fortran</literal> but also under the form of a library. Virtually, any library could be linked to Scilab.
          </para>
        </listitem>
        
        <listitem>
          <para>4. Create the output arguments for the Scilab engine</para>
          <para>Once the application code has been executed, usually, some data will be returned to the Scilab interpreter.</para>
          <para>For example, to create in the Scilab engine memory a matrix of double, the C function <literal>
              SciErr createMatrixOfDouble(void* context, int position, int nbRows, int nbCols, const double* matrixOfDouble)
            </literal>
            should be called.
          </para>
          <para>
            The position is usually provided by <literal>nbInputArgument + X</literal>. <literal>X</literal> being the position of the returned output argument. For example, with the function profile <literal>[a, b, c] = foo();</literal> the <literal>nbInputArgument + 3</literal> will be the variable <literal>c</literal>.
          </para>
          <para>Note that the order of creation must be respected in the gateway.</para>
          <para>Almost all Scilab datatypes have an equivalent C function to perform such task.</para>
        </listitem>
        
        <listitem>
          <para>5. Return the output arguments to the Scilab engine</para>
          <para>Following, the task 4, the created variable will be returned.</para>
          
          
          <para>
            Taking the previous example <literal>[a, b, c] = foo();</literal>, to return <literal>a</literal>, the following declaration must be done: <literal>AssignOutputVariable(1) = nbInputArgument + 1;</literal>
          </para>
          
          <para>
            To commit the new variable to the Scilab engine, the function <literal>ReturnArguments();</literal> must be called.
          </para>
        </listitem>
        
      </itemizedlist>
      
    </para>
    <para>Note that almost all the API_Scilab functions returns a C structure called SciErr which contains many information about the error.</para>
    <para>
      By default, Scilab numerical values are stored with the C type <literal>double</literal>.
    </para>
    <para>
      As convention, gateways are stored in <literal>sci_gateway/c/</literal> (or <literal>/cpp/</literal>) and are called <literal>sci_functionName.c</literal>.
    </para>
  </refsection>
  <refsection>
    <title>Real life example</title>
    <para>Taking the sample Scilab function:</para>
    <para>
      <literal>[c,d] = foo(a,b);</literal>
    </para>
    <para>
      with <literal>a</literal> being a matrix of double and <literal>b</literal> a matrix of boolean with the same size of <literal>a</literal>, foo will multiply each element of <literal>a</literal> by 2 and return it as <literal>c</literal> and transform each element of element of b to its opposite.
    </para>
    <programlisting role="code_gateway">
      <![CDATA[ 
    // Full source can be found in the sci_gateway/c/ directory of the
    // toolbox skeleton

    // Standard header
    #include "api_scilab.h"
    #include "BOOL.h"

    // Function declaration
    int sci_foo(char *fname, unsigned long fname_len)
    {
    // Error management variable
    SciErr sciErr;

    ////////// Variables declaration //////////
    int m1 = 0, n1 = 0;
    int *piAddressVarOne = NULL;
    double *matrixOfDouble = NULL;
    double *newMatrixOfDouble = NULL;
    int iType1 = 0;

    int m2 = 0, n2 = 0;
    int *piAddressVarTwo = NULL;
    int *matrixOfBoolean = NULL;
    int *newMatrixOfBoolean = NULL;
    int iType2 = 0;

    int i = 0;


    ////////// Check the number of input and output arguments //////////
    /* --> [c, d] = foo(a, b) */
    /* check that we have only 2 input arguments */
    /* check that we have only 2 output argument */
    CheckInputArgument(pvApiCtx, 2, 2) ;
    CheckOutputArgument(pvApiCtx, 2, 2) ;


    ////////// Manage the first input argument (double) //////////
    /* get Address of inputs */
    sciErr = getVarAddressFromPosition(pvApiCtx, 1, &piAddressVarOne);
    if (sciErr.iErr)
    {
        printError(&sciErr, 0);
        return 0;
    }


    /* check input type */
    sciErr = getVarType(pvApiCtx, piAddressVarOne, &iType1);
    if (sciErr.iErr)
    {
        printError(&sciErr, 0);
        return 0;
    }

    if ( iType1 != sci_matrix )
    {
        Scierror(999, "%s: Wrong type for input argument #%d: A matrix expected.\n", fname, 1);
        return 0;
    }

    /* get matrix */
    sciErr = getMatrixOfDouble(pvApiCtx, piAddressVarOne, &m1, &n1, &matrixOfDouble);
    if (sciErr.iErr)
    {
        printError(&sciErr, 0);
        return 0;
    }

    ////////// Manage the second input argument (boolean) //////////

    /* get Address of inputs */
    sciErr = getVarAddressFromPosition(pvApiCtx, 2, &piAddressVarTwo);
    if (sciErr.iErr)
    {
        printError(&sciErr, 0);
        return 0;
    }


    /* check input type */
    sciErr = getVarType(pvApiCtx, piAddressVarTwo, &iType2);
    if (sciErr.iErr)
    {
        printError(&sciErr, 0);
        return 0;
    }

    if ( iType2 != sci_boolean )
    {
        Scierror(999, "%s: Wrong type for input argument #%d: A boolean matrix expected.\n", fname, 2);
        return 0;
    }

    /* get matrix */
    sciErr = getMatrixOfBoolean(pvApiCtx, piAddressVarTwo, &m2, &n2, &matrixOfBoolean);
    if (sciErr.iErr)
    {
        printError(&sciErr, 0);
        return 0;
    }

    ////////// Check the consistency of the two input arguments //////////

    if ((m1 != m2) |- (n1 != n2))
    {
        Scierror(999, "%s: Wrong size for input arguments: Same size expected.\n", fname, 1);
        return 0;
    }

    
    newMatrixOfDouble = (double*)malloc(sizeof(double)*m1*n1);
    ////////// Application code //////////
    // Could be replaced by a call to a library

    for (i = 0; i < m1 * n1; i++)
    {
        /* For each element of the matrix, multiply by 2 */
         newMatrixOfDouble[i] = matrixOfDouble[i]*2;
    }

    newMatrixOfBoolean = (int*)malloc(sizeof(double)*m2*n2);
    for (i = 0; i < m2 * n2; i++)
    {
        /* For each element of the matrix, invert the value */
      newMatrixOfBoolean[i] = matrixOfBoolean[i]==TRUE?FALSE:TRUE;
    }

    ////////// Create the output arguments //////////

    /* Create the matrix as return of the function */
    createMatrixOfDouble(pvApiCtx, nbInputArgument + 1, m1, n1, newMatrixOfDouble);
    if (sciErr.iErr)
    {
        printError(&sciErr, 0);
        return 0;
    }

    /* Create the matrix as return of the function */
    createMatrixOfBoolean(pvApiCtx, nbInputArgument + 2, m2, n2, newMatrixOfBoolean);
    if (sciErr.iErr)
    {
        printError(&sciErr, 0);
        return 0;
    }

    ////////// Return the output arguments to the Scilab engine //////////

    AssignOutputVariable(1) = nbInputArgument + 1;
    AssignOutputVariable(2) = nbInputArgument + 2;

    ReturnArguments();

    return 0;
}
      ]]>
    </programlisting>
    <para>
      To build this code and load it to Scilab, we use the dynamic link capabilities of Scilab. Delegating the build to Scilab, this code is multiplaform.
      <programlisting role="scilab">
        <![CDATA[ 
      files=["sci_foo.c"];
      // TODO: WTF ?
      WITHOUT_AUTO_PUTLHSVAR = %t;
      ilib_build('build_lib',['foo','sci_foo'],files,[]);
      exec loader.sce
      [c, d] = foo([2,%pi], [%t, %f])
      ]]>
      </programlisting>
    </para>
    <para>
      Various checks can be performed:
      <programlisting role="no-scilab-exec"><![CDATA[ 
-->[c, d] = foo(2, 2) 
                   !--error 999 
foo: Wrong type for input argument #2: A boolean matrix expected.
      ]]></programlisting>
      <programlisting role="no-scilab-exec"><![CDATA[ 
-->[c, d] = foo([2,2], %t)
                        !--error 999 
foo: Wrong size for input arguments: Same size expected.
      ]]></programlisting>
      <programlisting role="no-scilab-exec"><![CDATA[ 
-->[c, d] = foo([2,%pi], [%t, %f])
 d  =
 
  F T  
 c  =
 
    4.    6.2831853 
      ]]></programlisting>
    </para>
    
  </refsection>
</refentry>
