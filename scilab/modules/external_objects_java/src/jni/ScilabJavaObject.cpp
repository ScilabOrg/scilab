#include "ScilabJavaObject.hxx"
/* Generated by GIWS (version 2.0.2) with command:
giws --disable-return-size-array --output-dir src/jni/ --throws-exception-on-error --description-file src/jni/ScilabObjects.giws.xml 
*/
/*

This is generated code.

This software is a computer program whose purpose is to hide the complexity
of accessing Java objects/methods from C++ code.

This software is governed by the CeCILL-B license under French law and
abiding by the rules of distribution of free software.  You can  use,
modify and/ or redistribute the software under the terms of the CeCILL-B
license as circulated by CEA, CNRS and INRIA at the following URL
"http://www.cecill.info".

As a counterpart to the access to the source code and  rights to copy,
modify and redistribute granted by the license, users are provided only
with a limited warranty  and the software's author,  the holder of the
economic rights,  and the successive licensors  have only  limited
liability.

In this respect, the user's attention is drawn to the risks associated
with loading,  using,  modifying and/or developing or reproducing the
software by the user in light of its specific status of free software,
that may mean  that it is complicated to manipulate,  and  that  also
therefore means  that it is reserved for developers  and  experienced
professionals having in-depth computer knowledge. Users are therefore
encouraged to load and test the software's suitability as regards their
requirements in conditions enabling the security of their systems and/or
data to be ensured and,  more generally, to use and operate it in the
same conditions as regards security.

The fact that you are presently reading this means that you have had
knowledge of the CeCILL-B license and that you accept its terms.
*/

namespace org_scilab_modules_external_objects_java {

                // Static declarations (if any)
                
// Returns the current env

JNIEnv * ScilabJavaObject::getCurrentEnv() {
JNIEnv * curEnv = NULL;
jint res=this->jvm->AttachCurrentThread(reinterpret_cast<void **>(&curEnv), NULL);
if (res != JNI_OK) {
throw GiwsException::JniException(getCurrentEnv());
}
return curEnv;
}
// Destructor

ScilabJavaObject::~ScilabJavaObject() {
JNIEnv * curEnv = NULL;
this->jvm->AttachCurrentThread(reinterpret_cast<void **>(&curEnv), NULL);
curEnv->DeleteGlobalRef(this->instance);
curEnv->DeleteGlobalRef(this->instanceClass);
curEnv->DeleteGlobalRef(this->stringArrayClass);}
// Constructors
ScilabJavaObject::ScilabJavaObject(JavaVM * jvm_) {
jmethodID constructObject = NULL ;
jobject localInstance ;
jclass localClass ;

const std::string construct="<init>";
const std::string param="()V";
jvm=jvm_;

JNIEnv * curEnv = getCurrentEnv();

localClass = curEnv->FindClass( this->className().c_str() ) ;
if (localClass == NULL) {
  throw GiwsException::JniClassNotFoundException(curEnv, this->className());
}

this->instanceClass = static_cast<jclass>(curEnv->NewGlobalRef(localClass));

/* localClass is not needed anymore */
curEnv->DeleteLocalRef(localClass);

if (this->instanceClass == NULL) {
throw GiwsException::JniObjectCreationException(curEnv, this->className());
}


constructObject = curEnv->GetMethodID( this->instanceClass, construct.c_str() , param.c_str() ) ;
if(constructObject == NULL){
throw GiwsException::JniObjectCreationException(curEnv, this->className());
}

localInstance = curEnv->NewObject( this->instanceClass, constructObject ) ;
if(localInstance == NULL){
throw GiwsException::JniObjectCreationException(curEnv, this->className());
}
 
this->instance = curEnv->NewGlobalRef(localInstance) ;
if(this->instance == NULL){
throw GiwsException::JniObjectCreationException(curEnv, this->className());
}
/* localInstance not needed anymore */
curEnv->DeleteLocalRef(localInstance);

                /* Methods ID set to NULL */
jintinvokejintintjstringjava_lang_StringjintArray_intintID=NULL;
voidinitScilabJavaObjectID=NULL;
voidgarbageCollectID=NULL;
jstringgetRepresentationjintintID=NULL;
jbooleanisValidJavaObjectjintintID=NULL;
voidenableTracejstringjava_lang_StringID=NULL;
voiddisableTraceID=NULL;
voidsetFieldjintintjstringjava_lang_StringjintintID=NULL;
jintgetFieldjintintjstringjava_lang_StringID=NULL;
jintgetFieldTypejintintjstringjava_lang_StringID=NULL;
jintjavaCastjintintjstringjava_lang_StringID=NULL;
jintjavaCastjintintjintintID=NULL;
jstringgetClassNamejintintID=NULL;
jintgetArrayElementjintintjintArray_intintID=NULL;
voidsetArrayElementjintintjintArray_intintjintintID=NULL;
voidremoveScilabJavaObjectjintintID=NULL;
voidlimitDirectBufferjintintID=NULL;
jintisUnwrappablejintintID=NULL;
jintwrapDoublejdoubledoubleID=NULL;
jintwrapDoublejdoubleArray_doubledoubleID=NULL;
jintwrapDoublejobjectArray__doubledoubleID=NULL;
jintwrapIntjintintID=NULL;
jintwrapIntjintArray_intintID=NULL;
jintwrapIntjobjectArray__intintID=NULL;
jintwrapUIntjlonglongID=NULL;
jintwrapUIntjlongArray_longlongID=NULL;
jintwrapUIntjobjectArray__longlongID=NULL;
jintwrapBytejbytebyteID=NULL;
jintwrapBytejbyteArray_bytebyteID=NULL;
jintwrapBytejobjectArray__bytebyteID=NULL;
jintwrapUBytejshortshortID=NULL;
jintwrapUBytejshortArray_shortshortID=NULL;
jintwrapUBytejobjectArray__shortshortID=NULL;
jintwrapShortjshortshortID=NULL;
jintwrapShortjshortArray_shortshortID=NULL;
jintwrapShortjobjectArray__shortshortID=NULL;
jintwrapUShortjintintID=NULL;
jintwrapUShortjintArray_intintID=NULL;
jintwrapUShortjobjectArray__intintID=NULL;
jintwrapStringjstringjava_lang_StringID=NULL;
jintwrapStringjobjectArray_java_lang_Stringjava_lang_StringID=NULL;
jintwrapStringjobjectArray__java_lang_Stringjava_lang_StringID=NULL;
jintwrapBooleanjbooleanbooleanID=NULL;
jintwrapBooleanjbooleanArray_booleanbooleanID=NULL;
jintwrapBooleanjobjectArray__booleanbooleanID=NULL;
jintwrapCharjcharcharID=NULL;
jintwrapCharjcharArray_charcharID=NULL;
jintwrapCharjobjectArray__charcharID=NULL;
jintwrapFloatjfloatfloatID=NULL;
jintwrapFloatjfloatArray_floatfloatID=NULL;
jintwrapFloatjobjectArray__floatfloatID=NULL;
jintwrapLongjlonglongID=NULL;
jintwrapLongjlongArray_longlongID=NULL;
jintwrapLongjobjectArray__longlongID=NULL;
jdoubleunwrapDoublejintintID=NULL;
jdoubleArray_unwrapRowDoublejintintID=NULL;
jobjectArray__unwrapMatDoublejintintID=NULL;
jintunwrapIntjintintID=NULL;
jintArray_unwrapRowIntjintintID=NULL;
jobjectArray__unwrapMatIntjintintID=NULL;
jlongunwrapUIntjintintID=NULL;
jlongArray_unwrapRowUIntjintintID=NULL;
jobjectArray__unwrapMatUIntjintintID=NULL;
jbyteunwrapBytejintintID=NULL;
jbyteArray_unwrapRowBytejintintID=NULL;
jobjectArray__unwrapMatBytejintintID=NULL;
jshortunwrapUBytejintintID=NULL;
jshortArray_unwrapRowUBytejintintID=NULL;
jobjectArray__unwrapMatUBytejintintID=NULL;
jshortunwrapShortjintintID=NULL;
jshortArray_unwrapRowShortjintintID=NULL;
jobjectArray__unwrapMatShortjintintID=NULL;
jintunwrapUShortjintintID=NULL;
jintArray_unwrapRowUShortjintintID=NULL;
jobjectArray__unwrapMatUShortjintintID=NULL;
jstringunwrapStringjintintID=NULL;
jobjectArray_unwrapRowStringjintintID=NULL;
jobjectArray__unwrapMatStringjintintID=NULL;
jbooleanunwrapBooleanjintintID=NULL;
jbooleanArray_unwrapRowBooleanjintintID=NULL;
jobjectArray__unwrapMatBooleanjintintID=NULL;
jcharunwrapCharjintintID=NULL;
jcharArray_unwrapRowCharjintintID=NULL;
jobjectArray__unwrapMatCharjintintID=NULL;
jfloatunwrapFloatjintintID=NULL;
jfloatArray_unwrapRowFloatjintintID=NULL;
jobjectArray__unwrapMatFloatjintintID=NULL;
jlongunwrapLongjintintID=NULL;
jlongArray_unwrapRowLongjintintID=NULL;
jobjectArray__unwrapMatLongjintintID=NULL;


}

ScilabJavaObject::ScilabJavaObject(JavaVM * jvm_, jobject JObj) {
        jvm=jvm_;

        JNIEnv * curEnv = getCurrentEnv();

jclass localClass = curEnv->GetObjectClass(JObj);
        this->instanceClass = static_cast<jclass>(curEnv->NewGlobalRef(localClass));
        curEnv->DeleteLocalRef(localClass);

        if (this->instanceClass == NULL) {
throw GiwsException::JniObjectCreationException(curEnv, this->className());
        }

        this->instance = curEnv->NewGlobalRef(JObj) ;
        if(this->instance == NULL){
throw GiwsException::JniObjectCreationException(curEnv, this->className());
        }
        /* Methods ID set to NULL */
        jintinvokejintintjstringjava_lang_StringjintArray_intintID=NULL;
voidinitScilabJavaObjectID=NULL;
voidgarbageCollectID=NULL;
jstringgetRepresentationjintintID=NULL;
jbooleanisValidJavaObjectjintintID=NULL;
voidenableTracejstringjava_lang_StringID=NULL;
voiddisableTraceID=NULL;
voidsetFieldjintintjstringjava_lang_StringjintintID=NULL;
jintgetFieldjintintjstringjava_lang_StringID=NULL;
jintgetFieldTypejintintjstringjava_lang_StringID=NULL;
jintjavaCastjintintjstringjava_lang_StringID=NULL;
jintjavaCastjintintjintintID=NULL;
jstringgetClassNamejintintID=NULL;
jintgetArrayElementjintintjintArray_intintID=NULL;
voidsetArrayElementjintintjintArray_intintjintintID=NULL;
voidremoveScilabJavaObjectjintintID=NULL;
voidlimitDirectBufferjintintID=NULL;
jintisUnwrappablejintintID=NULL;
jintwrapDoublejdoubledoubleID=NULL;
jintwrapDoublejdoubleArray_doubledoubleID=NULL;
jintwrapDoublejobjectArray__doubledoubleID=NULL;
jintwrapIntjintintID=NULL;
jintwrapIntjintArray_intintID=NULL;
jintwrapIntjobjectArray__intintID=NULL;
jintwrapUIntjlonglongID=NULL;
jintwrapUIntjlongArray_longlongID=NULL;
jintwrapUIntjobjectArray__longlongID=NULL;
jintwrapBytejbytebyteID=NULL;
jintwrapBytejbyteArray_bytebyteID=NULL;
jintwrapBytejobjectArray__bytebyteID=NULL;
jintwrapUBytejshortshortID=NULL;
jintwrapUBytejshortArray_shortshortID=NULL;
jintwrapUBytejobjectArray__shortshortID=NULL;
jintwrapShortjshortshortID=NULL;
jintwrapShortjshortArray_shortshortID=NULL;
jintwrapShortjobjectArray__shortshortID=NULL;
jintwrapUShortjintintID=NULL;
jintwrapUShortjintArray_intintID=NULL;
jintwrapUShortjobjectArray__intintID=NULL;
jintwrapStringjstringjava_lang_StringID=NULL;
jintwrapStringjobjectArray_java_lang_Stringjava_lang_StringID=NULL;
jintwrapStringjobjectArray__java_lang_Stringjava_lang_StringID=NULL;
jintwrapBooleanjbooleanbooleanID=NULL;
jintwrapBooleanjbooleanArray_booleanbooleanID=NULL;
jintwrapBooleanjobjectArray__booleanbooleanID=NULL;
jintwrapCharjcharcharID=NULL;
jintwrapCharjcharArray_charcharID=NULL;
jintwrapCharjobjectArray__charcharID=NULL;
jintwrapFloatjfloatfloatID=NULL;
jintwrapFloatjfloatArray_floatfloatID=NULL;
jintwrapFloatjobjectArray__floatfloatID=NULL;
jintwrapLongjlonglongID=NULL;
jintwrapLongjlongArray_longlongID=NULL;
jintwrapLongjobjectArray__longlongID=NULL;
jdoubleunwrapDoublejintintID=NULL;
jdoubleArray_unwrapRowDoublejintintID=NULL;
jobjectArray__unwrapMatDoublejintintID=NULL;
jintunwrapIntjintintID=NULL;
jintArray_unwrapRowIntjintintID=NULL;
jobjectArray__unwrapMatIntjintintID=NULL;
jlongunwrapUIntjintintID=NULL;
jlongArray_unwrapRowUIntjintintID=NULL;
jobjectArray__unwrapMatUIntjintintID=NULL;
jbyteunwrapBytejintintID=NULL;
jbyteArray_unwrapRowBytejintintID=NULL;
jobjectArray__unwrapMatBytejintintID=NULL;
jshortunwrapUBytejintintID=NULL;
jshortArray_unwrapRowUBytejintintID=NULL;
jobjectArray__unwrapMatUBytejintintID=NULL;
jshortunwrapShortjintintID=NULL;
jshortArray_unwrapRowShortjintintID=NULL;
jobjectArray__unwrapMatShortjintintID=NULL;
jintunwrapUShortjintintID=NULL;
jintArray_unwrapRowUShortjintintID=NULL;
jobjectArray__unwrapMatUShortjintintID=NULL;
jstringunwrapStringjintintID=NULL;
jobjectArray_unwrapRowStringjintintID=NULL;
jobjectArray__unwrapMatStringjintintID=NULL;
jbooleanunwrapBooleanjintintID=NULL;
jbooleanArray_unwrapRowBooleanjintintID=NULL;
jobjectArray__unwrapMatBooleanjintintID=NULL;
jcharunwrapCharjintintID=NULL;
jcharArray_unwrapRowCharjintintID=NULL;
jobjectArray__unwrapMatCharjintintID=NULL;
jfloatunwrapFloatjintintID=NULL;
jfloatArray_unwrapRowFloatjintintID=NULL;
jobjectArray__unwrapMatFloatjintintID=NULL;
jlongunwrapLongjintintID=NULL;
jlongArray_unwrapRowLongjintintID=NULL;
jobjectArray__unwrapMatLongjintintID=NULL;


}

// Generic methods

void ScilabJavaObject::synchronize() {
if (getCurrentEnv()->MonitorEnter(instance) != JNI_OK) {
throw GiwsException::JniMonitorException(getCurrentEnv(), "ScilabJavaObject");
}
}

void ScilabJavaObject::endSynchronize() {
if ( getCurrentEnv()->MonitorExit(instance) != JNI_OK) {
throw GiwsException::JniMonitorException(getCurrentEnv(), "ScilabJavaObject");
}
}
// Method(s)

int ScilabJavaObject::invoke (JavaVM * jvm_, int id, char const* methodName, int const* args, int argsSize){

JNIEnv * curEnv = NULL;
jvm_->AttachCurrentThread(reinterpret_cast<void **>(&curEnv), NULL);
jclass cls = curEnv->FindClass( className().c_str() );
if ( cls == NULL) {
throw GiwsException::JniCallMethodException(curEnv);
}

jmethodID jintinvokejintintjstringjava_lang_StringjintArray_intintID = curEnv->GetStaticMethodID(cls, "invoke", "(ILjava/lang/String;[I)I" ) ;
if (jintinvokejintintjstringjava_lang_StringjintArray_intintID == NULL) {
throw GiwsException::JniMethodNotFoundException(curEnv, "invoke");
}

jstring methodName_ = curEnv->NewStringUTF( methodName );
if (methodName != NULL && methodName_ == NULL)
{
throw GiwsException::JniBadAllocException(curEnv);
}


jintArray args_ = curEnv->NewIntArray( argsSize ) ;

if (args_ == NULL)
{
// check that allocation succeed
throw GiwsException::JniBadAllocException(curEnv);
}

curEnv->SetIntArrayRegion( args_, 0, argsSize, (jint*)(args) ) ;


                        jint res =  static_cast<jint>( curEnv->CallStaticIntMethod(cls, jintinvokejintintjstringjava_lang_StringjintArray_intintID ,id, methodName_, args_));
                        curEnv->DeleteLocalRef(methodName_);
curEnv->DeleteLocalRef(args_);
curEnv->DeleteLocalRef(cls);
if (curEnv->ExceptionCheck()) {
throw GiwsException::JniCallMethodException(curEnv);
}
return res;

}

void ScilabJavaObject::initScilabJavaObject (JavaVM * jvm_){

JNIEnv * curEnv = NULL;
jvm_->AttachCurrentThread(reinterpret_cast<void **>(&curEnv), NULL);
jclass cls = curEnv->FindClass( className().c_str() );
if ( cls == NULL) {
throw GiwsException::JniCallMethodException(curEnv);
}

jmethodID voidinitScilabJavaObjectID = curEnv->GetStaticMethodID(cls, "initScilabJavaObject", "()V" ) ;
if (voidinitScilabJavaObjectID == NULL) {
throw GiwsException::JniMethodNotFoundException(curEnv, "initScilabJavaObject");
}

                         curEnv->CallStaticVoidMethod(cls, voidinitScilabJavaObjectID );
                        curEnv->DeleteLocalRef(cls);
if (curEnv->ExceptionCheck()) {
throw GiwsException::JniCallMethodException(curEnv);
}
}

void ScilabJavaObject::garbageCollect (JavaVM * jvm_){

JNIEnv * curEnv = NULL;
jvm_->AttachCurrentThread(reinterpret_cast<void **>(&curEnv), NULL);
jclass cls = curEnv->FindClass( className().c_str() );
if ( cls == NULL) {
throw GiwsException::JniCallMethodException(curEnv);
}

jmethodID voidgarbageCollectID = curEnv->GetStaticMethodID(cls, "garbageCollect", "()V" ) ;
if (voidgarbageCollectID == NULL) {
throw GiwsException::JniMethodNotFoundException(curEnv, "garbageCollect");
}

                         curEnv->CallStaticVoidMethod(cls, voidgarbageCollectID );
                        curEnv->DeleteLocalRef(cls);
if (curEnv->ExceptionCheck()) {
throw GiwsException::JniCallMethodException(curEnv);
}
}

char* ScilabJavaObject::getRepresentation (JavaVM * jvm_, int id){

JNIEnv * curEnv = NULL;
jvm_->AttachCurrentThread(reinterpret_cast<void **>(&curEnv), NULL);
jclass cls = curEnv->FindClass( className().c_str() );
if ( cls == NULL) {
throw GiwsException::JniCallMethodException(curEnv);
}

jmethodID jstringgetRepresentationjintintID = curEnv->GetStaticMethodID(cls, "getRepresentation", "(I)Ljava/lang/String;" ) ;
if (jstringgetRepresentationjintintID == NULL) {
throw GiwsException::JniMethodNotFoundException(curEnv, "getRepresentation");
}

                        jstring res =  static_cast<jstring>( curEnv->CallStaticObjectMethod(cls, jstringgetRepresentationjintintID ,id));
                        if (curEnv->ExceptionCheck()) {
throw GiwsException::JniCallMethodException(curEnv);
}if (res != NULL) { 

const char *tempString = curEnv->GetStringUTFChars(res, 0);
char * myStringBuffer = new char[strlen(tempString) + 1];
strcpy(myStringBuffer, tempString);
curEnv->ReleaseStringUTFChars(res, tempString);
curEnv->DeleteLocalRef(res);
curEnv->DeleteLocalRef(cls);
if (curEnv->ExceptionCheck()) {
delete[] myStringBuffer;
                                throw GiwsException::JniCallMethodException(curEnv);
}
return myStringBuffer;
 } else { 
curEnv->DeleteLocalRef(res);
return NULL;
}
}

bool ScilabJavaObject::isValidJavaObject (JavaVM * jvm_, int id){

JNIEnv * curEnv = NULL;
jvm_->AttachCurrentThread(reinterpret_cast<void **>(&curEnv), NULL);
jclass cls = curEnv->FindClass( className().c_str() );
if ( cls == NULL) {
throw GiwsException::JniCallMethodException(curEnv);
}

jmethodID jbooleanisValidJavaObjectjintintID = curEnv->GetStaticMethodID(cls, "isValidJavaObject", "(I)Z" ) ;
if (jbooleanisValidJavaObjectjintintID == NULL) {
throw GiwsException::JniMethodNotFoundException(curEnv, "isValidJavaObject");
}

                        jboolean res =  static_cast<jboolean>( curEnv->CallStaticBooleanMethod(cls, jbooleanisValidJavaObjectjintintID ,id));
                        curEnv->DeleteLocalRef(cls);
if (curEnv->ExceptionCheck()) {
throw GiwsException::JniCallMethodException(curEnv);
}
return (res == JNI_TRUE);

}

void ScilabJavaObject::enableTrace (JavaVM * jvm_, char const* filename){

JNIEnv * curEnv = NULL;
jvm_->AttachCurrentThread(reinterpret_cast<void **>(&curEnv), NULL);
jclass cls = curEnv->FindClass( className().c_str() );
if ( cls == NULL) {
throw GiwsException::JniCallMethodException(curEnv);
}

jmethodID voidenableTracejstringjava_lang_StringID = curEnv->GetStaticMethodID(cls, "enableTrace", "(Ljava/lang/String;)V" ) ;
if (voidenableTracejstringjava_lang_StringID == NULL) {
throw GiwsException::JniMethodNotFoundException(curEnv, "enableTrace");
}

jstring filename_ = curEnv->NewStringUTF( filename );
if (filename != NULL && filename_ == NULL)
{
throw GiwsException::JniBadAllocException(curEnv);
}


                         curEnv->CallStaticVoidMethod(cls, voidenableTracejstringjava_lang_StringID ,filename_);
                        curEnv->DeleteLocalRef(filename_);
curEnv->DeleteLocalRef(cls);
if (curEnv->ExceptionCheck()) {
throw GiwsException::JniCallMethodException(curEnv);
}
}

void ScilabJavaObject::disableTrace (JavaVM * jvm_){

JNIEnv * curEnv = NULL;
jvm_->AttachCurrentThread(reinterpret_cast<void **>(&curEnv), NULL);
jclass cls = curEnv->FindClass( className().c_str() );
if ( cls == NULL) {
throw GiwsException::JniCallMethodException(curEnv);
}

jmethodID voiddisableTraceID = curEnv->GetStaticMethodID(cls, "disableTrace", "()V" ) ;
if (voiddisableTraceID == NULL) {
throw GiwsException::JniMethodNotFoundException(curEnv, "disableTrace");
}

                         curEnv->CallStaticVoidMethod(cls, voiddisableTraceID );
                        curEnv->DeleteLocalRef(cls);
if (curEnv->ExceptionCheck()) {
throw GiwsException::JniCallMethodException(curEnv);
}
}

void ScilabJavaObject::setField (JavaVM * jvm_, int id, char const* fieldName, int idarg){

JNIEnv * curEnv = NULL;
jvm_->AttachCurrentThread(reinterpret_cast<void **>(&curEnv), NULL);
jclass cls = curEnv->FindClass( className().c_str() );
if ( cls == NULL) {
throw GiwsException::JniCallMethodException(curEnv);
}

jmethodID voidsetFieldjintintjstringjava_lang_StringjintintID = curEnv->GetStaticMethodID(cls, "setField", "(ILjava/lang/String;I)V" ) ;
if (voidsetFieldjintintjstringjava_lang_StringjintintID == NULL) {
throw GiwsException::JniMethodNotFoundException(curEnv, "setField");
}

jstring fieldName_ = curEnv->NewStringUTF( fieldName );
if (fieldName != NULL && fieldName_ == NULL)
{
throw GiwsException::JniBadAllocException(curEnv);
}


                         curEnv->CallStaticVoidMethod(cls, voidsetFieldjintintjstringjava_lang_StringjintintID ,id, fieldName_, idarg);
                        curEnv->DeleteLocalRef(fieldName_);
curEnv->DeleteLocalRef(cls);
if (curEnv->ExceptionCheck()) {
throw GiwsException::JniCallMethodException(curEnv);
}
}

int ScilabJavaObject::getField (JavaVM * jvm_, int id, char const* fieldName){

JNIEnv * curEnv = NULL;
jvm_->AttachCurrentThread(reinterpret_cast<void **>(&curEnv), NULL);
jclass cls = curEnv->FindClass( className().c_str() );
if ( cls == NULL) {
throw GiwsException::JniCallMethodException(curEnv);
}

jmethodID jintgetFieldjintintjstringjava_lang_StringID = curEnv->GetStaticMethodID(cls, "getField", "(ILjava/lang/String;)I" ) ;
if (jintgetFieldjintintjstringjava_lang_StringID == NULL) {
throw GiwsException::JniMethodNotFoundException(curEnv, "getField");
}

jstring fieldName_ = curEnv->NewStringUTF( fieldName );
if (fieldName != NULL && fieldName_ == NULL)
{
throw GiwsException::JniBadAllocException(curEnv);
}


                        jint res =  static_cast<jint>( curEnv->CallStaticIntMethod(cls, jintgetFieldjintintjstringjava_lang_StringID ,id, fieldName_));
                        curEnv->DeleteLocalRef(fieldName_);
curEnv->DeleteLocalRef(cls);
if (curEnv->ExceptionCheck()) {
throw GiwsException::JniCallMethodException(curEnv);
}
return res;

}

int ScilabJavaObject::getFieldType (JavaVM * jvm_, int id, char const* fieldName){

JNIEnv * curEnv = NULL;
jvm_->AttachCurrentThread(reinterpret_cast<void **>(&curEnv), NULL);
jclass cls = curEnv->FindClass( className().c_str() );
if ( cls == NULL) {
throw GiwsException::JniCallMethodException(curEnv);
}

jmethodID jintgetFieldTypejintintjstringjava_lang_StringID = curEnv->GetStaticMethodID(cls, "getFieldType", "(ILjava/lang/String;)I" ) ;
if (jintgetFieldTypejintintjstringjava_lang_StringID == NULL) {
throw GiwsException::JniMethodNotFoundException(curEnv, "getFieldType");
}

jstring fieldName_ = curEnv->NewStringUTF( fieldName );
if (fieldName != NULL && fieldName_ == NULL)
{
throw GiwsException::JniBadAllocException(curEnv);
}


                        jint res =  static_cast<jint>( curEnv->CallStaticIntMethod(cls, jintgetFieldTypejintintjstringjava_lang_StringID ,id, fieldName_));
                        curEnv->DeleteLocalRef(fieldName_);
curEnv->DeleteLocalRef(cls);
if (curEnv->ExceptionCheck()) {
throw GiwsException::JniCallMethodException(curEnv);
}
return res;

}

int ScilabJavaObject::javaCast (JavaVM * jvm_, int id, char const* objName){

JNIEnv * curEnv = NULL;
jvm_->AttachCurrentThread(reinterpret_cast<void **>(&curEnv), NULL);
jclass cls = curEnv->FindClass( className().c_str() );
if ( cls == NULL) {
throw GiwsException::JniCallMethodException(curEnv);
}

jmethodID jintjavaCastjintintjstringjava_lang_StringID = curEnv->GetStaticMethodID(cls, "javaCast", "(ILjava/lang/String;)I" ) ;
if (jintjavaCastjintintjstringjava_lang_StringID == NULL) {
throw GiwsException::JniMethodNotFoundException(curEnv, "javaCast");
}

jstring objName_ = curEnv->NewStringUTF( objName );
if (objName != NULL && objName_ == NULL)
{
throw GiwsException::JniBadAllocException(curEnv);
}


                        jint res =  static_cast<jint>( curEnv->CallStaticIntMethod(cls, jintjavaCastjintintjstringjava_lang_StringID ,id, objName_));
                        curEnv->DeleteLocalRef(objName_);
curEnv->DeleteLocalRef(cls);
if (curEnv->ExceptionCheck()) {
throw GiwsException::JniCallMethodException(curEnv);
}
return res;

}

int ScilabJavaObject::javaCast (JavaVM * jvm_, int id, int classId){

JNIEnv * curEnv = NULL;
jvm_->AttachCurrentThread(reinterpret_cast<void **>(&curEnv), NULL);
jclass cls = curEnv->FindClass( className().c_str() );
if ( cls == NULL) {
throw GiwsException::JniCallMethodException(curEnv);
}

jmethodID jintjavaCastjintintjintintID = curEnv->GetStaticMethodID(cls, "javaCast", "(II)I" ) ;
if (jintjavaCastjintintjintintID == NULL) {
throw GiwsException::JniMethodNotFoundException(curEnv, "javaCast");
}

                        jint res =  static_cast<jint>( curEnv->CallStaticIntMethod(cls, jintjavaCastjintintjintintID ,id, classId));
                        curEnv->DeleteLocalRef(cls);
if (curEnv->ExceptionCheck()) {
throw GiwsException::JniCallMethodException(curEnv);
}
return res;

}

char* ScilabJavaObject::getClassName (JavaVM * jvm_, int id){

JNIEnv * curEnv = NULL;
jvm_->AttachCurrentThread(reinterpret_cast<void **>(&curEnv), NULL);
jclass cls = curEnv->FindClass( className().c_str() );
if ( cls == NULL) {
throw GiwsException::JniCallMethodException(curEnv);
}

jmethodID jstringgetClassNamejintintID = curEnv->GetStaticMethodID(cls, "getClassName", "(I)Ljava/lang/String;" ) ;
if (jstringgetClassNamejintintID == NULL) {
throw GiwsException::JniMethodNotFoundException(curEnv, "getClassName");
}

                        jstring res =  static_cast<jstring>( curEnv->CallStaticObjectMethod(cls, jstringgetClassNamejintintID ,id));
                        if (curEnv->ExceptionCheck()) {
throw GiwsException::JniCallMethodException(curEnv);
}if (res != NULL) { 

const char *tempString = curEnv->GetStringUTFChars(res, 0);
char * myStringBuffer = new char[strlen(tempString) + 1];
strcpy(myStringBuffer, tempString);
curEnv->ReleaseStringUTFChars(res, tempString);
curEnv->DeleteLocalRef(res);
curEnv->DeleteLocalRef(cls);
if (curEnv->ExceptionCheck()) {
delete[] myStringBuffer;
                                throw GiwsException::JniCallMethodException(curEnv);
}
return myStringBuffer;
 } else { 
curEnv->DeleteLocalRef(res);
return NULL;
}
}

int ScilabJavaObject::getArrayElement (JavaVM * jvm_, int id, int const* index, int indexSize){

JNIEnv * curEnv = NULL;
jvm_->AttachCurrentThread(reinterpret_cast<void **>(&curEnv), NULL);
jclass cls = curEnv->FindClass( className().c_str() );
if ( cls == NULL) {
throw GiwsException::JniCallMethodException(curEnv);
}

jmethodID jintgetArrayElementjintintjintArray_intintID = curEnv->GetStaticMethodID(cls, "getArrayElement", "(I[I)I" ) ;
if (jintgetArrayElementjintintjintArray_intintID == NULL) {
throw GiwsException::JniMethodNotFoundException(curEnv, "getArrayElement");
}

jintArray index_ = curEnv->NewIntArray( indexSize ) ;

if (index_ == NULL)
{
// check that allocation succeed
throw GiwsException::JniBadAllocException(curEnv);
}

curEnv->SetIntArrayRegion( index_, 0, indexSize, (jint*)(index) ) ;


                        jint res =  static_cast<jint>( curEnv->CallStaticIntMethod(cls, jintgetArrayElementjintintjintArray_intintID ,id, index_));
                        curEnv->DeleteLocalRef(index_);
curEnv->DeleteLocalRef(cls);
if (curEnv->ExceptionCheck()) {
throw GiwsException::JniCallMethodException(curEnv);
}
return res;

}

void ScilabJavaObject::setArrayElement (JavaVM * jvm_, int id, int const* index, int indexSize, int idArg){

JNIEnv * curEnv = NULL;
jvm_->AttachCurrentThread(reinterpret_cast<void **>(&curEnv), NULL);
jclass cls = curEnv->FindClass( className().c_str() );
if ( cls == NULL) {
throw GiwsException::JniCallMethodException(curEnv);
}

jmethodID voidsetArrayElementjintintjintArray_intintjintintID = curEnv->GetStaticMethodID(cls, "setArrayElement", "(I[II)V" ) ;
if (voidsetArrayElementjintintjintArray_intintjintintID == NULL) {
throw GiwsException::JniMethodNotFoundException(curEnv, "setArrayElement");
}

jintArray index_ = curEnv->NewIntArray( indexSize ) ;

if (index_ == NULL)
{
// check that allocation succeed
throw GiwsException::JniBadAllocException(curEnv);
}

curEnv->SetIntArrayRegion( index_, 0, indexSize, (jint*)(index) ) ;


                         curEnv->CallStaticVoidMethod(cls, voidsetArrayElementjintintjintArray_intintjintintID ,id, index_, idArg);
                        curEnv->DeleteLocalRef(index_);
curEnv->DeleteLocalRef(cls);
if (curEnv->ExceptionCheck()) {
throw GiwsException::JniCallMethodException(curEnv);
}
}

void ScilabJavaObject::removeScilabJavaObject (JavaVM * jvm_, int id){

JNIEnv * curEnv = NULL;
jvm_->AttachCurrentThread(reinterpret_cast<void **>(&curEnv), NULL);
jclass cls = curEnv->FindClass( className().c_str() );
if ( cls == NULL) {
throw GiwsException::JniCallMethodException(curEnv);
}

jmethodID voidremoveScilabJavaObjectjintintID = curEnv->GetStaticMethodID(cls, "removeScilabJavaObject", "(I)V" ) ;
if (voidremoveScilabJavaObjectjintintID == NULL) {
throw GiwsException::JniMethodNotFoundException(curEnv, "removeScilabJavaObject");
}

                         curEnv->CallStaticVoidMethod(cls, voidremoveScilabJavaObjectjintintID ,id);
                        curEnv->DeleteLocalRef(cls);
if (curEnv->ExceptionCheck()) {
throw GiwsException::JniCallMethodException(curEnv);
}
}

void ScilabJavaObject::limitDirectBuffer (JavaVM * jvm_, int id){

JNIEnv * curEnv = NULL;
jvm_->AttachCurrentThread(reinterpret_cast<void **>(&curEnv), NULL);
jclass cls = curEnv->FindClass( className().c_str() );
if ( cls == NULL) {
throw GiwsException::JniCallMethodException(curEnv);
}

jmethodID voidlimitDirectBufferjintintID = curEnv->GetStaticMethodID(cls, "limitDirectBuffer", "(I)V" ) ;
if (voidlimitDirectBufferjintintID == NULL) {
throw GiwsException::JniMethodNotFoundException(curEnv, "limitDirectBuffer");
}

                         curEnv->CallStaticVoidMethod(cls, voidlimitDirectBufferjintintID ,id);
                        curEnv->DeleteLocalRef(cls);
if (curEnv->ExceptionCheck()) {
throw GiwsException::JniCallMethodException(curEnv);
}
}

int ScilabJavaObject::isUnwrappable (JavaVM * jvm_, int id){

JNIEnv * curEnv = NULL;
jvm_->AttachCurrentThread(reinterpret_cast<void **>(&curEnv), NULL);
jclass cls = curEnv->FindClass( className().c_str() );
if ( cls == NULL) {
throw GiwsException::JniCallMethodException(curEnv);
}

jmethodID jintisUnwrappablejintintID = curEnv->GetStaticMethodID(cls, "isUnwrappable", "(I)I" ) ;
if (jintisUnwrappablejintintID == NULL) {
throw GiwsException::JniMethodNotFoundException(curEnv, "isUnwrappable");
}

                        jint res =  static_cast<jint>( curEnv->CallStaticIntMethod(cls, jintisUnwrappablejintintID ,id));
                        curEnv->DeleteLocalRef(cls);
if (curEnv->ExceptionCheck()) {
throw GiwsException::JniCallMethodException(curEnv);
}
return res;

}

int ScilabJavaObject::wrapDouble (JavaVM * jvm_, double x){

JNIEnv * curEnv = NULL;
jvm_->AttachCurrentThread(reinterpret_cast<void **>(&curEnv), NULL);
jclass cls = curEnv->FindClass( className().c_str() );
if ( cls == NULL) {
throw GiwsException::JniCallMethodException(curEnv);
}

jmethodID jintwrapDoublejdoubledoubleID = curEnv->GetStaticMethodID(cls, "wrapDouble", "(D)I" ) ;
if (jintwrapDoublejdoubledoubleID == NULL) {
throw GiwsException::JniMethodNotFoundException(curEnv, "wrapDouble");
}

                        jint res =  static_cast<jint>( curEnv->CallStaticIntMethod(cls, jintwrapDoublejdoubledoubleID ,x));
                        curEnv->DeleteLocalRef(cls);
if (curEnv->ExceptionCheck()) {
throw GiwsException::JniCallMethodException(curEnv);
}
return res;

}

int ScilabJavaObject::wrapDouble (JavaVM * jvm_, double const* x, int xSize){

JNIEnv * curEnv = NULL;
jvm_->AttachCurrentThread(reinterpret_cast<void **>(&curEnv), NULL);
jclass cls = curEnv->FindClass( className().c_str() );
if ( cls == NULL) {
throw GiwsException::JniCallMethodException(curEnv);
}

jmethodID jintwrapDoublejdoubleArray_doubledoubleID = curEnv->GetStaticMethodID(cls, "wrapDouble", "([D)I" ) ;
if (jintwrapDoublejdoubleArray_doubledoubleID == NULL) {
throw GiwsException::JniMethodNotFoundException(curEnv, "wrapDouble");
}

jdoubleArray x_ = curEnv->NewDoubleArray( xSize ) ;

if (x_ == NULL)
{
// check that allocation succeed
throw GiwsException::JniBadAllocException(curEnv);
}

curEnv->SetDoubleArrayRegion( x_, 0, xSize, (jdouble*)(x) ) ;


                        jint res =  static_cast<jint>( curEnv->CallStaticIntMethod(cls, jintwrapDoublejdoubleArray_doubledoubleID ,x_));
                        curEnv->DeleteLocalRef(x_);
curEnv->DeleteLocalRef(cls);
if (curEnv->ExceptionCheck()) {
throw GiwsException::JniCallMethodException(curEnv);
}
return res;

}

int ScilabJavaObject::wrapDouble (JavaVM * jvm_, double const* const* x, int xSize, int xSizeCol){

JNIEnv * curEnv = NULL;
jvm_->AttachCurrentThread(reinterpret_cast<void **>(&curEnv), NULL);
jclass cls = curEnv->FindClass( className().c_str() );
if ( cls == NULL) {
throw GiwsException::JniCallMethodException(curEnv);
}

jmethodID jintwrapDoublejobjectArray__doubledoubleID = curEnv->GetStaticMethodID(cls, "wrapDouble", "([[D)I" ) ;
if (jintwrapDoublejobjectArray__doubledoubleID == NULL) {
throw GiwsException::JniMethodNotFoundException(curEnv, "wrapDouble");
}

 jobjectArray x_ = curEnv->NewObjectArray(xSize, curEnv->FindClass("[D"),NULL);

if (x_ == NULL)
{
// check that allocation succeed
throw GiwsException::JniBadAllocException(curEnv);
}

 for (int i=0; i<xSize; i++){

jdoubleArray xLocal = curEnv->NewDoubleArray( xSizeCol ) ;

if (xLocal == NULL)
{
// check that allocation succeed
curEnv->DeleteLocalRef(x_);
throw GiwsException::JniBadAllocException(curEnv);
}

curEnv->SetDoubleArrayRegion( xLocal, 0, xSizeCol, (jdouble*)(x[i]) ) ;
curEnv->SetObjectArrayElement(x_, i, xLocal);
curEnv->DeleteLocalRef(xLocal);
}

                        jint res =  static_cast<jint>( curEnv->CallStaticIntMethod(cls, jintwrapDoublejobjectArray__doubledoubleID ,x_));
                        curEnv->DeleteLocalRef(x_);
curEnv->DeleteLocalRef(cls);
if (curEnv->ExceptionCheck()) {
throw GiwsException::JniCallMethodException(curEnv);
}
return res;

}

int ScilabJavaObject::wrapInt (JavaVM * jvm_, int x){

JNIEnv * curEnv = NULL;
jvm_->AttachCurrentThread(reinterpret_cast<void **>(&curEnv), NULL);
jclass cls = curEnv->FindClass( className().c_str() );
if ( cls == NULL) {
throw GiwsException::JniCallMethodException(curEnv);
}

jmethodID jintwrapIntjintintID = curEnv->GetStaticMethodID(cls, "wrapInt", "(I)I" ) ;
if (jintwrapIntjintintID == NULL) {
throw GiwsException::JniMethodNotFoundException(curEnv, "wrapInt");
}

                        jint res =  static_cast<jint>( curEnv->CallStaticIntMethod(cls, jintwrapIntjintintID ,x));
                        curEnv->DeleteLocalRef(cls);
if (curEnv->ExceptionCheck()) {
throw GiwsException::JniCallMethodException(curEnv);
}
return res;

}

int ScilabJavaObject::wrapInt (JavaVM * jvm_, int const* x, int xSize){

JNIEnv * curEnv = NULL;
jvm_->AttachCurrentThread(reinterpret_cast<void **>(&curEnv), NULL);
jclass cls = curEnv->FindClass( className().c_str() );
if ( cls == NULL) {
throw GiwsException::JniCallMethodException(curEnv);
}

jmethodID jintwrapIntjintArray_intintID = curEnv->GetStaticMethodID(cls, "wrapInt", "([I)I" ) ;
if (jintwrapIntjintArray_intintID == NULL) {
throw GiwsException::JniMethodNotFoundException(curEnv, "wrapInt");
}

jintArray x_ = curEnv->NewIntArray( xSize ) ;

if (x_ == NULL)
{
// check that allocation succeed
throw GiwsException::JniBadAllocException(curEnv);
}

curEnv->SetIntArrayRegion( x_, 0, xSize, (jint*)(x) ) ;


                        jint res =  static_cast<jint>( curEnv->CallStaticIntMethod(cls, jintwrapIntjintArray_intintID ,x_));
                        curEnv->DeleteLocalRef(x_);
curEnv->DeleteLocalRef(cls);
if (curEnv->ExceptionCheck()) {
throw GiwsException::JniCallMethodException(curEnv);
}
return res;

}

int ScilabJavaObject::wrapInt (JavaVM * jvm_, int const* const* x, int xSize, int xSizeCol){

JNIEnv * curEnv = NULL;
jvm_->AttachCurrentThread(reinterpret_cast<void **>(&curEnv), NULL);
jclass cls = curEnv->FindClass( className().c_str() );
if ( cls == NULL) {
throw GiwsException::JniCallMethodException(curEnv);
}

jmethodID jintwrapIntjobjectArray__intintID = curEnv->GetStaticMethodID(cls, "wrapInt", "([[I)I" ) ;
if (jintwrapIntjobjectArray__intintID == NULL) {
throw GiwsException::JniMethodNotFoundException(curEnv, "wrapInt");
}

 jobjectArray x_ = curEnv->NewObjectArray(xSize, curEnv->FindClass("[I"),NULL);

if (x_ == NULL)
{
// check that allocation succeed
throw GiwsException::JniBadAllocException(curEnv);
}

 for (int i=0; i<xSize; i++){

jintArray xLocal = curEnv->NewIntArray( xSizeCol ) ;

if (xLocal == NULL)
{
// check that allocation succeed
curEnv->DeleteLocalRef(x_);
throw GiwsException::JniBadAllocException(curEnv);
}

curEnv->SetIntArrayRegion( xLocal, 0, xSizeCol, (jint*)(x[i]) ) ;
curEnv->SetObjectArrayElement(x_, i, xLocal);
curEnv->DeleteLocalRef(xLocal);
}

                        jint res =  static_cast<jint>( curEnv->CallStaticIntMethod(cls, jintwrapIntjobjectArray__intintID ,x_));
                        curEnv->DeleteLocalRef(x_);
curEnv->DeleteLocalRef(cls);
if (curEnv->ExceptionCheck()) {
throw GiwsException::JniCallMethodException(curEnv);
}
return res;

}

int ScilabJavaObject::wrapUInt (JavaVM * jvm_, long long x){

JNIEnv * curEnv = NULL;
jvm_->AttachCurrentThread(reinterpret_cast<void **>(&curEnv), NULL);
jclass cls = curEnv->FindClass( className().c_str() );
if ( cls == NULL) {
throw GiwsException::JniCallMethodException(curEnv);
}

jmethodID jintwrapUIntjlonglongID = curEnv->GetStaticMethodID(cls, "wrapUInt", "(J)I" ) ;
if (jintwrapUIntjlonglongID == NULL) {
throw GiwsException::JniMethodNotFoundException(curEnv, "wrapUInt");
}

                        jint res =  static_cast<jint>( curEnv->CallStaticIntMethod(cls, jintwrapUIntjlonglongID ,x));
                        curEnv->DeleteLocalRef(cls);
if (curEnv->ExceptionCheck()) {
throw GiwsException::JniCallMethodException(curEnv);
}
return res;

}

int ScilabJavaObject::wrapUInt (JavaVM * jvm_, long long const* x, int xSize){

JNIEnv * curEnv = NULL;
jvm_->AttachCurrentThread(reinterpret_cast<void **>(&curEnv), NULL);
jclass cls = curEnv->FindClass( className().c_str() );
if ( cls == NULL) {
throw GiwsException::JniCallMethodException(curEnv);
}

jmethodID jintwrapUIntjlongArray_longlongID = curEnv->GetStaticMethodID(cls, "wrapUInt", "([J)I" ) ;
if (jintwrapUIntjlongArray_longlongID == NULL) {
throw GiwsException::JniMethodNotFoundException(curEnv, "wrapUInt");
}

jlongArray x_ = curEnv->NewLongArray( xSize ) ;

if (x_ == NULL)
{
// check that allocation succeed
throw GiwsException::JniBadAllocException(curEnv);
}

curEnv->SetLongArrayRegion( x_, 0, xSize, (jlong*)(x) ) ;


                        jint res =  static_cast<jint>( curEnv->CallStaticIntMethod(cls, jintwrapUIntjlongArray_longlongID ,x_));
                        curEnv->DeleteLocalRef(x_);
curEnv->DeleteLocalRef(cls);
if (curEnv->ExceptionCheck()) {
throw GiwsException::JniCallMethodException(curEnv);
}
return res;

}

int ScilabJavaObject::wrapUInt (JavaVM * jvm_, long long const* const* x, int xSize, int xSizeCol){

JNIEnv * curEnv = NULL;
jvm_->AttachCurrentThread(reinterpret_cast<void **>(&curEnv), NULL);
jclass cls = curEnv->FindClass( className().c_str() );
if ( cls == NULL) {
throw GiwsException::JniCallMethodException(curEnv);
}

jmethodID jintwrapUIntjobjectArray__longlongID = curEnv->GetStaticMethodID(cls, "wrapUInt", "([[J)I" ) ;
if (jintwrapUIntjobjectArray__longlongID == NULL) {
throw GiwsException::JniMethodNotFoundException(curEnv, "wrapUInt");
}

 jobjectArray x_ = curEnv->NewObjectArray(xSize, curEnv->FindClass("[J"),NULL);

if (x_ == NULL)
{
// check that allocation succeed
throw GiwsException::JniBadAllocException(curEnv);
}

 for (int i=0; i<xSize; i++){

jlongArray xLocal = curEnv->NewLongArray( xSizeCol ) ;

if (xLocal == NULL)
{
// check that allocation succeed
curEnv->DeleteLocalRef(x_);
throw GiwsException::JniBadAllocException(curEnv);
}

curEnv->SetLongArrayRegion( xLocal, 0, xSizeCol, (jlong*)(x[i]) ) ;
curEnv->SetObjectArrayElement(x_, i, xLocal);
curEnv->DeleteLocalRef(xLocal);
}

                        jint res =  static_cast<jint>( curEnv->CallStaticIntMethod(cls, jintwrapUIntjobjectArray__longlongID ,x_));
                        curEnv->DeleteLocalRef(x_);
curEnv->DeleteLocalRef(cls);
if (curEnv->ExceptionCheck()) {
throw GiwsException::JniCallMethodException(curEnv);
}
return res;

}

int ScilabJavaObject::wrapByte (JavaVM * jvm_, byte x){

JNIEnv * curEnv = NULL;
jvm_->AttachCurrentThread(reinterpret_cast<void **>(&curEnv), NULL);
jclass cls = curEnv->FindClass( className().c_str() );
if ( cls == NULL) {
throw GiwsException::JniCallMethodException(curEnv);
}

jmethodID jintwrapBytejbytebyteID = curEnv->GetStaticMethodID(cls, "wrapByte", "(B)I" ) ;
if (jintwrapBytejbytebyteID == NULL) {
throw GiwsException::JniMethodNotFoundException(curEnv, "wrapByte");
}

                        jint res =  static_cast<jint>( curEnv->CallStaticIntMethod(cls, jintwrapBytejbytebyteID ,x));
                        curEnv->DeleteLocalRef(cls);
if (curEnv->ExceptionCheck()) {
throw GiwsException::JniCallMethodException(curEnv);
}
return res;

}

int ScilabJavaObject::wrapByte (JavaVM * jvm_, byte const* x, int xSize){

JNIEnv * curEnv = NULL;
jvm_->AttachCurrentThread(reinterpret_cast<void **>(&curEnv), NULL);
jclass cls = curEnv->FindClass( className().c_str() );
if ( cls == NULL) {
throw GiwsException::JniCallMethodException(curEnv);
}

jmethodID jintwrapBytejbyteArray_bytebyteID = curEnv->GetStaticMethodID(cls, "wrapByte", "([B)I" ) ;
if (jintwrapBytejbyteArray_bytebyteID == NULL) {
throw GiwsException::JniMethodNotFoundException(curEnv, "wrapByte");
}

jbyteArray x_ = curEnv->NewByteArray( xSize ) ;

if (x_ == NULL)
{
// check that allocation succeed
throw GiwsException::JniBadAllocException(curEnv);
}

curEnv->SetByteArrayRegion( x_, 0, xSize, (jbyte*)(x) ) ;


                        jint res =  static_cast<jint>( curEnv->CallStaticIntMethod(cls, jintwrapBytejbyteArray_bytebyteID ,x_));
                        curEnv->DeleteLocalRef(x_);
curEnv->DeleteLocalRef(cls);
if (curEnv->ExceptionCheck()) {
throw GiwsException::JniCallMethodException(curEnv);
}
return res;

}

int ScilabJavaObject::wrapByte (JavaVM * jvm_, byte const* const* x, int xSize, int xSizeCol){

JNIEnv * curEnv = NULL;
jvm_->AttachCurrentThread(reinterpret_cast<void **>(&curEnv), NULL);
jclass cls = curEnv->FindClass( className().c_str() );
if ( cls == NULL) {
throw GiwsException::JniCallMethodException(curEnv);
}

jmethodID jintwrapBytejobjectArray__bytebyteID = curEnv->GetStaticMethodID(cls, "wrapByte", "([[B)I" ) ;
if (jintwrapBytejobjectArray__bytebyteID == NULL) {
throw GiwsException::JniMethodNotFoundException(curEnv, "wrapByte");
}

 jobjectArray x_ = curEnv->NewObjectArray(xSize, curEnv->FindClass("[B"),NULL);

if (x_ == NULL)
{
// check that allocation succeed
throw GiwsException::JniBadAllocException(curEnv);
}

 for (int i=0; i<xSize; i++){

jbyteArray xLocal = curEnv->NewByteArray( xSizeCol ) ;

if (xLocal == NULL)
{
// check that allocation succeed
curEnv->DeleteLocalRef(x_);
throw GiwsException::JniBadAllocException(curEnv);
}

curEnv->SetByteArrayRegion( xLocal, 0, xSizeCol, (jbyte*)(x[i]) ) ;
curEnv->SetObjectArrayElement(x_, i, xLocal);
curEnv->DeleteLocalRef(xLocal);
}

                        jint res =  static_cast<jint>( curEnv->CallStaticIntMethod(cls, jintwrapBytejobjectArray__bytebyteID ,x_));
                        curEnv->DeleteLocalRef(x_);
curEnv->DeleteLocalRef(cls);
if (curEnv->ExceptionCheck()) {
throw GiwsException::JniCallMethodException(curEnv);
}
return res;

}

int ScilabJavaObject::wrapUByte (JavaVM * jvm_, short x){

JNIEnv * curEnv = NULL;
jvm_->AttachCurrentThread(reinterpret_cast<void **>(&curEnv), NULL);
jclass cls = curEnv->FindClass( className().c_str() );
if ( cls == NULL) {
throw GiwsException::JniCallMethodException(curEnv);
}

jmethodID jintwrapUBytejshortshortID = curEnv->GetStaticMethodID(cls, "wrapUByte", "(S)I" ) ;
if (jintwrapUBytejshortshortID == NULL) {
throw GiwsException::JniMethodNotFoundException(curEnv, "wrapUByte");
}

                        jint res =  static_cast<jint>( curEnv->CallStaticIntMethod(cls, jintwrapUBytejshortshortID ,x));
                        curEnv->DeleteLocalRef(cls);
if (curEnv->ExceptionCheck()) {
throw GiwsException::JniCallMethodException(curEnv);
}
return res;

}

int ScilabJavaObject::wrapUByte (JavaVM * jvm_, short const* x, int xSize){

JNIEnv * curEnv = NULL;
jvm_->AttachCurrentThread(reinterpret_cast<void **>(&curEnv), NULL);
jclass cls = curEnv->FindClass( className().c_str() );
if ( cls == NULL) {
throw GiwsException::JniCallMethodException(curEnv);
}

jmethodID jintwrapUBytejshortArray_shortshortID = curEnv->GetStaticMethodID(cls, "wrapUByte", "([S)I" ) ;
if (jintwrapUBytejshortArray_shortshortID == NULL) {
throw GiwsException::JniMethodNotFoundException(curEnv, "wrapUByte");
}

jshortArray x_ = curEnv->NewShortArray( xSize ) ;

if (x_ == NULL)
{
// check that allocation succeed
throw GiwsException::JniBadAllocException(curEnv);
}

curEnv->SetShortArrayRegion( x_, 0, xSize, (jshort*)(x) ) ;


                        jint res =  static_cast<jint>( curEnv->CallStaticIntMethod(cls, jintwrapUBytejshortArray_shortshortID ,x_));
                        curEnv->DeleteLocalRef(x_);
curEnv->DeleteLocalRef(cls);
if (curEnv->ExceptionCheck()) {
throw GiwsException::JniCallMethodException(curEnv);
}
return res;

}

int ScilabJavaObject::wrapUByte (JavaVM * jvm_, short const* const* x, int xSize, int xSizeCol){

JNIEnv * curEnv = NULL;
jvm_->AttachCurrentThread(reinterpret_cast<void **>(&curEnv), NULL);
jclass cls = curEnv->FindClass( className().c_str() );
if ( cls == NULL) {
throw GiwsException::JniCallMethodException(curEnv);
}

jmethodID jintwrapUBytejobjectArray__shortshortID = curEnv->GetStaticMethodID(cls, "wrapUByte", "([[S)I" ) ;
if (jintwrapUBytejobjectArray__shortshortID == NULL) {
throw GiwsException::JniMethodNotFoundException(curEnv, "wrapUByte");
}

 jobjectArray x_ = curEnv->NewObjectArray(xSize, curEnv->FindClass("[S"),NULL);

if (x_ == NULL)
{
// check that allocation succeed
throw GiwsException::JniBadAllocException(curEnv);
}

 for (int i=0; i<xSize; i++){

jshortArray xLocal = curEnv->NewShortArray( xSizeCol ) ;

if (xLocal == NULL)
{
// check that allocation succeed
curEnv->DeleteLocalRef(x_);
throw GiwsException::JniBadAllocException(curEnv);
}

curEnv->SetShortArrayRegion( xLocal, 0, xSizeCol, (jshort*)(x[i]) ) ;
curEnv->SetObjectArrayElement(x_, i, xLocal);
curEnv->DeleteLocalRef(xLocal);
}

                        jint res =  static_cast<jint>( curEnv->CallStaticIntMethod(cls, jintwrapUBytejobjectArray__shortshortID ,x_));
                        curEnv->DeleteLocalRef(x_);
curEnv->DeleteLocalRef(cls);
if (curEnv->ExceptionCheck()) {
throw GiwsException::JniCallMethodException(curEnv);
}
return res;

}

int ScilabJavaObject::wrapShort (JavaVM * jvm_, short x){

JNIEnv * curEnv = NULL;
jvm_->AttachCurrentThread(reinterpret_cast<void **>(&curEnv), NULL);
jclass cls = curEnv->FindClass( className().c_str() );
if ( cls == NULL) {
throw GiwsException::JniCallMethodException(curEnv);
}

jmethodID jintwrapShortjshortshortID = curEnv->GetStaticMethodID(cls, "wrapShort", "(S)I" ) ;
if (jintwrapShortjshortshortID == NULL) {
throw GiwsException::JniMethodNotFoundException(curEnv, "wrapShort");
}

                        jint res =  static_cast<jint>( curEnv->CallStaticIntMethod(cls, jintwrapShortjshortshortID ,x));
                        curEnv->DeleteLocalRef(cls);
if (curEnv->ExceptionCheck()) {
throw GiwsException::JniCallMethodException(curEnv);
}
return res;

}

int ScilabJavaObject::wrapShort (JavaVM * jvm_, short const* x, int xSize){

JNIEnv * curEnv = NULL;
jvm_->AttachCurrentThread(reinterpret_cast<void **>(&curEnv), NULL);
jclass cls = curEnv->FindClass( className().c_str() );
if ( cls == NULL) {
throw GiwsException::JniCallMethodException(curEnv);
}

jmethodID jintwrapShortjshortArray_shortshortID = curEnv->GetStaticMethodID(cls, "wrapShort", "([S)I" ) ;
if (jintwrapShortjshortArray_shortshortID == NULL) {
throw GiwsException::JniMethodNotFoundException(curEnv, "wrapShort");
}

jshortArray x_ = curEnv->NewShortArray( xSize ) ;

if (x_ == NULL)
{
// check that allocation succeed
throw GiwsException::JniBadAllocException(curEnv);
}

curEnv->SetShortArrayRegion( x_, 0, xSize, (jshort*)(x) ) ;


                        jint res =  static_cast<jint>( curEnv->CallStaticIntMethod(cls, jintwrapShortjshortArray_shortshortID ,x_));
                        curEnv->DeleteLocalRef(x_);
curEnv->DeleteLocalRef(cls);
if (curEnv->ExceptionCheck()) {
throw GiwsException::JniCallMethodException(curEnv);
}
return res;

}

int ScilabJavaObject::wrapShort (JavaVM * jvm_, short const* const* x, int xSize, int xSizeCol){

JNIEnv * curEnv = NULL;
jvm_->AttachCurrentThread(reinterpret_cast<void **>(&curEnv), NULL);
jclass cls = curEnv->FindClass( className().c_str() );
if ( cls == NULL) {
throw GiwsException::JniCallMethodException(curEnv);
}

jmethodID jintwrapShortjobjectArray__shortshortID = curEnv->GetStaticMethodID(cls, "wrapShort", "([[S)I" ) ;
if (jintwrapShortjobjectArray__shortshortID == NULL) {
throw GiwsException::JniMethodNotFoundException(curEnv, "wrapShort");
}

 jobjectArray x_ = curEnv->NewObjectArray(xSize, curEnv->FindClass("[S"),NULL);

if (x_ == NULL)
{
// check that allocation succeed
throw GiwsException::JniBadAllocException(curEnv);
}

 for (int i=0; i<xSize; i++){

jshortArray xLocal = curEnv->NewShortArray( xSizeCol ) ;

if (xLocal == NULL)
{
// check that allocation succeed
curEnv->DeleteLocalRef(x_);
throw GiwsException::JniBadAllocException(curEnv);
}

curEnv->SetShortArrayRegion( xLocal, 0, xSizeCol, (jshort*)(x[i]) ) ;
curEnv->SetObjectArrayElement(x_, i, xLocal);
curEnv->DeleteLocalRef(xLocal);
}

                        jint res =  static_cast<jint>( curEnv->CallStaticIntMethod(cls, jintwrapShortjobjectArray__shortshortID ,x_));
                        curEnv->DeleteLocalRef(x_);
curEnv->DeleteLocalRef(cls);
if (curEnv->ExceptionCheck()) {
throw GiwsException::JniCallMethodException(curEnv);
}
return res;

}

int ScilabJavaObject::wrapUShort (JavaVM * jvm_, int x){

JNIEnv * curEnv = NULL;
jvm_->AttachCurrentThread(reinterpret_cast<void **>(&curEnv), NULL);
jclass cls = curEnv->FindClass( className().c_str() );
if ( cls == NULL) {
throw GiwsException::JniCallMethodException(curEnv);
}

jmethodID jintwrapUShortjintintID = curEnv->GetStaticMethodID(cls, "wrapUShort", "(I)I" ) ;
if (jintwrapUShortjintintID == NULL) {
throw GiwsException::JniMethodNotFoundException(curEnv, "wrapUShort");
}

                        jint res =  static_cast<jint>( curEnv->CallStaticIntMethod(cls, jintwrapUShortjintintID ,x));
                        curEnv->DeleteLocalRef(cls);
if (curEnv->ExceptionCheck()) {
throw GiwsException::JniCallMethodException(curEnv);
}
return res;

}

int ScilabJavaObject::wrapUShort (JavaVM * jvm_, int const* x, int xSize){

JNIEnv * curEnv = NULL;
jvm_->AttachCurrentThread(reinterpret_cast<void **>(&curEnv), NULL);
jclass cls = curEnv->FindClass( className().c_str() );
if ( cls == NULL) {
throw GiwsException::JniCallMethodException(curEnv);
}

jmethodID jintwrapUShortjintArray_intintID = curEnv->GetStaticMethodID(cls, "wrapUShort", "([I)I" ) ;
if (jintwrapUShortjintArray_intintID == NULL) {
throw GiwsException::JniMethodNotFoundException(curEnv, "wrapUShort");
}

jintArray x_ = curEnv->NewIntArray( xSize ) ;

if (x_ == NULL)
{
// check that allocation succeed
throw GiwsException::JniBadAllocException(curEnv);
}

curEnv->SetIntArrayRegion( x_, 0, xSize, (jint*)(x) ) ;


                        jint res =  static_cast<jint>( curEnv->CallStaticIntMethod(cls, jintwrapUShortjintArray_intintID ,x_));
                        curEnv->DeleteLocalRef(x_);
curEnv->DeleteLocalRef(cls);
if (curEnv->ExceptionCheck()) {
throw GiwsException::JniCallMethodException(curEnv);
}
return res;

}

int ScilabJavaObject::wrapUShort (JavaVM * jvm_, int const* const* x, int xSize, int xSizeCol){

JNIEnv * curEnv = NULL;
jvm_->AttachCurrentThread(reinterpret_cast<void **>(&curEnv), NULL);
jclass cls = curEnv->FindClass( className().c_str() );
if ( cls == NULL) {
throw GiwsException::JniCallMethodException(curEnv);
}

jmethodID jintwrapUShortjobjectArray__intintID = curEnv->GetStaticMethodID(cls, "wrapUShort", "([[I)I" ) ;
if (jintwrapUShortjobjectArray__intintID == NULL) {
throw GiwsException::JniMethodNotFoundException(curEnv, "wrapUShort");
}

 jobjectArray x_ = curEnv->NewObjectArray(xSize, curEnv->FindClass("[I"),NULL);

if (x_ == NULL)
{
// check that allocation succeed
throw GiwsException::JniBadAllocException(curEnv);
}

 for (int i=0; i<xSize; i++){

jintArray xLocal = curEnv->NewIntArray( xSizeCol ) ;

if (xLocal == NULL)
{
// check that allocation succeed
curEnv->DeleteLocalRef(x_);
throw GiwsException::JniBadAllocException(curEnv);
}

curEnv->SetIntArrayRegion( xLocal, 0, xSizeCol, (jint*)(x[i]) ) ;
curEnv->SetObjectArrayElement(x_, i, xLocal);
curEnv->DeleteLocalRef(xLocal);
}

                        jint res =  static_cast<jint>( curEnv->CallStaticIntMethod(cls, jintwrapUShortjobjectArray__intintID ,x_));
                        curEnv->DeleteLocalRef(x_);
curEnv->DeleteLocalRef(cls);
if (curEnv->ExceptionCheck()) {
throw GiwsException::JniCallMethodException(curEnv);
}
return res;

}

int ScilabJavaObject::wrapString (JavaVM * jvm_, char const* x){

JNIEnv * curEnv = NULL;
jvm_->AttachCurrentThread(reinterpret_cast<void **>(&curEnv), NULL);
jclass cls = curEnv->FindClass( className().c_str() );
if ( cls == NULL) {
throw GiwsException::JniCallMethodException(curEnv);
}

jmethodID jintwrapStringjstringjava_lang_StringID = curEnv->GetStaticMethodID(cls, "wrapString", "(Ljava/lang/String;)I" ) ;
if (jintwrapStringjstringjava_lang_StringID == NULL) {
throw GiwsException::JniMethodNotFoundException(curEnv, "wrapString");
}

jstring x_ = curEnv->NewStringUTF( x );
if (x != NULL && x_ == NULL)
{
throw GiwsException::JniBadAllocException(curEnv);
}


                        jint res =  static_cast<jint>( curEnv->CallStaticIntMethod(cls, jintwrapStringjstringjava_lang_StringID ,x_));
                        curEnv->DeleteLocalRef(x_);
curEnv->DeleteLocalRef(cls);
if (curEnv->ExceptionCheck()) {
throw GiwsException::JniCallMethodException(curEnv);
}
return res;

}

int ScilabJavaObject::wrapString (JavaVM * jvm_, char const* const* x, int xSize){

JNIEnv * curEnv = NULL;
jvm_->AttachCurrentThread(reinterpret_cast<void **>(&curEnv), NULL);
jclass cls = curEnv->FindClass( className().c_str() );
if ( cls == NULL) {
throw GiwsException::JniCallMethodException(curEnv);
}

jmethodID jintwrapStringjobjectArray_java_lang_Stringjava_lang_StringID = curEnv->GetStaticMethodID(cls, "wrapString", "([Ljava/lang/String;)I" ) ;
if (jintwrapStringjobjectArray_java_lang_Stringjava_lang_StringID == NULL) {
throw GiwsException::JniMethodNotFoundException(curEnv, "wrapString");
}
jclass stringArrayClass = curEnv->FindClass("java/lang/String");

// create java array of strings.
jobjectArray x_ = curEnv->NewObjectArray( xSize, stringArrayClass, NULL);
if (x_ == NULL)
{
throw GiwsException::JniBadAllocException(curEnv);
}

// convert each char * to java strings and fill the java array.
for ( int i = 0; i < xSize; i++)
{
jstring TempString = curEnv->NewStringUTF( x[i] );
if (TempString == NULL)
{
throw GiwsException::JniBadAllocException(curEnv);
}

curEnv->SetObjectArrayElement( x_, i, TempString);

// avoid keeping reference on to many strings
curEnv->DeleteLocalRef(TempString);
}
                        jint res =  static_cast<jint>( curEnv->CallStaticIntMethod(cls, jintwrapStringjobjectArray_java_lang_Stringjava_lang_StringID ,x_));
                        curEnv->DeleteLocalRef(stringArrayClass);
curEnv->DeleteLocalRef(x_);
curEnv->DeleteLocalRef(cls);
if (curEnv->ExceptionCheck()) {
throw GiwsException::JniCallMethodException(curEnv);
}
return res;

}

int ScilabJavaObject::wrapString (JavaVM * jvm_, char const* const* const* x, int xSize, int xSizeCol){

JNIEnv * curEnv = NULL;
jvm_->AttachCurrentThread(reinterpret_cast<void **>(&curEnv), NULL);
jclass cls = curEnv->FindClass( className().c_str() );
if ( cls == NULL) {
throw GiwsException::JniCallMethodException(curEnv);
}

jmethodID jintwrapStringjobjectArray__java_lang_Stringjava_lang_StringID = curEnv->GetStaticMethodID(cls, "wrapString", "([[Ljava/lang/String;)I" ) ;
if (jintwrapStringjobjectArray__java_lang_Stringjava_lang_StringID == NULL) {
throw GiwsException::JniMethodNotFoundException(curEnv, "wrapString");
}
jclass stringArrayClass = curEnv->FindClass("java/lang/String");
// create java array of array of strings.
jobjectArray x_ = curEnv->NewObjectArray( xSize, curEnv->FindClass("[Ljava/lang/String;"), NULL);
if (x_ == NULL)
{
throw GiwsException::JniBadAllocException(curEnv);
}

for ( int i = 0; i < xSize; i++)
{
jobjectArray xLocal = curEnv->NewObjectArray( xSizeCol, stringArrayClass, NULL);
// convert each char * to java strings and fill the java array.
for ( int j = 0; j < xSizeCol; j++) {
jstring TempString = curEnv->NewStringUTF( x[i][j] );

if (TempString == NULL)
{
throw GiwsException::JniBadAllocException(curEnv);
}

curEnv->SetObjectArrayElement( xLocal, j, TempString);

// avoid keeping reference on to many strings
curEnv->DeleteLocalRef(TempString);
}
curEnv->SetObjectArrayElement(x_, i, xLocal);
curEnv->DeleteLocalRef(xLocal);

}
                        jint res =  static_cast<jint>( curEnv->CallStaticIntMethod(cls, jintwrapStringjobjectArray__java_lang_Stringjava_lang_StringID ,x_));
                        curEnv->DeleteLocalRef(stringArrayClass);
curEnv->DeleteLocalRef(x_);
curEnv->DeleteLocalRef(cls);
if (curEnv->ExceptionCheck()) {
throw GiwsException::JniCallMethodException(curEnv);
}
return res;

}

int ScilabJavaObject::wrapBoolean (JavaVM * jvm_, bool x){

JNIEnv * curEnv = NULL;
jvm_->AttachCurrentThread(reinterpret_cast<void **>(&curEnv), NULL);
jclass cls = curEnv->FindClass( className().c_str() );
if ( cls == NULL) {
throw GiwsException::JniCallMethodException(curEnv);
}

jmethodID jintwrapBooleanjbooleanbooleanID = curEnv->GetStaticMethodID(cls, "wrapBoolean", "(Z)I" ) ;
if (jintwrapBooleanjbooleanbooleanID == NULL) {
throw GiwsException::JniMethodNotFoundException(curEnv, "wrapBoolean");
}

jboolean x_ = (static_cast<bool>(x) ? JNI_TRUE : JNI_FALSE);

                        jint res =  static_cast<jint>( curEnv->CallStaticIntMethod(cls, jintwrapBooleanjbooleanbooleanID ,x_));
                        curEnv->DeleteLocalRef(cls);
if (curEnv->ExceptionCheck()) {
throw GiwsException::JniCallMethodException(curEnv);
}
return res;

}

int ScilabJavaObject::wrapBoolean (JavaVM * jvm_, bool const* x, int xSize){

JNIEnv * curEnv = NULL;
jvm_->AttachCurrentThread(reinterpret_cast<void **>(&curEnv), NULL);
jclass cls = curEnv->FindClass( className().c_str() );
if ( cls == NULL) {
throw GiwsException::JniCallMethodException(curEnv);
}

jmethodID jintwrapBooleanjbooleanArray_booleanbooleanID = curEnv->GetStaticMethodID(cls, "wrapBoolean", "([Z)I" ) ;
if (jintwrapBooleanjbooleanArray_booleanbooleanID == NULL) {
throw GiwsException::JniMethodNotFoundException(curEnv, "wrapBoolean");
}

jbooleanArray x_ = curEnv->NewBooleanArray( xSize ) ;
curEnv->SetBooleanArrayRegion( x_, 0, xSize, (jboolean*)x ) ;

                        jint res =  static_cast<jint>( curEnv->CallStaticIntMethod(cls, jintwrapBooleanjbooleanArray_booleanbooleanID ,x_));
                        curEnv->DeleteLocalRef(x_);
curEnv->DeleteLocalRef(cls);
if (curEnv->ExceptionCheck()) {
throw GiwsException::JniCallMethodException(curEnv);
}
return res;

}

int ScilabJavaObject::wrapBoolean (JavaVM * jvm_, bool const* const* x, int xSize, int xSizeCol){

JNIEnv * curEnv = NULL;
jvm_->AttachCurrentThread(reinterpret_cast<void **>(&curEnv), NULL);
jclass cls = curEnv->FindClass( className().c_str() );
if ( cls == NULL) {
throw GiwsException::JniCallMethodException(curEnv);
}

jmethodID jintwrapBooleanjobjectArray__booleanbooleanID = curEnv->GetStaticMethodID(cls, "wrapBoolean", "([[Z)I" ) ;
if (jintwrapBooleanjobjectArray__booleanbooleanID == NULL) {
throw GiwsException::JniMethodNotFoundException(curEnv, "wrapBoolean");
}

jobjectArray x_ = curEnv->NewObjectArray(xSize, curEnv->FindClass("[Z"),NULL);
for (int i=0; i<xSize; i++){
                        jbooleanArray xLocal = curEnv->NewBooleanArray( xSizeCol ) ;
                        curEnv->SetBooleanArrayRegion( xLocal, 0, xSizeCol, (jboolean*)(x[i]) ) ;
                        curEnv->SetObjectArrayElement(x_, i, xLocal);
                        curEnv->DeleteLocalRef(xLocal);
                        }

                        jint res =  static_cast<jint>( curEnv->CallStaticIntMethod(cls, jintwrapBooleanjobjectArray__booleanbooleanID ,x_));
                        curEnv->DeleteLocalRef(x_);
curEnv->DeleteLocalRef(cls);
if (curEnv->ExceptionCheck()) {
throw GiwsException::JniCallMethodException(curEnv);
}
return res;

}

int ScilabJavaObject::wrapChar (JavaVM * jvm_, unsigned short x){

JNIEnv * curEnv = NULL;
jvm_->AttachCurrentThread(reinterpret_cast<void **>(&curEnv), NULL);
jclass cls = curEnv->FindClass( className().c_str() );
if ( cls == NULL) {
throw GiwsException::JniCallMethodException(curEnv);
}

jmethodID jintwrapCharjcharcharID = curEnv->GetStaticMethodID(cls, "wrapChar", "(C)I" ) ;
if (jintwrapCharjcharcharID == NULL) {
throw GiwsException::JniMethodNotFoundException(curEnv, "wrapChar");
}

                        jint res =  static_cast<jint>( curEnv->CallStaticIntMethod(cls, jintwrapCharjcharcharID ,x));
                        curEnv->DeleteLocalRef(cls);
if (curEnv->ExceptionCheck()) {
throw GiwsException::JniCallMethodException(curEnv);
}
return res;

}

int ScilabJavaObject::wrapChar (JavaVM * jvm_, unsigned short const* x, int xSize){

JNIEnv * curEnv = NULL;
jvm_->AttachCurrentThread(reinterpret_cast<void **>(&curEnv), NULL);
jclass cls = curEnv->FindClass( className().c_str() );
if ( cls == NULL) {
throw GiwsException::JniCallMethodException(curEnv);
}

jmethodID jintwrapCharjcharArray_charcharID = curEnv->GetStaticMethodID(cls, "wrapChar", "([C)I" ) ;
if (jintwrapCharjcharArray_charcharID == NULL) {
throw GiwsException::JniMethodNotFoundException(curEnv, "wrapChar");
}

jcharArray x_ = curEnv->NewCharArray( xSize ) ;

if (x_ == NULL)
{
// check that allocation succeed
throw GiwsException::JniBadAllocException(curEnv);
}

curEnv->SetCharArrayRegion( x_, 0, xSize, (jchar*)(x) ) ;


                        jint res =  static_cast<jint>( curEnv->CallStaticIntMethod(cls, jintwrapCharjcharArray_charcharID ,x_));
                        curEnv->DeleteLocalRef(x_);
curEnv->DeleteLocalRef(cls);
if (curEnv->ExceptionCheck()) {
throw GiwsException::JniCallMethodException(curEnv);
}
return res;

}

int ScilabJavaObject::wrapChar (JavaVM * jvm_, unsigned short const* const* x, int xSize, int xSizeCol){

JNIEnv * curEnv = NULL;
jvm_->AttachCurrentThread(reinterpret_cast<void **>(&curEnv), NULL);
jclass cls = curEnv->FindClass( className().c_str() );
if ( cls == NULL) {
throw GiwsException::JniCallMethodException(curEnv);
}

jmethodID jintwrapCharjobjectArray__charcharID = curEnv->GetStaticMethodID(cls, "wrapChar", "([[C)I" ) ;
if (jintwrapCharjobjectArray__charcharID == NULL) {
throw GiwsException::JniMethodNotFoundException(curEnv, "wrapChar");
}

 jobjectArray x_ = curEnv->NewObjectArray(xSize, curEnv->FindClass("[C"),NULL);

if (x_ == NULL)
{
// check that allocation succeed
throw GiwsException::JniBadAllocException(curEnv);
}

 for (int i=0; i<xSize; i++){

jcharArray xLocal = curEnv->NewCharArray( xSizeCol ) ;

if (xLocal == NULL)
{
// check that allocation succeed
curEnv->DeleteLocalRef(x_);
throw GiwsException::JniBadAllocException(curEnv);
}

curEnv->SetCharArrayRegion( xLocal, 0, xSizeCol, (jchar*)(x[i]) ) ;
curEnv->SetObjectArrayElement(x_, i, xLocal);
curEnv->DeleteLocalRef(xLocal);
}

                        jint res =  static_cast<jint>( curEnv->CallStaticIntMethod(cls, jintwrapCharjobjectArray__charcharID ,x_));
                        curEnv->DeleteLocalRef(x_);
curEnv->DeleteLocalRef(cls);
if (curEnv->ExceptionCheck()) {
throw GiwsException::JniCallMethodException(curEnv);
}
return res;

}

int ScilabJavaObject::wrapFloat (JavaVM * jvm_, float x){

JNIEnv * curEnv = NULL;
jvm_->AttachCurrentThread(reinterpret_cast<void **>(&curEnv), NULL);
jclass cls = curEnv->FindClass( className().c_str() );
if ( cls == NULL) {
throw GiwsException::JniCallMethodException(curEnv);
}

jmethodID jintwrapFloatjfloatfloatID = curEnv->GetStaticMethodID(cls, "wrapFloat", "(F)I" ) ;
if (jintwrapFloatjfloatfloatID == NULL) {
throw GiwsException::JniMethodNotFoundException(curEnv, "wrapFloat");
}

                        jint res =  static_cast<jint>( curEnv->CallStaticIntMethod(cls, jintwrapFloatjfloatfloatID ,x));
                        curEnv->DeleteLocalRef(cls);
if (curEnv->ExceptionCheck()) {
throw GiwsException::JniCallMethodException(curEnv);
}
return res;

}

int ScilabJavaObject::wrapFloat (JavaVM * jvm_, float const* x, int xSize){

JNIEnv * curEnv = NULL;
jvm_->AttachCurrentThread(reinterpret_cast<void **>(&curEnv), NULL);
jclass cls = curEnv->FindClass( className().c_str() );
if ( cls == NULL) {
throw GiwsException::JniCallMethodException(curEnv);
}

jmethodID jintwrapFloatjfloatArray_floatfloatID = curEnv->GetStaticMethodID(cls, "wrapFloat", "([F)I" ) ;
if (jintwrapFloatjfloatArray_floatfloatID == NULL) {
throw GiwsException::JniMethodNotFoundException(curEnv, "wrapFloat");
}

jfloatArray x_ = curEnv->NewFloatArray( xSize ) ;

if (x_ == NULL)
{
// check that allocation succeed
throw GiwsException::JniBadAllocException(curEnv);
}

curEnv->SetFloatArrayRegion( x_, 0, xSize, (jfloat*)(x) ) ;


                        jint res =  static_cast<jint>( curEnv->CallStaticIntMethod(cls, jintwrapFloatjfloatArray_floatfloatID ,x_));
                        curEnv->DeleteLocalRef(x_);
curEnv->DeleteLocalRef(cls);
if (curEnv->ExceptionCheck()) {
throw GiwsException::JniCallMethodException(curEnv);
}
return res;

}

int ScilabJavaObject::wrapFloat (JavaVM * jvm_, float const* const* x, int xSize, int xSizeCol){

JNIEnv * curEnv = NULL;
jvm_->AttachCurrentThread(reinterpret_cast<void **>(&curEnv), NULL);
jclass cls = curEnv->FindClass( className().c_str() );
if ( cls == NULL) {
throw GiwsException::JniCallMethodException(curEnv);
}

jmethodID jintwrapFloatjobjectArray__floatfloatID = curEnv->GetStaticMethodID(cls, "wrapFloat", "([[F)I" ) ;
if (jintwrapFloatjobjectArray__floatfloatID == NULL) {
throw GiwsException::JniMethodNotFoundException(curEnv, "wrapFloat");
}

 jobjectArray x_ = curEnv->NewObjectArray(xSize, curEnv->FindClass("[F"),NULL);

if (x_ == NULL)
{
// check that allocation succeed
throw GiwsException::JniBadAllocException(curEnv);
}

 for (int i=0; i<xSize; i++){

jfloatArray xLocal = curEnv->NewFloatArray( xSizeCol ) ;

if (xLocal == NULL)
{
// check that allocation succeed
curEnv->DeleteLocalRef(x_);
throw GiwsException::JniBadAllocException(curEnv);
}

curEnv->SetFloatArrayRegion( xLocal, 0, xSizeCol, (jfloat*)(x[i]) ) ;
curEnv->SetObjectArrayElement(x_, i, xLocal);
curEnv->DeleteLocalRef(xLocal);
}

                        jint res =  static_cast<jint>( curEnv->CallStaticIntMethod(cls, jintwrapFloatjobjectArray__floatfloatID ,x_));
                        curEnv->DeleteLocalRef(x_);
curEnv->DeleteLocalRef(cls);
if (curEnv->ExceptionCheck()) {
throw GiwsException::JniCallMethodException(curEnv);
}
return res;

}

int ScilabJavaObject::wrapLong (JavaVM * jvm_, long long x){

JNIEnv * curEnv = NULL;
jvm_->AttachCurrentThread(reinterpret_cast<void **>(&curEnv), NULL);
jclass cls = curEnv->FindClass( className().c_str() );
if ( cls == NULL) {
throw GiwsException::JniCallMethodException(curEnv);
}

jmethodID jintwrapLongjlonglongID = curEnv->GetStaticMethodID(cls, "wrapLong", "(J)I" ) ;
if (jintwrapLongjlonglongID == NULL) {
throw GiwsException::JniMethodNotFoundException(curEnv, "wrapLong");
}

                        jint res =  static_cast<jint>( curEnv->CallStaticIntMethod(cls, jintwrapLongjlonglongID ,x));
                        curEnv->DeleteLocalRef(cls);
if (curEnv->ExceptionCheck()) {
throw GiwsException::JniCallMethodException(curEnv);
}
return res;

}

int ScilabJavaObject::wrapLong (JavaVM * jvm_, long long const* x, int xSize){

JNIEnv * curEnv = NULL;
jvm_->AttachCurrentThread(reinterpret_cast<void **>(&curEnv), NULL);
jclass cls = curEnv->FindClass( className().c_str() );
if ( cls == NULL) {
throw GiwsException::JniCallMethodException(curEnv);
}

jmethodID jintwrapLongjlongArray_longlongID = curEnv->GetStaticMethodID(cls, "wrapLong", "([J)I" ) ;
if (jintwrapLongjlongArray_longlongID == NULL) {
throw GiwsException::JniMethodNotFoundException(curEnv, "wrapLong");
}

jlongArray x_ = curEnv->NewLongArray( xSize ) ;

if (x_ == NULL)
{
// check that allocation succeed
throw GiwsException::JniBadAllocException(curEnv);
}

curEnv->SetLongArrayRegion( x_, 0, xSize, (jlong*)(x) ) ;


                        jint res =  static_cast<jint>( curEnv->CallStaticIntMethod(cls, jintwrapLongjlongArray_longlongID ,x_));
                        curEnv->DeleteLocalRef(x_);
curEnv->DeleteLocalRef(cls);
if (curEnv->ExceptionCheck()) {
throw GiwsException::JniCallMethodException(curEnv);
}
return res;

}

int ScilabJavaObject::wrapLong (JavaVM * jvm_, long long const* const* x, int xSize, int xSizeCol){

JNIEnv * curEnv = NULL;
jvm_->AttachCurrentThread(reinterpret_cast<void **>(&curEnv), NULL);
jclass cls = curEnv->FindClass( className().c_str() );
if ( cls == NULL) {
throw GiwsException::JniCallMethodException(curEnv);
}

jmethodID jintwrapLongjobjectArray__longlongID = curEnv->GetStaticMethodID(cls, "wrapLong", "([[J)I" ) ;
if (jintwrapLongjobjectArray__longlongID == NULL) {
throw GiwsException::JniMethodNotFoundException(curEnv, "wrapLong");
}

 jobjectArray x_ = curEnv->NewObjectArray(xSize, curEnv->FindClass("[J"),NULL);

if (x_ == NULL)
{
// check that allocation succeed
throw GiwsException::JniBadAllocException(curEnv);
}

 for (int i=0; i<xSize; i++){

jlongArray xLocal = curEnv->NewLongArray( xSizeCol ) ;

if (xLocal == NULL)
{
// check that allocation succeed
curEnv->DeleteLocalRef(x_);
throw GiwsException::JniBadAllocException(curEnv);
}

curEnv->SetLongArrayRegion( xLocal, 0, xSizeCol, (jlong*)(x[i]) ) ;
curEnv->SetObjectArrayElement(x_, i, xLocal);
curEnv->DeleteLocalRef(xLocal);
}

                        jint res =  static_cast<jint>( curEnv->CallStaticIntMethod(cls, jintwrapLongjobjectArray__longlongID ,x_));
                        curEnv->DeleteLocalRef(x_);
curEnv->DeleteLocalRef(cls);
if (curEnv->ExceptionCheck()) {
throw GiwsException::JniCallMethodException(curEnv);
}
return res;

}

double ScilabJavaObject::unwrapDouble (JavaVM * jvm_, int x){

JNIEnv * curEnv = NULL;
jvm_->AttachCurrentThread(reinterpret_cast<void **>(&curEnv), NULL);
jclass cls = curEnv->FindClass( className().c_str() );
if ( cls == NULL) {
throw GiwsException::JniCallMethodException(curEnv);
}

jmethodID jdoubleunwrapDoublejintintID = curEnv->GetStaticMethodID(cls, "unwrapDouble", "(I)D" ) ;
if (jdoubleunwrapDoublejintintID == NULL) {
throw GiwsException::JniMethodNotFoundException(curEnv, "unwrapDouble");
}

                        jdouble res =  static_cast<jdouble>( curEnv->CallStaticDoubleMethod(cls, jdoubleunwrapDoublejintintID ,x));
                        curEnv->DeleteLocalRef(cls);
if (curEnv->ExceptionCheck()) {
throw GiwsException::JniCallMethodException(curEnv);
}
return res;

}

double* ScilabJavaObject::unwrapRowDouble (JavaVM * jvm_, int x){

JNIEnv * curEnv = NULL;
jvm_->AttachCurrentThread(reinterpret_cast<void **>(&curEnv), NULL);
jclass cls = curEnv->FindClass( className().c_str() );
if ( cls == NULL) {
throw GiwsException::JniCallMethodException(curEnv);
}

jmethodID jdoubleArray_unwrapRowDoublejintintID = curEnv->GetStaticMethodID(cls, "unwrapRowDouble", "(I)[D" ) ;
if (jdoubleArray_unwrapRowDoublejintintID == NULL) {
throw GiwsException::JniMethodNotFoundException(curEnv, "unwrapRowDouble");
}

                        jdoubleArray res =  static_cast<jdoubleArray>( curEnv->CallStaticObjectMethod(cls, jdoubleArray_unwrapRowDoublejintintID ,x));
                        if (res == NULL) { return NULL; }
                        if (curEnv->ExceptionCheck()) {
throw GiwsException::JniCallMethodException(curEnv);
}int lenRow;
 lenRow = curEnv->GetArrayLength(res);
jboolean isCopy = JNI_FALSE;

/* GetPrimitiveArrayCritical is faster than getXXXArrayElements */
jdouble *resultsArray = static_cast<jdouble *>(curEnv->GetPrimitiveArrayCritical(res, &isCopy));
double* myArray= new double[ lenRow];

for (jsize i = 0; i <  lenRow; i++){
myArray[i]=resultsArray[i];
}
curEnv->ReleasePrimitiveArrayCritical(res, resultsArray, JNI_ABORT);

                        curEnv->DeleteLocalRef(res);
curEnv->DeleteLocalRef(cls);
if (curEnv->ExceptionCheck()) {
delete[] myArray;
                                throw GiwsException::JniCallMethodException(curEnv);
}
return myArray;

}

double** ScilabJavaObject::unwrapMatDouble (JavaVM * jvm_, int x){

JNIEnv * curEnv = NULL;
jvm_->AttachCurrentThread(reinterpret_cast<void **>(&curEnv), NULL);
jclass cls = curEnv->FindClass( className().c_str() );
if ( cls == NULL) {
throw GiwsException::JniCallMethodException(curEnv);
}

jmethodID jobjectArray__unwrapMatDoublejintintID = curEnv->GetStaticMethodID(cls, "unwrapMatDouble", "(I)[[D" ) ;
if (jobjectArray__unwrapMatDoublejintintID == NULL) {
throw GiwsException::JniMethodNotFoundException(curEnv, "unwrapMatDouble");
}

                        jobjectArray res =  static_cast<jobjectArray>( curEnv->CallStaticObjectMethod(cls, jobjectArray__unwrapMatDoublejintintID ,x));
                        if (res == NULL) { return NULL; }
                        if (curEnv->ExceptionCheck()) {
throw GiwsException::JniCallMethodException(curEnv);
}int lenCol;int lenRow;
 lenRow = curEnv->GetArrayLength(res);
jboolean isCopy = JNI_FALSE;

double ** myArray = new double*[ lenRow];
for(int i=0; i< lenRow; i++) {
jdoubleArray oneDim = (jdoubleArray)curEnv->GetObjectArrayElement(res, i);
 lenCol=curEnv->GetArrayLength(oneDim);
double *resultsArray = static_cast<double *>(curEnv->GetPrimitiveArrayCritical(oneDim, &isCopy));
myArray[i] = new double[ lenCol];
for(int j=0; j< lenCol; j++) {
myArray[i][j]= resultsArray[j];
}
curEnv->ReleasePrimitiveArrayCritical(res, resultsArray, JNI_ABORT);
}

curEnv->DeleteLocalRef(res);
curEnv->DeleteLocalRef(cls);
if (curEnv->ExceptionCheck()) {
delete[] myArray;
                                throw GiwsException::JniCallMethodException(curEnv);
}
return myArray;

}

int ScilabJavaObject::unwrapInt (JavaVM * jvm_, int x){

JNIEnv * curEnv = NULL;
jvm_->AttachCurrentThread(reinterpret_cast<void **>(&curEnv), NULL);
jclass cls = curEnv->FindClass( className().c_str() );
if ( cls == NULL) {
throw GiwsException::JniCallMethodException(curEnv);
}

jmethodID jintunwrapIntjintintID = curEnv->GetStaticMethodID(cls, "unwrapInt", "(I)I" ) ;
if (jintunwrapIntjintintID == NULL) {
throw GiwsException::JniMethodNotFoundException(curEnv, "unwrapInt");
}

                        jint res =  static_cast<jint>( curEnv->CallStaticIntMethod(cls, jintunwrapIntjintintID ,x));
                        curEnv->DeleteLocalRef(cls);
if (curEnv->ExceptionCheck()) {
throw GiwsException::JniCallMethodException(curEnv);
}
return res;

}

int* ScilabJavaObject::unwrapRowInt (JavaVM * jvm_, int x){

JNIEnv * curEnv = NULL;
jvm_->AttachCurrentThread(reinterpret_cast<void **>(&curEnv), NULL);
jclass cls = curEnv->FindClass( className().c_str() );
if ( cls == NULL) {
throw GiwsException::JniCallMethodException(curEnv);
}

jmethodID jintArray_unwrapRowIntjintintID = curEnv->GetStaticMethodID(cls, "unwrapRowInt", "(I)[I" ) ;
if (jintArray_unwrapRowIntjintintID == NULL) {
throw GiwsException::JniMethodNotFoundException(curEnv, "unwrapRowInt");
}

                        jintArray res =  static_cast<jintArray>( curEnv->CallStaticObjectMethod(cls, jintArray_unwrapRowIntjintintID ,x));
                        if (res == NULL) { return NULL; }
                        if (curEnv->ExceptionCheck()) {
throw GiwsException::JniCallMethodException(curEnv);
}int lenRow;
 lenRow = curEnv->GetArrayLength(res);
jboolean isCopy = JNI_FALSE;

/* GetPrimitiveArrayCritical is faster than getXXXArrayElements */
jint *resultsArray = static_cast<jint *>(curEnv->GetPrimitiveArrayCritical(res, &isCopy));
int* myArray= new int[ lenRow];

for (jsize i = 0; i <  lenRow; i++){
myArray[i]=resultsArray[i];
}
curEnv->ReleasePrimitiveArrayCritical(res, resultsArray, JNI_ABORT);

                        curEnv->DeleteLocalRef(res);
curEnv->DeleteLocalRef(cls);
if (curEnv->ExceptionCheck()) {
delete[] myArray;
                                throw GiwsException::JniCallMethodException(curEnv);
}
return myArray;

}

int** ScilabJavaObject::unwrapMatInt (JavaVM * jvm_, int x){

JNIEnv * curEnv = NULL;
jvm_->AttachCurrentThread(reinterpret_cast<void **>(&curEnv), NULL);
jclass cls = curEnv->FindClass( className().c_str() );
if ( cls == NULL) {
throw GiwsException::JniCallMethodException(curEnv);
}

jmethodID jobjectArray__unwrapMatIntjintintID = curEnv->GetStaticMethodID(cls, "unwrapMatInt", "(I)[[I" ) ;
if (jobjectArray__unwrapMatIntjintintID == NULL) {
throw GiwsException::JniMethodNotFoundException(curEnv, "unwrapMatInt");
}

                        jobjectArray res =  static_cast<jobjectArray>( curEnv->CallStaticObjectMethod(cls, jobjectArray__unwrapMatIntjintintID ,x));
                        if (res == NULL) { return NULL; }
                        if (curEnv->ExceptionCheck()) {
throw GiwsException::JniCallMethodException(curEnv);
}int lenCol;int lenRow;
 lenRow = curEnv->GetArrayLength(res);
jboolean isCopy = JNI_FALSE;

int ** myArray = new int*[ lenRow];
for(int i=0; i< lenRow; i++) {
jintArray oneDim = (jintArray)curEnv->GetObjectArrayElement(res, i);
 lenCol=curEnv->GetArrayLength(oneDim);
int *resultsArray = static_cast<int *>(curEnv->GetPrimitiveArrayCritical(oneDim, &isCopy));
myArray[i] = new int[ lenCol];
for(int j=0; j< lenCol; j++) {
myArray[i][j]= resultsArray[j];
}
curEnv->ReleasePrimitiveArrayCritical(res, resultsArray, JNI_ABORT);
}

curEnv->DeleteLocalRef(res);
curEnv->DeleteLocalRef(cls);
if (curEnv->ExceptionCheck()) {
delete[] myArray;
                                throw GiwsException::JniCallMethodException(curEnv);
}
return myArray;

}

long long ScilabJavaObject::unwrapUInt (JavaVM * jvm_, int x){

JNIEnv * curEnv = NULL;
jvm_->AttachCurrentThread(reinterpret_cast<void **>(&curEnv), NULL);
jclass cls = curEnv->FindClass( className().c_str() );
if ( cls == NULL) {
throw GiwsException::JniCallMethodException(curEnv);
}

jmethodID jlongunwrapUIntjintintID = curEnv->GetStaticMethodID(cls, "unwrapUInt", "(I)J" ) ;
if (jlongunwrapUIntjintintID == NULL) {
throw GiwsException::JniMethodNotFoundException(curEnv, "unwrapUInt");
}

                        jlong res =  static_cast<jlong>( curEnv->CallStaticLongMethod(cls, jlongunwrapUIntjintintID ,x));
                        curEnv->DeleteLocalRef(cls);
if (curEnv->ExceptionCheck()) {
throw GiwsException::JniCallMethodException(curEnv);
}
return res;

}

long long* ScilabJavaObject::unwrapRowUInt (JavaVM * jvm_, int x){

JNIEnv * curEnv = NULL;
jvm_->AttachCurrentThread(reinterpret_cast<void **>(&curEnv), NULL);
jclass cls = curEnv->FindClass( className().c_str() );
if ( cls == NULL) {
throw GiwsException::JniCallMethodException(curEnv);
}

jmethodID jlongArray_unwrapRowUIntjintintID = curEnv->GetStaticMethodID(cls, "unwrapRowUInt", "(I)[J" ) ;
if (jlongArray_unwrapRowUIntjintintID == NULL) {
throw GiwsException::JniMethodNotFoundException(curEnv, "unwrapRowUInt");
}

                        jlongArray res =  static_cast<jlongArray>( curEnv->CallStaticObjectMethod(cls, jlongArray_unwrapRowUIntjintintID ,x));
                        if (res == NULL) { return NULL; }
                        if (curEnv->ExceptionCheck()) {
throw GiwsException::JniCallMethodException(curEnv);
}int lenRow;
 lenRow = curEnv->GetArrayLength(res);
jboolean isCopy = JNI_FALSE;

/* GetPrimitiveArrayCritical is faster than getXXXArrayElements */
jlong *resultsArray = static_cast<jlong *>(curEnv->GetPrimitiveArrayCritical(res, &isCopy));
long long* myArray= new long long[ lenRow];

for (jsize i = 0; i <  lenRow; i++){
myArray[i]=resultsArray[i];
}
curEnv->ReleasePrimitiveArrayCritical(res, resultsArray, JNI_ABORT);

                        curEnv->DeleteLocalRef(res);
curEnv->DeleteLocalRef(cls);
if (curEnv->ExceptionCheck()) {
delete[] myArray;
                                throw GiwsException::JniCallMethodException(curEnv);
}
return myArray;

}

long long** ScilabJavaObject::unwrapMatUInt (JavaVM * jvm_, int x){

JNIEnv * curEnv = NULL;
jvm_->AttachCurrentThread(reinterpret_cast<void **>(&curEnv), NULL);
jclass cls = curEnv->FindClass( className().c_str() );
if ( cls == NULL) {
throw GiwsException::JniCallMethodException(curEnv);
}

jmethodID jobjectArray__unwrapMatUIntjintintID = curEnv->GetStaticMethodID(cls, "unwrapMatUInt", "(I)[[J" ) ;
if (jobjectArray__unwrapMatUIntjintintID == NULL) {
throw GiwsException::JniMethodNotFoundException(curEnv, "unwrapMatUInt");
}

                        jobjectArray res =  static_cast<jobjectArray>( curEnv->CallStaticObjectMethod(cls, jobjectArray__unwrapMatUIntjintintID ,x));
                        if (res == NULL) { return NULL; }
                        if (curEnv->ExceptionCheck()) {
throw GiwsException::JniCallMethodException(curEnv);
}int lenCol;int lenRow;
 lenRow = curEnv->GetArrayLength(res);
jboolean isCopy = JNI_FALSE;

long long ** myArray = new long long*[ lenRow];
for(int i=0; i< lenRow; i++) {
jlongArray oneDim = (jlongArray)curEnv->GetObjectArrayElement(res, i);
 lenCol=curEnv->GetArrayLength(oneDim);
long long *resultsArray = static_cast<long long *>(curEnv->GetPrimitiveArrayCritical(oneDim, &isCopy));
myArray[i] = new long long[ lenCol];
for(int j=0; j< lenCol; j++) {
myArray[i][j]= resultsArray[j];
}
curEnv->ReleasePrimitiveArrayCritical(res, resultsArray, JNI_ABORT);
}

curEnv->DeleteLocalRef(res);
curEnv->DeleteLocalRef(cls);
if (curEnv->ExceptionCheck()) {
delete[] myArray;
                                throw GiwsException::JniCallMethodException(curEnv);
}
return myArray;

}

byte ScilabJavaObject::unwrapByte (JavaVM * jvm_, int x){

JNIEnv * curEnv = NULL;
jvm_->AttachCurrentThread(reinterpret_cast<void **>(&curEnv), NULL);
jclass cls = curEnv->FindClass( className().c_str() );
if ( cls == NULL) {
throw GiwsException::JniCallMethodException(curEnv);
}

jmethodID jbyteunwrapBytejintintID = curEnv->GetStaticMethodID(cls, "unwrapByte", "(I)B" ) ;
if (jbyteunwrapBytejintintID == NULL) {
throw GiwsException::JniMethodNotFoundException(curEnv, "unwrapByte");
}

                        jbyte res =  static_cast<jbyte>( curEnv->CallStaticByteMethod(cls, jbyteunwrapBytejintintID ,x));
                        curEnv->DeleteLocalRef(cls);
if (curEnv->ExceptionCheck()) {
throw GiwsException::JniCallMethodException(curEnv);
}
return res;

}

byte* ScilabJavaObject::unwrapRowByte (JavaVM * jvm_, int x){

JNIEnv * curEnv = NULL;
jvm_->AttachCurrentThread(reinterpret_cast<void **>(&curEnv), NULL);
jclass cls = curEnv->FindClass( className().c_str() );
if ( cls == NULL) {
throw GiwsException::JniCallMethodException(curEnv);
}

jmethodID jbyteArray_unwrapRowBytejintintID = curEnv->GetStaticMethodID(cls, "unwrapRowByte", "(I)[B" ) ;
if (jbyteArray_unwrapRowBytejintintID == NULL) {
throw GiwsException::JniMethodNotFoundException(curEnv, "unwrapRowByte");
}

                        jbyteArray res =  static_cast<jbyteArray>( curEnv->CallStaticObjectMethod(cls, jbyteArray_unwrapRowBytejintintID ,x));
                        if (res == NULL) { return NULL; }
                        if (curEnv->ExceptionCheck()) {
throw GiwsException::JniCallMethodException(curEnv);
}int lenRow;
 lenRow = curEnv->GetArrayLength(res);
jboolean isCopy = JNI_FALSE;

/* GetPrimitiveArrayCritical is faster than getXXXArrayElements */
jbyte *resultsArray = static_cast<jbyte *>(curEnv->GetPrimitiveArrayCritical(res, &isCopy));
byte* myArray= new byte[ lenRow];

for (jsize i = 0; i <  lenRow; i++){
myArray[i]=resultsArray[i];
}
curEnv->ReleasePrimitiveArrayCritical(res, resultsArray, JNI_ABORT);

                        curEnv->DeleteLocalRef(res);
curEnv->DeleteLocalRef(cls);
if (curEnv->ExceptionCheck()) {
delete[] myArray;
                                throw GiwsException::JniCallMethodException(curEnv);
}
return myArray;

}

byte** ScilabJavaObject::unwrapMatByte (JavaVM * jvm_, int x){

JNIEnv * curEnv = NULL;
jvm_->AttachCurrentThread(reinterpret_cast<void **>(&curEnv), NULL);
jclass cls = curEnv->FindClass( className().c_str() );
if ( cls == NULL) {
throw GiwsException::JniCallMethodException(curEnv);
}

jmethodID jobjectArray__unwrapMatBytejintintID = curEnv->GetStaticMethodID(cls, "unwrapMatByte", "(I)[[B" ) ;
if (jobjectArray__unwrapMatBytejintintID == NULL) {
throw GiwsException::JniMethodNotFoundException(curEnv, "unwrapMatByte");
}

                        jobjectArray res =  static_cast<jobjectArray>( curEnv->CallStaticObjectMethod(cls, jobjectArray__unwrapMatBytejintintID ,x));
                        if (res == NULL) { return NULL; }
                        if (curEnv->ExceptionCheck()) {
throw GiwsException::JniCallMethodException(curEnv);
}int lenCol;int lenRow;
 lenRow = curEnv->GetArrayLength(res);
jboolean isCopy = JNI_FALSE;

byte ** myArray = new byte*[ lenRow];
for(int i=0; i< lenRow; i++) {
jbyteArray oneDim = (jbyteArray)curEnv->GetObjectArrayElement(res, i);
 lenCol=curEnv->GetArrayLength(oneDim);
byte *resultsArray = static_cast<byte *>(curEnv->GetPrimitiveArrayCritical(oneDim, &isCopy));
myArray[i] = new byte[ lenCol];
for(int j=0; j< lenCol; j++) {
myArray[i][j]= resultsArray[j];
}
curEnv->ReleasePrimitiveArrayCritical(res, resultsArray, JNI_ABORT);
}

curEnv->DeleteLocalRef(res);
curEnv->DeleteLocalRef(cls);
if (curEnv->ExceptionCheck()) {
delete[] myArray;
                                throw GiwsException::JniCallMethodException(curEnv);
}
return myArray;

}

short ScilabJavaObject::unwrapUByte (JavaVM * jvm_, int x){

JNIEnv * curEnv = NULL;
jvm_->AttachCurrentThread(reinterpret_cast<void **>(&curEnv), NULL);
jclass cls = curEnv->FindClass( className().c_str() );
if ( cls == NULL) {
throw GiwsException::JniCallMethodException(curEnv);
}

jmethodID jshortunwrapUBytejintintID = curEnv->GetStaticMethodID(cls, "unwrapUByte", "(I)S" ) ;
if (jshortunwrapUBytejintintID == NULL) {
throw GiwsException::JniMethodNotFoundException(curEnv, "unwrapUByte");
}

                        jshort res =  static_cast<jshort>( curEnv->CallStaticShortMethod(cls, jshortunwrapUBytejintintID ,x));
                        curEnv->DeleteLocalRef(cls);
if (curEnv->ExceptionCheck()) {
throw GiwsException::JniCallMethodException(curEnv);
}
return res;

}

short* ScilabJavaObject::unwrapRowUByte (JavaVM * jvm_, int x){

JNIEnv * curEnv = NULL;
jvm_->AttachCurrentThread(reinterpret_cast<void **>(&curEnv), NULL);
jclass cls = curEnv->FindClass( className().c_str() );
if ( cls == NULL) {
throw GiwsException::JniCallMethodException(curEnv);
}

jmethodID jshortArray_unwrapRowUBytejintintID = curEnv->GetStaticMethodID(cls, "unwrapRowUByte", "(I)[S" ) ;
if (jshortArray_unwrapRowUBytejintintID == NULL) {
throw GiwsException::JniMethodNotFoundException(curEnv, "unwrapRowUByte");
}

                        jshortArray res =  static_cast<jshortArray>( curEnv->CallStaticObjectMethod(cls, jshortArray_unwrapRowUBytejintintID ,x));
                        if (res == NULL) { return NULL; }
                        if (curEnv->ExceptionCheck()) {
throw GiwsException::JniCallMethodException(curEnv);
}int lenRow;
 lenRow = curEnv->GetArrayLength(res);
jboolean isCopy = JNI_FALSE;

/* GetPrimitiveArrayCritical is faster than getXXXArrayElements */
jshort *resultsArray = static_cast<jshort *>(curEnv->GetPrimitiveArrayCritical(res, &isCopy));
short* myArray= new short[ lenRow];

for (jsize i = 0; i <  lenRow; i++){
myArray[i]=resultsArray[i];
}
curEnv->ReleasePrimitiveArrayCritical(res, resultsArray, JNI_ABORT);

                        curEnv->DeleteLocalRef(res);
curEnv->DeleteLocalRef(cls);
if (curEnv->ExceptionCheck()) {
delete[] myArray;
                                throw GiwsException::JniCallMethodException(curEnv);
}
return myArray;

}

short** ScilabJavaObject::unwrapMatUByte (JavaVM * jvm_, int x){

JNIEnv * curEnv = NULL;
jvm_->AttachCurrentThread(reinterpret_cast<void **>(&curEnv), NULL);
jclass cls = curEnv->FindClass( className().c_str() );
if ( cls == NULL) {
throw GiwsException::JniCallMethodException(curEnv);
}

jmethodID jobjectArray__unwrapMatUBytejintintID = curEnv->GetStaticMethodID(cls, "unwrapMatUByte", "(I)[[S" ) ;
if (jobjectArray__unwrapMatUBytejintintID == NULL) {
throw GiwsException::JniMethodNotFoundException(curEnv, "unwrapMatUByte");
}

                        jobjectArray res =  static_cast<jobjectArray>( curEnv->CallStaticObjectMethod(cls, jobjectArray__unwrapMatUBytejintintID ,x));
                        if (res == NULL) { return NULL; }
                        if (curEnv->ExceptionCheck()) {
throw GiwsException::JniCallMethodException(curEnv);
}int lenCol;int lenRow;
 lenRow = curEnv->GetArrayLength(res);
jboolean isCopy = JNI_FALSE;

short ** myArray = new short*[ lenRow];
for(int i=0; i< lenRow; i++) {
jshortArray oneDim = (jshortArray)curEnv->GetObjectArrayElement(res, i);
 lenCol=curEnv->GetArrayLength(oneDim);
short *resultsArray = static_cast<short *>(curEnv->GetPrimitiveArrayCritical(oneDim, &isCopy));
myArray[i] = new short[ lenCol];
for(int j=0; j< lenCol; j++) {
myArray[i][j]= resultsArray[j];
}
curEnv->ReleasePrimitiveArrayCritical(res, resultsArray, JNI_ABORT);
}

curEnv->DeleteLocalRef(res);
curEnv->DeleteLocalRef(cls);
if (curEnv->ExceptionCheck()) {
delete[] myArray;
                                throw GiwsException::JniCallMethodException(curEnv);
}
return myArray;

}

short ScilabJavaObject::unwrapShort (JavaVM * jvm_, int x){

JNIEnv * curEnv = NULL;
jvm_->AttachCurrentThread(reinterpret_cast<void **>(&curEnv), NULL);
jclass cls = curEnv->FindClass( className().c_str() );
if ( cls == NULL) {
throw GiwsException::JniCallMethodException(curEnv);
}

jmethodID jshortunwrapShortjintintID = curEnv->GetStaticMethodID(cls, "unwrapShort", "(I)S" ) ;
if (jshortunwrapShortjintintID == NULL) {
throw GiwsException::JniMethodNotFoundException(curEnv, "unwrapShort");
}

                        jshort res =  static_cast<jshort>( curEnv->CallStaticShortMethod(cls, jshortunwrapShortjintintID ,x));
                        curEnv->DeleteLocalRef(cls);
if (curEnv->ExceptionCheck()) {
throw GiwsException::JniCallMethodException(curEnv);
}
return res;

}

short* ScilabJavaObject::unwrapRowShort (JavaVM * jvm_, int x){

JNIEnv * curEnv = NULL;
jvm_->AttachCurrentThread(reinterpret_cast<void **>(&curEnv), NULL);
jclass cls = curEnv->FindClass( className().c_str() );
if ( cls == NULL) {
throw GiwsException::JniCallMethodException(curEnv);
}

jmethodID jshortArray_unwrapRowShortjintintID = curEnv->GetStaticMethodID(cls, "unwrapRowShort", "(I)[S" ) ;
if (jshortArray_unwrapRowShortjintintID == NULL) {
throw GiwsException::JniMethodNotFoundException(curEnv, "unwrapRowShort");
}

                        jshortArray res =  static_cast<jshortArray>( curEnv->CallStaticObjectMethod(cls, jshortArray_unwrapRowShortjintintID ,x));
                        if (res == NULL) { return NULL; }
                        if (curEnv->ExceptionCheck()) {
throw GiwsException::JniCallMethodException(curEnv);
}int lenRow;
 lenRow = curEnv->GetArrayLength(res);
jboolean isCopy = JNI_FALSE;

/* GetPrimitiveArrayCritical is faster than getXXXArrayElements */
jshort *resultsArray = static_cast<jshort *>(curEnv->GetPrimitiveArrayCritical(res, &isCopy));
short* myArray= new short[ lenRow];

for (jsize i = 0; i <  lenRow; i++){
myArray[i]=resultsArray[i];
}
curEnv->ReleasePrimitiveArrayCritical(res, resultsArray, JNI_ABORT);

                        curEnv->DeleteLocalRef(res);
curEnv->DeleteLocalRef(cls);
if (curEnv->ExceptionCheck()) {
delete[] myArray;
                                throw GiwsException::JniCallMethodException(curEnv);
}
return myArray;

}

short** ScilabJavaObject::unwrapMatShort (JavaVM * jvm_, int x){

JNIEnv * curEnv = NULL;
jvm_->AttachCurrentThread(reinterpret_cast<void **>(&curEnv), NULL);
jclass cls = curEnv->FindClass( className().c_str() );
if ( cls == NULL) {
throw GiwsException::JniCallMethodException(curEnv);
}

jmethodID jobjectArray__unwrapMatShortjintintID = curEnv->GetStaticMethodID(cls, "unwrapMatShort", "(I)[[S" ) ;
if (jobjectArray__unwrapMatShortjintintID == NULL) {
throw GiwsException::JniMethodNotFoundException(curEnv, "unwrapMatShort");
}

                        jobjectArray res =  static_cast<jobjectArray>( curEnv->CallStaticObjectMethod(cls, jobjectArray__unwrapMatShortjintintID ,x));
                        if (res == NULL) { return NULL; }
                        if (curEnv->ExceptionCheck()) {
throw GiwsException::JniCallMethodException(curEnv);
}int lenCol;int lenRow;
 lenRow = curEnv->GetArrayLength(res);
jboolean isCopy = JNI_FALSE;

short ** myArray = new short*[ lenRow];
for(int i=0; i< lenRow; i++) {
jshortArray oneDim = (jshortArray)curEnv->GetObjectArrayElement(res, i);
 lenCol=curEnv->GetArrayLength(oneDim);
short *resultsArray = static_cast<short *>(curEnv->GetPrimitiveArrayCritical(oneDim, &isCopy));
myArray[i] = new short[ lenCol];
for(int j=0; j< lenCol; j++) {
myArray[i][j]= resultsArray[j];
}
curEnv->ReleasePrimitiveArrayCritical(res, resultsArray, JNI_ABORT);
}

curEnv->DeleteLocalRef(res);
curEnv->DeleteLocalRef(cls);
if (curEnv->ExceptionCheck()) {
delete[] myArray;
                                throw GiwsException::JniCallMethodException(curEnv);
}
return myArray;

}

int ScilabJavaObject::unwrapUShort (JavaVM * jvm_, int x){

JNIEnv * curEnv = NULL;
jvm_->AttachCurrentThread(reinterpret_cast<void **>(&curEnv), NULL);
jclass cls = curEnv->FindClass( className().c_str() );
if ( cls == NULL) {
throw GiwsException::JniCallMethodException(curEnv);
}

jmethodID jintunwrapUShortjintintID = curEnv->GetStaticMethodID(cls, "unwrapUShort", "(I)I" ) ;
if (jintunwrapUShortjintintID == NULL) {
throw GiwsException::JniMethodNotFoundException(curEnv, "unwrapUShort");
}

                        jint res =  static_cast<jint>( curEnv->CallStaticIntMethod(cls, jintunwrapUShortjintintID ,x));
                        curEnv->DeleteLocalRef(cls);
if (curEnv->ExceptionCheck()) {
throw GiwsException::JniCallMethodException(curEnv);
}
return res;

}

int* ScilabJavaObject::unwrapRowUShort (JavaVM * jvm_, int x){

JNIEnv * curEnv = NULL;
jvm_->AttachCurrentThread(reinterpret_cast<void **>(&curEnv), NULL);
jclass cls = curEnv->FindClass( className().c_str() );
if ( cls == NULL) {
throw GiwsException::JniCallMethodException(curEnv);
}

jmethodID jintArray_unwrapRowUShortjintintID = curEnv->GetStaticMethodID(cls, "unwrapRowUShort", "(I)[I" ) ;
if (jintArray_unwrapRowUShortjintintID == NULL) {
throw GiwsException::JniMethodNotFoundException(curEnv, "unwrapRowUShort");
}

                        jintArray res =  static_cast<jintArray>( curEnv->CallStaticObjectMethod(cls, jintArray_unwrapRowUShortjintintID ,x));
                        if (res == NULL) { return NULL; }
                        if (curEnv->ExceptionCheck()) {
throw GiwsException::JniCallMethodException(curEnv);
}int lenRow;
 lenRow = curEnv->GetArrayLength(res);
jboolean isCopy = JNI_FALSE;

/* GetPrimitiveArrayCritical is faster than getXXXArrayElements */
jint *resultsArray = static_cast<jint *>(curEnv->GetPrimitiveArrayCritical(res, &isCopy));
int* myArray= new int[ lenRow];

for (jsize i = 0; i <  lenRow; i++){
myArray[i]=resultsArray[i];
}
curEnv->ReleasePrimitiveArrayCritical(res, resultsArray, JNI_ABORT);

                        curEnv->DeleteLocalRef(res);
curEnv->DeleteLocalRef(cls);
if (curEnv->ExceptionCheck()) {
delete[] myArray;
                                throw GiwsException::JniCallMethodException(curEnv);
}
return myArray;

}

int** ScilabJavaObject::unwrapMatUShort (JavaVM * jvm_, int x){

JNIEnv * curEnv = NULL;
jvm_->AttachCurrentThread(reinterpret_cast<void **>(&curEnv), NULL);
jclass cls = curEnv->FindClass( className().c_str() );
if ( cls == NULL) {
throw GiwsException::JniCallMethodException(curEnv);
}

jmethodID jobjectArray__unwrapMatUShortjintintID = curEnv->GetStaticMethodID(cls, "unwrapMatUShort", "(I)[[I" ) ;
if (jobjectArray__unwrapMatUShortjintintID == NULL) {
throw GiwsException::JniMethodNotFoundException(curEnv, "unwrapMatUShort");
}

                        jobjectArray res =  static_cast<jobjectArray>( curEnv->CallStaticObjectMethod(cls, jobjectArray__unwrapMatUShortjintintID ,x));
                        if (res == NULL) { return NULL; }
                        if (curEnv->ExceptionCheck()) {
throw GiwsException::JniCallMethodException(curEnv);
}int lenCol;int lenRow;
 lenRow = curEnv->GetArrayLength(res);
jboolean isCopy = JNI_FALSE;

int ** myArray = new int*[ lenRow];
for(int i=0; i< lenRow; i++) {
jintArray oneDim = (jintArray)curEnv->GetObjectArrayElement(res, i);
 lenCol=curEnv->GetArrayLength(oneDim);
int *resultsArray = static_cast<int *>(curEnv->GetPrimitiveArrayCritical(oneDim, &isCopy));
myArray[i] = new int[ lenCol];
for(int j=0; j< lenCol; j++) {
myArray[i][j]= resultsArray[j];
}
curEnv->ReleasePrimitiveArrayCritical(res, resultsArray, JNI_ABORT);
}

curEnv->DeleteLocalRef(res);
curEnv->DeleteLocalRef(cls);
if (curEnv->ExceptionCheck()) {
delete[] myArray;
                                throw GiwsException::JniCallMethodException(curEnv);
}
return myArray;

}

char* ScilabJavaObject::unwrapString (JavaVM * jvm_, int x){

JNIEnv * curEnv = NULL;
jvm_->AttachCurrentThread(reinterpret_cast<void **>(&curEnv), NULL);
jclass cls = curEnv->FindClass( className().c_str() );
if ( cls == NULL) {
throw GiwsException::JniCallMethodException(curEnv);
}

jmethodID jstringunwrapStringjintintID = curEnv->GetStaticMethodID(cls, "unwrapString", "(I)Ljava/lang/String;" ) ;
if (jstringunwrapStringjintintID == NULL) {
throw GiwsException::JniMethodNotFoundException(curEnv, "unwrapString");
}

                        jstring res =  static_cast<jstring>( curEnv->CallStaticObjectMethod(cls, jstringunwrapStringjintintID ,x));
                        if (curEnv->ExceptionCheck()) {
throw GiwsException::JniCallMethodException(curEnv);
}if (res != NULL) { 

const char *tempString = curEnv->GetStringUTFChars(res, 0);
char * myStringBuffer = new char[strlen(tempString) + 1];
strcpy(myStringBuffer, tempString);
curEnv->ReleaseStringUTFChars(res, tempString);
curEnv->DeleteLocalRef(res);
curEnv->DeleteLocalRef(cls);
if (curEnv->ExceptionCheck()) {
delete[] myStringBuffer;
                                throw GiwsException::JniCallMethodException(curEnv);
}
return myStringBuffer;
 } else { 
curEnv->DeleteLocalRef(res);
return NULL;
}
}

char** ScilabJavaObject::unwrapRowString (JavaVM * jvm_, int x){

JNIEnv * curEnv = NULL;
jvm_->AttachCurrentThread(reinterpret_cast<void **>(&curEnv), NULL);
jclass cls = curEnv->FindClass( className().c_str() );
if ( cls == NULL) {
throw GiwsException::JniCallMethodException(curEnv);
}

jmethodID jobjectArray_unwrapRowStringjintintID = curEnv->GetStaticMethodID(cls, "unwrapRowString", "(I)[Ljava/lang/String;" ) ;
if (jobjectArray_unwrapRowStringjintintID == NULL) {
throw GiwsException::JniMethodNotFoundException(curEnv, "unwrapRowString");
}

                        jobjectArray res =  static_cast<jobjectArray>( curEnv->CallStaticObjectMethod(cls, jobjectArray_unwrapRowStringjintintID ,x));
                        if (curEnv->ExceptionCheck()) {
throw GiwsException::JniCallMethodException(curEnv);
}if (res != NULL) { int lenRow;
 lenRow = curEnv->GetArrayLength(res);

char **arrayOfString;
arrayOfString = new char *[lenRow];
for (jsize i = 0; i < lenRow; i++){
jstring resString = reinterpret_cast<jstring>(curEnv->GetObjectArrayElement(res, i));
const char *tempString = curEnv->GetStringUTFChars(resString, 0);
arrayOfString[i] = new char[strlen(tempString) + 1];

strcpy(arrayOfString[i], tempString);
curEnv->ReleaseStringUTFChars(resString, tempString);
curEnv->DeleteLocalRef(resString);
}
curEnv->DeleteLocalRef(cls);
if (curEnv->ExceptionCheck()) {
delete[] arrayOfString;
                                throw GiwsException::JniCallMethodException(curEnv);
}
curEnv->DeleteLocalRef(res);
return arrayOfString;
 } else { 
curEnv->DeleteLocalRef(res);
return NULL;
}
}

char*** ScilabJavaObject::unwrapMatString (JavaVM * jvm_, int x){

JNIEnv * curEnv = NULL;
jvm_->AttachCurrentThread(reinterpret_cast<void **>(&curEnv), NULL);
jclass cls = curEnv->FindClass( className().c_str() );
if ( cls == NULL) {
throw GiwsException::JniCallMethodException(curEnv);
}

jmethodID jobjectArray__unwrapMatStringjintintID = curEnv->GetStaticMethodID(cls, "unwrapMatString", "(I)[[Ljava/lang/String;" ) ;
if (jobjectArray__unwrapMatStringjintintID == NULL) {
throw GiwsException::JniMethodNotFoundException(curEnv, "unwrapMatString");
}

                        jobjectArray res =  static_cast<jobjectArray>( curEnv->CallStaticObjectMethod(cls, jobjectArray__unwrapMatStringjintintID ,x));
                        if (curEnv->ExceptionCheck()) {
throw GiwsException::JniCallMethodException(curEnv);
}if (res != NULL) { int lenCol;int lenRow;
 lenRow = curEnv->GetArrayLength(res);

char ***arrayOfString;
arrayOfString = new char **[lenRow];
for (jsize i = 0; i < lenRow; i++){ /* Line of the array */
jobjectArray resStringLine = reinterpret_cast<jobjectArray>(curEnv->GetObjectArrayElement(res, i));
lenCol = curEnv->GetArrayLength(resStringLine);
arrayOfString[i]=new char*[lenCol];
for (jsize j = 0; j < lenCol; j++){
jstring resString = reinterpret_cast<jstring>(curEnv->GetObjectArrayElement(resStringLine, j));
const char *tempString = curEnv->GetStringUTFChars(resString, 0);
arrayOfString[i][j] = new char[strlen(tempString) + 1];
strcpy(arrayOfString[i][j], tempString);
curEnv->ReleaseStringUTFChars(resString, tempString);
curEnv->DeleteLocalRef(resString);
}
curEnv->DeleteLocalRef(resStringLine);
 }
curEnv->DeleteLocalRef(cls);
if (curEnv->ExceptionCheck()) {
delete[] arrayOfString;
                                throw GiwsException::JniCallMethodException(curEnv);
}
curEnv->DeleteLocalRef(res);
return arrayOfString;
 } else { 
curEnv->DeleteLocalRef(res);
return NULL;
}
}

bool ScilabJavaObject::unwrapBoolean (JavaVM * jvm_, int x){

JNIEnv * curEnv = NULL;
jvm_->AttachCurrentThread(reinterpret_cast<void **>(&curEnv), NULL);
jclass cls = curEnv->FindClass( className().c_str() );
if ( cls == NULL) {
throw GiwsException::JniCallMethodException(curEnv);
}

jmethodID jbooleanunwrapBooleanjintintID = curEnv->GetStaticMethodID(cls, "unwrapBoolean", "(I)Z" ) ;
if (jbooleanunwrapBooleanjintintID == NULL) {
throw GiwsException::JniMethodNotFoundException(curEnv, "unwrapBoolean");
}

                        jboolean res =  static_cast<jboolean>( curEnv->CallStaticBooleanMethod(cls, jbooleanunwrapBooleanjintintID ,x));
                        curEnv->DeleteLocalRef(cls);
if (curEnv->ExceptionCheck()) {
throw GiwsException::JniCallMethodException(curEnv);
}
return (res == JNI_TRUE);

}

bool* ScilabJavaObject::unwrapRowBoolean (JavaVM * jvm_, int x){

JNIEnv * curEnv = NULL;
jvm_->AttachCurrentThread(reinterpret_cast<void **>(&curEnv), NULL);
jclass cls = curEnv->FindClass( className().c_str() );
if ( cls == NULL) {
throw GiwsException::JniCallMethodException(curEnv);
}

jmethodID jbooleanArray_unwrapRowBooleanjintintID = curEnv->GetStaticMethodID(cls, "unwrapRowBoolean", "(I)[Z" ) ;
if (jbooleanArray_unwrapRowBooleanjintintID == NULL) {
throw GiwsException::JniMethodNotFoundException(curEnv, "unwrapRowBoolean");
}

                        jbooleanArray res =  static_cast<jbooleanArray>( curEnv->CallStaticObjectMethod(cls, jbooleanArray_unwrapRowBooleanjintintID ,x));
                        if (curEnv->ExceptionCheck()) {
throw GiwsException::JniCallMethodException(curEnv);
}int *lenRow;                   
*lenRow = curEnv->GetArrayLength(res);
jboolean isCopy = JNI_FALSE;


/* faster than getXXXArrayElements */
jboolean *resultsArray = static_cast<jboolean *>(curEnv->GetPrimitiveArrayCritical(res, &isCopy));
bool * myArray= new bool[*lenRow];

for (jsize i = 0; i < *lenRow; i++){
myArray[i]=(resultsArray[i] == JNI_TRUE);
}
curEnv->ReleasePrimitiveArrayCritical(res, resultsArray, JNI_ABORT);

curEnv->DeleteLocalRef(res);
curEnv->DeleteLocalRef(cls);
if (curEnv->ExceptionCheck()) {
delete[] myArray;
                                throw GiwsException::JniCallMethodException(curEnv);
}
return myArray;

}

bool** ScilabJavaObject::unwrapMatBoolean (JavaVM * jvm_, int x){

JNIEnv * curEnv = NULL;
jvm_->AttachCurrentThread(reinterpret_cast<void **>(&curEnv), NULL);
jclass cls = curEnv->FindClass( className().c_str() );
if ( cls == NULL) {
throw GiwsException::JniCallMethodException(curEnv);
}

jmethodID jobjectArray__unwrapMatBooleanjintintID = curEnv->GetStaticMethodID(cls, "unwrapMatBoolean", "(I)[[Z" ) ;
if (jobjectArray__unwrapMatBooleanjintintID == NULL) {
throw GiwsException::JniMethodNotFoundException(curEnv, "unwrapMatBoolean");
}

                        jobjectArray res =  static_cast<jobjectArray>( curEnv->CallStaticObjectMethod(cls, jobjectArray__unwrapMatBooleanjintintID ,x));
                        if (curEnv->ExceptionCheck()) {
throw GiwsException::JniCallMethodException(curEnv);
}int *lenCol;int *lenRow;                   
*lenRow = curEnv->GetArrayLength(res);
jboolean isCopy = JNI_FALSE;

bool ** myArray = new bool*[*lenRow];
for(int i=0; i<*lenRow; i++) {
jbooleanArray oneDim = (jbooleanArray)curEnv->GetObjectArrayElement(res, i);
*lenCol=curEnv->GetArrayLength(oneDim);
bool *resultsArray = static_cast<bool *>(curEnv->GetPrimitiveArrayCritical(oneDim, &isCopy));
myArray[i] = new bool[*lenCol];
for(int j=0; j<*lenCol; j++) {
myArray[i][j]=(resultsArray[j] == JNI_TRUE);
}
curEnv->ReleasePrimitiveArrayCritical(res, resultsArray, JNI_ABORT);
}
 
curEnv->DeleteLocalRef(res);
curEnv->DeleteLocalRef(cls);
if (curEnv->ExceptionCheck()) {
delete[] myArray;
                                throw GiwsException::JniCallMethodException(curEnv);
}
return myArray;

}

unsigned short ScilabJavaObject::unwrapChar (JavaVM * jvm_, int x){

JNIEnv * curEnv = NULL;
jvm_->AttachCurrentThread(reinterpret_cast<void **>(&curEnv), NULL);
jclass cls = curEnv->FindClass( className().c_str() );
if ( cls == NULL) {
throw GiwsException::JniCallMethodException(curEnv);
}

jmethodID jcharunwrapCharjintintID = curEnv->GetStaticMethodID(cls, "unwrapChar", "(I)C" ) ;
if (jcharunwrapCharjintintID == NULL) {
throw GiwsException::JniMethodNotFoundException(curEnv, "unwrapChar");
}

                        jchar res =  static_cast<jchar>( curEnv->CallStaticCharMethod(cls, jcharunwrapCharjintintID ,x));
                        curEnv->DeleteLocalRef(cls);
if (curEnv->ExceptionCheck()) {
throw GiwsException::JniCallMethodException(curEnv);
}
return res;

}

unsigned short* ScilabJavaObject::unwrapRowChar (JavaVM * jvm_, int x){

JNIEnv * curEnv = NULL;
jvm_->AttachCurrentThread(reinterpret_cast<void **>(&curEnv), NULL);
jclass cls = curEnv->FindClass( className().c_str() );
if ( cls == NULL) {
throw GiwsException::JniCallMethodException(curEnv);
}

jmethodID jcharArray_unwrapRowCharjintintID = curEnv->GetStaticMethodID(cls, "unwrapRowChar", "(I)[C" ) ;
if (jcharArray_unwrapRowCharjintintID == NULL) {
throw GiwsException::JniMethodNotFoundException(curEnv, "unwrapRowChar");
}

                        jcharArray res =  static_cast<jcharArray>( curEnv->CallStaticObjectMethod(cls, jcharArray_unwrapRowCharjintintID ,x));
                        if (res == NULL) { return NULL; }
                        if (curEnv->ExceptionCheck()) {
throw GiwsException::JniCallMethodException(curEnv);
}int lenRow;
 lenRow = curEnv->GetArrayLength(res);
jboolean isCopy = JNI_FALSE;

/* GetPrimitiveArrayCritical is faster than getXXXArrayElements */
jchar *resultsArray = static_cast<jchar *>(curEnv->GetPrimitiveArrayCritical(res, &isCopy));
unsigned short* myArray= new unsigned short[ lenRow];

for (jsize i = 0; i <  lenRow; i++){
myArray[i]=resultsArray[i];
}
curEnv->ReleasePrimitiveArrayCritical(res, resultsArray, JNI_ABORT);

                        curEnv->DeleteLocalRef(res);
curEnv->DeleteLocalRef(cls);
if (curEnv->ExceptionCheck()) {
delete[] myArray;
                                throw GiwsException::JniCallMethodException(curEnv);
}
return myArray;

}

unsigned short** ScilabJavaObject::unwrapMatChar (JavaVM * jvm_, int x){

JNIEnv * curEnv = NULL;
jvm_->AttachCurrentThread(reinterpret_cast<void **>(&curEnv), NULL);
jclass cls = curEnv->FindClass( className().c_str() );
if ( cls == NULL) {
throw GiwsException::JniCallMethodException(curEnv);
}

jmethodID jobjectArray__unwrapMatCharjintintID = curEnv->GetStaticMethodID(cls, "unwrapMatChar", "(I)[[C" ) ;
if (jobjectArray__unwrapMatCharjintintID == NULL) {
throw GiwsException::JniMethodNotFoundException(curEnv, "unwrapMatChar");
}

                        jobjectArray res =  static_cast<jobjectArray>( curEnv->CallStaticObjectMethod(cls, jobjectArray__unwrapMatCharjintintID ,x));
                        if (res == NULL) { return NULL; }
                        if (curEnv->ExceptionCheck()) {
throw GiwsException::JniCallMethodException(curEnv);
}int lenCol;int lenRow;
 lenRow = curEnv->GetArrayLength(res);
jboolean isCopy = JNI_FALSE;

unsigned short ** myArray = new unsigned short*[ lenRow];
for(int i=0; i< lenRow; i++) {
jcharArray oneDim = (jcharArray)curEnv->GetObjectArrayElement(res, i);
 lenCol=curEnv->GetArrayLength(oneDim);
unsigned short *resultsArray = static_cast<unsigned short *>(curEnv->GetPrimitiveArrayCritical(oneDim, &isCopy));
myArray[i] = new unsigned short[ lenCol];
for(int j=0; j< lenCol; j++) {
myArray[i][j]= resultsArray[j];
}
curEnv->ReleasePrimitiveArrayCritical(res, resultsArray, JNI_ABORT);
}

curEnv->DeleteLocalRef(res);
curEnv->DeleteLocalRef(cls);
if (curEnv->ExceptionCheck()) {
delete[] myArray;
                                throw GiwsException::JniCallMethodException(curEnv);
}
return myArray;

}

float ScilabJavaObject::unwrapFloat (JavaVM * jvm_, int x){

JNIEnv * curEnv = NULL;
jvm_->AttachCurrentThread(reinterpret_cast<void **>(&curEnv), NULL);
jclass cls = curEnv->FindClass( className().c_str() );
if ( cls == NULL) {
throw GiwsException::JniCallMethodException(curEnv);
}

jmethodID jfloatunwrapFloatjintintID = curEnv->GetStaticMethodID(cls, "unwrapFloat", "(I)F" ) ;
if (jfloatunwrapFloatjintintID == NULL) {
throw GiwsException::JniMethodNotFoundException(curEnv, "unwrapFloat");
}

                        jfloat res =  static_cast<jfloat>( curEnv->CallStaticFloatMethod(cls, jfloatunwrapFloatjintintID ,x));
                        curEnv->DeleteLocalRef(cls);
if (curEnv->ExceptionCheck()) {
throw GiwsException::JniCallMethodException(curEnv);
}
return res;

}

float* ScilabJavaObject::unwrapRowFloat (JavaVM * jvm_, int x){

JNIEnv * curEnv = NULL;
jvm_->AttachCurrentThread(reinterpret_cast<void **>(&curEnv), NULL);
jclass cls = curEnv->FindClass( className().c_str() );
if ( cls == NULL) {
throw GiwsException::JniCallMethodException(curEnv);
}

jmethodID jfloatArray_unwrapRowFloatjintintID = curEnv->GetStaticMethodID(cls, "unwrapRowFloat", "(I)[F" ) ;
if (jfloatArray_unwrapRowFloatjintintID == NULL) {
throw GiwsException::JniMethodNotFoundException(curEnv, "unwrapRowFloat");
}

                        jfloatArray res =  static_cast<jfloatArray>( curEnv->CallStaticObjectMethod(cls, jfloatArray_unwrapRowFloatjintintID ,x));
                        if (res == NULL) { return NULL; }
                        if (curEnv->ExceptionCheck()) {
throw GiwsException::JniCallMethodException(curEnv);
}int lenRow;
 lenRow = curEnv->GetArrayLength(res);
jboolean isCopy = JNI_FALSE;

/* GetPrimitiveArrayCritical is faster than getXXXArrayElements */
jfloat *resultsArray = static_cast<jfloat *>(curEnv->GetPrimitiveArrayCritical(res, &isCopy));
float* myArray= new float[ lenRow];

for (jsize i = 0; i <  lenRow; i++){
myArray[i]=resultsArray[i];
}
curEnv->ReleasePrimitiveArrayCritical(res, resultsArray, JNI_ABORT);

                        curEnv->DeleteLocalRef(res);
curEnv->DeleteLocalRef(cls);
if (curEnv->ExceptionCheck()) {
delete[] myArray;
                                throw GiwsException::JniCallMethodException(curEnv);
}
return myArray;

}

float** ScilabJavaObject::unwrapMatFloat (JavaVM * jvm_, int x){

JNIEnv * curEnv = NULL;
jvm_->AttachCurrentThread(reinterpret_cast<void **>(&curEnv), NULL);
jclass cls = curEnv->FindClass( className().c_str() );
if ( cls == NULL) {
throw GiwsException::JniCallMethodException(curEnv);
}

jmethodID jobjectArray__unwrapMatFloatjintintID = curEnv->GetStaticMethodID(cls, "unwrapMatFloat", "(I)[[F" ) ;
if (jobjectArray__unwrapMatFloatjintintID == NULL) {
throw GiwsException::JniMethodNotFoundException(curEnv, "unwrapMatFloat");
}

                        jobjectArray res =  static_cast<jobjectArray>( curEnv->CallStaticObjectMethod(cls, jobjectArray__unwrapMatFloatjintintID ,x));
                        if (res == NULL) { return NULL; }
                        if (curEnv->ExceptionCheck()) {
throw GiwsException::JniCallMethodException(curEnv);
}int lenCol;int lenRow;
 lenRow = curEnv->GetArrayLength(res);
jboolean isCopy = JNI_FALSE;

float ** myArray = new float*[ lenRow];
for(int i=0; i< lenRow; i++) {
jfloatArray oneDim = (jfloatArray)curEnv->GetObjectArrayElement(res, i);
 lenCol=curEnv->GetArrayLength(oneDim);
float *resultsArray = static_cast<float *>(curEnv->GetPrimitiveArrayCritical(oneDim, &isCopy));
myArray[i] = new float[ lenCol];
for(int j=0; j< lenCol; j++) {
myArray[i][j]= resultsArray[j];
}
curEnv->ReleasePrimitiveArrayCritical(res, resultsArray, JNI_ABORT);
}

curEnv->DeleteLocalRef(res);
curEnv->DeleteLocalRef(cls);
if (curEnv->ExceptionCheck()) {
delete[] myArray;
                                throw GiwsException::JniCallMethodException(curEnv);
}
return myArray;

}

long long ScilabJavaObject::unwrapLong (JavaVM * jvm_, int x){

JNIEnv * curEnv = NULL;
jvm_->AttachCurrentThread(reinterpret_cast<void **>(&curEnv), NULL);
jclass cls = curEnv->FindClass( className().c_str() );
if ( cls == NULL) {
throw GiwsException::JniCallMethodException(curEnv);
}

jmethodID jlongunwrapLongjintintID = curEnv->GetStaticMethodID(cls, "unwrapLong", "(I)J" ) ;
if (jlongunwrapLongjintintID == NULL) {
throw GiwsException::JniMethodNotFoundException(curEnv, "unwrapLong");
}

                        jlong res =  static_cast<jlong>( curEnv->CallStaticLongMethod(cls, jlongunwrapLongjintintID ,x));
                        curEnv->DeleteLocalRef(cls);
if (curEnv->ExceptionCheck()) {
throw GiwsException::JniCallMethodException(curEnv);
}
return res;

}

long long* ScilabJavaObject::unwrapRowLong (JavaVM * jvm_, int x){

JNIEnv * curEnv = NULL;
jvm_->AttachCurrentThread(reinterpret_cast<void **>(&curEnv), NULL);
jclass cls = curEnv->FindClass( className().c_str() );
if ( cls == NULL) {
throw GiwsException::JniCallMethodException(curEnv);
}

jmethodID jlongArray_unwrapRowLongjintintID = curEnv->GetStaticMethodID(cls, "unwrapRowLong", "(I)[J" ) ;
if (jlongArray_unwrapRowLongjintintID == NULL) {
throw GiwsException::JniMethodNotFoundException(curEnv, "unwrapRowLong");
}

                        jlongArray res =  static_cast<jlongArray>( curEnv->CallStaticObjectMethod(cls, jlongArray_unwrapRowLongjintintID ,x));
                        if (res == NULL) { return NULL; }
                        if (curEnv->ExceptionCheck()) {
throw GiwsException::JniCallMethodException(curEnv);
}int lenRow;
 lenRow = curEnv->GetArrayLength(res);
jboolean isCopy = JNI_FALSE;

/* GetPrimitiveArrayCritical is faster than getXXXArrayElements */
jlong *resultsArray = static_cast<jlong *>(curEnv->GetPrimitiveArrayCritical(res, &isCopy));
long long* myArray= new long long[ lenRow];

for (jsize i = 0; i <  lenRow; i++){
myArray[i]=resultsArray[i];
}
curEnv->ReleasePrimitiveArrayCritical(res, resultsArray, JNI_ABORT);

                        curEnv->DeleteLocalRef(res);
curEnv->DeleteLocalRef(cls);
if (curEnv->ExceptionCheck()) {
delete[] myArray;
                                throw GiwsException::JniCallMethodException(curEnv);
}
return myArray;

}

long long** ScilabJavaObject::unwrapMatLong (JavaVM * jvm_, int x){

JNIEnv * curEnv = NULL;
jvm_->AttachCurrentThread(reinterpret_cast<void **>(&curEnv), NULL);
jclass cls = curEnv->FindClass( className().c_str() );
if ( cls == NULL) {
throw GiwsException::JniCallMethodException(curEnv);
}

jmethodID jobjectArray__unwrapMatLongjintintID = curEnv->GetStaticMethodID(cls, "unwrapMatLong", "(I)[[J" ) ;
if (jobjectArray__unwrapMatLongjintintID == NULL) {
throw GiwsException::JniMethodNotFoundException(curEnv, "unwrapMatLong");
}

                        jobjectArray res =  static_cast<jobjectArray>( curEnv->CallStaticObjectMethod(cls, jobjectArray__unwrapMatLongjintintID ,x));
                        if (res == NULL) { return NULL; }
                        if (curEnv->ExceptionCheck()) {
throw GiwsException::JniCallMethodException(curEnv);
}int lenCol;int lenRow;
 lenRow = curEnv->GetArrayLength(res);
jboolean isCopy = JNI_FALSE;

long long ** myArray = new long long*[ lenRow];
for(int i=0; i< lenRow; i++) {
jlongArray oneDim = (jlongArray)curEnv->GetObjectArrayElement(res, i);
 lenCol=curEnv->GetArrayLength(oneDim);
long long *resultsArray = static_cast<long long *>(curEnv->GetPrimitiveArrayCritical(oneDim, &isCopy));
myArray[i] = new long long[ lenCol];
for(int j=0; j< lenCol; j++) {
myArray[i][j]= resultsArray[j];
}
curEnv->ReleasePrimitiveArrayCritical(res, resultsArray, JNI_ABORT);
}

curEnv->DeleteLocalRef(res);
curEnv->DeleteLocalRef(cls);
if (curEnv->ExceptionCheck()) {
delete[] myArray;
                                throw GiwsException::JniCallMethodException(curEnv);
}
return myArray;

}

}
