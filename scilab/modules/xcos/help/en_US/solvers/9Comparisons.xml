<?xml version="1.0" encoding="UTF-8"?>
<!--
 * Scilab ( http://www.scilab.org/ ) - This file is part of Scilab
 * Copyright (C) Scilab Enterprises - 2012 - Paul Bignier
 *
 * This file must be used under the terms of the CeCILL.
 * This source file is licensed as described in the file COPYING, which
 * you should have received as part of this distribution.
 * The terms are also available at
 * http://www.cecill.info/licences/Licence_CeCILL_V2-en.txt
 -->
<refentry xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:svg="http://www.w3.org/2000/svg"  xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:db="http://docbook.org/ns/docbook" xmlns:scilab="http://www.scilab.org" xml:lang="en_US" xml:id="Comparisons">
    <refnamediv>
        <refname>Comparisons</refname>
        <refpurpose>
            This page compares solvers to determine which one is best fitted for the studied problem.
        </refpurpose>
    </refnamediv>
    <refsection>
        <title>Introduction</title>
        <para>
            Following the type of problem studied, finding out which method to use is not always obvious, only genereal guidelines can be established. Those are and discussed in this page.
        </para>
        <title>Stiffness</title>
        <para>
            The solvers can be divided into two distinct main families : the <emphasis>Variable</emphasis>-size and the <emphasis>Fixed</emphasis>-size step methods.
        </para>
        <para>
            They both compute the next simulation time as the sum of the current simulation time and a quantity known as the step size, which is constant in the Fixed-size solvers and can change in the Variable-size ones, depending on the model dynamics and the input <link linkend="Simulatemenu_Menu_entries">tolerances</link>.
        </para>
        <para>
            If looking for stable computation time, the user should select a Fixed-size step solver, because the computation overhead for a Variable-size step method cannot be properly foreseen.
        </para>
        <para>
            Although for a simple problem (or loose tolerances) a Variable-size solver can significantly improve the simulation time by computing higher step sizes, a Fixed-size method is preferable if the ideal step size is known and roughly constant (the user should then mention it in <link linkend="Simulatemenu_Menu_entries">max step size</link>).
        </para>
        <para>
            The family choice is usually determined by the <emphasis>stiffness</emphasis> of the problem. That concept is not steady enough to be mathematically defined, but is generally a system that is sensitive to discontinuitues, meaning that the required precision is not constant.
        </para>
        <para>
            <!--<informaltable border="1">
                <tr>
                <td align="center"><emphasis role="bold">Variable</emphasis></td>
                <td align="center"><emphasis role="bold">Fixed</emphasis></td>
                </tr>
                <tr>
                <td>LSodar</td>
                <td>Runge-Kutta</td>
                </tr>
                <tr>
                <td>CVode</td>
                <td>Dormand-Price</td>
                </tr>
                <tr>
                <td>IDA</td>
                <td>Implicit Runge-Kutta</td>
                </tr>
            </informaltable>-->
            <emphasis role="bold">Variable</emphasis>-size step solvers :
            <simplelist>
                <member>LSodar</member>
                <member>CVode</member>
                <member>IDA</member>
            </simplelist>
            <emphasis role="bold">Fixed</emphasis>-size step solvers :
            <simplelist>
                <member>Runge-Kutta 4(5)</member>
                <member>Dormand-Price 4(5)</member>
                <member>Implicit Runge-Kutta 4(5)</member>
            </simplelist>
        </para>
        <para>
            Within these two families, we can distinguish <emphasis>Explicit</emphasis> solvers from <emphasis>Implicit</emphasis> ones.
        </para>
        <para>
            While <emphasis>explicit</emphasis> methods only use data available on the current step, the <emphasis>implicit</emphasis> ones will attempt to compute derivatives at further times. In order to do this, they use nonlinear solvers such as fixed-point iterations, functional iterations (nonstiff) or modified Newton methods (stiff).
        </para>
        <para>
            <emphasis role="bold">Implicit</emphasis> solvers :
            <simplelist>
                <member>LSodar</member>
                <member>CVode</member>
                <member>IDA</member>
                <member>Implicit Runge-Kutta 4(5)</member>
            </simplelist>
            <emphasis role="bold">Explicit</emphasis> solvers :
            <simplelist>
                <member>Runge-Kutta 4(5)</member>
                <member>Dormand-Price 4(5)</member>
            </simplelist>
        </para>
        <para>
            To put it simply, the <emphasis>Explicit</emphasis> go straight to a computation of the solution, whereas the <emphasis>Implicit</emphasis> concentrate on stability, involving more operations, following the tolerances.
        </para>
        <title>So how to choose ?</title>
        <para>
            Because it is not possible to know for sure wether a solver will be efficient for a given system or not, the best way is to run the most probable on it and to compare their results.
        </para>
        <para>
            Simple systems will be best simulated by <emphasis>Fixed-size step Explicit</emphasis> solvers, whereas complex oscillatory systems are likely to run best under <emphasis>Variable-size step Implicit</emphasis> ones.
        </para>
    </refsection>
    <refsection>
        <title>Examples</title>
        <para>
            We will begin with a simple nonstiff example : a Sinus integration.
            <link type="scilab" linkend="scilab.xcos/xcos/examples/solvers/ODE_Example.xcos">
                <inlinemediaobject>
                    <imageobject>
                        <imagedata align="center" fileref="../../../examples/solvers/ODE_Example.xcos" valign="middle"/>
                    </imageobject>
                </inlinemediaobject>
            </link>
            <scilab:image><![CDATA[
loadScicos();
loadXcosLibs();
importXcosDiagram(SCI + "/modules/xcos/examples/solvers/ODE_Example.xcos");
scs_m.props.tol(6) = 5;
scs_m.props.tol(7) = 10^-2;
try xcos_simulate(scs_m, 4); catch disp(lasterror()); end;
]]></scilab:image>
        </para>
        <para>
            In the following script, we compare the time difference between Runge-Kutta and Sundials by running the example with the five solvers in turn :
            <link type="scilab" linkend ="scilab.scinotes/xcos/examples/solvers/integRK.sce">
                Open the script
            </link>
        </para>
        <para>
            <screen><![CDATA[
Time for BDF / Newton :
 25.457

Time for BDF / Functional :
 24.893

Time for Adams / Functional :
 20.049

Time for Adams / Newton :
 20.469

Time for Runge-Kutta :
 18.254
            ]]></screen>
        </para>
        <para>
            These results show that on a nonstiff problem, for relatively same precision required and forcing the same step size, Runge-Kutta is faster.
        </para>
        <para>
            Variable step-size ODE solvers are not appropriate for deterministic real-time applications because the computational overhead of taking a time step varies over the course of an application.
        </para>
    </refsection>
    <refsection>
        <title>See Also</title>
        <simplelist type="inline">
            <member>
                <link linkend="LSodar">LSodar</link>
            </member>
            <member>
                <link linkend="CVode">CVode</link>
            </member>
            <member>
                <link linkend="IDA">IDA</link>
            </member>
            <member>
                <link linkend="RK">Runge-Kutta 4(5)</link>
            </member>
            <member>
                <link linkend="DoPri">Dormand-Price 4(5)</link>
            </member>
            <member>
                <link linkend="ode">ode</link>
            </member>
            <member>
                <link linkend="ode_discrete">ode_discrete</link>
            </member>
            <member>
                <link linkend="ode_root">ode_root</link>
            </member>
            <member>
                <link linkend="odedc">odedc</link>
            </member>
            <member>
                <link linkend="impl">impl</link>
            </member>
        </simplelist>
    </refsection>
</refentry>
