<?xml version="1.0" encoding="UTF-8"?>
<!--
 * Scilab ( http://www.scilab.org/ ) - This file is part of Scilab
 * Copyright (C) Scilab Enterprises - 2012 - Paul Bignier
 *
 * This file must be used under the terms of the CeCILL.
 * This source file is licensed as described in the file COPYING, which
 * you should have received as part of this distribution.
 * The terms are also available at
 * http://www.cecill.info/licences/Licence_CeCILL_V2-en.txt
 -->
<refentry xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:svg="http://www.w3.org/2000/svg"  xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:db="http://docbook.org/ns/docbook" xmlns:scilab="http://www.scilab.org" xml:lang="en_US" xml:id="LSodar">
    <refnamediv>
        <refname>LSodar</refname>
        <refpurpose>
            LSODAR (short for Livermore Solver for Ordinary Differential equations, with Automatic method switching for stiff and nonstiff problems, and with Root-finding) is a numerical solver providing an efficient and stable method to solve Ordinary Differential Equations (ODEs) Initial Value Problems. Called by <link linkend="xcos">xcos</link>.
        </refpurpose>
    </refnamediv>
    <refsection>
        <title>Description</title>
        <para>
            LSODAR (short for Livermore Solver for Ordinary Differential equations, with Automatic method switching for stiff and nonstiff problems, and with Root-finding) is a numerical solver providing an efficient and stable variable-size step method to solve Initial Value Problems of the form :
        </para>
        <para>
            <latex>
                \begin{eqnarray}
                \dot{y} = f(t,y), \hspace{3 mm} y(t_0) = y_0, \hspace{3 mm} y \in R^N
                \end{eqnarray}
            </latex>
        </para>
        <para>
            LSodar is similar to <emphasis>CVode</emphasis> in many ways.
        </para>
        <para>
            <itemizedlist>
                <listitem>
                    It uses variable-size steps,
                </listitem>
                <listitem>
                    It can potentially use <emphasis>BDF</emphasis> and <emphasis>Adams</emphasis> integration methods,
                </listitem>
                <listitem>
                    They both look for roots over the integration interval.
                </listitem>
            </itemizedlist>
        </para>
        <para>
            The main difference though is that <emphasis>LSodar</emphasis> is fully automated, and chooses between <emphasis>BDF</emphasis> and <emphasis>Adams</emphasis> itself, by checking for stiffness at every step.
        </para>
        <para>
            A drawback of that is the unpredictable computation time. With DoPri, we do not adapt to the complexity of the problem, but we guarantee a stable computation time.
        </para>
        <para>
            As of now, this method is explicit, so it is not concerned with Newton or Functional iterations, and not advised for stiff problems.
        </para>
        <para>
            It is an enhancement of the Euler method, which approximates 
            <emphasis>
                y<subscript>n+1</subscript>
            </emphasis>
            by truncating the Taylor expansion.
        </para>
        <para>
            By convention, to use fixed-size steps, the program first computes a fitting <emphasis>h</emphasis> that approaches the simulation parameter <link linkend="Simulatemenu_Menu_entries">max step size</link>.
        </para>
        <para>
            An important difference of DoPri with the previous methods is that it computes up to the seventh derivative of <emphasis>y</emphasis>, while the others only use linear combinations of <emphasis>y</emphasis> and <emphasis>y'</emphasis>.
        </para>
        <para>
            Here, the next value is determined by the present value 
            <emphasis>
                y<subscript>n</subscript>
            </emphasis>
            plus the weighted average of six increments, where each increment is the product of the size of the interval, <emphasis>h</emphasis>, and an estimated slope specified by the function <emphasis>f(t,y)</emphasis> :
            <itemizedlist>
                <listitem>
                    <emphasis>k1</emphasis> is the increment based on the slope at the beginning of the interval, using 
                    <emphasis>
                        y<subscript>n</subscript>
                    </emphasis>
                    (Euler's method),
                </listitem>
                <listitem>
                    <emphasis>k2, k3, k4</emphasis> and <emphasis>k5</emphasis> are the increments based on the slope at respectively <emphasis>0.2, 0.3, 0.8</emphasis> and <emphasis>0.9</emphasis> of the interval, using combinations of each other,
                </listitem>
                <listitem>
                    <emphasis>k6</emphasis> and <emphasis>k7</emphasis> are the increments based on the slope at the end, also using combinations of the other <emphasis>ki</emphasis>.
                </listitem>
            </itemizedlist>
        </para>
        <para>
            We can see that with the <emphasis>ki</emphasis>, we progress in the derivatives of 
            <emphasis>
                y<subscript>n</subscript>
            </emphasis>
            . In the computation of the <emphasis>ki</emphasis>, we deliberately use coefficients that yield an error in 
            <emphasis>
                O(h<superscript>5</superscript>)
            </emphasis>
            at every step.
        </para>
        <para>
            So the total error is 
            <emphasis>
                number of steps * O(h<superscript>5</superscript>)
            </emphasis>
            . And since <emphasis>number of steps = interval size / h</emphasis> by definition, the total error is in 
            <emphasis>
                O(h<superscript>4</superscript>)
            </emphasis>
            .
        </para>
        <para>
            That error analysis baptized the method <emphasis>Dopri 4(5)</emphasis> : 
            <emphasis>
                O(h<superscript>5</superscript>)
            </emphasis>
            per step, 
            <emphasis>
                O(h<superscript>4</superscript>)
            </emphasis>
            in total.
        </para>
        <para>
            Althought the solver works fine for <link linkend="Simulatemenu_Menu_entries">max step size</link> up to 
            <emphasis>
                10<superscript>-3</superscript>
            </emphasis>
            , rounding errors sometimes come into play as it approaches 
            <emphasis>
                4*10<superscript>-4</superscript>
            </emphasis>
            . Indeed, the interval splitting cannot be done properly and we get capricious results.
        </para>
    </refsection>
    <refsection>
        <title>Examples</title>
        <para>
            <link type="scilab" linkend="scilab.xcos/xcos/examples/solvers/ODE_Example.xcos">
                <inlinemediaobject>
                    <imageobject>
                        <imagedata align="center" fileref="../../../examples/solvers/ODE_Example.xcos" valign="middle"/>
                    </imageobject>
                </inlinemediaobject>
            </link>
            <scilab:image><![CDATA[
loadScicos();
loadXcosLibs();
importXcosDiagram(SCI + "/modules/xcos/examples/solvers/ODE_Example.xcos");
scs_m.props.tol(6) = 0;
try xcos_simulate(scs_m, 4); catch disp(lasterror()); end;
]]></scilab:image>
        </para>
        <para>
            The integral block returns its continuous state, we can evaluate it with LSodar by running the example :
        </para>
        <para>
            <programlisting language="example"><![CDATA[
      // Import the diagram and set the ending time
      loadScicos();
      loadXcosLibs();
      importXcosDiagram("SCI/modules/xcos/examples/solvers/ODE_Example.xcos");
      scs_m.props.tf = 10000;

      // Select the LSodar solver
      scs_m.props.tol(6) = 0;

      // Start the timer, launch the simulation and display time
      tic();
      try xcos_simulate(scs_m, 4); catch disp(lasterror()); end;
      t = toc();
      disp(t, "Time for LSodar :");
      ]]></programlisting>
        </para>
        <para>
            The Scilab console displays :
            <screen><![CDATA[
Time for LSodar :
 5.001
            ]]></screen>
        </para>
        <para>
            Now, in the following script, we compare the time difference between the methods by running the example with the five solvers in turn :
            <link type="scilab" linkend ="scilab.scinotes/xcos/examples/solvers/integLSodar.sce">
                Open the script
            </link>
        </para>
        <para>
            <screen><![CDATA[
Time for LSodar :
 5.001

Time for BDF / Newton :
 12.943

Time for BDF / Functional :
 12.415

Time for Adams / Functional :
 8.651

Time for Adams / Newton :
 7.962
            ]]></screen>
        </para>
        <para>
            These results show that on a nonstiff problem, for the same precision required, LSodar is significantly faster. Other tests prove the proximity of the results. Indeed, we find that the solution difference order between LSodar and CVode is close to the order of the tolerances ( 
            <emphasis>
                y<subscript>lsodar</subscript> - y<subscript>cvode</subscript>
            </emphasis>
            &#8776; <emphasis>mean(reltol, abstol)</emphasis> ).
        </para>
        <para>
            Variable step-size ODE solvers are not appropriate for deterministic real-time applications because the computational overhead of taking a time step varies over the course of an application.
        </para>
    </refsection>
    <refsection>
        <title>See Also</title>
        <simplelist type="inline">
            <member>
                <link linkend="CVode">CVode</link>
            </member>
            <member>
                <link linkend="IDA">IDA</link>
            </member>
            <member>
                <link linkend="RK">Runge-Kutta 4(5)</link>
            </member>
            <member>
                <link linkend="ode">ode</link>
            </member>
            <member>
                <link linkend="ode_discrete">ode_discrete</link>
            </member>
            <member>
                <link linkend="ode_root">ode_root</link>
            </member>
            <member>
                <link linkend="odedc">odedc</link>
            </member>
            <member>
                <link linkend="impl">impl</link>
            </member>
        </simplelist>
    </refsection>
    <refsection>
        <title>Bibliography</title>
        <para>
            <!--ACM SIGNUM Newsletter, Volume 15, Issue 4, December 1980, Pages 10-11 <ulink url="http://dl.acm.org/citation.cfm?id=1218052.1218054&coll=DL&dl=GUIDE&CFID=213153447&CFTOKEN=26634355">LSode - LSodi</ulink>-->
            <ulink url="https://computation.llnl.gov/casc/sundials/documentation/documentation.html">Sundials Documentation</ulink>
        </para>
    </refsection>
</refentry>
