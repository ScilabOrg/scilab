<?xml version="1.0" encoding="UTF-8"?>
<!--
 * Scicos
 * 
 * Copyright (C) INRIA - METALAU Project <scicos@inria.fr> (HTML version)
 * Copyright (C) DIGITEO - Scilab Consortium (XML Docbook version)
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 * 
 * See the file ./license.txt
 -->
<refentry xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:svg="http://www.w3.org/2000/svg" xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:db="http://docbook.org/ns/docbook" xmlns:scilab="http://www.scilab.org" xml:id="C_struct">
    <refnamediv>
        <refname>C_struct</refname>
        <refpurpose>C Block structure of a computational function</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <title>Description</title>
        
    </refsynopsisdiv>
    <refsection id="Contents_C_struct">
        <title>Contents</title>
        <itemizedlist>
            <listitem>
                <para>
                    <link linkend="C_struct">C_struct - C Block structure of a computational function</link>
                </para>
            </listitem>
            <listitem>
                <itemizedlist>
                    <listitem>
                        <para>
                            <xref linkend="Module_C_struct">Module</xref>
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            <xref linkend="Description_C_struct">Description</xref>
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            <xref linkend="Inputsoutputs_C_struct">Inputs/outputs</xref>
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            <xref linkend="Events_C_struct">Events</xref>
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            <xref linkend="Parameters_C_struct">Parameters</xref>
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            <xref linkend="Statesandwork_C_struct">States and work</xref>
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            <xref linkend="Zerocrossingsurfacesandmodes_C_struct">Zero crossing surfaces and modes</xref>
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            <xref linkend="Miscallaneous_C_struct">Miscallaneous</xref>
                        </para>
                    </listitem>
                </itemizedlist>
            </listitem>
        </itemizedlist>
    </refsection>
    <refsection id="Module_C_struct">
        <title>Module</title>
        <itemizedlist>
            <listitem>
                <para>
                    <link linkend="xcos">xcos</link>
                </para>
            </listitem>
        </itemizedlist>
    </refsection>
    <refsection id="Description_C_struct">
        <title>Description</title>
        <para>
            The C structure of a Scicos block defines all the fields to handle data provided by the simulator
            such inputs/outputs, parameters, states, ...
        </para>
        <para>
            That structure of type <literal>scicos_block</literal> is defined in the file scicos_block4.h, and user must include that header in each computational functions in the form :
        </para>
        <para>
            
        </para>
        <para>
            The fields, that can be either C pointers or directly data, are then accessible via the <literal>*block</literal>
            structure :
        </para>
        <para>
            
        </para>
        <para>
            This access is a  approach and most of users should prefer the  approach for facilities purpose.
        </para>
        <para>
            In the current version of Scicos, the <literal>scicos-&gt;block</literal> structure is defined :
        </para>
        <para>
            
        </para>
        <para>
            
        </para>
    </refsection>
    <refsection id="Inputsoutputs_C_struct">
        <title>Inputs/outputs</title>
        <para>
            
        </para>
        <itemizedlist>
            <listitem>
                <para>
                    <emphasis role="bold">block-&gt;nin :</emphasis> Integer that gives the number of regular input ports of the block.
                </para>
                <para> One can't override the index when reading sizes of input ports in the array and the index when reading data in the array with a C computational function.</para>
                <para> The number of regular input ports can also be got by the use of the C macros . </para>
            </listitem>
            <listitem>
                <para>
                    <emphasis role="bold">block-&gt;insz :</emphasis> An array of integers of size that respectively gives the first dimensions, the second dimensions and the type of data driven by regular input ports.
                </para>
                <para> Note that this array of size differs from the array and to provide full compatibility with blocks that only use a single dimension.</para>
                <para> Suppose that you have a block with three inputs : the first is an int32 matrix of size 3,2, the second a single complex number (matrix of size 1,1) and the last a real matrix of size 4,1.</para>
                <para>
                    In the<link linkend="scicos_model">scicos_model</link> of such a block, the inputs will be defined :
                </para>
                <programlisting role="code"><![CDATA[                     model.in    = [3;1;4] 

model.in2   = [2;1;1] 

model.intyp = [2;1;3] 
                    ]]></programlisting>
                <para>
                    
                    and the corresponding 
                </para>
                <programlisting role="code"><![CDATA[block->insz]]></programlisting>
                <para> field at C computational function level will be
                    coded as :
                    
                    
                    
                    
                    Do the difference here in the type numbers defined at the <emphasis role="bold">Scilab level</emphasis> (2,1,3)
                    and the type numbers defined at the <emphasis role="bold">C level</emphasis> (84,11,10). The following table gives
                    the correspondance for all Scicos type:
                    
                </para>
                <informaltable border="1" cellpadding="3">
                    <tr>
                        <td align="left">
                            <emphasis role="bold">Scilab Type</emphasis>
                        </td>
                        <td align="left">
                            <emphasis role="bold">Scilab Number</emphasis>
                        </td>
                        <td align="left">
                            <emphasis role="bold">C Type</emphasis>
                        </td>
                        <td align="left">
                            <emphasis role="bold">C Number</emphasis>
                        </td>
                    </tr>
                    <tr>
                        <td align="left">real</td>
                        <td align="left">1</td>
                        <td align="left">double</td>
                        <td align="left">10</td>
                    </tr>
                    <tr>
                        <td align="left">complex</td>
                        <td align="left">2</td>
                        <td align="left">double</td>
                        <td align="left">11</td>
                    </tr>
                    <tr>
                        <td align="left">int32</td>
                        <td align="left">3</td>
                        <td align="left">long</td>
                        <td align="left">84</td>
                    </tr>
                    <tr>
                        <td align="left">int16</td>
                        <td align="left">4</td>
                        <td align="left">short</td>
                        <td align="left">82</td>
                    </tr>
                    <tr>
                        <td align="left">int8</td>
                        <td align="left">5</td>
                        <td align="left">char</td>
                        <td align="left">81</td>
                    </tr>
                    <tr>
                        <td align="left">uint32</td>
                        <td align="left">6</td>
                        <td align="left">unsigned long</td>
                        <td align="left">814</td>
                    </tr>
                    <tr>
                        <td align="left">uint16</td>
                        <td align="left">7</td>
                        <td align="left">unsigned short</td>
                        <td align="left">812</td>
                    </tr>
                    <tr>
                        <td align="left">uint8</td>
                        <td align="left">8</td>
                        <td align="left">unsigned char</td>
                        <td align="left">811</td>
                    </tr>
                </informaltable>
            </listitem>
            <listitem>
                <para>
                    <emphasis role="bold">block-&gt;inptr :</emphasis> An array of pointers of size nin,1 that allow to directly acces to the data contained in the regular input matrices.
                </para>
                <para> Suppose the previous example (block with three inputs : an int32 matrix of size [3,2], a complex scalar and a real matrix of size [4,1]).</para>
                <para>  contains three pointers, and should be viewed as arrays contained the data for the int32, the real and the complex matrices :
                    
                    
                    
                    For i.e., to directly access to the data, the user can use theses instructions :
                    
                </para>
                <programlisting role="code"><![CDATA[                     #include "scicos_block4.h"
                     ...

SCSINT32_COP *ptr_i;

SCSCOMPLEX_COP *ptr_dc;

SCSREAL_COP *ptr_d;

int n1,m1;

SCSINT32_COP cumsum_i=0;

int i;
                     ...

void mycomputfunc(scicos_block *block,int flag) 
                     {
                     ...
                     /*get the ptrs of the first int32 regular input port*/

ptr_i = (SCSINT32_COP *) block->inptr[0];
                     /*get the ptrs of the second complex regular input port*/

ptr_dc = (SCSCOMPLEX_COP *) block->inptr[1];
                     /*get the ptrs of the third real regular input port*/

ptr_d = (SCSREAL_COP *) block->inptr[2];
                     ...
                     /*get the dimension of the first int32 regular input port*/

n1=block->insz[0];

m1=block->insz[3];
                     ...
                     /*compute the cumsum of the input int32 matrix*/

for(i=0;i<n1*m1;i++) {

cumsum_i += ptr_i[i];
                     }
                     ...
                     }
                    ]]></programlisting>
                <para>
                    
                    One can also use the set of C macros :
                </para>
                <para>                    </para>
                <programlisting role="code"><![CDATA[GetInPortPtrs(blk,x)]]></programlisting>
                <para>, </para>
                <programlisting role="code"><![CDATA[GetRealInPortPtrs(block,x)]]></programlisting>
                <para>, 
                </para>
                <para>                    </para>
                <programlisting role="code"><![CDATA[GetImagInPortPtrs(block,x)]]></programlisting>
                <para>, </para>
                <programlisting role="code"><![CDATA[Getint8InPortPtrs(block,x)]]></programlisting>
                <para>, 
                </para>
                <para>                    </para>
                <programlisting role="code"><![CDATA[Getint16InPortPtrs(block,x)]]></programlisting>
                <para>, </para>
                <programlisting role="code"><![CDATA[Getint32InPortPtrs(block,x)]]></programlisting>
                <para>, 
                </para>
                <para>                    </para>
                <programlisting role="code"><![CDATA[Getuint8InPortPtrs(block,x)]]></programlisting>
                <para>, </para>
                <programlisting role="code"><![CDATA[Getuint16InPortPtrs(block,x)]]></programlisting>
                <para>, 
                </para>
                <para>                    </para>
                <programlisting role="code"><![CDATA[Getuint32InPortPtrs(block,x)]]></programlisting>
                <para> 
                </para>
                <para>
                    to have the appropriate pointer of the data to handle and 
                </para>
                <para>                    </para>
                <programlisting role="code"><![CDATA[GetNin(block)]]></programlisting>
                <para>, </para>
                <programlisting role="code"><![CDATA[GetInPortRows(block,x)]]></programlisting>
                <para>, 
                </para>
                <para>                    </para>
                <programlisting role="code"><![CDATA[GetInPortCols(block,x)]]></programlisting>
                <para>, </para>
                <programlisting role="code"><![CDATA[GetInPortSize(block,x,y)]]></programlisting>
                <para>, 
                </para>
                <para>                    </para>
                <programlisting role="code"><![CDATA[GetInType(block,x)]]></programlisting>
                <para>, </para>
                <programlisting role="code"><![CDATA[GetSizeOfIn(block,x)]]></programlisting>
                <para> 
                </para>
                <para>
                    to handle number, dimensions and type of regular input ports.
                    (<emphasis role="bold">x is numbered from 1 to nin and y numbered  from 1 to 2</emphasis>).
                </para>
                <para> 
                    For the previous example that gives :
                    
                </para>
                <programlisting role="code"><![CDATA[                     #include "scicos_block4.h"
                     ...

SCSINT32_COP *ptr_i;

SCSCOMPLEX_COP *ptr_dc;

SCSREAL_COP *ptr_d;

int n1,m1;

SCSINT32_COP cumsum_i=0;

int i;
                     ...

void mycomputfunc(scicos_block *block,int flag)
                     {
                     ...
                     /*get the ptrs of the first int32 regular input port*/

ptr_i = Getint32InPortPtrs(block,1);
                     /*get the ptrs of the second complex regular input port*/

ptr_dc = GetRealInPortPtrs(block,2);
                     /*get the ptrs of the third real regular input port*/

ptr_d = GetRealInPortPtrs(block,3);
                     ...
                     /*get the dimension of the first int32 regular input port*/

n1=GetInPortRows(block,1);

m1=GetInPortCols(block,1);
                     ...
                     }
                    ]]></programlisting>
                <para>
                    
                    Finally note that the regular input port registers are only accessible for reading.
                </para>
            </listitem>
            <listitem>
                <para>
                    <emphasis role="bold">block-&gt;nout :</emphasis> Integer that gives the number of regular output ports of the block.
                </para>
                <para> One can't override the index when reading sizes of output ports in the array and the index when reading data in the array with a C computational function.</para>
                <para> The number of regular output ports can also be got by the use of the C macros . </para>
            </listitem>
            <listitem>
                <para>
                    <emphasis role="bold">block-&gt;outsz :</emphasis> An array of integers of size that respectively gives the first dimensions, the second dimensions and the type of data driven by regular output ports.
                </para>
                <para> Note that this array of size differs from the array and to provide full compatibility with blocks that only use a single dimension.</para>
                <para> Suppose that you have a block with two outputs : the first is an int32 matrix of size 3,2, the second a single complex number (matrix of size 1,1) and the last a real matrix of size 4,1.</para>
                <para>
                    In the<link linkend="scicos_model">scicos_model</link> of such a block, the outputs will be defined :
                </para>
                <programlisting role="code"><![CDATA[                      model.out   = [3;1;4] 

model.out2   = [2;1;1] 

model.outtyp = [2;1;3] 
                     ]]></programlisting>
                <para>
                    
                    and the corresponding 
                </para>
                <programlisting role="code"><![CDATA[block->outsz]]></programlisting>
                <para> field at C computational function level will be
                    coded as :
                    
                    
                    
                    
                    Do the difference here in the type numbers defined at the <emphasis role="bold">Scilab level</emphasis> (2,1,3)
                    and the type numbers defined at the <emphasis role="bold">C level</emphasis> (84,11,10) and please report to the 
                    previous table to have the correspondence for all Scicos type.
                </para>
            </listitem>
            <listitem>
                <para>
                    <emphasis role="bold">block-&gt;outptr :</emphasis> An array of pointers of size nout,1 that allow to directly acces to the data contained in the regular output matrices.
                </para>
                <para> Suppose the previous example (block with three outputs : an int32 matrix of size [3,2], a complex scalar and a real matrix of size [4,1]).</para>
                <para>  contains three pointers, and should be viewed as arrays contained the data for the int32, the real and the complex matrices :
                    
                    
                    
                    For i.e., to directly access to the data, the user can use theses instructions :
                    
                </para>
                <programlisting role="code"><![CDATA[                     #include "scicos_block4.h"
                     ...

SCSINT32_COP *ptr_i;

SCSCOMPLEX_COP *ptr_dc;

SCSREAL_COP *ptr_d;

int n1,m1;

SCSINT32_COP cumsum_i=0;

int i;
                     ...

void mycomputfunc(scicos_block *block,int flag)
                     {
                     /*get the ptrs of the first int32 regular output port*/

ptr_i = (SCSINT32_COP *) block->outptr[0];
                     /*get the ptrs of the second complex regular output port*/

ptr_dc = (SCSCOMPLEX_COP *) block->outptr[1];
                     /*get the ptrs of the third real regular output port*/

ptr_d = (SCSREAL_COP *) block->outptr[2];
                     ...
                     /*get the dimension of the first int32 regular output port*/

n1=block->outsz[0];

m1=block->outsz[3];
                     ...
                     /*compute the cumsum of the output int32 matrix*/

for(i=0;i<n1*m1;i++) {

cumsum_i += ptr_i[i];
                     }
                     ...
                     }
                    ]]></programlisting>
                <para>
                    
                    One can also use the set of C macros :
                </para>
                <para>                    </para>
                <programlisting role="code"><![CDATA[GetOutPortPtrs(block,x)]]></programlisting>
                <para>, </para>
                <programlisting role="code"><![CDATA[GetRealOutPortPtrs(block,x)]]></programlisting>
                <para>, 
                </para>
                <para>                    </para>
                <programlisting role="code"><![CDATA[GetImagOutPortPtrs(block,x)]]></programlisting>
                <para>, </para>
                <programlisting role="code"><![CDATA[Getint8OutPortPtrs(block,x)]]></programlisting>
                <para>, 
                </para>
                <para>                    </para>
                <programlisting role="code"><![CDATA[Getint16OutPortPtrs(block,x)]]></programlisting>
                <para>, </para>
                <programlisting role="code"><![CDATA[Getint32OutPortPtrs(block,x)]]></programlisting>
                <para>, 
                </para>
                <para>                    </para>
                <programlisting role="code"><![CDATA[Getuint8OutPortPtrs(block,x)]]></programlisting>
                <para>, </para>
                <programlisting role="code"><![CDATA[Getuint16OutPortPtrs(block,x)]]></programlisting>
                <para>, 
                </para>
                <para>                    </para>
                <programlisting role="code"><![CDATA[Getuint32OutPortPtrs(block,x)]]></programlisting>
                <para> 
                </para>
                <para>
                    to have the appropriate pointer of the data to handle and 
                </para>
                <para>                    </para>
                <programlisting role="code"><![CDATA[GetNout(block)]]></programlisting>
                <para>, </para>
                <programlisting role="code"><![CDATA[GetOutPortRows(block,x)]]></programlisting>
                <para>, 
                </para>
                <para>                    </para>
                <programlisting role="code"><![CDATA[GetOutPortCols(block,x)]]></programlisting>
                <para>, </para>
                <programlisting role="code"><![CDATA[GetOutPortSize(block,x,y)]]></programlisting>
                <para>, 
                </para>
                <para>                    </para>
                <programlisting role="code"><![CDATA[GetOutType(block,x)]]></programlisting>
                <para>, </para>
                <programlisting role="code"><![CDATA[GetSizeOfOut(block,x)]]></programlisting>
                <para> 
                </para>
                <para>
                    to handle number, dimensions and type of regular output ports.
                    (<emphasis role="bold">x is numbered from 1 to nout and y is numbered  from 1 to 2</emphasis>).
                    
                    For the previous example that gives :
                    
                </para>
                <programlisting role="code"><![CDATA[                     #include "scicos_block4.h"
                     ...

SCSINT32_COP *ptr_i;

SCSCOMPLEX_COP *ptr_dc;

SCSREAL_COP *ptr_d;

int n1,m1;

SCSINT32_COP cumsum_i=0;

int i;
                     ...

void mycomputfunc(scicos_block *block,int flag)
                     {
                     ...
                     /*get the ptrs of the first int32 regular output port*/

ptr_i = GetOutPortPtrs(block,1);
                     /*get the ptrs of the second complex regular output port*/

ptr_dc = GetRealOutPortPtrs(block,2);
                     /*get the ptrs of the third real regular output port*/

ptr_d = GetRealOutPortPtrs(block,3);
                     ...
                     /*get the dimension of the first int32 regular output port*/

n1=GetOutPortRows(block,1);

m1=GetOutPortCols(block,1);
                     ...
                     }
                    ]]></programlisting>
                <para>
                    
                    Finally note that the regular output port registers must be only written for 
                </para>
                <programlisting role="code"><![CDATA[flag]]></programlisting>
                <para>=1. </para>
            </listitem>
        </itemizedlist>
        <para>
            
        </para>
    </refsection>
    <refsection id="Events_C_struct">
        <title>Events</title>
        <para>
            
        </para>
        <itemizedlist>
            <listitem>
                <para>
                    <emphasis role="bold">block-&gt;nevprt :</emphasis> Integer that gives the event input port number by which the block has been activated. This number is a binary coding. For i.e, if block has two event inputs ports, can take the value 1 if the block has been called by its first event input port, the value 2 if it has been called by the second event input port and 3 if it is called by the same event on both input port 1 and 2.
                </para>
                <para> Note that can be -1 if the block is internally called.</para>
                <para> One can also retrieve this number by using the C macros . </para>
            </listitem>
            <listitem>
                <para>
                    <emphasis role="bold">block-&gt;nevout :</emphasis> Integer that gives the number of event output ports of the block (also called the length of the output event register).
                </para>
                <para> One can't override the index when setting value of events in the output event register .</para>
                <para> The number of event output ports can also be got by the use of the C macro . </para>
            </listitem>
            <listitem>
                <para>
                    <emphasis role="bold">block-&gt;evout :</emphasis> Array of double of size nevout,1 corresponding to the output event register. That register is used to program date of events during the simulation.
                </para>
                <para> When setting values in that array, you must understand that you give a delay relative to the current time of simulator :</para>
                <para>
                    where 
                    <inlinemediaobject>
                        <imageobject>
                            <imagedata fileref="../../../images/C_struct_img6_eng.gif" align="center" valign="middle"/>
                        </imageobject>
                    </inlinemediaobject>
                    is the date of the programmed event, 
                    <inlinemediaobject>
                        <imageobject>
                            <imagedata fileref="../../../images/C_struct_img7_eng.gif" align="center" valign="middle"/>
                        </imageobject>
                    </inlinemediaobject>
                    is the current time in the simulator and 
                    <inlinemediaobject>
                        <imageobject>
                            <imagedata fileref="../../../images/C_struct_img8_eng.gif" align="center" valign="middle"/>
                        </imageobject>
                    </inlinemediaobject>
                    the value that must be informed in the output event register.
                    For i.e, suppose that you want generate an event with the first event output port, 1ms after
                    each calls of the block, then you'll use :
                    
                </para>
                <programlisting role="code"><![CDATA[                      #include "scicos_block4.h"
                      ...

void mycomputfunc(scicos_block *block,int flag)
                      {
                      ...

if (flag==3) { 

block->evout[0]=0.001;
                      }
                      ...
                     }
                     ]]></programlisting>
                <para>
                </para>
                <para> 
                    Note that every events generated from output event register will be asynchronous with event
                    coming from event input port (even if you set 
                </para>
                <programlisting role="code"><![CDATA[block->evout[x]=0]]></programlisting>
                <para>). 
                </para>
                <para>
                    The event output register must be only written for 
                </para>
                <programlisting role="code"><![CDATA[flag]]></programlisting>
                <para>=3. </para>
            </listitem>
        </itemizedlist>
        <para>
            
        </para>
    </refsection>
    <refsection id="Parameters_C_struct">
        <title>Arguments</title>
        <para>
            
        </para>
        <itemizedlist>
            <listitem>
                <para>
                    <emphasis role="bold">block-&gt;nrpar :</emphasis> Integer that gives the length of the real parameter register.
                </para>
                <para> One can't override the index when reading value of real parameters in the register .</para>
                <para> The total number of real parameters can also be got by the use of the C macro . </para>
            </listitem>
            <listitem>
                <para>
                    <emphasis role="bold">block-&gt;rpar :</emphasis> Array of double of size nrpar,1 corresponding to the real parameter register. That register is used to pass real parameters coming from the scilab/scicos environment to your block model.
                </para>
                <para> The C type of that array is (or C scicos type ).</para>
                <para>
                    Suppose that you have defined the following real parameters in the<link linkend="scicos_model">scicos_model</link> of a block :
                </para>
                <programlisting role="code"><![CDATA[                     model.rpar   = [%pi;%pi/2;%pi/4]
                    ]]></programlisting>
                <para>
                    
                    you can retrieve the previous data in the C computational function with :
                    
                </para>
                <programlisting role="code"><![CDATA[                     #include "scicos_block4.h"
                     ...

double PI;

double PI_2;

double PI_4;
                     ...

void mycomputfunc(scicos_block *block,int flag)
                     {
                     ...
                     /*get the first value of the real param register*/

PI = block->rpar[0];
                     /*get the second value of the real param register*/

PI_2 = block->rpar[1];
                     /*get the third value of the real param register*/

PI_4 = block->rpar[2];
                     ...
                     }
                    ]]></programlisting>
                <para>
                    
                    You can also use the C macro 
                </para>
                <programlisting role="code"><![CDATA[GetRparPtrs(block)]]></programlisting>
                <para> to get the pointer of the
                    real parameter register. For i.e., if we define the following
                    <link linkend="scicos_model">scicos_model</link>
                    in an interfacing function of a
                    scicos block :
                    
                </para>
                <programlisting role="code"><![CDATA[                     A = [1.3 ; 4.5 ; 7.9 ; 9.8];

B = [0.1 ; 0.98]; 

model.rpar   = [A;B] 
                    ]]></programlisting>
                <para>
                    
                    in the corresponding C computational function of that block, we'll use :
                    
                </para>
                <programlisting role="code"><![CDATA[                     #include "scicos_block4.h"
                     ...

double *rpar;

double *A; 

double *B; 
                     ...

void mycomputfunc(scicos_block *block,int flag)
                     {
                     ...
                     /*get ptrs of the real param register*/

rpar = GetRparPtrs(block); 
                     /*get the A ptrs array*/

A = rpar;
                     /*get the B ptrs array*/

B = &rpar[4];
                     /*or B = rpar + 4;*/
                     ...
                     }
                    ]]></programlisting>
                <para>
                    
                    Note that real parameters register is only accessible for reading.
                </para>
            </listitem>
            <listitem>
                <para>
                    <emphasis role="bold">block-&gt;nipar :</emphasis> Integer that gives the length of the integer parameter register.
                </para>
                <para> One can't override the index when reading value of integer parameters in the register .</para>
                <para> The total number of integer parameters can also be got by the use of the C macro . </para>
            </listitem>
            <listitem>
                <para>
                    <emphasis role="bold">block-&gt;ipar :</emphasis> Array of int of size nipar,1 corresponding to the integer parameter register. That register is used to pass integer parameters coming from the scilab/scicos environment to your block model.
                </para>
                <para> The C type of that array is (or C scicos type ).</para>
                <para>
                    Suppose that you have defined the following integer parameters in the<link linkend="scicos_model">scicos_model</link> of a block :
                </para>
                <programlisting role="code"><![CDATA[                     model.ipar   = [(1:3)';5] 
                    ]]></programlisting>
                <para>
                    
                    you can retrieve the previous data in the C computational function with :
                    
                </para>
                <programlisting role="code"><![CDATA[                     #include "scicos_block4.h"
                     ...

int one;

int two;

int three;

int five;
                     ...

void mycomputfunc(scicos_block *block,int flag)
                     {
                     ...
                     /*get the first value of the integer param register*/

one = block->ipar[0]; 
                     /*get the second value of the integer param register*/

two = block->ipar[1]; 
                     /*get the third value of the integer param register*/

three = block->ipar[2]; 
                     /*get the fourth value of the integer param register*/

five = block->ipar[3]; 
                     ...
                     }
                    ]]></programlisting>
                <para>
                    
                    You can also use the C macro 
                </para>
                <programlisting role="code"><![CDATA[GetIparPtrs(block)]]></programlisting>
                <para> to get the pointer of the
                    real parameter register.
                </para>
                <para>
                    Most of time in the scicos C block libraries, the integer register is used to
                    parametrize the length of real parameters. For i.e. if you define the following
                    <link linkend="scicos_model">scicos_model</link>
                    in a block :
                    
                </para>
                <programlisting role="code"><![CDATA[                     // set a random size for the first real parameters 

A_sz = int(rand(10)*10); 
                     // set a random size for the second real parameters 

B_sz = int(rand(10)*10); 
                     // set the first real parameters 

A = rand(A_sz,1,``uniform''); 
                     // set the second real parameters 

B = rand(B_sz,1,``normal''); 
                     // set ipar 

model.ipar = [A_sz;B_sz] 
                     // set rpar (length of A_sz+B_sz) 

model.rpar = [A;B] 
                    ]]></programlisting>
                <para>
                    
                    the array of real parameters (parametrized by ipar) can be retrieved in the
                    correspondig C computational function with :
                    
                </para>
                <programlisting role="code"><![CDATA[                     #include "scicos_block4.h"
                     ...

int A_sz; 

int B_sz; 

double *rpar; 

double *A; 

double *B; 

double cumsum;

int i;Â 
                     ...

void mycomputfunc(scicos_block *block,int flag)
                     {
                     ...
                     /*get ptrs of the real param register*/

rpar = GetRparPtrs(block); 
                     /*get size of the first real param register*/

A_sz = block->ipar[0]; 
                     /*get size of the second real param register*/

B_sz = block->ipar[1]; 
                     /*get the A ptrs array*/

A = rpar; 
                     /*get the B ptrs array*/

B = &rpar[A_sz]; 
                     ...
                     /*compute the cumsum of the first real parameter array*/

cumsum = 0;

for(i=0;i<A_sz;i++) {

cumsum += A[i];
                     }
                     ...
                     /*compute the cumsum of the second real parameter array*/

cumsum = 0;

for(i=0;i<B_sz;i++) {

cumsum += B[i]; 
                     }
                    ]]></programlisting>
                <para>
                    
                    Note that integer parameters register is only accessible for reading.
                </para>
            </listitem>
            <listitem>
                <para>
                    <emphasis role="bold">block-&gt;nopar :</emphasis> Integer that gives the number of the object parameters.
                </para>
                <para> One can't override the index when accessing data in the arrays , and in a C computational function.</para>
                <para> This value is also accessible via the C macro . </para>
            </listitem>
            <listitem>
                <para>
                    <emphasis role="bold">block-&gt;oparsz :</emphasis> An array of integer of size nopar,2 that contains the dimensions of matrices of object parameters.
                </para>
                <para> The first column is for the first dimension and the second for the second dimension. For i.e. if we want the dimensions of the last object parameters, we'll use the instructions :
                </para>
                <programlisting role="code"><![CDATA[                     #include "scicos_block4.h"
                     ...

int nopar;

int n,m;
                     ...

void mycomputfunc(scicos_block *block,int flag)
                     {
                     ...
                     /*get the number of object parameter*/

nopar=block>nopar;
                     ...
                     /*get number of row of the last object parameter*/

n=block>oparsz[nopar-1];
                     /*get number of column of the last object parameter*/

m=block>oparsz[2*nopar-1];
                     ...
                     }
                    ]]></programlisting>
                <para>
                    
                    The dimensions of object parameters can be get with the following C macro :
                    
                </para>
                <programlisting role="code"><![CDATA[                     GetOparSize(block,x,1); /*get first dimension of opar*/ 

GetOparSize(block,x,2); /*get second dimension of opar*/ 
                    ]]></programlisting>
                <para>
                    
                    with 
                </para>
                <programlisting role="code"><![CDATA[x]]></programlisting>
                <para>
                    an integer that gives the index of the object parameter, <emphasis role="bold">numbered
                        from 1 to nopar
                    </emphasis>
                    .
                </para>
            </listitem>
            <listitem>
                <para>
                    <emphasis role="bold">block-&gt;opartyp :</emphasis> An array of integer of size nopar,1 that contains the type of matrices of object parameters.
                </para>
                <para> The following table gives the correspondence for scicos type expressed in Scilab number, in C number and also corresponding C pointers and C macros used for :
                    
                    The type of object parameter can also be got by the use of the C macro
                </para>
                <programlisting role="code"><![CDATA[GetOparType(block,x)]]></programlisting>
                <para>. For i.e, if we want the C number type of the first
                    object parameter, we'll use the following C instructions:
                    
                </para>
                <programlisting role="code"><![CDATA[                      #include "scicos_block4.h"
                     ...

int opartyp_1;
                     ...

void mycomputfunc(scicos_block *block,int flag)
                      {
                      ...
                      /*get the number type of the first object parameter*/

opartyp_1 = GetOparType(block,1);
                      ...
                     }
                     ]]></programlisting>
                <para>
                </para>
            </listitem>
            <listitem>
                <para>
                    <emphasis role="bold">block-&gt;oparptr :</emphasis> An array of pointers of size nopar,1 that allow to directly acces to the data contained in the object parameter.
                </para>
                <para>
                    Suppose that you have defined in the editor a block with the following<emphasis role="bold">opar</emphasis> field in<link linkend="scicos_model">scicos_model</link> :
                </para>
                <programlisting role="code"><![CDATA[model.opar=list(int32([1,2;3,4]),[1+%i %i 0.5]);]]></programlisting>
                <para>
                    
                    Then we have two object parameters, one is an 32-bit integer matrix with two rows and two
                    columns and the second is a vector of complex numbers that can be understand as a matrix
                    of size 1,3.
                </para>
                <para>
                    At the C computational function level, the instructions 
                </para>
                <programlisting role="code"><![CDATA[block->oparsz[0]]]></programlisting>
        <para>,
                     </para>
        <programlisting role="code"><![CDATA[block->oparsz[1]]]></programlisting>
        <para>,Â </para>
        <programlisting role="code"><![CDATA[block->oparsz[2]]]></programlisting>
        <para>, </para>
        <programlisting role="code"><![CDATA[block->oparsz[3]]]></programlisting>
        <para> will respectively return the
                     values 2,1,2,3 and the instructions </para>
        <programlisting role="code"><![CDATA[block->opartyp[0]]]></programlisting>
        <para>, </para>
        <programlisting role="code"><![CDATA[block->opartyp[1]]]></programlisting>
        <para> the values 11 and
                     84.
</para>
        <para>                     </para>
        <programlisting role="code"><![CDATA[block->oparptr]]></programlisting>
                <para> will contain then two pointers, and should be viewed as arrays contained data of
                    object parameter as shown in the following figure :
                    
                    
                    
                    
                    For i.e., to directly access to the data, the user can use theses instructions :
                    
                </para>
                <programlisting role="code"><![CDATA[                     #include "scicos_block4.h"
                     ...

SCSINT32_COP *ptr_i;

SCSINT32_COP cumsum_i;

SCSCOMPLEX_COP *ptr_d;

SCSREAL_COP cumsum_d;
                     ...

void mycomputfunc(scicos_block *block,int flag)
                     {
                     ...
                     /*get the ptrs of an int32 object parameter*/

ptr_i = (SCSINT32_COP *) block->oparptr[0];
                     /*get the ptrs of a double object parameter*/

ptr_d = (SCSCOMPLEX_COP *) block->oparptr[1];
                     ...
                     /*compute the cumsum of the int32 matrix*/

cumsum_i = ptr_i[0]+ptr_i[1]+ptr_i[2]+ptr_i[3];
                     ...
                     /*compute the cumsum of the real part of the complex matrix*/

cumsum_d = ptr_d[0]+ptr_d[1]+ptr_d[2];
                     ...
                     }
                    ]]></programlisting>
                <para>
                    
                    One can also use the set of C macros :
                </para>
                <para>                    </para>
                <programlisting role="code"><![CDATA[GetRealOparPtrs(block,x)]]></programlisting>
                <para>,  </para>
                <programlisting role="code"><![CDATA[GetImagOparPtrs(block,x)]]></programlisting>
                <para>,
                </para>
                <para>                    </para>
                <programlisting role="code"><![CDATA[Getint8OparPtrs(block,x)]]></programlisting>
                <para>,  </para>
                <programlisting role="code"><![CDATA[Getint16OparPtrs(block,x)]]></programlisting>
                <para>,
                </para>
                <para>                    </para>
                <programlisting role="code"><![CDATA[Getint32OparPtrs(block,x)]]></programlisting>
                <para>, </para>
                <programlisting role="code"><![CDATA[Getuint8OparPtrs(block,x)]]></programlisting>
                <para>,
                </para>
                <para>                    </para>
                <programlisting role="code"><![CDATA[Getuint16OparPtrs(block,x)]]></programlisting>
                <para>, </para>
                <programlisting role="code"><![CDATA[Getuint32OparPtrs(block,x)]]></programlisting>
                <para>
                </para>
                <para>
                    to have the appropriate pointer of the data to handle (<emphasis role="bold">x is numbered from 1 to nopar</emphasis>).
                </para>
                <para>
                    For the previous example that gives :
                    
                </para>
                <programlisting role="code"><![CDATA[                     #include "scicos_block4.h"
                     ...

SCSINT32_COP *ptr_i;

SCSREAL_COP *ptr_dr;

SCSREAL_COP *ptr_di;
                     ...

void mycomputfunc(scicos_block *block,int flag)
                     {
                     ...
                     /*get the ptrs of an int32 object parameter*/

ptr_i = Getint32OparPtrs(block,1);
                     /*get the ptrs of a double object parameter*/

ptr_dr = GetRealOparPtrs(block,2);

ptr_di = GetImagOparPtrs(block,2);
                     ...
                     }
                    ]]></programlisting>
                <para>
                    
                    Note that object parameters register is only accessible for reading. 
                </para>
            </listitem>
        </itemizedlist>
        <para>
            
        </para>
    </refsection>
    <refsection id="Statesandwork_C_struct">
        <title>States and work</title>
        <para>
            
        </para>
        <itemizedlist>
            <listitem>
                <para>
                    <emphasis role="bold">block-&gt;nx :</emphasis> Integer that gives the length of the continus state register.
                </para>
                <para> One can't override the index when reading or writing data in the array , or with a C computational function. </para>
            </listitem>
            <listitem>
                <para>
                    <emphasis role="bold">block-&gt;x :</emphasis> Array of double of size nx,1 corresponding to the continuous state register.
                </para>
                <para> That gives the result of the computation of the state derivative.</para>
                <para> A value of a continuous state is readable (for i.e the first state) with the C instructions :
                </para>
                <programlisting role="code"><![CDATA[                  #include "scicos_block4.h"
                  ...

double x_1;
                  ...

void mycomputfunc(scicos_block *block,int flag)
                  {
                  ...

x_1=block->x[0];
                  ...
                  }
                 ]]></programlisting>
                <para>
                    
                    Note that on 
                </para>
                <programlisting role="code"><![CDATA[flag]]></programlisting>
                <para>=4, user can write some initial conditions in that register.
                </para>
                <para>
                    The pointer of that array can also be retrieve via the C macro 
                </para>
                <programlisting role="code"><![CDATA[GetState(block)]]></programlisting>
                <para>.
                </para>
            </listitem>
            <listitem>
                <para>
                    <emphasis role="bold">block-&gt;xd :</emphasis> Array of double of size nx,1 corresponding to the derivative of the continuous state register.
                </para>
                <para> When systems are explicitly given in terms of Ordinary Differential Equations (ODE), it can be explicitly expressed or implicitly used in the residual vector when systems are expressed in terms of Differantial Algebraic Equations (DAE).</para>
                <para> Both systems must be programmed with .</para>
                <para> For i.e the Lorenz attractor written as an ODE system with three state variables, of the form :
                </para>
                <para>
                    will be defined :
                </para>
                <programlisting role="code"><![CDATA[                   #include "scicos_block4.h"
                   ...

double *x = block->x;

double *xd = block->xd;
                   ...
                   /* define parameters */

double a = 10;

double b = 28;

double c = 8/3;
                   ...

void mycomputfunc(scicos_block *block,int flag)
                   {
                   ...

if (flag == 0) {

xd[0] = a*(x[1]-x[0]);

xd[1] = x[1]*(b-x[2])-x[1];

xd[2] = x[0]*x[1]-c*x[2];
                   }
                   ...
                   }
                  ]]></programlisting>
                <para>
                </para>
            </listitem>
            <listitem>
                <para>
                    <emphasis role="bold">block-&gt;res :</emphasis> Array of double of size nx,1 corresponding to Differential Algebraic Equation (DAE) residual.
                </para>
                <para> It is used to write the vector of systems that have the following form :</para>
                <para>  For i.e the Lorenz attractor written as a DAE system with three state variables, will be defined :
                </para>
                <programlisting role="code"><![CDATA[                    #include "scicos_block4.h"
                    ...

double *x = block->x;

double *xd = block->xd;

double *res = block->res;
                    ...
                    /* define parameters */

double a = 10;

double b = 28;

double c = 8/3;
                    ...

void mycomputfunc(scicos_block *block,int flag)
                    {
                    ...

if (flag == 0) {

res[0] =  - xd[0] + (a*(x[1]-x[0]));

res[1] =  - xd[1] + (x[0]*(b-x[2])-x[1]);

res[2] =  - xd[2] + (x[0]*x[1]-c*x[2]);
                    }
                    ...
                    }
                   ]]></programlisting>
                <para>
                </para>
            </listitem>
            <listitem>
                <para>
                    <emphasis role="bold">block-&gt;nz :</emphasis> Integer that gives the length of the discrete state register.
                </para>
                <para> One can't override the index when reading data in the array with a C computational function.</para>
                <para> This value is also accessible via the C macros . </para>
            </listitem>
            <listitem>
                <para>
                    <emphasis role="bold">block-&gt;z :</emphasis> Array of double of size nz,1 corresponding to the discrete state register.
                </para>
                <para> A value of a discrete state is directly readable (for i.e the second state) with the C instructions :
                </para>
                <programlisting role="code"><![CDATA[                  #include "scicos_block4.h"
                  ...

double z_2;
                  ...

void mycomputfunc(scicos_block *block,int flag)
                  {
                  ...

z_2=block->z[1];
                  ...
                  }
                 ]]></programlisting>
                <para>
                    
                    Note that the state register should be only written for 
                </para>
                <programlisting role="code"><![CDATA[flag]]></programlisting>
                <para>=4 and </para>
                <programlisting role="code"><![CDATA[flag]]></programlisting>
                <para>=2.
                </para>
                <para>
                    The pointer of that array can also be retrieve via the C macro 
                </para>
                <programlisting role="code"><![CDATA[GetDstate(block)]]></programlisting>
                <para>.
                </para>
            </listitem>
            <listitem>
                <para>
                    <emphasis role="bold">block-&gt;noz :</emphasis> Integer that gives the number of the discrete object states.
                </para>
                <para> One can't override the index when accessing data in the arrays , and in a C computational function.</para>
                <para> This value is also accessible via the C macro . </para>
            </listitem>
            <listitem>
                <para>
                    <emphasis role="bold">block-&gt;ozsz :</emphasis> An array of integer of size noz,2 that contains the dimensions of matrices of discrete object states.
                </para>
                <para> The first column is for the first dimension and the second for the second dimension. For i.e. if we want the dimensions of the last object state, we'll use the instructions :
                </para>
                <programlisting role="code"><![CDATA[                     #include "scicos_block4.h"
                     ...

int noz;

int n,m;
                     ...
                     /*get the number of object state*/

noz=block>noz;
                     ...

void mycomputfunc(scicos_block *block,int flag)
                     {
                     ...
                     /*get number of row of the last object state*/

n=block>ozsz[noz-1];
                     /*get number of column of the last object state*/

m=block>ozsz[2*noz-1];
                     ...
                     }
                    ]]></programlisting>
                <para>
                    
                    The dimensions of object discrete states can be get with the following C macro :
                    
                </para>
                <programlisting role="code"><![CDATA[                     GetOzSize(block,x,1); /*get first dimension of oz*/ 

GetOzSize(block,x,2); /*get second dimension of oz*/ 
                    ]]></programlisting>
                <para>
                    
                    with 
                </para>
                <programlisting role="code"><![CDATA[x]]></programlisting>
                <para>
                    an integer that gives the index of the discrete object state, <emphasis role="bold">numbered
                        from 1 to noz
                    </emphasis>
                    .
                </para>
            </listitem>
            <listitem>
                <para>
                    <emphasis role="bold">block-&gt;oztyp :</emphasis> An array of integer of size noz,1 that contains the type of matrices of discrete object states.
                </para>
                <para> The following table gives the correspondence table for scicos type expressed in Scilab number, in C number and also corresponding C pointers and C macros used for :
                    
                    The type of discrete object state can also be got by the use of the C macro
                </para>
                <programlisting role="code"><![CDATA[GetOzType(block,x)]]></programlisting>
                <para>. For i.e, if we want the C number type of the first
                    discrete object state, we'll use the following C instructions:
                    
                </para>
                <programlisting role="code"><![CDATA[                      #include "scicos_block4.h"
                      ...

int oztyp_1;
                      ...

void mycomputfunc(scicos_block *block,int flag)
                      {
                      ...
                      /*get the number type of the first object state*/

oztyp_1 = GetOzType(block,1);
                     ...
                     }
                     ]]></programlisting>
                <para>
                </para>
            </listitem>
            <listitem>
                <para>
                    <emphasis role="bold">block-&gt;ozptr :</emphasis> An array of pointers of size noz,1 that allow to directly acces to the data contained in the discrete object state.
                </para>
                <para>
                    Suppose that you have defined in the editor a block with the following<emphasis role="bold">odstate</emphasis> field in <link linkend="scicos_model">scicos_model</link> :
                </para>
                <programlisting role="code"><![CDATA[model.odstate=list(int32([1,2;3,4]),[1+%i %i 0.5]);]]></programlisting>
                <para>
                    
                    Then we have two discrete object states, one is an 32-bit integer matrix with two rows and two
                    columns and the second is a vector of complex numbers that can be understand as a matrix
                    of size 1,3.
                </para>
                <para>
                    At the C computational function level, the instructions 
                </para>
                <programlisting role="code"><![CDATA[block->ozsz[0]]]></programlisting>
        <para>,
                     </para>
        <programlisting role="code"><![CDATA[block->ozsz[1]]]></programlisting>
        <para>,Â </para>
        <programlisting role="code"><![CDATA[block->ozsz[2]]]></programlisting>
        <para>, </para>
        <programlisting role="code"><![CDATA[block->ozsz[3]]]></programlisting>
        <para> will respectively return the
                     values 2,1,2,3 and the instructions </para>
        <programlisting role="code"><![CDATA[block->oztyp[0]]]></programlisting>
        <para>, </para>
        <programlisting role="code"><![CDATA[block->oztyp[1]]]></programlisting>
        <para> the values 11 and
                     84.
</para>
        <para>                     </para>
        <programlisting role="code"><![CDATA[block->ozptr]]></programlisting>
                <para> will contain then two pointers, and should be viewed as arrays contained data of
                    discrete object state as shown in the following figure :
                    
                    
                    
                    
                    For i.e., to directly access to the data, the user can use theses instructions :
                    
                </para>
                <programlisting role="code"><![CDATA[                     #include "scicos_block4.h"
                     ...

SCSINT32_COP *ptr_i;

SCSINT32_COP cumsum_i;

SCSCOMPLEX_COP *ptr_d;

SCSREAL_COP cumsum_d;
                     ...

void mycomputfunc(scicos_block *block,int flag)
                     {
                     ...
                     /*get the ptrs of an int32 discrete object state*/

ptr_i = (SCSINT32_COP *) block->ozptr[0];
                     /*get the ptrs of a double discrete object state*/

ptr_d = (SCSCOMPLEX_COP *) block->ozptr[1];
                     ...
                     /*compute the cumsum of the int32 matrix*/

cumsum_i = ptr_i[0]+ptr_i[1]+ptr_i[2]+ptr_i[3];
                     ...
                     /*compute the cumsum of the real part of the complex matrix*/

cumsum_d = ptr_d[0]+ptr_d[1]+ptr_d[2];
                     ...
                     }
                    ]]></programlisting>
                <para>
                    
                    One can also use the set of C macros :
                </para>
                <para>                    </para>
                <programlisting role="code"><![CDATA[GetRealOzPtrs(block,x)]]></programlisting>
                <para>,  </para>
                <programlisting role="code"><![CDATA[GetImagOzPtrs(block,x)]]></programlisting>
                <para>,
                </para>
                <para>                    </para>
                <programlisting role="code"><![CDATA[Getint8OzPtrs(block,x)]]></programlisting>
                <para>,  </para>
                <programlisting role="code"><![CDATA[Getint16OzPtrs(block,x)]]></programlisting>
                <para>,
                </para>
                <para>                    </para>
                <programlisting role="code"><![CDATA[Getint32OzPtrs(block,x)]]></programlisting>
                <para>, </para>
                <programlisting role="code"><![CDATA[Getuint8OzPtrs(block,x)]]></programlisting>
                <para>,
                </para>
                <para>                    </para>
                <programlisting role="code"><![CDATA[Getuint16OzPtrs(block,x)]]></programlisting>
                <para>, </para>
                <programlisting role="code"><![CDATA[Getuint32OzPtrs(block,x)]]></programlisting>
                <para> 
                </para>
                <para>
                    to have the appropriate pointer of the data to handle (<emphasis role="bold">x is numbered from 1 to noz</emphasis>).
                </para>
                <para>
                    For the previous example that gives :
                    
                </para>
                <programlisting role="code"><![CDATA[                     #include "scicos_block4.h"
                     ...

SCSINT32_COP *ptr_i;

SCSREAL_COP *ptr_dr;

SCSREAL_COP *ptr_di;
                     ...

void mycomputfunc(scicos_block *block,int flag)
                     {
                     ...
                     /*get the ptrs of an int32 discrete object state*/

ptr_i = Getint32OzPtrs(block,1);
                     /*get the ptrs of a double discrete object state*/

ptr_dr = GetRealOzPtrs(block,2);

ptr_di = GetImagOzPtrs(block,2);
                     ...
                     }
                    ]]></programlisting>
                <para>
                    
                    Finally note that the discrete objects state should be only written for 
                </para>
                <programlisting role="code"><![CDATA[flag]]></programlisting>
                <para>=4 and </para>
                <programlisting role="code"><![CDATA[flag]]></programlisting>
                <para>=2.
                </para>
            </listitem>
            <listitem>
                <para>
                    <emphasis role="bold">block-&gt;work :</emphasis> A free pointer to set a working array for the block.
                </para>
                <para> The work pointer must be firstly allocated when = 4 and finally be free in the = 5.</para>
                <para> Then a basic life cyle of that pointer in a C computational function should be :
                </para>
                <programlisting role="code"><![CDATA[                            #include "scicos_block4.h"
                            ...

void** work=block->work;
                            ...

void mycomputfunc(scicos_block *block,int flag)
                            {
                           ...
                            /*initialization*/

if (flag==4) {
                              /*allocation of work*/

if (*work=scicos_malloc(sizeof(double))==NULL) {

set_block_error(-16);

return;
                              }
                            ...
                            }
                            ...
                            /*other flag treatment*/
                            ...
                            /*finish*/

else if (flag==5) {

scicos_free(*work);
                            }
                            ...
                            }
                           ]]></programlisting>
                <para>
                    
                    Note that if a block use a 
                </para>
                <programlisting role="code"><![CDATA[work]]></programlisting>
                <para> pointer, it will be called with </para>
                <programlisting role="code"><![CDATA[flag]]></programlisting>
                <para>=2 even if
                    the block do not use discrete states.
                </para>
                <para>
                    The pointer of that array can also be retrieve via the C macro 
                </para>
                <programlisting role="code"><![CDATA[GetWorkPtrs(block)]]></programlisting>
                <para>. </para>
            </listitem>
        </itemizedlist>
        <para>
            
        </para>
    </refsection>
    <refsection id="Zerocrossingsurfacesandmodes_C_struct">
        <title>Zero crossing surfaces and modes</title>
        <para>
            
        </para>
        <itemizedlist>
            <listitem>
                <para>
                    <emphasis role="bold">block-&gt;ng :</emphasis> Integer that gives the number of zero crossing surface of the block.
                </para>
                <para> One can't override the index when reading/writing data in the array with a C computational function.</para>
                <para> The number of zero crossing surface can also be got by the use of the C macro . </para>
            </listitem>
            <listitem>
                <para>
                    <emphasis role="bold">block-&gt;g :</emphasis> Array of double of size ng,1 corresponding to the zero crossing surface register.
                </para>
                <para> That register is used to detect zero crossing of state variable during time domain integration.</para>
                <para> Note that it is accessible for writing for = 9.</para>
                <para> The pointer of that array can also be retrieve via the C macro . </para>
            </listitem>
            <listitem>
                <para>
                    <emphasis role="bold">block-&gt;nmode :</emphasis> Integer that gives the number of mode of the block.
                </para>
                <para> One can't override the index when reading/writing data in the array with a C computational function.</para>
                <para> The number of mode can also be got by the use of the C macro . </para>
            </listitem>
            <listitem>
                <para>
                    <emphasis role="bold">block-&gt;mode :</emphasis> Array of integer of size nmode,1 corresponding to the mode register.
                </para>
                <para> That register is used to set the mode of state variable during time domain integration.</para>
                <para> It is typically accessible for writing for = 9.</para>
                <para> The pointer of that array can also be retrieve via the C macro . </para>
            </listitem>
        </itemizedlist>
        <para>
            
        </para>
    </refsection>
    <refsection id="Miscallaneous_C_struct">
        <title>Miscallaneous</title>
        <para>
            
            
        </para>
        <itemizedlist>
            <listitem>
                <para>
                    <emphasis role="bold">block-&gt;type :</emphasis> Integer that gives the type of the computational function. For C blocks, this number is equal to 4. 
                </para>
            </listitem>
            <listitem>
                <para>
                    <emphasis role="bold">block-&gt;label :</emphasis> Strings array that allows to retrieve the label of the block.
                </para>
            </listitem>
            <listitem>
                <para>
                    <emphasis role="bold">block-&gt;uid :</emphasis> Strings array that allows to retrieve the uid of the block.
                </para>
            </listitem>
        </itemizedlist>
    </refsection>
</refentry>

