// =============================================================================
// Scilab ( http://www.scilab.org/ ) - This file is part of Scilab
// Copyright (C) 2013 - Serge Steer - INRIA
//
//  This file is distributed under the same license as the Scilab package.
// =============================================================================
// <-- ENGLISH IMPOSED -->
// <-- XCOS TEST -->
ilib_verbose(0);
//Very simple system
importXcosDiagram("SCI/modules/xcos/tests/unit_tests/test_lincos.zcos")
 ans  =
 
  T  
execstr(scs_m.props.context)
//direct call of lincos
sys=lincos(scs_m);
assert_checkalmostequal (sys.A ,A,sqrt(%eps),1e-8);
assert_checkalmostequal (sys.B ,B,sqrt(%eps),1e-8);
assert_checkalmostequal (sys.C ,C,sqrt(%eps),1e-8);
assert_checkalmostequal (sys.D ,D,sqrt(%eps),1e-8);
//steadycos +lincos linearization around u=1
X0=[0;0];U0=1; Y0=[0;0]; 
IndX=1:$;     //All the states
IndU=[];       //All the inputs
IndY=1:$;       //Only the second output (theta), the position x is imposed
IndXd=[];     //All state derivatives must be zero
[X,U,Y,Xd,cpr]=steadycos(scs_m,X0,U0,Y0,IndX,IndU,IndY,IndXd,list(1e-10,0));
sys=lincos(cpr,X,U,list(1e-5,0));
execstr(scs_m.props.context)
assert_checkalmostequal (sys.A ,A,sqrt(%eps),1e-8);
assert_checkalmostequal (sys.B ,B,sqrt(%eps),1e-8);
assert_checkalmostequal (sys.C ,C,sqrt(%eps),1e-8);
assert_checkalmostequal (sys.D ,D,sqrt(%eps),1e-8);
//Explicit system
importXcosDiagram("SCI/modules/xcos/tests/unit_tests/IVPD.zcos")
 ans  =
 
  T  
//Search a steady state with pendulum pointing up
X0=[0;0;0;0]; //Initial state value [x',x,theta', theta] (the state order is determined by the compiler)
U0=0;             //Initial input value force applied to the cart
Y0=[1;0];         //Initial value of the output [x; theta]
//Set variables to be computed
IndX=1:4;     //All the states
IndU=1;       //All the inputs
IndY=2;       //Only the second output (theta), the position x is imposed
IndXd=[];     //All state derivatives must be zero
[X,U,Y,Xd,cpr]=steadycos(scs_m,X0,U0,Y0,IndX,IndU,IndY,IndXd,list(1e-10,0));
sys=lincos(cpr,X,U);
sys=contrss(sys);
A_ref=[0.0000000855049,13.333872344818,-0.0000000694592,10.831655054733;
       1,0,0,0;
       0,-6.001172174465,0,-4.874999942768;
       0,0,-1,0];
B_ref=[-1.5859964876424;0;0;0];
C_ref=[0,-0.6305184201126,0,0.7761742856799;
       0,0.7761742857352,0,0.6305184201576];
D_ref=[0;0];
assert_checkalmostequal (sys.A ,A_ref,sqrt(%eps),1e-8);
assert_checkalmostequal (sys.B ,B_ref,sqrt(%eps),1e-8);
assert_checkalmostequal (sys.C ,C_ref,sqrt(%eps),1e-8);
assert_checkalmostequal (sys.D ,D_ref,sqrt(%eps),1e-8);
//Implicit system (requires Codelica and a compiler)
if ~atomsIsInstalled("coselica") then atomsInstall("coselica");end
importXcosDiagram("SCI/modules/xcos/tests/unit_tests/IVPDM.zcos")
 ans  =
 
  T  
[cpr,ok]=xcos_compile(scs_m);
--------------------------------------------\
 Fonction principale Modelica : TMPDIR/IVPDM_im.mo

 Flat Modelica : TMPDIR/IVPDM_imf.mo
 Simulation C code :TMPDIR/IVPDM_im.c
AVERTISSEMENT : Le diagramme contient des blocs implicites, compilation en cours pour le solveur implicite.
//Spécification du point initial
X0=[0;0;0;0;0]; //Valeur initiale des états [x;x';theta;theta';z]
U0=0;            //Valeur initiale des entrées
Y0=[1;0];       //Valeur initiale des sorties
//Spécification des variables à déterminer
IndX=1:5;     //Tous les états
IndU=1;        //Toutes les entrées
IndY=2;         //La deuxième sortie (Theta) est libre, la première (x) est imposée
IndXd=[];      //Toutes les dérivés  des états doivent être nulles
//Recherche d'un état stationnaire
[X,U,Y,Xd]=steadycos(cpr,X0,U0,Y0,IndX,IndU,IndY,IndXd,list(1e-10,0));
sys=lincos(cpr,[X;Xd],U)
 sys  =
 
 
       sys(1)   (state-space system:)
 
!lss  A  B  C  D  X0  dt  !
 
       sys(2) = A matrix = 
 
  - 0.0078262  - 0.7700099    0.0314974  - 0.1212382  
    0.0979304    1.105D-16    0.9902728  - 0.0072989  
  - 0.0064017  - 3.0737372    0.0794957  - 0.4858118  
  - 0.6201253    0.0226344    0.1548214    0.0498000  
 
       sys(3) = B matrix = 
 
  - 0.6673223  
    1.471D-16  
  - 0.1252608  
    0.0196159  
 
       sys(4) = C matrix = 
 
    0.0290184  - 0.1552621    0.    0.9871881  
    0.0045724    0.9853582    0.    0.1555505  
 
       sys(5) = D matrix = 
 
    0.  
    0.  
 
       sys(6) = X0 (initial state) = 
 
    0.  
    0.  
    0.  
    0.  
 
       sys(7) = Time domain = 
 
 c   
sys=contrss(sys);
A_ref=[0.0225335812962,-0.3821298148313,0.0806530138820,1.2828647135879;
       0.6455340360503,0.0054498307514,0.1759342972931,0.0876719825571;
       0,-0.8331559762964,0.1351616581102,2.7878061720659;
       0,0,-0.9800632121560,-0.0416756649380];
B_ref=[0.6792599905338;0;0;0];
C_ref=[0,0.9572432752888,-0.0203688251322,0.2876787781652;
       0,-0.2856668481970,0.0320538407932,0.9552563606893];
D_ref=[0;0];
assert_checkalmostequal (sys.A ,A_ref,sqrt(%eps),1e-8);
assert_checkalmostequal (sys.B ,B_ref,sqrt(%eps),1e-8);
assert_checkalmostequal (sys.C ,C_ref,sqrt(%eps),1e-8);
assert_checkalmostequal (sys.D ,D_ref,sqrt(%eps),1e-8);
