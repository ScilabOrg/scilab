// =============================================================================
// Scilab ( http://www.scilab.org/ ) - This file is part of Scilab
// Copyright (C) 2013 - Serge Steer - INRIA
//
//  This file is distributed under the same license as the Scilab package.
// =============================================================================
// <-- ENGLISH IMPOSED -->
// <-- XCOS TEST -->
ilib_verbose(0);
//Very simple system
//==================
importXcosDiagram("SCI/modules/xcos/tests/unit_tests/test_lincos.zcos")
 ans  =
 
  T  
execstr(scs_m.props.context)
//direct call of lincos
sys=lincos(scs_m);
assert_checkalmostequal (sys.A ,A,sqrt(%eps),1e-8);
assert_checkalmostequal (sys.B ,B,sqrt(%eps),1e-8);
assert_checkalmostequal (sys.C ,C,sqrt(%eps),1e-8);
assert_checkalmostequal (sys.D ,D,sqrt(%eps),1e-8);
//steadycos +lincos linearization around u=1
X0=[0;0];U0=1; Y0=[0;0]; 
IndX=1:$;     //All the states
IndU=[];       //All the inputs
IndY=1:$;       //Only the second output (theta), the position x is imposed
IndXd=[];     //All state derivatives must be zero
[X,U,Y,Xd,cpr]=steadycos(scs_m,X0,U0,Y0,IndX,IndU,IndY,IndXd,list(1e-10,0));
sys=lincos(cpr,X,U,list(1e-5,0));
execstr(scs_m.props.context)
assert_checkalmostequal (sys.A ,A,sqrt(%eps),1e-8);
assert_checkalmostequal (sys.B ,B,sqrt(%eps),1e-8);
assert_checkalmostequal (sys.C ,C,sqrt(%eps),1e-8);
assert_checkalmostequal (sys.D ,D,sqrt(%eps),1e-8);
//Explicit system
//==================
importXcosDiagram("SCI/modules/xcos/tests/unit_tests/IVPD.zcos")
 ans  =
 
  T  
//Search a steady state with pendulum pointing up
X0=[0;0;0;0]; //Initial state value [x',x,theta', theta] (the state order is determined by the compiler)
U0=0;             //Initial input value force applied to the cart
Y0=[1;0];         //Initial value of the output [x; theta]
//Set variables to be computed
IndX=1:4;     //All the states
IndU=1;       //All the inputs
IndY=2;       //Only the second output (theta), the position x is imposed
IndXd=[];     //All state derivatives must be zero
[X,U,Y,Xd,cpr]=steadycos(scs_m,X0,U0,Y0,IndX,IndU,IndY,IndXd,list(1e-10,0));
sys=lincos(cpr,X,U);
sys=contrss(sys);
A_ref=[0.0000000855049,13.333872344818,-0.0000000694592,10.831655054733;
       1,0,0,0;
       0,-6.001172174465,0,-4.874999942768;
       0,0,-1,0];
B_ref=[-1.5859964876424;0;0;0];
C_ref=[0,-0.6305184201126,0,0.7761742856799;
       0,0.7761742857352,0,0.6305184201576];
D_ref=[0;0];
assert_checkalmostequal (sys.A ,A_ref,sqrt(%eps),1e-8);
assert_checkalmostequal (sys.B ,B_ref,sqrt(%eps),1e-8);
assert_checkalmostequal (sys.C ,C_ref,sqrt(%eps),1e-8);
assert_checkalmostequal (sys.D ,D_ref,sqrt(%eps),1e-8);
//Implicit system (requires Codelica and a compiler)
//==================================================
if ~atomsIsInstalled("coselica") then atomsInstall("coselica");end
importXcosDiagram("SCI/modules/xcos/tests/unit_tests/IVPDM.zcos");
[cpr,ok]=xcos_compile(scs_m);
--------------------------------------------\
 Main Modelica : TMPDIR/IVPDM_im.mo

 Flat Modelica : TMPDIR/IVPDM_imf.mo
 Simulation C code :TMPDIR/IVPDM_im.c
WARNING: Diagram contains implicit blocks, compiling for implicit Solver.
//Spécification du point initial
X0=[0;0;0;0;0]; //Valeur initiale des états [x;x';theta;theta';z]
U0=0;            //Valeur initiale des entrées
Y0=[1;0];       //Valeur initiale des sorties
//Set variables to be computed
IndX=1:5;      //All the states
IndU=1;        //All the inputs
IndY=2;        //Only the second output (theta), the position x is imposed
IndXd=[];      //All state derivatives must be zero
//Compute the steady state
[X,U,Y,Xd]=steadycos(cpr,X0,U0,Y0,IndX,IndU,IndY,IndXd,list(1e-10,0));
sys=lincos(cpr,[X;Xd],U);
sys=contrss(sys);
A_ref=[0.0225335812962,-0.3821298148313,0.0806530138820,1.2828647135879;
       0.6455340360503,0.0054498307514,0.1759342972931,0.0876719825571;
       0,-0.8331559762964,0.1351616581102,2.7878061720659;
       0,0,-0.9800632121560,-0.0416756649380];
B_ref=[0.6792599905338;0;0;0];
C_ref=[0,0.9572432752888,-0.0203688251322,0.2876787781652;
       0,-0.2856668481970,0.0320538407932,0.9552563606893];
D_ref=[0;0];
assert_checkalmostequal (sys.A ,A_ref,sqrt(%eps),1e-8);
assert_checkalmostequal (sys.B ,B_ref,sqrt(%eps),1e-8);
assert_checkalmostequal (sys.C ,C_ref,sqrt(%eps),1e-8);
assert_checkalmostequal (sys.D ,D_ref,sqrt(%eps),1e-8);
