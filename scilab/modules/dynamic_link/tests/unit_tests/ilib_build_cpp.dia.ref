// =============================================================================
// Scilab ( http://www.scilab.org/ ) - This file is part of Scilab
// Copyright (C) 2008 - DIGITEO - Sylvestre LEDRU
// Copyright (C) 2009-2011 - DIGITEO
// Copyright (C) 2015 - Scilab Enterprises - Anais AUBERT
//
//  This file is distributed under the same license as the Scilab package.
// =============================================================================
//
// <-- CLI SHELL MODE -->
//
// =============================================================================
//Here with give a complete example on adding new primitive to Scilab
ilib_verbose(0);
i = ['#include <string>'
'#define __USE_DEPRECATED_STACK_FUNCTIONS__'
'extern ""C"" {'
   '#include ""api_scilab.h""'
   '#include <stdio.h>'
'int sci_cppfind(char *fname, void *pvApiCtx) {'
'  int m1 = 0, n1 = 0, *l1 = NULL;'
'  char *inputString1 = NULL, *inputString2 = NULL;'
'  int m2 = 0, n2 = 0, *l2 = NULL;'
'  int m3 = 0, n3 = 0;'
   '  SciErr sciErr;'
    'int* piAddr1 = NULL;'
    'int* piAddr2 = NULL;'
'  double *position = NULL; /* Where we will store the position */'
'  CheckRhs(2,2); /* Check the number of input argument */'
'  CheckLhs(1,1); /* Check the number of output argument */'
    'sciErr = getVarAddressFromPosition(pvApiCtx, 1, &piAddr1);'
    'sciErr = getMatrixOfString(pvApiCtx, piAddr1, &m1, &n1, NULL, NULL);'
    'l1 = (int*)MALLOC(sizeof(int)*m1*n1);'
    'sciErr = getMatrixOfString(pvApiCtx, piAddr1, &m1, &n1, l1, NULL);'
    'inputString1 = (char*)malloc(sizeof(char) * m1 * n1);'
    'sciErr = getMatrixOfString(pvApiCtx, piAddr1, &m1, &n1,l1, &inputString1);'
    
    'sciErr = getVarAddressFromPosition(pvApiCtx,2, &piAddr2);'
    'sciErr = getMatrixOfString(pvApiCtx, piAddr2, &m2, &n2, NULL, NULL);'
    'l2 = (int*)MALLOC(sizeof(int)*m2*n2);'
    'sciErr = getMatrixOfString(pvApiCtx, piAddr2, &m2, &n2, l2, NULL);'
    'inputString2 = (char*)malloc(sizeof(char) * m2 * n2);'
    'sciErr = getMatrixOfString(pvApiCtx, piAddr2, &m2, &n2, l2, &inputString2);'
    
'  std::string myMessage (inputString1);'
'  std::string search (inputString2);'
'  m3=1;n3=1;'
    'sciErr = allocMatrixOfDouble(pvApiCtx, Rhs + 1, m3, n3, &position);'
'  if (myMessage.find(search) != std::string::npos) {'
'    *position = myMessage.find(search); /* The actual operation */'
'  } else {'
'    *position = -1; /* Substring not found */'
'  }'
'  LhsVar(1) = Rhs+1;'
    ' PutLhsVar();'
'  return 0;'
'}'
'}'];
mkdir(TMPDIR, "ilib_build_cpp");
cd(TMPDIR + "/ilib_build_cpp");
mputl(i, TMPDIR + "/ilib_build_cpp/" + "sci_cppfind.cxx");
//creating the shared library (a gateway, a Makefile and a loader are 
//generated. 
files = ['sci_cppfind.cxx'];
ilib_build('foo', ['cppfind', 'sci_cppfind'], files,[]);
// load the shared library 
exec loader.sce;
// Small test to see if the function is actually working.
assert_checkequal(cppfind("my very long string", "long"), 8);
assert_checkequal(cppfind("my very long string","very"), 3);
assert_checkequal(cppfind("my very long string","short"), -1);
if getos() == "Linux" | getos() == "Darwin" then
// Force the usage 
   files = ['sci_cppfind.cxx'];
   ilib_build('foo2', ['cppfind2', 'sci_cppfind'], files,[],[], [], "-fpermissive", [], [], "g++");
   exec loader.sce;
   // Small test to see if the function is actually working.
   assert_checkequal(cppfind("my very long string", "long"), 8);
   assert_checkequal(cppfind("my very long string","very"), 3);
   assert_checkequal(cppfind("my very long string","short"), -1);
end
