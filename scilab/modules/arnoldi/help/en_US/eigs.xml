<?xml version="1.0" encoding="utf-8"?>
<!--
 * Scilab ( http://www.scilab.org/ ) - This file is part of Scilab
 * Copyright (C) 2012 - Scilab Enterprises - Adeline CARNIS
 * 
 * This file must be used under the terms of the CeCILL.
 * This source file is licensed as described in the file COPYING, which
 * you should have received as part of this distribution.  The terms
 * are also available at    
 * http://www.cecill.info/licences/Licence_CeCILL_V2-en.txt
 *
 -->
<refentry xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:svg="http://www.w3.org/2000/svg" xmlns:ns5="http://www.w3.org/1999/xhtml" xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:db="http://docbook.org/ns/docbook" version="5.0-subset Scilab" xml:id="eigs" xml:lang="en">
  <refnamediv>
    <refname>eigs</refname>
    <refpurpose>calculates eigenvalues and eigenvectors of matrices</refpurpose>
  </refnamediv>
  <refsynopsisdiv>
    <title>Calling Sequence</title>
    <synopsis>
      d = eigs(A [,B [,k [,sigma [,opts]]]])
      [d, v] = eigs(A [,B [,k [,sigma [,opts]]]])
    </synopsis>
  </refsynopsisdiv>
  <refsection>
    <title>Arguments</title>
    <variablelist>
      <varlistentry>
        <term>A</term>
        <listitem>
          <para>a full or sparse, real or complex, symmetric or non-symmetric square matrix or a function</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>B</term>
        <listitem>
          <para>
            a sparse, real or complex, square matrix with same dimensions as
            <literal> A</literal>
          </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>k</term>
        <listitem>
          <para>a integer, number of eigenvalues to be computed</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>sigma</term>
        <listitem>
          <para>a real scalar or a string of length 2</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>opts</term>
        <listitem>
          <para>a structure</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>d</term>
        <listitem>
          <para>a real or complex eigenvalues vector or diagonal matrix (eigenvalues along the diagonal)</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>v</term>
        <listitem>
          <para>
            real or complex eigenvector matrix
          </para>
        </listitem>
      </varlistentry>
    </variablelist>
  </refsection>
  <refsection>
    <title>Description</title>
    <variablelist>
      <varlistentry>
        <term>d = eigs(A)</term>
        <listitem>
          <para>
            solves the eigenvalue problem <literal>A * v = lambda * v</literal>. This calling returns a vector <literal>d</literal> containing the six largest magnitude eigenvalues.
            <literal>A</literal> is either a square matrix, which can be symmetric or non-symmetric, real or complex, full or sparse, or a function.
          </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>[d, v] = eigs(A)</term>
        <listitem>
          <para>
            returns a diagonal matrix <literal>d</literal> containing the six largest magnitude eigenvalues on the diagonal.
            <literal>v</literal> is a n by six matrix whose columns are the six eigenvectors corresponding to the returned eigenvalues.
          </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>d = eigs(A, B)</term>
        <listitem>
          <para>
            solves the generalized eigenvalue problem <literal>A * v = lambda  * B * v </literal> with positive, definite matrix <literal>B</literal>.
          </para>
          <itemizedlist>
            <listitem>
              <para>
                if <literal>B</literal> is not specified, <literal>B = []</literal> is used.
              </para>
            </listitem>
            <listitem>
              <para>
                if <literal>B</literal> is specified, <literal>B</literal> must be the same size as A.
              </para>
            </listitem>
          </itemizedlist>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>d = eigs(A, B, k)</term>
        <listitem>
          <para>
            returns in vector <literal>d</literal> the <literal>k</literal> eigenvalues.
            If <literal>k</literal> is not specified, <literal>k = min(n, 6)</literal>, where n is the row number of A.
          </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>d = eigs(A, B, k, sigma)</term>
        <listitem>
          <para>
            returns in vector <literal>d</literal> the <literal>k</literal> eigenvalues determined by <literal>sigma</literal>.
            <literal>sigma</literal> can be either a real or complex including 0 scalar or string.
            If sigma is a string of length 2, it takes one of the followings values :
          </para>
          <itemizedlist>
            <listitem>
              <para>
                <literal>'LM'</literal> compute the NEV largest in magnitude eigenvalues (by default).
              </para>
            </listitem>
            <listitem>
              <para>
                <literal>'SM'</literal> compute the NEV smallest in magnitude eigenvalues (same as sigma = 0).
              </para>
            </listitem>
            <listitem>
              <para>
                <literal>'LA'</literal> compute the NEV Largest Algebraic eigenvalues, only for real symmetric problems.
              </para>
            </listitem>
            <listitem>
              <para>
                <literal>'SA'</literal> compute the NEV Smallest Algebraic eigenvalues, only for real symmetric problems.
              </para>
            </listitem>
            <listitem>
              <para>
                <literal>'BE'</literal> compute NEV eigenvalues, half from each end of the spectrum, only for real symmetric problems.
              </para>
            </listitem>
            <listitem>
              <para>
                <literal>'LR'</literal> compute the NEV eigenvalues of Largest Real part, only for real non-symmetric or complex problems.
              </para>
            </listitem>
            <listitem>
              <para>
                <literal>'SR'</literal> compute the NEV eigenvalues of Smallest Real part, only for real non-symmetric or complex problems.
              </para>
            </listitem>
            <listitem>
              <para>
                <literal>'LI'</literal> compute the NEV eigenvalues of Largest Imaginary part, only for real non-symmetric or complex problems.
              </para>
            </listitem>
            <listitem>
              <para>
                <literal>'SI'</literal> compute the NEV eigenvalues of Smallest Imaginary part, only for real non-symmetric or complex problems.
              </para>
            </listitem>
          </itemizedlist>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>d = eigs(A, B, k, sigma, opts)</term>
        <listitem>
          <para>
            If the <literal> opts </literal> structure is specified, different options can be used to compute the <literal>k</literal> eigenvalues :
          </para>
          <itemizedlist>
            <listitem>
              <para>
                <term>tol</term>
                <para>
                  required convergence tolerance. By default, <literal>tol = %eps</literal>.
                </para>
              </para>
            </listitem>
            <listitem>
              <para>
                <term>maxiter</term>
                <para>
                  maximum number of iterations. By default, <literal>maxiter = 300</literal>.
                </para>
              </para>
            </listitem>
            <listitem>
              <para>
                <term>ncv</term>
                <para>
                  number of Lanzcos basis vectors to use. The <literal>ncv</literal> value must be greater or equal than <literal>2 * k + 1 </literal> for real non-symmetric
                  problems. For real symmetric or complex problems, <literal>ncv</literal> must be greater or equal <literal>2 * k </literal>.
                </para>
              </para>
            </listitem>
            <listitem>
              <para>
                <term>resid</term>
                <para>
                  starting vector whose contains the initial residual vector, possibly from a previous run. By default,
                  <literal>resid</literal> is a random initial vector.
                </para>
              </para>
            </listitem>
            <listitem>
              <para>
                <term>cholB</term>
                <para>
                  if <literal>chol(B)</literal> is passed rather than <literal>B</literal>. By default, <literal>cholB</literal> is 0.
                </para>
              </para>
            </listitem>
          </itemizedlist>
        </listitem>
      </varlistentry>
    </variablelist>
  </refsection>
  <refsection>
    <title>References</title>
    <para>
      This function is based on the ARPACK package written by R. Lehoucq, K. Maschhoff, D. Sorensen, and C. Yang.
    </para>
    <itemizedlist>
      <listitem>
        <para>DSAUPD and DSEUPD routines for real symmetric problems,</para>
      </listitem>
      <listitem>
        <para>DNAUPD and DNEUPD routines for real non-symmetric problems.</para>
      </listitem>
      <listitem>
        <para>ZNAUPD and ZNEUPD routines for complex problems.</para>
      </listitem>
    </itemizedlist>
  </refsection>
  <refsection>
    <title>Examples</title>
    <programlisting role="example">
      <![CDATA[ 
// REAL SYMMETRIC PROBLEM WITH FULL MATRIX
A            = diag(10*ones(10,1));
A(1:$-1,2:$) = A(1:$-1,2:$) + diag(6*ones(9,1));
A(2:$,1:$-1) = A(2:$,1:$-1) + diag(6*ones(9,1));
d = eigs(A)
[d, v] = eigs(A)

B = eye(10,10);
k = 8;
sigma = 'SM';

d = eigs(A, B, k, sigma)
[d, v] = eigs(A, B, k, sigma)

opts.cholB = 1;

d = eigs(A, B, k, sigma, opts)
[d, v] = eigs(A, B, k, sigma, opts)

// REAL SYMMETRIC PROBLEM WITH SPARSE MATRIX
// The results are the same 
AS = sparse(A);
BS = sparse(B);
d = eigs(AS)
[d, v] = eigs(AS)

d = eigs(AS, BS, k, sigma)
[d, v] = eigs(AS, BS, k, sigma)

d = eigs(AS, BS, k, sigma, opts)
[d, v] = eigs(AS, BS, k, sigma, opts)

// REAL NON-SYMMETRIC PROBLEM WITH FULL MATRIX
A            = diag(10*ones(10,1));
A(1:$-1,2:$) = A(1:$-1,2:$) + diag(6*ones(9,1));
A(2:$,1:$-1) = A(2:$,1:$-1) + diag(-6*ones(9,1));
d = eigs(A)
[d, v] = eigs(A)

B = eye(10,10);
k = 8;
sigma = 'SM';

d = eigs(A, B, k, sigma)
[d, v] = eigs(A, B, k, sigma)

opts.cholB = 1;

d = eigs(A, B, k, sigma, opts)
[d, v] = eigs(A, B, k, sigma, opts)

// REAL NON-SYMMETRIC PROBLEM WITH SPARSE MATRIX
// The results are the same 
AS = sparse(A);
BS = sparse(B);
d = eigs(AS)
[d, v] = eigs(AS)

d = eigs(AS, BS, k, sigma)
[d, v] = eigs(AS, BS, k, sigma)

d = eigs(AS, BS, k, sigma, opts)
[d, v] = eigs(AS, BS, k, sigma, opts)

// COMPLEX PROBLEM WITH FULL MATRIX
A            = diag(10*ones(10,1))+%i*ones(10,1));
A(1:$-1,2:$) = A(1:$-1,2:$) + diag(6*ones(9,1));
A(2:$,1:$-1) = A(2:$,1:$-1) + diag(-6*ones(9,1));
d = eigs(A)
[d, v] = eigs(A)

B = eye(10,10);
k = 8;
sigma = 'SM';

d = eigs(A, B, k, sigma)
[d, v] = eigs(A, B, k, sigma)

opts.cholB = 1;

d = eigs(A, B, k, sigma, opts)
[d, v] = eigs(A, B, k, sigma, opts)

// COMPLEX WITH SPARSE MATRIX
// The results are the same 
AS = sparse(A);
d = eigs(AS)
[d, v] = eigs(AS)

 ]]>
    </programlisting>
  </refsection>
  <refsection role="see also">
    <title>See Also</title>
    <simplelist type="inline">
      <member>
        <link linkend="spec">spec</link>
      </member>
    </simplelist>
  </refsection>
</refentry>
