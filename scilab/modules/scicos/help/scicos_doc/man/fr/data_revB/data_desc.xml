<!--  Scicos

   Copyright (C) INRIA - METALAU Project <scicos@inria.fr>

  This program is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 2 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

  See the file ../license.txt
-->

<?xml version="1.0" encoding="ISO-8859-1" standalone="no"?>
<DATA flag="desc">

<FILE name='ABCD_Blocks' type='XML'>
  <DESCRIPTION>

  </DESCRIPTION>
</FILE>

<FILE name='ABSBLK_f' type='LATEX'>
Le bloc Abs calcule à la sortie, la valeur absolue de l'entrée.
</FILE>

<FILE name='ABS_VALUE' type='LATEX'>
Le bloc Abs calcule à la sortie, la valeur absolue de l'entrée.
</FILE>

<FILE name='AFFICH_f' type='LATEX'>
Pendant la simulation, ce bloc affiche sur le diagramme
la valeur lue sur son unique port d'entrée.
</FILE>

<FILE name='AFFICH_m' type='LATEX'>
Pendant la simulation, ce bloc affiche sur le diagramme
la valeur lue sur son unique port d'entrée.
</FILE>

<FILE name='ANDBLK' type='LATEX'>
The Bus Creator block combines a set of signals, i.e., a
group of signals represented by a single line in a block diagram. It
allows you to reduce the number of lines required to route signals
from one part of a diagram to another. This makes your easier to
understand.
</FILE>

<FILE name='ANDLOG_f' type='LATEX'>
Ce bloc possédant deux entrées événementielles et une sortie régulière,
délivre {\bf +1} ou {\bf -1} sur sa sortie régulière suivant ses entrées événementielles.

\begin{itemize}
  \item{\bf +1 :} Lorsque les événements sont synchrones (même événement présent sur
                  les deux ports événementiels simultanément),

  \item{\bf -1 :} Lorsqu'un seul événement est présent.
\end{itemize}
</FILE>

<FILE name='AUTOMAT' type='LATEX'>
This block gives the possibility to construct hybrid automata, i.e., a
hybrid system whose discrete part is defined via modes and transitions
between modes, and the continuous part is defined via DAE
(differential algebraic equations). 

The automaton block provides a switching mechanism between subsystems
corresponding to control modes of an automaton.  Subsystems are
constructed in such a way that they have the state vector as input (
coming from the automaton block) and compute the flow and jump
functions (zero-crossing) and pass them back to the automaton
block. The state variables are defined in the automaton block and the
subsystems are static functions.

Suppose that a hybrid automaton consists of {\bf $M$} control
 modes. The continuous-time dynamics in mode $i$ is defined with DAE
 ($0=F_i(\dot x, x, u)$) where $i\in \{1 \dots M\}$ and the dimension
 of $x$ is $N$ ($N\ge0$) for any $i\in \{1 \dots M\}$. Suppose that in
 control mode $i$, there are $Z_i$ jump conditions indicating jumps
 toward other modes. The jump conditions are defined by
 $Jump_{ij}(\dot x,x,u)$ functions where $j\in \{1 \dots Z_i\}$.

 When a jump function changes sign and becomes positive, a mode
 transition will happen. When $k^{th}$ transition function becomes
 positive, a transition to mode $k$ happens and  state vector $x$ is reset
 to $Reset_k(\dot x,x,u)$, {\it i.e.,} $x_l=Reset_{kl}(\dot x,x,u)$
 for $l\in \{1 \dots N\}$.

 In order to develop an automaton containing a mode with multiple
 reset functions, the value of the current and previous active modes
 should be used. These values are available at the first output port
 of the block.


The automaton block has the following input/output ports.

\begin{itemize}
\item {\bf Output 1:} The first output port is a vector of size two
 consisting of the current and the previous active control modes,
 i.e., $OUT_1=[current-mode,~previous-mode]^t$.

\item {\bf Output 2:} The second output port is a vector of size {\bf
  $2N$} providing the state vector and its first time derivative, {\it
  i.e.,} $[ x,\dot x]^t$.  

\item {\bf Inputs:} The automaton block has $M$ vector input ports
  corresponding to $M$ modes or subsystems of the automaton.  Each
  input defines the dynamic behavior in the control each mode as well
  as the reset functions and the transition functions.  The input port
  $i$ which is the output of the $i^{th}$ subsystem is a vector of
  size $2N+Z_i$. Each input is composed of  the following vector.

  $Input_i=\left[F_i(\dot x,x,u),~ Reset_i(\dot x,x,u),~ Jump_i(\dot
  x,x,u) \right]^t$

\begin{itemize}
\item The first $N$ elements of the $Input_i$ are the continuous-time
dynamics.  The dynamics of the system in the control mode $i$ is
described by a smooth index-1 DAE ({\it i.e.,} $0=F_i(\dot x,x,u,t)$).

\item The next $N$ elements of $Input_i$ are the values used to
 reset the continuous-time states when a transition \underline{to} 
 control mode $i$ is activated.

\item The next $Z_i$ elements of $Input_i$ are the jump or
zero-crossing functions. If the $j^{th}$ zero-crossing function of
mode $i$ crosses zero with negative to positive direction, a
transition to $j^{th}$ destination mode happens.
\end{itemize}

\item {\bf Event Output:} This is an event output port, which is
activated whenever a mode transition happens. This event is useful
when an event is needed to activate or initialize a part of the
subsystem not included in the internal dynamics of the automaton
block.
\end{itemize}
 In the interface window, the number of control modes, the initial
control mode and the initial value of continuous-time states at the
beginning of the simulation should be given.

Find more documentation and demos about the Automaton block oat
www.scicos.org. Interested users are referred to the paper "Modeling
Hybrid Automata in Scicos", Masoud Najafi, Ramine Nikoukhah, 2007 IEEE
Multi-conference on Systems and Control, Singapore. 
</FILE>

<FILE name='About_scicos' type='LATEX'>
 \subsection{Au sujet de Scicos...}

  Scicos est actuellement développé par l'équipe Scicos (A. Layec, M. Najafi, F. Nassif)
  sous la direction de R. Nikoukhah au sein du projet METALAU à l'INRIA, unité de Recherche
  de Rocquencourt.

  Les principaux contributeurs de la famille Scicos 4.x sont :

  \begin{itemize}
      \item {\bf Fady Nassif} (INRIA) \\
         Jeu de blocs matriciels/entiers.\\
         Blocs SampleClk/Goto From/atomiques...

      \item {\bf Masoud Najafi} (INRIA) \\
         Intégration Modelica.\\
         Conception du simulateur.

      \item {\bf Ramine Nikoukhah} (INRIA) \\
         Algorithme du compilateur.\\
         Comportement multi-fenêtre de l'éditeur.

      \item {\bf Alan Layec} (INRIA) \\
         Intégration des données matricielles typées.\\
         Générateur de code C.\\
         Documentation HTML.

      \item {\bf Simone Mannori/Serge Steer} (INRIA) \\
         Conception de l'éditeur nouveau graphique.

      \item {\bf Benoit Bayol} (Etudiant) \\
         Jeu de blocs pour l'affichage des données (nouveau graphique)
 \end{itemize}
</FILE>

<FILE name='BACKLASH' type='LATEX'>
The Backlash block implements a system in which a change in input
causes an equal change in output. However, when the input changes
direction, an initial change in input has no effect on the output.
The amount of side-to-side play in the system is referred to as the
{\em deadband or gap}.
</FILE>

<FILE name='BIGSOM_f' type='LATEX'>
Le bloc somme réalise l'addition de ses entrées.
Ce bloc peut additionner des scalaires ou des vecteurs d'entrée.
</FILE>

<FILE name='BITCLEAR' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  This blocks set the specified bit of the integer input to 0.
	  The user can specify the bit in the field:"index of bit".
	  Bit 0 is the least significant bit.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='BITSET' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  This blocks set the specified bit of the integer input to 1.
	  The user can specify the bit in the field:"index of bit".
	  Bit 0 is the least significant bit.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='BOUNCE' type='XML'>
<DESCRIPTION>

</DESCRIPTION>
</FILE>

<FILE name='BOUNCEXY' type='XML'>
<DESCRIPTION>

</DESCRIPTION>
</FILE>

<FILE name='BPLATFORM' type='XML'>
  <DESCRIPTION>

  </DESCRIPTION>
</FILE>

<FILE name='Bache' type='LATEX'>
Ce composant représente une bache thermo-hydraulique qui consiste en
deux ports d'entrée et deux ports de sortie.  Conventionnellement, la
direction positive pour la rentrée est quand le fluide {\bf entre}
dans le port d'entree (ports noirs) et la direction positive pour les
ports de sortie est quand le fluide {\bf sort} des port de sortie
(ports blancs).  La surface de la bache, la température initiale et
l'altitude initiale du fluide peuvent être definies par l'utilisateur.
Si un port reste non-utilisé, il doit être bouché par le bloc {\bf
Bouchon}.
</FILE>

<FILE name='Branching_pal' type='LATEX'>
Dans la palette Branching, vous pouvez trouver divers blocs
pour la gestion des données véhiculées par les liens réguliers.
</FILE>

<FILE name='CANIMXY' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  This block realizes the visualization of the evolution of
          the two regular input signals by drawing the second input
          as a function of the first at instants of events on the
          event input port.  When a point is drawn on screen it stays
          until the buffer length is reached. This scope is useful to
          make simple animations.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='CANIMXY3D' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  This block realizes the visualization of the evolution of
          the three regular input signals by drawing the third input
          as a function of the two others at instants of events on the
          event input port. When a point is drawn on screen it stays
          until the buffer length is reached. This scope is useful to
          make simple animations.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='CBLOCK' type='LATEX'>
Ce bloc crée une fonction de calcul squelette en C.
Il crée aussi une librairie et un fichier objet à la compilation.
</FILE>

<FILE name='CBLOCK4' type='LATEX'>
Ce bloc crée une fonction de calcul squelette en C.
Il crée aussi une librairie et un fichier objet à la compilation.
</FILE>

<FILE name='CCS' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
    <DESCRIPTION_ITEM>
    <P>

    This block is an ideal current source. The current value is
    controlled through the explicit input of the block (connected to
    standard Scicos blocks). The voltage across the block is
    independent of the current value.

    </P>
    </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='CEVENTSCOPE' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  This block realizes the visualization of the input event
          signals.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='CFSCOPE' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  This is a floating scope block.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='CLINDUMMY_f' type='LATEX'>
Ce bloc peut être placé dans tous diagrammes qui contient un ou
des blocs 'zero-crossing' et qui ne dispose pas de blocs contenant
des états continus (x) temps dépendant (dep\_t=\%t).
Grâce à cela, le simulateur utilisera le solveur ode pour la détection
de surfaces des blocs 'zero-crossing'.
</FILE>

<FILE name='CLKFROM' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  This block is used to connect events ports. For more
          information on how it works please refer to the
          documentation of the FROM block by clicking on the link in
          the "See also" field.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='CLKGOTO' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  This block is used to connect events ports. For more
	  information on how it works please refer to the
	  documentation of the GOTO block by clicking on the link in
	  the "See also" field.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='CLKGotoTagVisibility' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  This block is used in the event case. For more information
	  on how it works please refer to the documentation of the
	  GotoTagVisibility block by clicking on the link in
	  the "See also" field.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='CLKINV_f' type='LATEX'>
Ce bloc doit seulement être utilisé à l'intérieur des superblocs.
Il est utilisé pour représenter un port d'entrée événementiel.
Dans un superbloc, les ports doivent être numérotés à partir de 1
jusqu'au nombre de ports.  
</FILE>

<FILE name='CLKIN_f' type='LATEX'>
Ce bloc doit seulement être utilisé à l'intérieur des superblocs.
Il est utilisé pour représenter un port d'entrée événementiel.
Dans un superbloc, les ports doivent être numérotés à partir de 1
jusqu'au nombre de ports.  
</FILE>

<FILE name='CLKOUTV_f' type='LATEX'>
Ce bloc doit seulement être utilisé à l'intérieur des superblocs.
Il est utilisé pour représenter un port de sortie événementiel.
Dans un superbloc, les ports doivent être numérotés à partir de 1
jusqu'au nombre de ports.  
</FILE>

<FILE name='CLKOUT_f' type='LATEX'>
Ce bloc doit seulement être utilisé à l'intérieur des superblocs.
Il est utilisé pour représenter un port de sortie événementiel.
Dans un superbloc, les ports doivent être numérotés à partir de 1
jusqu'au nombre de ports.
</FILE>

<FILE name='CLKSOMV_f' type='LATEX'>
Ce bloc est un bloc d'addition d'événement à trois entrées.
La sortie reproduit les événements de tous les ports d'entrées.
A proprement parler, CLKSOMV n'est pas un vrai bloc scicos, car
il est ignoré pendant la phase de compilation.\\
Les sorties et les entrées de ce bloc sont synchronisées.
</FILE>

<FILE name='CLKSOM_f' type='LATEX'>
Ce bloc est un bloc d'addition d'événement à trois entrées.
La sortie reproduit les événements de tous les ports d'entrées.
A proprement parler, CLKSOM\_f n'est pas un vrai bloc scicos, car
il est ignoré pendant la phase de compilation.\\
Les sorties et les entrées de ce bloc sont synchronisées.
</FILE>

<FILE name='CLKSPLIT_f' type='XML'>
<DESCRIPTION>

</DESCRIPTION>
</FILE>

<FILE name='CLOCK_c' type='LATEX'>
Ce bloc est un super-bloc construit grâce au bloc
\htmladdnormallink{EVTDLY\_c}{EVTDLY_c.htm} qui 
est rebouclé sur lui-même.\\
L'unique sortie de ce bloc génère des événements
à des dates précises, qui sont déterminées par le
paramètre {\bf Period} de la boîte de dialogue.
</FILE>

<FILE name='CLOCK_f' type='LATEX'>
Ce bloc est un super-bloc construit grâce au bloc
\htmladdnormallink{EVTDLY\_f}{EVTDLY_f.htm} qui
est rebouclé sur lui-même.\\
L'unique sortie de ce bloc génère des événements
à des dates précises, qui sont déterminées par le
paramètre {\bf Period} de la boîte de dialogue.
</FILE>

<FILE name='CLR' type='LATEX'>
Ce bloc réalise un système linéaire SISO (Single Input Single Output) 
représenté par une fonction de transfert rationnelle.
La fonction rationnelle doit être une fonction propre.
</FILE>

<FILE name='CLR_f' type='LATEX'>
Ce bloc réalise un système linéaire SISO (Single Input Single Output) 
représenté par une fonction de transfert rationnelle.
La fonction rationnelle doit être une fonction propre.
</FILE>

<FILE name='CLSS' type='LATEX'>
Ce bloc réalise un système linéaire d'équations d'état en temporel continu.
\begin{eqnarray}
\dot x&=&Ax+Bu\\
  y   &=&C*x+D*u
\end{eqnarray}
Le système est défini par les matrices $(A,B,C,D)$
et par l'état initial $x_0$.
Les dimensions des matrices et de l'état initial doivent être appropriées.
</FILE>

<FILE name='CLSS_f' type='LATEX'>
Ce bloc réalise un système linéaire d'équations d'état en temporel continu.
\begin{eqnarray}
\dot x&=&Ax+Bu\\
  y   &=&C*x+D*u
\end{eqnarray}
Le système est défini par les matrices $(A,B,C,D)$
et par l'état initial $x_0$.
Les dimensions des matrices et de l'état initial doivent être appropriées.
</FILE>

<FILE name='CMAT3D' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  CMAT3D est un scope qui montre les valeurs en Z des matrices
          sur une grille xy.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='CMATVIEW' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
          CMATVIEW est un scope qui montre les valeurs des matrices
          sur une grille en couleur.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='CMSCOPE' type='LATEX'>
Au début de la simulation, ce bloc ouvre une fenêtre  pour afficher
l'évolution temporelle des données qui seront lues sur les ports
d'entrées réguliers.
Ce bloc est donc similaire à un oscilloscope.
Il permet l'affichage de multiple abscisses (une par entrée).
Ces abscisses peuvent avoir des échelles temporelles différentes
qui seront définies par le paramètre {\bf Refresh period}.
</FILE>

<FILE name='CONST' type='LATEX'>
Ce bloc est un générateur de valeurs constantes.
</FILE>

<FILE name='CONSTRAINT2_c' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
    <DESCRIPTION_ITEM>
    <P>
The Algebraic-differential Constraint block constrains the input signal f(x',x) to
zero and outputs an algebraic state x and a derivative of the state x'. The block outputs the value
necessary to produce a zero at the input. The output must affect the
input through some direct feedback path, i.e., the feedback path
should only contains blocks with direct feedthrough (without internal
states). This enables the user to specify  equations for fully
implicit index-1 differential/algebraic systems (DAEs), i.e., F(x',x)=0.
    </P>
    <P>
By default, the initial values of the state vector and the derivative
of the state vector which is used as initial guess values are zero. If
the solver cannot converge towards the solution at the beginning of
the integration, the user can help the solver by providing an initial
guess that is close to the solution value. If f(x',x) has several
solutions, the initial guess helps the solver to select the desired
solution.
    </P>
    </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='CONSTRAINT_c' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
    <DESCRIPTION_ITEM>
    <P>
The Algebraic Constraint block constrains the input signal f(x) to
zero and outputs an algebraic state x. The block outputs the value
necessary to produce a zero at the input. The output must affect the
input through some direct feedback path, i.e., the feedback path
should only contains blocks with direct feedthrough (without internal
states). This enables the user to specify algebraic equations for index-1
differential/algebraic systems (DAEs).
    </P>
    <P>
By default, the initial value of the state which is used as initial
guess values is zero. If the solver cannot converge towards the
solution at the beginning of
the integration, the user can help the solver by providing an initial guess
that is close to the solution value. If  f(x) has
several solutions, the initial guess helps the solver to select the
desired solution.
    </P>
    </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='CONST_f' type='LATEX'>
Ce bloc est un générateur de valeurs constantes.
</FILE>

<FILE name='CONST_m' type='LATEX'>
Ce bloc est un générateur de valeurs constantes.
</FILE>

<FILE name='CONVERT' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	This block converts an input signal of any data type to a
        specified data type. The input can be real, complex or integer.
        When the output is an integer and when overflow occurs the block
        three different forms of results :
        </P>
	  <P>1- A normal non saturated result.</P>
	  <P>2- A saturated result.</P>
	  <P>3- An error message warning the user about the overflow..</P>
	<P>
        The user can select one of these three forms by setting
        the "DO ON OVERFLOW" field to 0,1 or 2.
        </P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='COSBLK_f' type='LATEX'>
$$y=\cos(u)$$
</FILE>

<FILE name='CSCOPE' type='LATEX'>
Au début de la simulation, ce bloc ouvre une fenêtre  pour afficher
l'évolution temporelle des données qui seront lues sur le port
d'entrée régulier.
Ce bloc est donc similaire à un oscilloscope.
Il permet d'afficher sur une même figure l'évolution des
éléments d'un vecteur.
Ce bloc ne possède qu'une seule échelle temporelle.
</FILE>

<FILE name='CSCOPXY' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  This block realizes the visualization of the evolution of the
          two regular inputs signals by drawing the second input as a
          function of the first at instants of events on the event input
          port. When a point is drawn on screen it stays until the
          simulation is finished.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='CSCOPXY3D' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  This block realizes the visualization of the evolution of the
          three regular inputs signals by drawing the third input as a
          function of the two others at instants of events on the event
          input port. When a point is drawn on screen it stays until the
          simulation is finished.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='CUMSUM' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  The CUMSUM block sums the element of an input m*n matrix u
          along either the rows, the columns or the first non singleton
          dimension. When the "Sum along" parameter is set to "1", the
          block sums across the elements of each row. The result will be
          displayed as a m*1 matrix.
	</P>
	<P>
	  When the "Sum along" parameter is set to "2", the block sums
          across the elements of each column. The result will be display
          as a 1*n matrix.
	</P>
	<P>
	  When the "Sum along" parameter is set to "0", the block sums
          across the first non singleton dimension. The result will be
          displayed as one element.
	  This block is equivalent to cumsum in scilab.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='CURVE_c' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
This block allows the user to create signals and use them as a signal
source block. The signals can be created either graphically by the
user or be defined by specifying two vectors, i.e., a vector for time
and a vector for amplitude. These vectors define the mesh points and
the signal value at intermediate points are obtained by interpolating
the points. Several interpolation methods are available. This block
can also generate the signal periodically. It is also possible to read
data from Excel data-sheets and from formatted C data files.
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='CURV_f' type='LATEX'>
Ce bloc définit une fonction tabulée en fonction du temps.
Entre chaque point des mailles, ce bloc réalise une interpolation
linéaire. En dehors des points tabulés, il fournit les derniers
points rencontrés. L'utilisateur peut définir les différents points
en utilisant un éditeur graphique de courbes.
</FILE>

<FILE name='CVS' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
    <DESCRIPTION_ITEM>
    <P>
    This block is an ideal voltage source. The voltage value is
    controlled through the explicit input of the block (connected to
    standard Scicos blocks). The current passing through  the block is
    independent of the voltage across the block terminals.
    </P>
    </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='C_macros' type='LATEX'>

The following C macros are avialable by including the file \htmladdnormallink{scicos\_block4.h}
{scicos_block4_rout.htm} in a C computational function.

\subsection{Inputs/outputs}
\begin{tabular}{|p{8cm}||p{20cm}|}
\hline 
{\bf Macro}&
{\bf Description}\vspace{0.2cm}\\
\hline
\hline 
GetNin(blk)&
Get number of regular input port.\vspace{0.2cm}\\
\hline 
GetInPortRows(blk,x)&
Get number of rows (first dimension) of regular input port number
x.\vspace{0.2cm}\\
\hline 
GetInPortCols(blk,x)&
Get number of columns (second dimension) of regular input port number
x.\vspace{0.2cm}\\
\hline 
GetInPortSize(blk,x,y)&
Get regular input port size number x. (y=1 for the first dimension,
y=2 for the second dimension)\vspace{0.2cm}\\
\hline 
GetInType(blk,x)&
Get type of regular input port number x.\vspace{0.2cm}\\
\hline 
GetInPortPtrs(blk,x)&
Get regular input port pointer of port number x.\vspace{0.2cm}\\
\hline 
GetRealInPortPtrs(blk,x)&
Get pointer of real part of regular input port number x.\vspace{0.2cm}\\
\hline 
GetImagInPortPtrs(blk,x)&
Get pointer of imaginary part of regular input port number x.\vspace{0.2cm}\\
\hline 
Getint8InPortPtrs(blk,x)&
Get pointer of int8 typed regular input port number x.\vspace{0.2cm}\\
\hline 
Getint16InPortPtrs(blk,x)&
Get pointer of int16 typed regular input port number x.\vspace{0.2cm}\\
\hline 
Getint32InPortPtrs(blk,x)&
Get pointer of int32 typed regular input port number x.\vspace{0.2cm}\\
\hline 
Getuint8InPortPtrs(blk,x)&
Get pointer of uint8 typed regular input port number x.\vspace{0.2cm}\\
\hline 
Getuint16InPortPtrs(blk,x)&
Get pointer of uint16 typed regular input port number x.\vspace{0.2cm}\\
\hline 
Getuint32InPortPtrs(blk,x)&
Get pointer of uint32 typed regular input port number x.\vspace{0.2cm}\\
\hline 
GetSizeOfIn(blk,x)&
Get the sizeof of the regular input port number x.\vspace{0.2cm}\\
\hline 
GetNout(blk)&
Get number of regular output port.\vspace{0.2cm}\\
\hline 
GetOutPortRows(blk,x)&
Get number of rows (first dimension) of regular output port number
x.\vspace{0.2cm}\\
\hline 
GetOutPortCols(blk,x)&
Get number of columns (second dimension) of regular output port number
x.\vspace{0.2cm}\\
\hline 
GetOutPortSize(blk,x,y)&
Get regular output port size number x. (y=1 for the first dimension,
y=2 for the second dimension)\vspace{0.2cm}\\
\hline 
GetOutType(blk,x)&
Get type of regular output port number x.\vspace{0.2cm}\\
\hline 
GetOutPortPtrs(blk,x)&
Get regular output port pointer of port number x.\vspace{0.2cm}\\
\hline 
GetRealOutPortPtrs(blk,x)&
Get pointer of real part of regular output port number x.\vspace{0.2cm}\\
\hline 
GetImagOutPortPtrs(blk,x)&
Get pointer of imaginary part of regular output port number x.\vspace{0.2cm}\\
\hline 
Getint8OutPortPtrs(blk,x)&
Get pointer of int8 typed regular output port number x.\vspace{0.2cm}\\
\hline 
Getint16OutPortPtrs(blk,x)&
Get pointer of int16 typed regular output port number x.\vspace{0.2cm}\\
\hline 
Getint32OutPortPtrs(blk,x)&
Get pointer of int32 typed regular output port number x.\vspace{0.2cm}\\
\hline 
Getuint8OutPortPtrs(blk,x)&
Get pointer of uint8 typed regular output port number x.\vspace{0.2cm}\\
\hline 
Getuint16OutPortPtrs(blk,x)&
Get pointer of uint16 typed regular output port number x.\vspace{0.2cm}\\
\hline 
Getuint32OutPortPtrs(blk,x)&
Get pointer of uint32 typed regular output port number x.\vspace{0.2cm}\\
\hline 
GetSizeOfOut(blk,x)&
Get the sizeof of the regular output port number x.\vspace{0.2cm}\\
\hline
\end{tabular}

\subsection{Events}

\begin{tabular}{|p{8cm}||p{20cm}|}
\hline 
{\bf Macro}&
{\bf Description}\vspace{0.2cm}\\
\hline
\hline 
GetNevIn(blk)&
Get the input event number.\vspace{0.2cm}\\
\hline 
GetNevOut(blk)&
Get number of event output port.\vspace{0.2cm}\\
\hline 
GetNevOutPtrs(blk)&
Get pointer of event output register.\vspace{0.2cm}\\
\hline
\end{tabular}

\subsection{Parameters}

\begin{tabular}{|p{8cm}||p{20cm}|}
\hline 
{\bf Macro}&
{\bf Description}\vspace{0.2cm}\\
\hline
\hline 
GetNipar(blk)&
Get number of integer parameters.\vspace{0.2cm}\\
\hline 
GetIparPtrs(blk)&
Get pointer of the integer parameters register\vspace{0.2cm}\\
\hline 
GetNrpar(blk)&
Get number of real parameters.\vspace{0.2cm}\\
\hline 
GetRparPtrs(blk)&
Get pointer of the real parameters register.\vspace{0.2cm}\\
\hline 
GetNopar(blk)&
Get number of object parameters.\vspace{0.2cm}\\
\hline 
GetOparType(blk,x)&
Get type of object parameters number x.\vspace{0.2cm}\\
\hline 
GetOparSize(blk,x,y)&
Get size of object parameters number x. (y=1 for the first dimension,
y=2 for the second dimension)\vspace{0.2cm}\\
\hline 
GetOparPtrs(blk,x)&
Get pointer of object parameters number x.\vspace{0.2cm}\\
\hline 
GetRealOparPtrs(blk,x)&
Get pointer of real object parameters number x.\vspace{0.2cm}\\
\hline 
GetImagOparPtrs(blk,x)&
Get pointer of imaginary part of object parameters number x.\vspace{0.2cm}\\
\hline 
Getint8OparPtrs(blk,x)&
Get pointer of int8 typed object parameters number x.\vspace{0.2cm}\\
\hline 
Getint16OparPtrs(blk,x)&
Get pointer of int16 typed object parameters number x.\vspace{0.2cm}\\
\hline 
Getint32OparPtrs(blk,x)&
Get pointer of int32 typed object parameters number x.\vspace{0.2cm}\\
\hline 
Getuint8OparPtrs(blk,x)&
Get pointer of uint8 typed object parameters number x.\vspace{0.2cm}\\
\hline 
Getuint16OparPtrs(blk,x)&
Get pointer of uint16 typed object parameters number x.\vspace{0.2cm}\\
\hline 
Getuint32OparPtrs(blk,x)&
Get pointer of uint32 typed object parameters number x.\vspace{0.2cm}\\
\hline 
GetSizeOfOpar(blk,x)&
Get the sizeof of the object parameters number x.\vspace{0.2cm}\\
\hline
\end{tabular}

\subsection{States and work}

\begin{tabular}{|p{8cm}||p{20cm}|}
\hline 
{\bf Macro}&
{\bf Description}\vspace{0.2cm}\\
\hline
\hline 
GetNstate(blk)&
Get number of continuous state.\vspace{0.2cm}\\
\hline 
GetState(blk)&
Get pointer of the continuous state register.\vspace{0.2cm}\\
\hline 
GetDstate(blk)&
Get number of discrete state.\vspace{0.2cm}\\
\hline 
GetNdstate(blk)&
Get pointer of the discrete state register.\vspace{0.2cm}\\
\hline 
GetNoz(blk)&
Get number of object state.\vspace{0.2cm}\\
\hline 
GetOzType(blk,x)&
Get type of object state number x.\vspace{0.2cm}\\
\hline 
GetOzSize(blk,x,y)&
Get size of object state number x. (y=1 for the first dimension, y=2
for the second dimension)\vspace{0.2cm}\\
\hline 
GetOzPtrs(blk,x)&
Get pointer of object state number x.\vspace{0.2cm}\\
\hline 
GetRealOzPtrs(blk,x)&
Get pointer of real object state number x.\vspace{0.2cm}\\
\hline 
GetImagOzPtrs(blk,x)&
Get pointer of imaginary part of object state number x.\vspace{0.2cm}\\
\hline 
Getint8OzPtrs(blk,x)&
Get pointer of int8 typed object state number x.\vspace{0.2cm}\\
\hline 
Getint16OzPtrs(blk,x)&
Get pointer of int16 typed object state number x.\vspace{0.2cm}\\
\hline 
Getint32OzPtrs(blk,x)&
Get pointer of int32 typed object state number x.\vspace{0.2cm}\\
\hline 
Getuint8OzPtrs(blk,x)&
Get pointer of uint8 typed object state number x.\vspace{0.2cm}\\
\hline 
Getuint16OzPtrs(blk,x)&
Get pointer of uint16 typed object state number x.\vspace{0.2cm}\\
\hline 
Getuint32OzPtrs(blk,x)&
Get pointer of uint32 typed object state number x.\vspace{0.2cm}\\
\hline 
GetSizeOfOz(blk,x)&
Get the sizeof of the object state number x.\vspace{0.2cm}\\
\hline
GetWorkPtrs(blk)(blk)&
Get the pointer of the Work array.\vspace{0.2cm}\\
\hline
\end{tabular}

\subsection{Zero crossing surfaces and modes}

\begin{tabular}{|p{8cm}||p{20cm}|}
\hline 
{\bf Macro}&
{\bf Description}\vspace{0.2cm}\\
\hline
\hline 
GetNg(blk)&
Get number of zero crossing surface.\vspace{0.2cm}\\
\hline 
GetGPtrs(blk)&
Get pointer of the zero crossing register.\vspace{0.2cm}\\
\hline 
GetNmode(blk)&
Get number of modes.\vspace{0.2cm}\\
\hline 
GetModePtrs(blk)&
Get pointer of the mode register.\vspace{0.2cm}\\
\hline
\end{tabular}
</FILE>

<FILE name='C_struct' type='LATEX'>

The C structure of a Scicos block defines all the fields to handle data provided by the simulator
such inputs/outputs, parameters, states, ...

That structure of type {\tt scicos\_block} is defined in the file \htmladdnormallink{scicos\_block4.h}
{scicos_block4_rout.htm}, and user must include that header in each computational functions in the form :

\begin{verbatim}
#include "scicos_block4.h"

void mycomputfunc(scicos_block *block,int flag)
{
 ...
}
\end{verbatim}

The fields, that can be either C pointers or directly data, are then accessible via the {\tt *block}
structure :

\begin{verbatim}
block->field
\end{verbatim}

This access is a \textbf{direct} approach and most of users should prefer the \textbf{\htmladdnormallink{C\_macros}
{C_macros.htm}} approach for facilities purpose.

In the current version of Scicos, the {\tt scicos->block} structure is defined :

\begin{verbatim}
/* scicos_block structure definition */
typedef struct {
  int nevprt;
  voidg funpt ;
  int type;
  int scsptr;
  int nz;
  double *z;
  int noz;
  int *ozsz;
  int *oztyp;
  void **ozptr;
  int nx;
  double *x;
  double *xd;
  double *res;
  int nin;
  int *insz;
  void **inptr;
  int nout;
  int *outsz;
  void **outptr;
  int nevout;
  double *evout;
  int nrpar;
  double *rpar;
  int nipar;
  int *ipar;
  int nopar;
  int *oparsz;
  int *opartyp;
  void **oparptr;
  int ng;
  double *g;
  int ztyp;
  int *jroot;
  char *label;
  void **work;
  int nmode;
  int *mode;
} scicos_block;
\end{verbatim}

\subsection{Inputs/outputs}

\begin{itemize}
 \item {\bf block->nin :} Integer that gives the number of regular input ports of the block.\\
                   One can't override the index {\tt (3*block->nin)-1} when reading sizes of
                   input ports in the array {\tt insz} and the index {\tt block->nin-1} when reading
                   data in the array {\tt inptr} with a C computational function.\\
                   The number of regular input ports can also be got by the use of the C macros
                   {\tt GetNin(block)}.

 \item {\bf block->insz :} An array of integers of size {\tt 3*nin,1} that respectively gives the first dimensions,
                    the second dimensions and the type of data driven by regular input ports.\\
                    Note that this array of size differs from the array {\tt ozsz} and {\tt oparsz} to
                    provide full compatibilty with blocks that only use a single dimension.\\
                    Suppose that you have a block with three inputs : the first is an int32 matrix of
                    size 3,2, the second a single complex number (matrix of size 1,1) and the last a real
                    matrix of size 4,1.\\
                    In the  \htmladdnormallink{scicos\_model}{scicos_model.htm} of such a block, the inputs
                    will be defined :

                    {\tt
                     model.in    = [3;1;4] \\
                     model.in2   = [2;1;1] \\
                     model.intyp = [2;1;3] \\
                    }

                    and the corresponding {\tt block->insz} field at C computational function level will be
                    coded as :

                     \begin{figure}[!h]
                      \begin{center}
                       \scalebox{0.7}{\input{insz.pstex_t}}
                      \end{center}
                     \end{figure}

                     Do the difference here in the type numbers defined at the {\bf Scilab level} (2,1,3)
                     and the type numbers defined at the {\bf C level} (84,11,10). The following table gives
                     the correspondance for all Scicos type:

                     \begin{center}
                      \begin{tabular}{|p{4cm}|p{4cm}||p{4cm}|p{4cm}|}
                       \hline
                       {\bf Scilab Type}&
                       {\bf Scilab Number}&
                       {\bf C Type}&
                       {\bf C Number}\\
                       \hline
                       \hline
                       real&
                       1&
                       double&
                       10\\
                       \hline
                       complex&
                       2&
                       double&
                       11\\
                       \hline
                       int32&
                       3&
                       long&
                       84\\
                       \hline
                       int16&
                       4&
                       short&
                       82\\
                       \hline
                       int8&
                       5&
                       char&
                       81\\
                       \hline
                       uint32&
                       6&
                       unsigned long&
                       814\\
                       \hline
                       uint16&
                       7&
                       unsigned short&
                       812\\
                       \hline
                       uint8&
                       8&
                       unsigned char&
                       811\\
                       \hline
                      \end{tabular}
                     \end{center}

 \item {\bf block->inptr :} An array of pointers of size nin,1 that allows to directly acces to the
                     data contained in the regular input matrices.\\
                     Suppose the previous example (block with three inputs : an int32 matrix of size [3,2],
                     a complex scalar and a real matrix of size [4,1]).\\
                     {\tt block->inptr} contains three pointers, and should be viewed as arrays contained
                     the data for the int32, the real and the complex matrices :

                     \begin{figure}[!h]
                      \begin{center}
                       \scalebox{0.7}{\input{inptr.pstex_t}}
                      \end{center}
                     \end{figure}

                    For i.e., to directly access to the data, the user can use theses instructions :

                    {\tt
                     \#include "scicos\_block4.h"\\
                     ...\\
                     SCSINT32\_COP *ptr\_i;\\
                     SCSCOMPLEX\_COP *ptr\_dc;\\
                     SCSREAL\_COP *ptr\_d;\\
                     int n1,m1;\\
                     SCSINT32\_COP cumsum\_i=0;\\
                     int i;\\
                     ...\\
                     void mycomputfunc(scicos\_block *block,int flag) \\
                     \{\\
                     ...\\
                     /*get the ptrs of the first int32 regular input port*/\\
                     ptr\_i = (SCSINT32\_COP *) block->inptr[0];\\
                     /*get the ptrs of the second complex regular input port*/\\
                     ptr\_dc = (SCSCOMPLEX\_COP *) block->inptr[1];\\
                     /*get the ptrs of the third real regular input port*/\\
                     ptr\_d = (SCSREAL\_COP *) block->inptr[2];\\
                     ...\\
                     /*get the dimension of the first int32 regular input port*/\\
                     n1=block->insz[0];\\
                     m1=block->insz[3];\\
                     ...\\
                     /*compute the cumsum of the input int32 matrix*/\\
                     for(i=0;i<n1*m1;i++) \{\\
                     cumsum\_i += ptr\_i[i];\\
                     \}\\
                     ...\\
                     \}
                    }

                    One can also use the set of C macros :\\
                    {\tt GetInPortPtrs(blk,x)}, {\tt GetRealInPortPtrs(block,x)}, \\
                    {\tt GetImagInPortPtrs(block,x)}, {\tt Getint8InPortPtrs(block,x)}, \\
                    {\tt Getint16InPortPtrs(block,x)}, {\tt Getint32InPortPtrs(block,x)}, \\
                    {\tt Getuint8InPortPtrs(block,x)}, {\tt Getuint16InPortPtrs(block,x)}, \\
                    {\tt Getuint32InPortPtrs(block,x)} \\
                    to have the appropiate pointer of the data to handle and \\
                    {\tt GetNin(block)}, {\tt GetInPortRows(block,x)}, \\
                    {\tt GetInPortCols(block,x)}, {\tt GetInPortSize(block,x,y)}, \\
                    {\tt GetInType(block,x)}, {\tt GetSizeOfIn(block,x)} \\
                    to handle number, dimensions and type of regular input ports.
                    ({\bf x is numbered from 1 to nin and \bf y numbered  from 1 to 2}).\\

                    For the previous example that gives :

                    {\tt
                     \#include "scicos\_block4.h"\\
                     ...\\
                     SCSINT32\_COP *ptr\_i;\\
                     SCSCOMPLEX\_COP *ptr\_dc;\\
                     SCSREAL\_COP *ptr\_d;\\
                     int n1,m1;\\
                     SCSINT32\_COP cumsum\_i=0;\\
                     int i;\\
                     ...\\
                     void mycomputfunc(scicos\_block *block,int flag)\\
                     \{\\
                     ...\\
                     /*get the ptrs of the first int32 regular input port*/\\
                     ptr\_i = Getint32InPortPtrs(block,1);\\
                     /*get the ptrs of the second complex regular input port*/\\
                     ptr\_dc = GetRealInPortPtrs(block,2);\\
                     /*get the ptrs of the third real regular input port*/\\
                     ptr\_d = GetRealInPortPtrs(block,3);\\
                     ...\\
                     /*get the dimension of the first int32 regular input port*/\\
                     n1=GetInPortRows(block,1);\\
                     m1=GetInPortCols(block,1);\\
                     ...\\
                     \}
                    }

                    Finally note that the regular input port registers are only accessible for reading.

 \item {\bf block->nout :} Integer that gives the number of regular output ports of the block.\\
                    One can't override the index {\tt (3*block->nout)-1} when reading sizes of
                    output ports in the array {\tt outsz} and the index {\tt block->nout-1} when reading
                    data in the array {\tt outptr} with a C computational function.\\
                    The number of regular output ports can also be got by the use of the C macros
                    {\tt GetNout(block)}.

 \item {\bf block->outsz :} An array of integers of size {\tt 3*nout,1} that respectively gives the first dimensions,
                     the second dimensions and the type of data driven by regular output ports.\\
                     Note that this array of size differs from the array {\tt ozsz} and {\tt oparsz} to
                     provide full compatibilty with blocks that only use a single dimension.\\
                     Suppose that you have a block with two outputs : the first is an int32 matrix of
                     size 3,2, the second a single complex number (matrix of size 1,1) and the last a real
                     matrix of size 4,1.\\
                     In the  \htmladdnormallink{scicos\_model}{scicos_model.htm} of such a block, the outputs
                     will be defined :

                     {\tt
                      model.out   = [3;1;4] \\
                      model.out2   = [2;1;1] \\
                      model.outtyp = [2;1;3] \\
                     }

                     and the corresponding {\tt block->outsz} field at C computational function level will be
                     coded as :

                     \begin{figure}[!h]
                      \begin{center}
                       \scalebox{0.7}{\input{outsz.pstex_t}}
                      \end{center}
                     \end{figure}

                     Do the difference here in the type numbers defined at the {\bf Scilab level} (2,1,3)
                     and the type numbers defined at the {\bf C level} (84,11,10) and please report to the 
                     previous table to have the correspondence for all Scicos type.

 \item {\bf block->outptr :} An array of pointers of size nout,1 that allows to directly acces to the
                     data contained in the regular output matrices.\\
                     Suppose the previous example (block with three outputs : an int32 matrix of size [3,2],
                     a complex scalar and a real matrix of size [4,1]).\\
                     {\tt block->outptr} contains three pointers, and should be viewed as arrays contained
                     the data for the int32, the real and the complex matrices :

                     \begin{figure}[!h]
                      \begin{center}
                       \scalebox{0.7}{\input{outptr.pstex_t}}
                      \end{center}
                     \end{figure}

                    For i.e., to directly access to the data, the user can use theses instructions :

                    {\tt
                     \#include "scicos\_block4.h"\\
                     ...\\
                     SCSINT32\_COP *ptr\_i;\\
                     SCSCOMPLEX\_COP *ptr\_dc;\\
                     SCSREAL\_COP *ptr\_d;\\
                     int n1,m1;\\
                     SCSINT32\_COP cumsum\_i=0;\\
                     int i;\\
                     ...\\
                     void mycomputfunc(scicos\_block *block,int flag)\\
                     \{\\
                     /*get the ptrs of the first int32 regular output port*/\\
                     ptr\_i = (SCSINT32\_COP *) block->outptr[0];\\
                     /*get the ptrs of the second complex regular output port*/\\
                     ptr\_dc = (SCSCOMPLEX\_COP *) block->outptr[1];\\
                     /*get the ptrs of the third real regular output port*/\\
                     ptr\_d = (SCSREAL\_COP *) block->outptr[2];\\
                     ...\\
                     /*get the dimension of the first int32 regular output port*/\\
                     n1=block->outsz[0];\\
                     m1=block->outsz[3];\\
                     ...\\
                     /*compute the cumsum of the output int32 matrix*/\\
                     for(i=0;i<n1*m1;i++) \{\\
                     cumsum\_i += ptr\_i[i];\\
                     \}\\
                     ...\\
                     \}\\
                    }

                    One can also use the set of C macros :\\
                    {\tt GetOutPortPtrs(block,x)}, {\tt GetRealOutPortPtrs(block,x)}, \\
                    {\tt GetImagOutPortPtrs(block,x)}, {\tt Getint8OutPortPtrs(block,x)}, \\
                    {\tt Getint16OutPortPtrs(block,x)}, {\tt Getint32OutPortPtrs(block,x)}, \\
                    {\tt Getuint8OutPortPtrs(block,x)}, {\tt Getuint16OutPortPtrs(block,x)}, \\
                    {\tt Getuint32OutPortPtrs(block,x)} \\
                    to have the appropiate pointer of the data to handle and \\
                    {\tt GetNout(block)}, {\tt GetOutPortRows(block,x)}, \\
                    {\tt GetOutPortCols(block,x)}, {\tt GetOutPortSize(block,x,y)}, \\
                    {\tt GetOutType(block,x)}, {\tt GetSizeOfOut(block,x)} \\
                    to handle number, dimensions and type of regular output ports.
                    ({\bf x is numbered from 1 to nout and \bf y is numbered  from 1 to 2}).

                    For the previous example that gives :

                    {\tt
                     \#include "scicos\_block4.h"\\
                     ...\\
                     SCSINT32\_COP *ptr\_i;\\
                     SCSCOMPLEX\_COP *ptr\_dc;\\
                     SCSREAL\_COP *ptr\_d;\\
                     int n1,m1;\\
                     SCSINT32\_COP cumsum\_i=0;\\
                     int i;\\
                     ...\\
                     void mycomputfunc(scicos\_block *block,int flag)\\
                     \{\\
                     ...\\
                     /*get the ptrs of the first int32 regular output port*/\\
                     ptr\_i = GetOutPortPtrs(block,1);\\
                     /*get the ptrs of the second complex regular output port*/\\
                     ptr\_dc = GetRealOutPortPtrs(block,2);\\
                     /*get the ptrs of the third real regular output port*/\\
                     ptr\_d = GetRealOutPortPtrs(block,3);\\
                     ...\\
                     /*get the dimension of the first int32 regular output port*/\\
                     n1=GetOutPortRows(block,1);\\
                     m1=GetOutPortCols(block,1);\\
                     ...\\
                     \}\\
                    }

                    Finally note that the regular output port registers must be only written for {\tt flag}=1.
\end{itemize}

\subsection{Events}

\begin{itemize}
 \item {\bf block->nevprt :} Integer that gives the event input port number by which the block has been activated.
                      This number is a binary coding. For i.e, if block have two event inputs ports,
                      {\tt block->nevptr} can take the value 1 if the block has been called by its first
                      event input port, the value 2 if it has been called by the second event input port and 3
                      if it is called by the same event on both input port 1 and 2.\\
                      Note that {\tt block->nevptr} can be -1 if the block is internally called. \\
                      One can also retrieve this number by using the C macros {\tt GetNevIn(block)}.


 \item {\bf block->nevout :} Integer that gives the number of event output ports of the block (also called
                      the length of the output event register).\\
                      One can't override the index {\tt (block->nevout)-1} when setting value of events
                      in the output event register {\tt evout}.\\
                      The number of event output ports can also be got by the use of the C macro
                      {\tt GetNevOut(block)}.

 \item {\bf block->evout :} Array of double of size nevout,1 corresponding to the output event register. That register
                     is used to program date of events during the simulation.\\
                     When setting values in that array, you must understand that you give a delay relative
                     to the current time of simulator :
                     \begin{eqnarray}
                         t_{\rm event} = t_{\rm cur} + T_{\rm delay}
                     \end{eqnarray}
                     where $t_{\rm event}$ is the date of the programmed event, $t_{\rm cur}$ is the current time
                     in the simulator and $T_{\rm delay}$ the value that must be informed in the output event register.

                     For i.e, suppose that you want generate an event with the first event output port, 1ms after
                     each calls of the block, then you'll use :

                     {\tt
                      \#include "scicos\_block4.h"\\
                      ...\\
                      void mycomputfunc(scicos\_block *block,int flag)\\
                      \{\\
                      ...\\
                      if (flag==3) \{ \\
                       block->evout[0]=0.001;\\
                      \}\\
                      ...\\
                     \}\\
                     }\\

                     Note that every events generated from output event register will be asynchronous with event
                     coming from event input port (even if you set {\tt block->evout[x]=0}). \\
                     The event output register must be only written for {\tt flag}=3.
\end{itemize}

\subsection{Parameters}

\begin{itemize}

 \item {\bf block->nrpar :} Integer that gives the length of the real parameter register.\\
                     One can't override the index {\tt (block->nrpar)-1} when reading value of real
                     parameters in the register {\tt rpar}.\\
                     The total number of real parameters can also be got by the use of the C macro
                     {\tt GetNrpar(block)}.

 \item {\bf block->rpar :} Array of double of size nrpar,1 corresponding to the real parameter register. That register
                    is used to pass real parameters coming from the scilab/scicos environment to your block
                    model.\\
                    The C type of that array is {\tt double *} (or C scicos type {\tt SCSREAL\_COP *}).\\
                    Suppose that you have defined the following real parameters in the
                    \htmladdnormallink{scicos\_model}{scicos_model.htm} of a block :

                    {\tt
                     model.rpar   = [\%pi;\%pi/2;\%pi/4]\\
                    }

                    you can retrieve the previous data in the C computational function with :

                    {\tt
                     \#include "scicos\_block4.h"\\
                     ...\\
                     double PI;\\
                     double PI\_2;\\
                     double PI\_4;\\
                     ...\\
                     void mycomputfunc(scicos\_block *block,int flag)\\
                     \{\\
                     ...\\
                     /*get the first value of the real param register*/\\
                     PI = block->rpar[0];\\
                     /*get the second value of the real param register*/\\
                     PI\_2 = block->rpar[1];\\
                     /*get the third value of the real param register*/\\
                     PI\_4 = block->rpar[2];\\
                     ...\\
                     \}\\
                    }

                    You can also use the C macro {\tt GetRparPtrs(block)} to get the pointer of the
                    real parameter register. For i.e., if we define the following
                    \htmladdnormallink{scicos\_model}{scicos_model.htm} in an interfacing function of a
                    scicos block :

                    {\tt
                     A = [1.3 ; 4.5 ; 7.9 ; 9.8];\\
                     B = [0.1 ; 0.98]; \\
                     model.rpar   = [A;B] \\
                    }

                    in the corresponding C computational function of that block, we'll use :

                    {\tt
                     \#include "scicos\_block4.h"\\
                     ...\\
                     double *rpar;\\
                     double *A; \\
                     double *B; \\
                     ...\\
                     void mycomputfunc(scicos\_block *block,int flag)\\
                     \{\\
                     ...\\
                     /*get ptrs of the real param register*/\\
                     rpar = GetRparPtrs(block); \\
                     /*get the A ptrs array*/\\
                     A = rpar;\\
                     /*get the B ptrs array*/\\
                     B = \&rpar[4];\\
                     /*or B = rpar + 4;*/\\
                     ...\\
                     \}\\
                    }

                    Note that real parameters register is only accessible for reading.

 \item {\bf block->nipar :} Integer that gives the length of the integer parameter register.\\
                     One can't override the index {\tt (block->nipar)-1} when reading value of integer
                     parameters in the register {\tt ipar}.\\
                     The total number of integer parameters can also be got by the use of the C macro
                     {\tt GetNipar(block)}.

 \item {\bf block->ipar :} Array of int of size nipar,1 corresponding to the integer parameter register. That register
                    is used to pass integer parameters coming from the scilab/scicos environment to your block
                    model.\\
                    The C type of that array is {\tt int *} (or C scicos type {\tt SCSINT\_COP *}).\\
                    Suppose that you have defined the following integer parameters in the
                    \htmladdnormallink{scicos\_model}{scicos_model.htm} of a block :

                    {\tt
                     model.ipar   = [(1:3)';5] \\
                    }

                    you can retrieve the previous data in the C computational function with :

                    {\tt
                     \#include "scicos\_block4.h"\\
                     ...\\
                     int one;\\
                     int two;\\
                     int three;\\
                     int five;\\
                     ...\\
                     void mycomputfunc(scicos\_block *block,int flag)\\
                     \{\\
                     ...\\
                     /*get the first value of the integer param register*/\\
                     one = block->ipar[0]; \\
                     /*get the second value of the integer param register*/\\
                     two = block->ipar[1]; \\
                     /*get the third value of the integer param register*/\\
                     three = block->ipar[2]; \\
                     /*get the fourth value of the integer param register*/\\
                     five = block->ipar[3]; \\
                     ...\\
                     \}\\
                    }

                    You can also use the C macro {\tt GetIparPtrs(block)} to get the pointer of the
                    real parameter register.\\
                    Most of time in the scicos C block libraries, the integer register is used to
                    parametrize the length of real parameters. For i.e. if you define the following
                    \htmladdnormallink{scicos\_model}{scicos_model.htm} in a block :

                    {\tt
                     // set a random size for the first real parameters \\
                     A\_sz = int(rand(10)*10); \\
                     // set a random size for the second real parameters \\
                     B\_sz = int(rand(10)*10); \\
                     // set the first real parameters \\
                     A = rand(A\_sz,1,``uniform''); \\
                     // set the second real parameters \\
                     B = rand(B\_sz,1,``normal''); \\
                     // set ipar \\
                     model.ipar = [A\_sz;B\_sz] \\
                     // set rpar (length of A\_sz+B\_sz) \\
                     model.rpar = [A;B] \\
                    }

                    the array of real parameters (parametrized by ipar) can be retrieved in the
                    correspondig C computational function with :

                    {\tt
                     \#include "scicos\_block4.h"\\
                     ...\\
                     int A\_sz; \\
                     int B\_sz; \\
                     double *rpar; \\
                     double *A; \\
                     double *B; \\
                     double cumsum;\\
                     int i; \\
                     ...\\
                     void mycomputfunc(scicos\_block *block,int flag)\\
                     \{\\
                     ...\\
                     /*get ptrs of the real param register*/\\
                     rpar = GetRparPtrs(block); \\
                     /*get size of the first real param register*/\\
                     A\_sz = block->ipar[0]; \\
                     /*get size of the second real param register*/\\
                     B\_sz = block->ipar[1]; \\
                     /*get the A ptrs array*/\\
                     A = rpar; \\
                     /*get the B ptrs array*/\\
                     B = \&rpar[A\_sz]; \\
                     ...\\
                     /*compute the cumsum of the first real parameter array*/\\
                     cumsum = 0;\\
                     for(i=0;i<A\_sz;i++) \{\\
                     cumsum += A[i];\\
                     \}\\
                     ...\\
                     /*compute the cumsum of the second real parameter array*/\\
                     cumsum = 0;\\
                     for(i=0;i<B\_sz;i++) \{\\
                     cumsum += B[i]; \\
                     \}\\
                    }

                    Note that integer parameters register is only accessible for reading.

 \item {\bf block->nopar :} Integer that gives the number of the object parameters.\\
                     One can't override the index {\tt block->nopar-1} when accessing data in the arrays
                     {\tt oparsz}, {\tt opartyp} and {\tt oparptr} in a C computational function.\\
                     This value is also accessible via the C macro {\tt GetNopar(block)}.

 \item {\bf block->oparsz :} An array of integer of size nopar,2 that contains the dimensions of matrices of
                     object parameters.\\
                     The first column is for the first dimension and the second for the second dimension.
                     For i.e. if we want the dimensions of the last object parameters, we'll use the instructions :

                    {\tt
                     \#include "scicos\_block4.h"\\
                     ...\\
                     int nopar;\\
                     int n,m;\\
                     ...\\
                     void mycomputfunc(scicos\_block *block,int flag)\\
                     \{\\
                     ...\\
                     /*get the number of object parameter*/\\
                     nopar=block\->nopar;\\
                     ...\\
                     /*get number of row of the last object parameter*/\\
                     n=block\->oparsz[nopar-1];\\
                     /*get number of column of the last object parameter*/\\
                     m=block\->oparsz[2*nopar-1];\\
                     ...\\
                     \}\\
                    }

                    The dimensions of object parameters can be get with the following C macro :

                    {\tt
                     GetOparSize(block,x,1); /*get first dimension of opar*/ \\
                     GetOparSize(block,x,2); /*get second dimension of opar*/ \\
                    }

                    with {\tt x} an integer that gives the index of the object parameter, {\bf numbered
                    from 1 to nopar}.

 \item {\bf block->opartyp :} An array of integer of size nopar,1 that contains the type of matrices of
                     object parameters.\\
                     The following table gives the correspondence for scicos type expressed in Scilab number,
                     in C number and also corresponding C pointers and C macros used for {\tt oparptr} :

                     \begin{tabular}{|p{4cm}|p{3cm}|p{3cm}|p{4cm}|p{5cm}|}
                      \hline
                      {\bf Scilab}&
                      &
                      {\bf C}&
                      &
                      \\
                      \hline
                      \hline
                      Type&
                      Number&
                      Number&
                      Type&
                      Macros\\
                      \hline
                      real matrix&
                      1&
                      10&
                      double&
                      SCSREAL\_COP\\
                      \hline
                      complex matrix&
                      2&
                      11&
                      double&
                      SCSCOMPLEX\_COP\\
                      \hline
                      int32 matrix&
                      3&
                      84&
                      long int&
                      SCSINT32\_COP\\
                      \hline
                      int16 matrix&
                      4&
                      82&
                      short&
                      SCSINT16\_COP\\
                      \hline
                      int8 matrix&
                      5&
                      81&
                      char&
                      SCSINT8\_COP\\
                      \hline
                      uint32 matrix&
                      6&
                      814&
                      unsigned long int&
                      SCSUINT32\_COP\\
                      \hline
                      uint16 matrix&
                      7&
                      812&
                      unsigned short&
                      SCSUNINT16\_COP\\
                      \hline
                      uint8 matrix&
                      8&
                      811&
                      unsigned char&
                      SCSUINT8\_COP\\
                      \hline
                      all others data&
                      &
                      -1&
                      double&
                      SCSUNKNOWN\_COP\\
                      \hline
                     \end{tabular}

                     The type of object parameter can also be got by the use of the C macro
                     {\tt GetOparType(block,x)}. For i.e, if we want the C number type of the first
                     object parameter, we'll use the following C instructions:

                     {\tt
                      \#include "scicos\_block4.h"\\
                     ...\\
                      int opartyp\_1;\\
                     ...\\
                      void mycomputfunc(scicos\_block *block,int flag)\\
                      \{\\
                      ...\\
                      /*get the number type of the first object parameter*/\\
                      opartyp\_1 = GetOparType(block,1);\\
                      ...\\
                     \}\\
                     }

 \item {\bf block->oparptr :} An array of pointers of size nopar,1 that allows to directly acces to the
                     data contained in the object parameter.\\
                     Suppose that you have defined in the editor a block with the following 
                     \textbf{opar} field in \htmladdnormallink{scicos\_model}{scicos_model.htm} :

                     {\tt model.opar=list(int32([1,2;3,4]),[1+\%i \%i 0.5]);}

                     Then we have two object parameters, one is an 32-bit integer matrix with two rows and two
                     columns and the second is a vector of complex numbers that can be understand as a matrix
                     of size 1,3.\\
                     At the C computational function level, the instructions {\tt block->oparsz[0]},
                     {\tt block->oparsz[1]}, {\tt block->oparsz[2]}, {\tt block->oparsz[3]} will respectively return the
                     values 2,1,2,3 and the instructions {\tt block->opartyp[0]}, {\tt block->opartyp[1]} the values 11 and
                     84.\\
                     {\tt block->oparptr} will contain then two pointers, and should be viewed as arrays contained data of
                     object parameter as shown in the following figure :

                     \begin{figure}[!h]
                      \begin{center}
                       \scalebox{0.7}{\input{opar.pstex_t}}
                      \end{center}
                     \end{figure}

                    For i.e., to directly access to the data, the user can use theses instructions :

                    {\tt
                     \#include "scicos\_block4.h"\\
                     ...\\
                     SCSINT32\_COP *ptr\_i;\\
                     SCSINT32\_COP cumsum\_i;\\
                     SCSCOMPLEX\_COP *ptr\_d;\\
                     SCSREAL\_COP cumsum\_d;\\
                     ...\\
                     void mycomputfunc(scicos\_block *block,int flag)\\
                     \{\\
                     ...\\
                     /*get the ptrs of an int32 object parameter*/\\
                     ptr\_i = (SCSINT32\_COP *) block->oparptr[0];\\
                     /*get the ptrs of a double object parameter*/\\
                     ptr\_d = (SCSCOMPLEX\_COP *) block->oparptr[1];\\
                     ...\\
                     /*compute the cumsum of the int32 matrix*/\\
                     cumsum\_i = ptr\_i[0]+ptr\_i[1]+ptr\_i[2]+ptr\_i[3];
                     ...\\
                     /*compute the cumsum of the real part of the complex matrix*/\\
                     cumsum\_d = ptr\_d[0]+ptr\_d[1]+ptr\_d[2];\\
                     ...\\
                     \}\\
                    }

                    One can also use the set of C macros :\\
                    {\tt GetRealOparPtrs(block,x)},  {\tt GetImagOparPtrs(block,x)},\\
                    {\tt Getint8OparPtrs(block,x)},  {\tt Getint16OparPtrs(block,x)},\\
                    {\tt Getint32OparPtrs(block,x)}, {\tt Getuint8OparPtrs(block,x)},\\
                    {\tt Getuint16OparPtrs(block,x)}, {\tt Getuint32OparPtrs(block,x)}\\
                    to have the appropiate pointer of the data to handle ({\bf x is numbered from 1 to nopar}).\\
                    For the previous example that gives :

                    {\tt
                     \#include "scicos\_block4.h"\\
                     ...\\
                     SCSINT32\_COP *ptr\_i;\\
                     SCSREAL\_COP *ptr\_dr;\\
                     SCSREAL\_COP *ptr\_di;\\
                     ...\\
                     void mycomputfunc(scicos\_block *block,int flag)\\
                     \{\\
                     ...\\
                     /*get the ptrs of an int32 object parameter*/\\
                     ptr\_i = Getint32OparPtrs(block,1);\\
                     /*get the ptrs of a double object parameter*/\\
                     ptr\_dr = GetRealOparPtrs(block,2);\\
                     ptr\_di = GetImagOparPtrs(block,2);\\
                     ...\\
                     \}\\
                    }

                    Note that object parameters register is only accessible for reading.
\end{itemize}

\subsection{States and work}

\begin{itemize}
 \item {\bf block->nx :} Integer that gives the length of the continus state register.\\
                  One can't override the index {\tt block->nx-1} when reading or writing data in 
                  the array {\tt x}, {\tt xd} or {\tt res} with a C computational function.

 \item {\bf block->x :} Array of double of size nx,1 corresponding to the continuous state register.\\
                 That gives the result of the computation of the state derivative.\\
                 A value of a continuous state is readable (for i.e the first state) with
                 the C instructions :

                 {\tt
                  \#include "scicos\_block4.h"\\
                  ...\\
                  double x\_1;\\
                  ...\\
                  void mycomputfunc(scicos\_block *block,int flag)\\
                  \{\\
                  ...\\
                  x\_1=block->x[0];\\
                  ...\\
                  \}\\
                 }

                 Note that on {\tt flag}=4, user can write some initial conditions in that register.\\
                 The pointer of that array can also be retrieve via the C macro {\tt GetState(block)}.

 \item {\bf block->xd :} Array of double of size nx,1 corresponding to the derivative of the continuous state register.\\
                  When systems are explicitly given in terms of Ordinary Differential Equations (ODE), it can be
                  explicitly expressed or implicitly used in the residual vector {\tt res} when systems are expressed
                  in terms of Differantial Algebraic Equations (DAE). \\
                  Both systems must be programmed with {\tt flag= 0}.\\
                  For i.e the Lorentz attractor written as an ODE system with three state variables, of the form :

                   \begin{eqnarray}
                        \dot{x} &=& f(x,t)
                   \end{eqnarray}
                  will be defined :

                  {\tt
                   \#include "scicos\_block4.h"\\
                   ...\\
                   double *x = block->x;\\
                   double *xd = block->xd;\\
                   ...\\
                   /* define parameters */\\
                   double a = 10;\\
                   double b = 28;\\
                   double c = 8/3;\\
                   ...\\
                   void mycomputfunc(scicos\_block *block,int flag)\\
                   \{\\
                   ...\\
                   if (flag == 0) \{\\
                      xd[0] = a*(x[1]-x[0]);\\
                      xd[1] = x[1]*(b-x[2])-x[1];\\
                      xd[2] = x[0]*x[1]-c*x[2];\\
                   \}\\
                   ...\\
                   \}\\
                  }

 \item {\bf block->res :} Array of double of size nx,1 corresponding to Differential Algebraic Equation (DAE) residual.\\
                   It is used to write the vector of systems that have the following form :
                   \begin{eqnarray}
                        f(\dot{x},x,t) &=& 0
                   \end{eqnarray}
                   For i.e the Lorentz attractor written as a DAE system with three state variables, will be defined :

                   {\tt
                    \#include "scicos\_block4.h"\\
                    ...\\
                    double *x = block->x;\\
                    double *xd = block->xd;\\
                    double *res = block->res;\\
                    ...\\
                    /* define parameters */\\
                    double a = 10;\\
                    double b = 28;\\
                    double c = 8/3;\\
                    ...\\
                    void mycomputfunc(scicos\_block *block,int flag)\\
                    \{\\
                    ...\\
                    if (flag == 0) \{\\
                      res[0] =  - xd[0] + (a*(x[1]-x[0]));\\
                      res[1] =  - xd[1] + (x[0]*(b-x[2])-x[1]);\\
                      res[2] =  - xd[2] + (x[0]*x[1]-c*x[2]);\\
                    \}\\
                    ...\\
                    \}\\
                   }


 \item {\bf block->nz :} Integer that gives the length of the discrete state register.\\
                  One can't override the index {\tt block->nz-1} when reading data in the array {\tt z}
                  with a C computational function.\\
                  This value is also accessible via the C macros {\tt GetNdstate(block)}.

 \item {\bf block->z :} Array of double of size nz,1 corresponding to the discrete state register.\\
                 A value of a discrete state is directly readable (for i.e the second state) with
                 the C instructions :

                 {\tt
                  \#include "scicos\_block4.h"\\
                  ...\\
                  double z\_2;\\
                  ...\\
                  void mycomputfunc(scicos\_block *block,int flag)\\
                  \{\\
                  ...\\
                  z\_2=block->z[1];\\
                  ...\\
                  \}\\
                 }

                 Note that the state register should be only written for {\tt flag}=4 and {\tt flag}=2.\\
                 The pointer of that array can also be retrieve via the C macro {\tt GetDstate(block)}.

 \item {\bf block->noz :} Integer that gives the number of the discrete object states.\\
                   One can't override the index {\tt block->noz-1} when accessing data in the arrays
                   {\tt ozsz}, {\tt oztyp} and {\tt ozptr} in a C computational function.\\
                   This value is also accessible via the C macro {\tt GetNoz(block)}.

 \item {\bf block->ozsz :} An array of integer of size noz,2 that contains the dimensions of matrices of
                    discrete object states.\\
                    The first column is for the first dimension and the second for the second dimension.
                    For i.e. if we want the dimensions of the last object state, we'll use the instructions :

                    {\tt
                     \#include "scicos\_block4.h"\\
                     ...\\
                     int noz;\\
                     int n,m;\\
                     ...\\
                     /*get the number of object state*/\\
                     noz=block\->noz;\\
                     ...\\
                     void mycomputfunc(scicos\_block *block,int flag)\\
                     \{\\
                     ...\\
                     /*get number of row of the last object state*/\\
                     n=block\->ozsz[noz-1];\\
                     /*get number of column of the last object state*/\\
                     m=block\->ozsz[2*noz-1];\\
                     ...\\
                     \}\\
                    }

                    The dimensions of object discrete states can be get with the following C macro :

                    {\tt
                     GetOzSize(block,x,1); /*get first dimension of oz*/ \\
                     GetOzSize(block,x,2); /*get second dimension of oz*/ \\
                    }

                    with {\tt x} an integer that gives the index of the discrete object state, {\bf numbered
                    from 1 to noz}.

 \item {\bf block->oztyp :} An array of integer of size noz,1 that contains the type of matrices of
                     discrete object states.\\
                     The following table gives the correspondence table for scicos type expressed in Scilab number,
                     in C number and also corresponding C pointers and C macros used for {\tt ozptr} :

                     \begin{tabular}{|p{4cm}|p{3cm}|p{3cm}|p{4cm}|p{5cm}|}
                      \hline
                      {\bf Scilab}&
                      &
                      {\bf C}&
                      &
                      \\
                      \hline
                      \hline
                      Type&
                      Number&
                      Number&
                      Type&
                      Macros\\
                      \hline
                      real matrix&
                      1&
                      10&
                      double&
                      SCSREAL\_COP\\
                      \hline
                      complex matrix&
                      2&
                      11&
                      double&
                      SCSCOMPLEX\_COP\\
                      \hline
                      int32 matrix&
                      3&
                      84&
                      long int&
                      SCSINT32\_COP\\
                      \hline
                      int16 matrix&
                      4&
                      82&
                      short&
                      SCSINT16\_COP\\
                      \hline
                      int8 matrix&
                      5&
                      81&
                      char&
                      SCSINT8\_COP\\
                      \hline
                      uint32 matrix&
                      6&
                      814&
                      unsigned long int&
                      SCSUINT32\_COP\\
                      \hline
                      uint16 matrix&
                      7&
                      812&
                      unsigned short&
                      SCSUNINT16\_COP\\
                      \hline
                      uint8 matrix&
                      8&
                      811&
                      unsigned char&
                      SCSUINT8\_COP\\
                      \hline
                      all others data&
                      &
                      -1&
                      double&
                      SCSUNKNOWN\_COP\\
                      \hline
                     \end{tabular}

                     The type of discrete object state can also be got by the use of the C macro
                     {\tt GetOzType(block,x)}. For i.e, if we want the C number type of the first
                     discrete object state, we'll use the following C instructions:

                     {\tt
                      \#include "scicos\_block4.h"\\
                      ...\\
                      int oztyp\_1;\\
                      ...\\
                      void mycomputfunc(scicos\_block *block,int flag)\\
                      \{\\
                      ...\\
                      /*get the number type of the first object state*/\\
                      oztyp\_1 = GetOzType(block,1);\\
                     ...\\
                     \}\\
                     }

 \item {\bf block->ozptr :} An array of pointers of size noz,1 that allows to directly acces to the
                     data contained in the discrete object state.\\
                     Suppose that you have defined in the editor a block with the following 
                     \textbf{odstate} field in \htmladdnormallink{scicos\_model}{scicos_model.htm} :

                     {\tt model.odstate=list(int32([1,2;3,4]),[1+\%i \%i 0.5]);}

                     Then we have two discrete object states, one is an 32-bit integer matrix with two rows and two
                     columns and the second is a vector of complex numbers that can be understand as a matrix
                     of size 1,3.\\
                     At the C computational function level, the instructions {\tt block->ozsz[0]},
                     {\tt block->ozsz[1]}, {\tt block->ozsz[2]}, {\tt block->ozsz[3]} will respectively return the
                     values 2,1,2,3 and the instructions {\tt block->oztyp[0]}, {\tt block->oztyp[1]} the values 11 and
                     84.\\
                     {\tt block->ozptr} will contain then two pointers, and should be viewed as arrays contained data of
                     discrete object state as shown in the following figure :

                     \begin{figure}[!h]
                      \begin{center}
                       \scalebox{0.7}{\input{oz.pstex_t}}
                      \end{center}
                     \end{figure}

                    For i.e., to directly access to the data, the user can use theses instructions :

                    {\tt
                     \#include "scicos\_block4.h"\\
                     ...\\
                     SCSINT32\_COP *ptr\_i;\\
                     SCSINT32\_COP cumsum\_i;\\
                     SCSCOMPLEX\_COP *ptr\_d;\\
                     SCSREAL\_COP cumsum\_d;
                     ...\\
                     void mycomputfunc(scicos\_block *block,int flag)\\
                     \{\\
                     ...\\
                     /*get the ptrs of an int32 discrete object state*/\\
                     ptr\_i = (SCSINT32\_COP *) block->ozptr[0];\\
                     /*get the ptrs of a double discrete object state*/\\
                     ptr\_d = (SCSCOMPLEX\_COP *) block->ozptr[1];\\
                     ...\\
                     /*compute the cumsum of the int32 matrix*/\\
                     cumsum\_i = ptr\_i[0]+ptr\_i[1]+ptr\_i[2]+ptr\_i[3];\\
                     ...\\
                     /*compute the cumsum of the real part of the complex matrix*/\\
                     cumsum\_d = ptr\_d[0]+ptr\_d[1]+ptr\_d[2];\\
                     ...\\
                     \}\\
                    }

                    One can also use the set of C macros :\\
                    {\tt GetRealOzPtrs(block,x)},  {\tt GetImagOzPtrs(block,x)},\\
                    {\tt Getint8OzPtrs(block,x)},  {\tt Getint16OzPtrs(block,x)},\\
                    {\tt Getint32OzPtrs(block,x)}, {\tt Getuint8OzPtrs(block,x)},\\
                    {\tt Getuint16OzPtrs(block,x)}, {\tt Getuint32OzPtrs(block,x)} \\
                    to have the appropiate pointer of the data to handle ({\bf x is numbered from 1 to noz}).\\
                    For the previous example that gives :

                    {\tt
                     \#include "scicos\_block4.h"\\
                     ...\\
                     SCSINT32\_COP *ptr\_i;\\
                     SCSREAL\_COP *ptr\_dr;\\
                     SCSREAL\_COP *ptr\_di;\\
                     ...\\
                     void mycomputfunc(scicos\_block *block,int flag)\\
                     \{\\
                     ...\\
                     /*get the ptrs of an int32 discrete object state*/\\
                     ptr\_i = Getint32OzPtrs(block,1);\\
                     /*get the ptrs of a double discrete object state*/\\
                     ptr\_dr = GetRealOzPtrs(block,2);\\
                     ptr\_di = GetImagOzPtrs(block,2);\\
                     ...\\
                     \}\\
                    }

                    Finally note that the discrete objects state should be only written for {\tt flag}=4 and {\tt flag}=2.

 \item {\bf block->work :} A free pointer to set a working array for the block.\\
                           The work pointer must be firstly allocated when {\tt flag} = 4 and finally be free in the
                           {\tt flag} = 5.\\
                           Then a basic life cyle of that pointer in a C computational function should be :

                           {\tt
                            \#include "scicos\_block4.h"\\
                            ...\\
                            void** work=block->work;\\
                            ...\\
                            void mycomputfunc(scicos\_block *block,int flag)\\
                            \{\\
                           ...\\
                            /*initialization*/\\
                            if (flag==4) \{\\
                              /*allocation of work*/\\
                              if (*work=scicos\_malloc(sizeof(double))==NULL) \{\\
                               set\_block\_error(-16);\\
                               return;\\
                              \}\\
                            ...\\
                            \}\\
                            ...\\
                            /*other flag treatment*/\\
                            ...\\
                            /*finish*/\\
                            else if (flag==5) \{\\
                               scicos\_free(*work);\\
                            \}\\
                            ...\\
                            \}\\
                           }

                           Note that if a block use a {\tt work} pointer, it will be called with {\tt flag}=2 even if
                           the block don't use discrete states.\\
                           The pointer of that array can also be retrieve via the C macro {\tt GetWorkPtrs(block)}.
\end{itemize}

\subsection{Zero crossing surfaces and modes}

\begin{itemize}
 \item {\bf block->ng :} Integer that gives the number of zero crossing surface of the block.\\
                         One can't override the index {\tt (block->ng)-1} when reading/writing data
                         in the array {\tt g} with a C computational function.\\
                         The number of zero crossing surface can also be got by the use of the C macro
                         {\tt GetNg(block)}.

 \item {\bf block->g :} Array of double of size ng,1 corresponding to the zero crossing surface register.\\
                        That register is used to detect zero crossing of state variable during time domain
                        integration.\\
                        Note that it is accessible for writting for {\tt flag} = 9.\\
                        The pointer of that array can also be retrieve via the C macro {\tt GetGPtrs(block)}.

 \item {\bf block->nmode :} Integer that gives the number of mode of the block.\\
                            One can't override the index {\tt (block->mode)-1} when reading/writing data
                            in the array {\tt mode} with a C computational function.\\
                            The number of mode can also be got by the use of the C macro
                            {\tt GetNmode(block)}.

 \item {\bf block->mode :} Array of integer of size nmode,1 corresponding to the mode register.\\
                           That register is used to set the mode of state variable during time domain
                           integration.\\
                           It is typically accessible for writting for {\tt flag} = 9.\\
                           The pointer of that array can also be retrieve via the C macro {\tt GetModePtrs(block)}.

 %\item {\bf jroot :}
\end{itemize}

\subsection{Miscallaneous}

\begin{itemize}
 %\item {\bf funpt :}
 %\item {\bf scsptr :}
 %\item {\bf ztyp :}

 \item {\bf block->type :} Integer that gives the type of the computational function. For C blocks, this number
                    is equal to 4.

 \item {\bf block->label :} Strings array that allows to retrieve the label of the block.
\end{itemize}
</FILE>

<FILE name='C_utils' type='LATEX'>

The \htmladdnormallink{scicos\_block4.h}{scicos_block4_rout.htm} header provides some utilities
functions to interact with the simulator in the C computational functions.

\begin{itemize}

\item {\bf void do\_cold\_restart();}\\
      This function forces the solver to do a cold restart. It should be used in situations
      where the block creates a non smooth signal. Note that in most situations, non smooth
      situations are detected by zero-crossings and this function is not needed. This block is
      used in very exceptional situations.

\item {\bf int get\_phase\_simulation();} \\
      That function returns an integer which says if the simulator is realizing time domain
      integration. It can returns :
      \begin{itemize}
        \item {\bf 1 :} The simulator is on a discrete activation time.
        \item {\bf 2 :} The simulator is realizing a continuous time domain integration.
      \end{itemize}

\item {\bf double get\_scicos\_time();} \\
      That function returns the current time of simulator.

\item {\bf int get\_block\_number();}\\
      That function returns an integer : the block index in the compiled structure. Each
      block in the simulated diagram have a single index, and blocks are numbered from
      1 to nblk (the total number of blocks in the compiled structure).

\item {\bf void set\_block\_error(int);}\\
       Function to set a specific error during the simulation for the current block. If it is used, then
       after the execution of the computational function of the block, the simulator will end and will
       return an error message associated to the number given in the integer argument.\\
       The following calls are allowed :
       \begin{itemize}
          \item{\bf set\_block\_error(-1); :} the block has been called with input out of its domain,
          \item{\bf set\_block\_error(-2); :} singularity in a block,
          \item{\bf set\_block\_error(-3); :} block produces an internal error,
          \item{\bf set\_block\_error(-16); :} cannot allocate memory in block.
       \end{itemize}

\item {\bf void end\_scicos\_sim();}\\
      A very specific function to set the current time of the simulator to the final time integration.\\
      Only expert user should use this function.

\item {\bf void set\_pointer\_xproperty(int* pointer);}\\
       This function set a vector of integer to inform the type (algebraic or differential) of the 
       continuous state variables of the block.

\item {\bf void * scicos\_malloc(size\_t);}\\
      That function must be used to do allocation of scicos pointers inside a C computational function and
      in particular for {\tt flag}=4 for the work pointer {\tt *block->work}.

\item {\bf void scicos\_free(void *p);}\\
      That function must be used to free scicos pointers inside a C computational function and
      in particular for {\tt flag}=5 for the work pointer {\tt *block->work}.

%double Get_Jacobian_parameter(void);
%double Get_Scicos_SQUR(void);
%void Set_Jacobian_flag(int flag);
\end{itemize}
</FILE>

<FILE name='Capacitor' type='LATEX'>
Un condensateur est un composant électrique ou électronique dont
l'intérêt de base est d'avoir une capacité électrique. Son
comportement électrique idéal est:
      \[  I = C{dV\over dt}\]
où:
\begin{itemize}
\item $I$ est le courant qui traverse le composant.
\item $V$ est la tension aux bornes du composant.
\item $C$ est la capacité électrique du condensateur.
\item $\textstyle{{dV\over dt}}$ est la variation de tension avec le temps.
\end{itemize}

Le condensateur peut être utilisé pour distinguer les signaux
haute-fréquences et basse-fréquence. Cette faculté est très utile
dans la conception des filtres.
</FILE>

<FILE name='ConstantVoltage' type='LATEX'>
Ce composant est un modèle pour n'importe quel dispositif ou système
qui produit une force électromotrice constante entre ses terminaux. La
tension aux bornes de cette source est C. C est définie par
l'utilisateur. Le port noir indique la tension positive. La résistance
ohmique de ce composant est zéro.
</FILE>

<FILE name='Context' type='LATEX'>
\subsection{Introduction}
In most cases, double clicking on a Scicos block leads to the opening of a dialog box used
to set the values of block parameters. These parameters, which we refer to as GUI parameters,
are not necessarily the exact duplicate of the block parameters used in the {\em computational function}
of the block used during simulation. For example the GUI parameters of a linear system block can be
the numerator and the denominator of its transfer function, whereas the parameters used during the
simulation are the {\bf A}, {\bf B}, {\bf C} and {\bf D} matrices associated with the time domain specification of
this transfer function. It is the role of the {\em interfacing function} of the block to examine the
GUI parameters given by the user, generate error messages if needed, and convert them into simulation
parameters.

In specifying the GUI parameters, the user can enter numerical expressions in the dialog box, for example
{\tt 23} or {\tt [1,4;0,2]}, but he can also enter Scilab expressions such as: {\tt exp(.4*3)+sin(.3)} or 
{\tt ones(5,5)+diag([1:5])}. But more importantly, the user can enter expressions using Scilab
variables: {\tt A}, {\tt cos(theta)/2}. These variables, which we call {\em symbolic parameters} of the block,
must have been previously defined; in most cases this is done in a {\em context}.

Using symbolic parameters in specifying GUI parameters allows the user to easily change a system parameter
affecting multiple blocks (otherwise the GUI parameter of each block has to be individually changed). To
make an analogy with standard programming languages such as C, it would be like setting {\tt double mass=0.3;} 
and using {\tt mass} everywhere in the program instead of {\tt 0.3}. Symbolic parameters can also be used to
construct parameterized models, for example it is possible to build the model
of a fully generic linear-system-Kalman-filter system in which even the size of the blocks' states 
and input/outputs are not determined in advance and vary depending on the value of the parameters. 
Indeed, the sizes of the symbolic parameters can also be changed if it does not create inconsistencies in the diagram.  

\subsection{Diagram context}
Each Scicos diagram (the main diagram as well as the Super Blocks) has a context associated with it.
The context is a {\em Scilab script}; it can be edited interactively using the ``Diagram/Context'' menu of
the diagram. To use a symbolic parameter, say the matrix {\tt A}, to be used in defining 
the GUI parameter of a block, {\tt A}
can be defined in the context of the diagram. But all the symbolic parameters of all the blocks in a diagram
are not necessarily defined in the context of that same diagram.

\subsubsection{Scope of a context variable}
A Scilab variable defined in the context of a diagram is accessible not only to the blocks of that diagram,
but also to the contexts and the blocks of all sub-diagrams below it. For example if {\tt A} is defined in the
context of Diagram D1, and Diagram D2 is a sub-diagram of D1 (is the content of a super block of D1), then
{\tt A} is available to the context of D2 and can be used in the definition of the GUI parameters of its blocks.
The context of D2 can for example contain the following instruction: {\tt B=A+2}.

If the variable {\tt A} is redefined in the context of Dn, one of the sub-diagrams of D1, then it is the new value
that is available in the blocks of Dn, and the context and the blocks of the sub-diagrams below it. So in general, to
find the definition of a symbolic parameter used in a block, first the context of the diagram containing the
block must be examined. If the parameter is not defined there, the context of the diagram containing the
first diagram must be examined and so on until the definition of the parameter is found.  

This hierarchical treatment of parameter definition using multiple contexts as opposed to a single workspace
has many advantages. The most important advantage is that a Super Block can be placed inside a diagram
without any risk of conflict, even if symbolic parameters with similar names are used in both. Another advantage
is its natural usage in the masking operation that we shall see later.

\subsubsection{Evaluation of the context}
As previously stated, a context is nothing but a list of Scilab instructions: a Scilab script. The context
of a diagram must be evaluated (script executed) in order to compute 
the symbolic parameters that are used in the definition of the GUI parameters of its blocks. The contexts
are evaluated only when necessary, in particular when the content of a context is modified. In that case,
all the GUI parameters of all the blocks in the diagram in which the context has been modified are re-evaluated, and
so are the context and the blocks' GUI parameters of all the sub-diagrams below it. The reason for re-evaluating
the sub-diagrams below it has to do with the scope of the parameters defined in the context of the first diagram.
Indeed any change in this context can affect GUI parameters of all the blocks within sub-diagrams below this first
diagram.

When a diagram is opened, its context is also evaluated so that symbolic parameters are 
made available in the environment.
The GUI parameters of the blocks are however not re-evaluated. The reason is that it is assumed that two
evaluation of the same identical contexts leads necessary to the same values of symbolic parameters. So, since
the content of the context of the diagram has not changed since it has last been saved, the blocks GUI parameters
must be up to date. This assumption holds in most cases, but not if functions such as {\tt rand} or {\tt date} are
used in the context. Another instruction that can invalidate the assumption is the execution of an external
script, for example {\tt exec('myprog.sce')}. Clearly if the file {\tt myprog.sce} is modified, the re-evaluation
of the context can lead to different values for the symbolic parameters. Scicos attempts to identify the presence 
of such commands inside the text of the context and issues a full re-evaluation if it finds it necessary when
a diagram is opened. But this identification is not full proof and a manual ``Evaluate'' button is provided to
force a full re-evaluation if the user finds it necessary. 

The ``Evaluate'' button is particularly useful when the context contains an {\tt exec} command since Scicos
does not know if the executed file is edited. In such a case, it is up to the user to force an evaluation.

Finally it should be noted that all the variables defined in a context, except for functions, are available 
as symbolic parameters. So it is recommended that intermediate variables used in the context be cleared at
the end of the context to avoid overloading the list of symbolic parameters. 


\subsection{Masking operation}
The masking operation consists of modifying a Super Block in such a way that it resembles a regular block.
Double clicking on a masked block, opens a GUI, just as in the case of a regular block (double clicking on
a Super Block opens up the diagram contained in the Super Block). The GUI parameters of a masked block
are the symbolic parameters needed to evaluate its content. These parameters are identified automatically
when the ``Create Mask'' operation is applied to a Super Block. 

By choosing to define or not to define in the context various symbolic parameters needed in a Super Block, user
can specify the GUI parameters of the block obtained after the masking operation. This is an easy way of
constructing custom blocks. The dialog box associated with the block can also be customized using the
``Customize Mask'' operation. Finally, the mask can be removed  by the ``Remove Mask'' operation. 
</FILE>

<FILE name='Counter' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	Ce bloc, suivant la loi choisie, compte à partir d'un minimum vers un maximum ou d'un maximum vers un minimun.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='CurrentSensor' type='LATEX'>
Ce bloc est inséré en série dans un circuit électrique pour mesurer le
courant qui passe à travers. Si le courant positif {\bf entre} par le
port noir, il est consideré positif. La résistance ohmique de ce
composant est zéro.
</FILE>

<FILE name='DEADBAND' type='LATEX'>
Fournit une zone où la sortie est égale à zéro.
</FILE>

<FILE name='DEBUG_SCICOS' type='LATEX'>

The DEBUG block is a powerful debugging tool in Scicos. When placed in a Scicos diagram,
during simulation, it impersonates every block, once before its activation, once after.
By opening the DEBUG block, user can write the scilab script that will be executed when
it is activated. The DEBUG block is very similar to a standard type 5 Scilab block. It is
called with two arguments (block and flag), it has access to functions such as
curblock(), scicos\_time(), etc., and its output is block.

For every block, during simulation, the DEBUG block is called first (as if it were the
block itself). Then the simulation routine of the block is called, and finally the DEBUG
is called a second time the same way. This way, the DEBUG block can be used to monitor
the block values before and after executation. The DEBUG block can also modify these
values, thus making it a powerful debugging tool.

For example if a simple pause is placed in the DEBUG block, then the simulation runs in
single step mode. But the pause statement can also be made conditional. For example:

{\tt
if curblock()==3 \& scicos\_time()>2 \& flag==2 then pause, end
}

The test can also be made dependent on the values of the block, for example:
if block.outptr(1)(1)>9 then disp(scicos\_time()),end

This block can also be used to create log files by printing information about the block
values during simulation.

Note that for the DEBUG block to function, the debugging level must be set to 2 or
higher. The debugging level is changed automatically when the DEBUG block is placed
inside the diagram. It is possible to disable a DEBUG block by changing back the
debugging level to 0, without having to remove it from the diagram. This can be done by
using the menu Debug Level, or at the Scilab prompt (often under pause), using the
scicos\_debug() function.
</FILE>

<FILE name='DELAYV_f' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='DELAY_f' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
          Ce super-bloc compilé réalise un retard discret.
          Il est construit avec un registre à décalage et une horloge.
          La valeur du retard est donnée par la pas temporel discret multiplié
          par le nombre-1 d'état du registre.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='DEMUX' type='LATEX'>
En fournissant un vecteur sur le port d'entrée régulier, ce bloc
peut séparer les éléments de l'entrée par des vecteurs sur les ports
de sortie.
L'entrée est donc définie $u=[y_1;y_2,\cdots;y_n]$, où  $y_i$ sont
numérotés dans un ordre décroissant.
Les tailles des ports d'entrée et de sortie sont déterminées par le contexte.
</FILE>

<FILE name='DEMUX_f' type='LATEX'>
Given a vector valued input this block splits inputs over vector
valued outputs. So $ u=[y_1;y_2,\cdots;y_n]$ , where  $y_i$  are
numbered from top to bottom. Input and Output port sizes are
determined by the context.
</FILE>

<FILE name='DERIV' type='LATEX'>
Le bloc dérivée fait l'approximation de la dérivée de son entrée en calculant:
$$\frac{\Delta u}{\Delta t}$$.
</FILE>

<FILE name='DFLIPFLOP' type='LATEX'>
The DFLIPFLOP block outputs the input state when the enable is
set and on the rising edge of the clock. The input is D the
enable is en and the clock is clk. Q and !Q are the outputs of
this block. This block is almostly used with digital number, 
the input data type is int8.\\

The truth table of this block is
\begin{tabular}{|c|c||c|c|}
\hline
en&
D&
Q&
!Q\\
\hline
0&
0&
0&
1\\
\hline
0&
1&
0&
1\\
\hline
1&
0&
0&
1\\
\hline
1&
1&
1&
0\\
\hline
\end{tabular}
</FILE>

<FILE name='DIFF_c' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
    <DESCRIPTION_ITEM>
    <P>
    The implicit Derivative block provides the derivative of its
    input. This block imposes the algebraic constraint (x=u) on the
    solver, where u is the block input and x is the internal
    state. The solver varies the internal states to make state x
    follow the input's variations.  The solver computes the
    derivatives of the state which is made available at the block
    output. The solver uses multi-order multi-step BDF (backward
    differentiation formula ) method to estimate the derivative. The
    accuracy of this method is higher than "du/dt" block which uses
    order 1 method. In order to increase the accuracy of the
    derivative, the user can reduce the error tolerances.
    </P>
    </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='DIFF_f' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
    <DESCRIPTION_ITEM>
    <P>
    This is an old block. Please use \htmladdnormallink{DIFF_c}{DIFF_c.htm}.
    </P>
    <P>
    The implicit Derivative block provides the derivative of its
    input. This block imposes the algebraic constraint (x=u) on the
    solver, where u is the block input and x is the internal
    state. The solver varies the internal states to make state x
    follow the input's variations.  The solver computes the
    derivatives of the state which is made available at the block
    output. The solver uses multi-order multi-step BDF (backward
    differentiation formula ) method to estimate the derivative. The
    accuracy of this method is higher than "du/dt" block which uses
    order 1 method. In order to increase the accuracy of the
    derivative, the user can reduce the error tolerances.
    </P>
    </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='DLATCH' type='LATEX'>
This block outputs the input state when the input gate is high.
The input is D the enable is C. Q and !Q are the outputs of 
this block. This block is almostly used with digital number, 
the input data type is int8.\\

The truth table of this block is

\begin{tabular}{|c|c||c|c|}
\hline
C&
D&
Q&
!Q\\
\hline
0&
0&
0&
1\\
\hline 
0&
1&
0&
1\\
\hline 
1&
0&
0&
1\\
\hline 
1&
1&
1&
0\\
\hline
\end{tabular}
</FILE>

<FILE name='DLR' type='LATEX'>
Ce bloc réalise un système linéaire SISO (Single Input Single Output) 
représenté par une fonction de transfert rationnelle
dans l'espace de la transformée en z.
La fonction rationnelle doit être une fonction propre.
</FILE>

<FILE name='DLRADAPT_f' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='DLR_f' type='LATEX'>
Ce bloc réalise un système linéaire SISO (Single Input Single Output) 
représenté par une fonction de transfert rationnelle
dans l'espace de la transformée en z.
La fonction rationnelle doit être une fonction propre.
</FILE>

<FILE name='DLSS' type='LATEX'>
Ce bloc réalise un système d'équations d'état temporel discret.
Le système est défini par les matrices $(A,B,C,D)$
et par l'état initial $x_0$.
Les dimensions des matrices et de l'état initial doivent être appropriées.
Lorsque qu'un événement active le bloc (par son unique port événementiel)
l'état est alors mis à jour.
</FILE>

<FILE name='DLSS_f' type='LATEX'>
Ce bloc réalise un système d'équations d'état temporel discret.
Le système est défini par les matrices $(A,B,C,D)$
et par l'état initial $x_0$.
Les dimensions des matrices et de l'état initial doivent être appropriées.
Lorsque qu'un événement active le bloc (par son unique port événementiel)
l'état est alors mis à jour.
</FILE>

<FILE name='DOLLAR' type='LATEX'>
Le bloc retard retarde ses entrées de la période spécifiée au niveau du port
d'entrée événementiel.
Ce bloc est équivalent à l'opérateur discret $z^{-1}$.
Il accepte une seule entrée et génére une seule sortie qui peuvent être
aussi bien un scalaire qu'un vecteur.
Si l'entrée est un vecteur alors tous les éléments du vecteur sont
retardés par la même période.
</FILE>

<FILE name='DOLLAR_f' type='LATEX'>
Le bloc retard retarde ses entrées de la période spécifiée au niveau du port
d'entrée événementiel.
Ce bloc est équivalent à l'opérateur discret $z^{-1}$.
Il accepte une seule entrée et génére une seule sortie qui peuvent être
aussi bien un scalaire qu'un vecteur.
Si l'entrée est un vecteur alors tous les éléments du vecteur sont
retardés par la même période.
</FILE>

<FILE name='DOLLAR_m' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
        Le bloc retard retarde ses entrées de la période spécifiée au niveau
        du port d'entrée événementiel. Ce bloc est équivalent à l'opérateur
        discret z-1.
	Il accepte une seule entrée et génére une seule sortie qui peuvent
        être aussi bien un scalaire qu'un vecteur.
	Si l'entrée est un vecteur alors tous les éléments du vecteur sont
        retardés par la même période.
	</P>
	<P>
        Ce bloc supporte tous les types de données de scicos.
        Les types de données en entrée/sortie sont hérités du paramètre
        "initial condition".
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='DemoBlocks_pal' type='LATEX'>
Les blocs de cette palette sont utilisés pour faire des
diagrammes de démonstration.
</FILE>

<FILE name='Diode' type='LATEX'>
Ce composant consiste en une diode simple mise en parallèle avec une résistance
ohmique $R$. Le courant qui passe dans la diode est défini en
fonction de la tension aux bornes de le diode, {\it c.-à-d.},

\[I = I_{ds} (\exp^{v/V_t} - 1) + \frac {v} {R} \]

où $I_{ds}$ et $V_t$ sont le courant de saturation et la tension
équivalente de la température, respectivement. Si la valeur de $v/V_t$
atteint une certaine limite ($Maxexp$), la courbe caractéristique de
la diode devient linéaire pour éviter un dépassement numérique.
</FILE>

<FILE name='EDGETRIGGER' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ce bloc est utilisé seulement dans le super bloc EDGE_TRIGGER.
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='EDGE_TRIGGER' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ce bloc génère un événement sur le front montant, descendant ou
les deux (en fonction du paramètre du bloc). Un front montant correspond
à un changement de valeur négative vers positive ou nulle, ou zéro
vers positive. Le front descendant est l'inverse. A noter que ce bloc
génère un événement si l'entrée saute à cause d'une
activation par événement. L'événement généré est synchrone
avec l'événement d'origine. Ce bloc ne détecte pas les traversés de
zéro des signaux continus.
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='ENDBLK' type='LATEX'>
Ce bloc peut être utiliser pour paramètrer le temps final de la simulation.
Lorsque ce bloc est correctement paramétré alors le simulateur fera avancer le
temps au temps final définit par le paramètre 'final integration time' de l'entrée
Setup du menu Simulate à la date définie par le paramètre de la boîte de dialogue
'Final simulation time'.
L'unique entrée de la boîte de dialogue peut être une valeur numérique
ou bien une variable symbolique définit dans le contexte.
</FILE>

<FILE name='END_c' type='LATEX'>
Ce bloc fait avancer le temps courant au temps final d'intégration lorsque celui-ci
est activé la première fois :
\begin{eqnarray}
  {\rm T_{f}} & = & {\rm T_{cur}}
\end{eqnarray}
avec {\bf Tcur} la date d'activation de ce bloc et {\bf Tf} le temps final d'intégration
définit via l'entrée Setup du menu Simulate (scs\_m.props.tf).
</FILE>

<FILE name='ESELECT_f' type='LATEX'>
Bloc spécial similaire au bloc If-Then-Else. Les entrées/sorties
événementielles sont synchronisées. L'événement entrant est redirigé
sur l'un des ports de sortie événementiels suivant le valeur de
l'entrée régulière.
</FILE>

<FILE name='EVTDLY_c' type='LATEX'>
Chaque événement de sortie est réalisé après l'événement 
d'entrée par un laps de temps {\bf Delay}.\\
La date de l'événement de sortie est donc déterminée par la formule :
\begin{eqnarray}
 t_{i}&=&t_{\rm{init}} + i * T_{\rm{delay}},
\end{eqnarray}
</FILE>

<FILE name='EVTDLY_f' type='LATEX'>
Ce bloc génére à la sortie des événements retardés par rapport aux
événements qui arrivent à l'entrée.
Le retard est définit par la valeur du paramètre {\bf Delay}.
Ce bloc peut aussi généré un événement à une date initiale.
</FILE>

<FILE name='EVTGEN_f' type='LATEX'>
Un événement est généré sur le port unique de sortie événementiel
si la valeur du paramètre {\bf Event time} est plus grand ou égal à
zéro.
Si cette valeur est négative alors aucun événement ne sera généré.
</FILE>

<FILE name='EVTVARDLY' type='LATEX'>
Ce bloc génére à la sortie des événements retardés par rapport aux
événements qui arrivent à l'entrée.
Le retard est définit par la valeur qui est lu sur le port d'entrée
régulier.
Ce bloc peut aussi généré un événement à une date initiale.
</FILE>

<FILE name='EXPBLK_f' type='LATEX'>
Ce bloc calcule $y(i)=a^u(i)$. 
Les tailles des ports d'entrée et de sortie sont déterminées par
le compilateur.
</FILE>

<FILE name='EXPBLK_m' type='LATEX'>
Ce bloc calcule $y(i)=a^u(i)$. \\
Les tailles des ports d'entrée et de sortie sont déterminées par
le compilateur.
</FILE>

<FILE name='EXPRESSION' type='LATEX'>
Le bloc EXPRESSION applique à son entrée les fonctions Scilab spécifiées
en paramètre.
</FILE>

<FILE name='EXTRACT' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  The EXTRACT block extracts some elements from the matrix.
          The size of the output depends on the number of rows and
          number of columns to extract.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='EXTRACTBITS' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	This block outputs a contiguous selection of bits from the input
        integer number.The Bits to extract defines the method by which
        the user select the output bits.
        </P>
	  <P>
          1- When "Upper Half" is selected the block outputs the half
             of the input that contain the most significant bit. In this
             case the third parameter "number of bits or index of bit"
             is ignored.
          </P>
	  <P>
          2- When "Lower Half" is selected the block outputs the half
             of the input that contain the least significant bit. In this
             case the third parameter "number of bits or index of bit"
             is ignored.
          </P>
	  <P>
          3- When "Range starting with most significant bit" is selected
             the block outputs certain number of bits of the input that
             contain the most significant bit. In this case the third
             parameter "number of bits or index of bit" defines the
             number of bits to extract.
          </P>
	  <P>
          4- When "Range ending with least significant bit" is selected
             the block outputs certain number of bits of the input that
             contain the least significant bit. In this case the third
             parameter "number of bits or index of bit" defines the
             number of bits to extract.
          </P>
	  <P>
          5- When "Range of bits" is selected the block outputs a range
             of bits of the input. In this case the third parameter
             "number of bits or index of bit" defines the range of bits
             to extract, it must be a vector with the format [start,end].
          </P>
	<P>
        The extracted value depends on the forth parameter "Treat bit
        field as an integer". When it is set to 0 the input scaling is
        used to determine the output scaling. When it is set to 1, only
        the extracted bits forms the output number.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='EXTRACTOR' type='LATEX'>
Extrait ou sélectionne une entrée régulière parmi plusieurs entrées régulières.
</FILE>

<FILE name='EXTTRI' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	The EXTTRI block extracts some elements from the input matrix u.
        </P>
	<P>
        When the "Extraction type" is set to "1", the block copies the
        elements on and above the main diagonal to an output matrix of
        the same size. The elements below the main diagonal are set to
        zero.
        </P>
	<P>
        When the "Extraction type" is set to "2", the block copies the
        elements on and below the main diagonal to an output matrix of
        the same size. The elements above the main diagonal are set to
        zero.
        </P>
	<P>
        When the "Extraction type" is set to "3", the block copies the
        elements on the main diagonal to an output matrix of the same
        size. The elements above and below the main diagonal are set to
        zero.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='Electrical_pal' type='LATEX'>
La boîte à outils électrique contient les composants basiques
électriques tels que la source de tension, la diode, le condensateur,
etc.
</FILE>

<FILE name='Events_pal' type='LATEX'>
La palette 'Events' (événements) est utilisée pour manipuler les
événements sur le diagramme. Elle contient entre autre plusieurs
sources d'activation, des blocs synchrones ainsi que des blocs
pour regrouper/combiner les événements sur un seul lien.
</FILE>

<FILE name='Extract_Activation' type='XML'>
  <DESCRIPTION>

  </DESCRIPTION>
</FILE>

<FILE name='FROM' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	The main role of the GOTO/FROM blocks is to transport signals
        from a block to another block without connecting them physically.
        The FROM block transports its received data (from the
        correponding GOTO) to its output. Multiples FROM blocks can
        receive data from one GOTO, although a GOTO can send data to
        multiple FROM.
        </P>
	<P>
        The GOTO and FROM blocks are connected by the tag parameter.
        </P>
	<P>
        For information on the visibility and limitation of these blocks
        please refer to the GOTO documentation.
        </P>
	<P>
        This block can support all the data types.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='FROMMO' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  This block is used to connect modelica's blocks. For more
          information on how it works please refer to the documentation
          of the FROM block by clicking on the link in the "See also"
          field.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='FROMWSB' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
    <DESCRIPTION_ITEM>
    <P>
    That block is used to get data defined in the Scilab workspace
    and use them in Scicos. Data should have "time" and "values" fields.
    </P>
    </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='FROMWS_c' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
    <DESCRIPTION_ITEM>
    <P>
     This block is used in \htmladdnormallink{FROMWSB}{FROMWSB.htm} superblock.
    </P>
    </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='FSV_f' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='Flowmeter' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
    <DESCRIPTION_ITEM>
    <P>
    Ajoutez ici un paragraphe pour la description de la fonction
    </P>
    </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='GAINBLK' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  Le bloc GAINBLK calcule le produit d'une matrice carré A par une matrice
          d'entrée U, où le nombre de lignes/colonnes de A est égal au nombre de lignes
          de U. Les types de données des entrées/sorties sont définis par le type de
          donnée de la matrice gain A.
	  <P>
          Lorsqu'un dépassement intervient, le résulat peut prendre des valeurs
          différentes suivant le paramètre "DO ON OVERFLOW":
          </P>
	  <P>1- Un résulat non saturé.</P>
	  <P>2- Un résultat saturé.</P>
	  <P>3- Un message d'erreur est signalé lorsqu'un dépassement intervient.</P>
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='GAINBLK_f' type='LATEX'>
Le bloc GAINBLK calcule le produit d'une matrice carré A par une matrice d'entrée U,
où le nombre de lignes/colonnes de A est égal au nombre de lignes de U.
</FILE>

<FILE name='GAIN_f' type='LATEX'>
Ce bloc calcule le produit d'une matrice carré A par une matrice d'entrée U, où le
nombre de lignes/colonnes de A est égal au nombre de lignes de U.
</FILE>

<FILE name='GENERAL_f' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='GENSIN_f' type='LATEX'>
Ce bloc est un générateur de sinusoïde : $M*\sin(F*t+P)$
</FILE>

<FILE name='GENSQR_f' type='LATEX'>
Ce bloc est un générateur de signal carré : la sortie prend des valeurs
entre -M et M.
Pour chaque événement reçu, la sortie saute d'une valeur -M à M 
ou de M à -M.
</FILE>

<FILE name='GEN_SQR' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
    <DESCRIPTION_ITEM>
    <P>
    This block is a square wave generator. The output switches between the Minimum value and the maximum value periodicly. The value of the fourth parameter of this block defines the period of the signal. The period of the switching is equal to the period of the signal divided by 2.
    </P>
    </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='GOTO' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	The main role of the GOTO/FROM blocks is to transport signals
        from a block to another block without connecting them physically.
        The GOTO block transports its input data to its corresponding
        FROM block. A simple GOTO block can send data to multiple FROM,
        although a FROM can receive data from only one GOTO.
        </P>
	<P>
        The GOTO and FROM blocks are connected by the tag parameter.
        </P>
	<P>
        The "Tag Visibility" parameter indicates if the location of
        the FROM block is limitted:
        </P>
	  <P>
          - Local: means that the corresponding FROM of that GOTO must
                   be in the same subsystem.
          </P>
	  <P>
          - Scoped: means that the corresponding FROM of that GOTO must
                    be in the same subsystem or in any subsystem below
                    the GotoTagVisibility block in the model hierarchy.
          </P>
	  <P>
          - Global: means that the corresponding FROM of that GOTO can
                    be anywhere in the model.
          </P>
	<P>
        This block can support all the data types.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='GOTOMO' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  This block is used to connect modelica's blocks. For more
          information on how it works please refer to the documentation
          of the GOTO block by clicking on the link in the "See also"
          field.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='GotoTagVisibility' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  This block defines the accessibility of the GOTO block
          when it is configure as "scoped". The FROM block corresponding
          to that GOTO must be in the same subsystem of the
          GotoTagVisibility or in subsystems below it in the model
          hierarchy.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='GotoTagVisibilityMO' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  This block is used in case of modelica's connection.
          For more information on how it works please refer to the
          GotoTagVisibility block by clicking on the link in the
          "See also" field.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='Ground' type='LATEX'>
Cet élément est un composant électrique simple fournissant une tension
de référence dans des circuits électriques. Le potentiel au noeud de
Terre est zéro. Chaque circuit électrique doit contenir au moins un
élément Terre.
</FILE>

<FILE name='Ground_g' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
    <DESCRIPTION_ITEM>
    <P>
    This block outputs a scalar value equal to 0. The outpu of the block inherit its type from the block at which it is connected.
    </P>
    </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='Gyrator' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
    <DESCRIPTION_ITEM>
    <P>
 A gyrator is a two-port element defined by the following equations:
    <SP>
    i1 =  G2 * v2
    </SP>
    <SP>
    i2 = -G1 * v1
    </SP>
where the constants G1, G2 are called the gyration conductance.
    </P>
    </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='HALT_f' type='LATEX'>
Ce bloc a un unique port d'entrée événementiel.
Lorsqu'un événement se présente sur ce port, alors la simulation
est arrêtée et la main est rendue à la fenêtre principale de Scicos.
La simulation peut être redémarrée ou continuée grâce au bouton Run.
</FILE>

<FILE name='HYSTHERESIS' type='LATEX'>
Permutte la valeur de la sortie entre deux constantes.
TODO
</FILE>

<FILE name='IFTHEL_f' type='LATEX'>
Ce bloc génére un événement sur l'une ses deux sorties événementielles
lorsqu'un événement en entrée active celui-ci.
Suivant le signe de la valeur lue sur le port d'entrée régulier,
l'événement est généré soit sur la branche 'then' ou bien sur la branche
'else'.
Ce bloc est un bloc synchrone, ce qui signifie que les événements en entrée
et en sortie sont générés exactement à la même date et simultanément.
</FILE>

<FILE name='IMPSPLIT_f' type='XML'>
  <DESCRIPTION>

  </DESCRIPTION>
</FILE>

<FILE name='INIMPL_f' type='LATEX'>
Les ports d'entrée INIMPL\_f sont des liens qui permettent de connecter
l'intérieur d'un système vers l'extérieur.
</FILE>

<FILE name='INTEGRAL' type='LATEX'>
Ce bloc est un intégrateur. La sortie est l'intégrale de l'entrée.
</FILE>

<FILE name='INTEGRAL_f' type='LATEX'>
Ce bloc est un intégrateur. La sortie est l'intégrale de l'entrée.
</FILE>

<FILE name='INTEGRAL_m' type='LATEX'>
Ce bloc est un intégrateur. La sortie est l'intégrale de l'entrée.
</FILE>

<FILE name='INTMUL' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	The INTMUL block computes the matrix multiplication of two
        integers inputs matrices.The number of rows of the second
        matrix must be equal to the number of columns of the first
        matrix. The output is a matrix where the number of rows is
        equal to the number of rows of the first input matrix and
        the number of columns is equal to the number of columns of
        the second input matrix. This block support all the integer
        data type.
        </P>
	<P>
        On overflow, the result can take different forms:
        </P>
	 <P>1- A normal non saturated result.</P>
	 <P>2- A saturated result.</P>
	 <P>3- An error message warning the user about the overflow.</P>
	<P>
        The user can select one of these three forms by setting
        the "DO ON OVERFLOW" field to 0,1 or 2.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='INTRP2BLK_f' type='LATEX'>
La sortie de ce bloc est fonction de l'entrée obtenue par interpolation
bilinéaire.
Ce bloc a deux entrées scalaires et une seule sortie scalaire.
Les grandeurs $X(i)$ et $Y(i)$ donnent respectivement les coordonnées
$X,Y$ du $i^{\rm \grave{e}me}$ point de donnée et $Z(Y(i),X(i))$
sa valeur.
</FILE>

<FILE name='INTRPLBLK_f' type='LATEX'>
La sortie de ce bloc est fonction de l'entrée obtenue par interpolation
linéaire.
Ce bloc a une seule entrée scalaire et une seule sortie scalaire.
Les grandeurs $X$ et $Y$ donnent respectivement les coordonnées
$X,Y$ des points de données qui seront interpolés.
$X$ doit être strictement croissant.
</FILE>

<FILE name='INVBLK' type='LATEX'>
Ce bloc calcule $y(i)=1/u(i)$.
La taille de l'entrée/sortie est déterminée par le contexte.
</FILE>

<FILE name='INVBLK_f' type='LATEX'>
Ce bloc calcule $y(i)=1/u(i)$.
La taille de l'entrée/sortie est déterminée par le contexte.
</FILE>

<FILE name='IN_f' type='LATEX'>
Ce bloc doit être utilisé dans un superbloc pour représenter un port
d'entrée régulier. La taille de ce port est automatiquement ajustée.
Dans un superbloc, les ports d'entrée réguliers doivent être numérotés
de 1 jusqu'au nombre de ports d'entrée réguliers composant le superbloc.
</FILE>

<FILE name='ISELECT_f' type='LATEX'>
Sélectionne des signaux suivant les événements d'entrée.
Ce bloc a un seul port régulier d'entrée.
</FILE>

<FILE name='ISELECT_m' type='LATEX'>
Sélectionne des signaux suivant les événements d'entrée.
Ce bloc a un seul port régulier d'entrée.
</FILE>

<FILE name='IdealTransformer' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
    <DESCRIPTION_ITEM>
    <P>
The ideal transformer is an ideal two-port resistive circuit element
which is characterized by the following two equations:
    <SP>
    v1 =  n * v2
    </SP>
    <SP>
    i2 = -n * i1
    </SP>
where n is a real number called the turns ratio.
    </P>
    </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='Inductor' type='LATEX'>
Une bobine est un composant électrique qui peut stocker l'énergie
dans des circuits électriques.  Le rapport entre la tension $v$ aux
borne d'une bobine d'inductance $L$ et le courant $I$ passant à
travers le composant est donné par :

\[v = L \frac{dI}{dt}\]

 Des inductances peuvent également être utilisées pour distinguer les
 signaux haute fréquence des signaux de basse fréquence et ceci
 rend les inductances utiles dans la conception des filtres. Une
 inductance présente une forte impédance pour les signaux haute
 fréquence et est passante pour les signaux DC.
</FILE>

<FILE name='Integer_pal' type='LATEX'>
Cette palette est dédicacée aux nombres entiers.
Des opérateurs variés sont ici implémentés pour la logique
et la manipulation des champs de bits ainsi que des portes
logiques qui sont fréquemment utilisées dans les circuits numériques.
</FILE>

<FILE name='JKFLIPFLOP' type='LATEX'>
The JK flip flop is the most versatile of the basic flip-flops.
It has two inputs traditionaly labeled J and K. When J and K are
different, the output takes the value of J at the next falling edge.
When J and K are both low, no change occurs in the output state,
when they are both high the output will toggle from one state to other.
It can perform the functions of the set/reset flip-flop and has the
advantage that there are no ambiguous states. It can also act as a
T flip-flop to accomplish toggling action if J and K are tied together.
This toggle application finds extensive use in binary counters. 
This block is almostly used with digital number, the input data type
is int8.\\

The truth table of this block is

\begin{tabular}{|c|c||c|c|}
\hline
J&
K&
Q(t)&
!Q(t)\\
\hline
0&
0&
Q(t-1)&
!Q(t-1)\\
\hline
0&
1&
0&
1\\
\hline
1&
0&
1&
0\\
\hline
1&
1&
!Q(t-1)&
Q(t-1)\\
\hline
\end{tabular}
</FILE>

<FILE name='Keyboard_shortcuts' type='XML'>
<DESCRIPTION>

</DESCRIPTION>
</FILE>

<FILE name='LOGBLK_f' type='LATEX'>
Ce bloc calcule $y(i)=log(u(i))/log(a)$. 
Les tailles des ports d'entrée/sortie sont déterminés par le contexte.
</FILE>

<FILE name='LOGIC' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  This block implements a standard truth table for modeling
          programming array, digital circuit and any other boolean
          expressions. The user can specify a matrix that defines all
          the possible block output in the Truth table field. Each row
          of the matrix contains the output of different combination
          of input elements. The number of rows must be a power of two,
          it defines the number of inputs using the equation:
        </P>
	<P>number of row = 2 ^ (number of input)</P>
	<P>
          The number of outputs is equal to the number of columns of
          the matrix.
        </P>
	<P>
          This block support only the int8 data type. When the input
          is positif, the input is considered as logical 1, When it is
          negatif or zero it is considered as logical 0.
        </P>
	<P>
          This block can be activated by an implicit input event or it
          can herit the clock from the regular input.
        </P>
	<P>
          This block is used to implement SR and JK flip-flops.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='LOGICAL_OP' type='LATEX'>
Le bloc Opérateur Logique réalise une opération logique
sur ses entrées qui est spécifiée en paramètre.
Une valeur d'entrée est VRAI (1), si elle est différente de zéro, et
elle est FAUSSE (0) si elle est égale zéro.
</FILE>

<FILE name='LOOKUP2D' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
    <DESCRIPTION_ITEM>
    <P>
The 2-D Lookup Table block realizes an approximation of a function
z=f(x,y) given x, y, z data points. The first input port corresponds
to the first table dimension, x. The Row index input values parameter
is a 1-by-m vector of x data points, the Column index input values
parameter is a 1-by-n vector of y data points.  The table data
parameter should be an m-by-n matrix of z data points. Both the row
and column vectors must be strictly monotonically increasing (i.e.,
the value of the next element in the vector is greater than the value
of the preceding element).
  </P>
  <P>
The block generates output based on the input values using one of
these methods selected from the Lookup method parameter list.
    </P>
    </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='LOOKUP_c' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
    <DESCRIPTION_ITEM>
    <P>
     Lookup Table block realizes a non-linear function defined using a
graphical editor.  This block computes an approximation to some
function y=f(x) given data vectors x and y.
      </P>
<P> The table is defined by specifying the Vector of input values
 parameter as a 1-by-n vector and the Table data parameter as a 1-by-n
 vector. The block generates output based on the input values using
 one of methods selected from the Lookup method parameter list.
 The length of the x and y data vectors provided to this block must be
 identical. Furthermore, the x data vector must be strictly
 monotonically increasing.
    </P>
    </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='LOOKUP_f' type='LATEX'>
Ce bloc réalise une fonction non-linéaire qui est défini grâce à un
éditeur graphique.
</FILE>

<FILE name='Linear_pal' type='LATEX'>
Cette palette contient des opérateurs basiques et des sous-systèmes
linéaires.
</FILE>

<FILE name='Lookup_Tables_pal' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
    <DESCRIPTION_ITEM>
    <P>
    Cette palette contient des blocs "lookup table" avec éditeur graphique.
    </P>
    </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='Lorentz_diagr' type='LATEX'>
Le système de Lorentz est défini par le système continu
d'équations non-linéaires différentielles suivant :
\begin{eqnarray}
\frac{dx(t)}{dt}&=&a\left(-x(t)+y(t)\right)\\
\frac{dy(t)}{dt}&=&bx(t)-y(t)-x(t)y(t)\\
\frac{dz(t)}{dt}&=&-cx(t)+x(t)y(t)
\end{eqnarray}
Les variables d'états $x(t)$, $y(t)$ et $z(t)$ sont respectivement la température de
l'air, la vitesse du vent et une troisième variable qui représente la variation de la
température en fonction de l'altitude.
</FILE>

<FILE name='MATBKSL' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  The MATBKSL block outputs the left matrix division. It is
          a solution to A*x=B. The higher input is the A matrix, the
          lower one is the B matrix, and the output is x. If A is an
          M-by-N1 matrix, B must be a M-by-N2 where N1 and N2 can be
          different or equal.
	  The output x is a N1-by-N2 matrix.
        </P>
	<P>
          The equivalent of BACKSLASH is "\" in Scilab.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='MATCATH' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  The MATCATH Block outputs the horizontal concatenation
          of multiple matrices. It is also called concatenation
          according to the columns. The inputs U1,U2,...,Un must
          have the same number of rows. The output is a
          M-by-(N1+N2+...+Nn) matrix, where N1,N2,...,Nn are the
          numbers of columns of the inputs matrices, and M is the
          number of rows.
	</P>
	<P>
          The equivalent of MATCATH in Scilab is y=[U1 U2 ... Un].
        </P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='MATCATV' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  The MATCATV Block outputs the vertical concatenation of
          multiple matrices. It is also called concatenation according
          to the rows. The inputs U1,U2,...,Un must have the same
          number of columns. The output is a (M1+M2+...+Mn)-by-N
          matrix, where M1,M2,...,Mn are the numbers of rows of the
          inputs matrices, and N is the number of columns.
	</P>
	<P>
          The equivalent of MATCATH in Scilab is y=[U1;U2;...;Un]
        </P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='MATDET' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	The MATDET outputs the determinant of a square input matrix.
        If the input A=[A11 A12 A13;A21 A22 A23;A31 A32 A33] then the
        output of the block has the form of:
        y=A11*(A22*A33-A23*A32)-A12*(A21*A33-A23*A31)+A13*(A21*A32-A22*A31).
       </P>
	<P>
        The equivalent of MATDET in Scilab is "det"
        </P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='MATDIAG' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  The MATDIAG block create a diagonal matrix from a 1D vector.
          If the input is a M-by-1 vector than the output is an M-by-M
          matrix.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='MATDIV' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
        The MATDIV block outputs the right matrix division. It is a
        solution to x*B=A. The higher input is the A matrix, the lower
        one is the B matrix, and the output is x. If A is an M1-by-N
        matrix, B must be a M2-by-N where M1 and M2 can be different
        or equal. The output x is a M1-by-M2 matrix.
        </P>
	<P>
        The equivalent of BACKSLASH is "/" in Scilab.
        </P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='MATEIG' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	The MATEIG calculate the eigenvalues and the eigenvectors
        of a square input matrix U.
        </P>
	<P>
        When the "Decomposition type" is set to 1, the block outputs
        the eigenvalues in a vector form, if the input is a M-by-M
        matrix the output is a M-by-1 vector.
        </P>
	<P>
        When the "Decomposition type" is set to 2, the block outputs
        two matrices. for an M-by-M input matrix,the first output is
        a M-by-M diagonal matrix composed by the eigenvalues, and the
        second is a M-by-M matrices composed by the eigenvectors; the
        eigenvectors are represented by the columns of the matrix.
        </P>
	<P>
        The equivalent of the MATEIG block in Scilab is "spec(A)"
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='MATEXPM' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  The MATEXPM outputs the matrix exponential of a square
          matrix input by the pade's approximants. The output is
          a square matrix with the same size of the input. The
          equivalent of this block in Scilab is "expm".
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='MATINV' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  The MATINV Block outputs the inverse of a square input matrix
          using the LU factorization. A warning message is printed if
          the input is badly scaled or nearly singular. The equivalent
          function of this block in Scilab is "inv".
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='MATLU' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  The MATLU Block outputs two matrices L and U, with row
          pivoting, from the LU factorization of a square input
          matrix. If A is the input matrix then E*A=L*U where E
          is the permutation matrix.The equivalent function of
          this block in Scilab is "[l,u,e]=lu(A)"
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='MATMAGPHI' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>MATMAGPHI Block has two types of decomposotions.</P>
	<P>
        When the type is set to one, the block converts a complex
        number to the magnitude and the radian angle, in this case
        the input is complex and the outputs are real double. If
        the input is real double, the angle will be zero or PI and
        the magnitude will be equal to the absolute of the input number.
        </P>
	<P>
        When the type is set to two, the block outputs a complex number
        given the magnitude and the radian angle. In this case the inputs
        are real double and the output is complex.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='MATMUL' type='XML'>
<DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  Le bloc MATMUL fait la multiplication matricielle de ses deux entrées. Le
          nombre de lignes de la seconde matrice doit être égal au nombre de colonnes
          de la première. La sortie est une matrice où le nombre de lignes est égal à
          celui de la première matrice d'entrée et où le nombre de colonnes est égal à
          celui de la deuxième matrice d'entrée.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='MATPINV' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	The MATPINV Block outputs the inverse of a non square input
        matrix using the SVD theory.if the SVD decomposition of A is
        equal to:
        </P>
	 <P>A=USV'</P>
	<P>
        The pseudoinverse x of A is given by:
        </P>
	 <P>X=VS"U' where S"(i,j)=1/S(i,j) (if S(i,j)~=0),
	    U' and V are respectivly the transpose of U and V'.
         </P>
	<P>
        and we have A*X*A=A and X*A*X=X. Both A*X and X*A
        are Hermitian . A warning message is printed if the input
        is badly scaled or nearly singular.
        </P>
	<P>
        When the input is a M-by-N matrix the output is a
        N-by-M matrix. The eqivalent function of this block
        in Scilab is "pinv".
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='MATRESH' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  The RESHAPE block changes the dimensions of a matrix or
          a vector to another dimensions specified by the user in
          the "output size desired" label. The output size must be
          less or equal to the input size.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='MATSING' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
        The MATSING block computes the economy sized SVD of the
        M-by-N input matrix A by finding U,S and V such that
        </P>
	 <P>A=U*S*V'.</P>
	<P>
        When the decomposition type is set to one, the output is
        a vector composed by the singular values.
        </P>
	<P>
        When the decomposition type is set to two, we have three
        outputs: the second output is a diagonal matrix S composed
        by the singular values and the other two outputs are the
        unitary matrices U and V.
        </P>
	<P>
        The equivalent function of this block in Scilab is "svd".
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='MATSUM' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  The MATSUM block returns the sum of the element of an input matrix/vector.
	  When the Sum along is set to all the block outputs the sum of all the
          elements of the matrix. The output is then a scalar.
	  When the Sum along is set to lines the block is a rowwise sum. The output is
          a row vector.
	  When the Sum along is set to Columns the block is a columnwise sum. The
          output is a column vector.
	  The equivalent function of this block in scilab is: "sum".
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='MATTRAN' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  Ce bloc fait la transposition d'une matrice de taille MxN en matrice de
          taille NxM. Pour les données de type complexe, celui-ci utilise une
          transposition Hermitienne. L'instruction scilab équivalente de ce bloc est
          y=u'.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='MATZCONJ' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  This blocks computes the conjugate of a complex input matrix.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='MATZREIM' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  This block decomposes a complex number by seperating the real
          and imaginary parts or compose a comples number by joining the
          two parts. The user can select even to seperate or to join real
          and imaginary part by setting the decomposition type to 1 or 2.
          When it is set to 1, the input is a complex matrix and the
          outputs are the real and imaginary parts of the input. When it
          set to 2, The inputs are two real matrices, the output is a
          complex number with real part the first input and imaginary
          part the second input.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='MAXMIN' type='LATEX'>
Ce bloc peut trouver aussi bien le maximum que le minimum dans les
éléments de ses entrées.
La fonction min ou max peut être choisie dans les paramètres de la
boîte de dialogue.
</FILE>

<FILE name='MAX_f' type='LATEX'>
Ce bloc trouve la valeur maximale dans les éléments
de son vecteur d'entrée.
</FILE>

<FILE name='MBLOCK' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
    <DESCRIPTION_ITEM>
    <P>
    The block "MBlock" provides an easy way to build a Scicos block
    whose behavior is specified by a Modelica program.  Using this
    block, the user will be able to write and compile Modelica
    programs in Scicos without creating any interfacing function.  The
    associated Modelica program of this block can be either given in a
    file or written in the window opened by the block. In order to
    link this block to other Scicos blocks that may be other Modelica
    blocks, the types of block ports' as well as their associated variables
    should be specified.
    </P>
    </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='MCLOCK_f' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='MEMORY_f' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='MFCLCK_f' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='MIN_f' type='LATEX'>
Ce bloc trouve la valeur minimale dans les éléments
de son vecteur d'entrée.
</FILE>

<FILE name='MOTOR' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='MPBLOCK' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
    <DESCRIPTION_ITEM>
    <P>
    Ajoutez ici un paragraphe pour la description de la fonction
    </P>
    </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='MUX' type='LATEX'>
Ce bloc regroupe $n$ vecteurs d'entrée en un seul vecteur à la sortie.
La sortie est $y=[u_1;u_2;\cdots;u_n]$ , où les $u_i$ numérotées dans
un ordre croissant correspondent aux ports réguliers d'entrée du haut
vers le bas.
Les tailles d'entrée/sortie sont soit déterminées automatiquement
à la compilation ou alors déterminées par le paramètre
{\bf number of input ports or vector of sizes}.
</FILE>

<FILE name='MUX_f' type='LATEX'>
Ce bloc regroupe $n$ vecteurs d'entrée en un seul vecteur à la sortie.
La sortie est $y=[u_1;u_2;\cdots;u_n]$ , où les $u_i$ numérotées dans
un ordre croissant correspondent aux ports réguliers d'entrée du haut
vers le bas.
Les tailles d'entrée/sortie sont soit déterminées automatiquement
à la compilation ou alors déterminées par le paramètre
{\bf number of input ports or vector of sizes}.
</FILE>

<FILE name='M_SWITCH' type='LATEX'>
The Multi-Port Switch block chooses between a number of inputs. The
first (top) input is called the control input, while the rest of the
inputs are called data inputs. The value of the control input
determines which data input is passed through to the output port.
</FILE>

<FILE name='M_freq' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	This blocks generates events at specific sample time of the
        simulation time. The sample time is given in the "Sample Time"
        field and the offset is given in the "Offset" field. This
        block has one event input, the number of event outputs depends
        on the number of different sample time. For exemple if the vector
        of sample time is [1 1 2] and the vector of offset is [0 .5 0]
        then the block has 7 outputs.
        </P>
	<P> - The first output is activated when the simulation time
              is equal to a multiple of the first sample time plus
              the first offset
        </P>
	<P> - The second output is activated when the simulation time
              is equal to a multiple of the second sample time plus
              the second offset.
        </P>
	<P> - The third output is activated when we have both cases,
              first case and second case.
        </P>
	<P> - The fourth output is activated when the simulation time
              is equal to a multiple of the third sample time plus
              the third offset.
        </P>
	<P> - The fifth output is activated when we have both cases,
              first case and forth case.
        </P>
	<P> - The sixth output is activated when we have both cases,
              second case and fourth case.
        </P>
	<P> - The seventh output is activated when we have both cases,
              third case and forth case.
        </P>
	<P> etc...</P>
	<P>
        So the number of outputs is equal to 2**number of differents
        time values. Each of these time values is represented by a
        binary number associated to the output's number in decimal.
        </P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='Matrix_pal' type='LATEX'>
Cette palette contient tous les blocs dont vous avez
besoin pour réaliser des opérations matricielles 
simples et complexes.
</FILE>

<FILE name='Menu_entries' type='XML'>
<DESCRIPTION>

</DESCRIPTION>
</FILE>

<FILE name='ModelicaBlocks' type='LATEX'>
\subsection{Modelica Blocks in Scicos}
First method: Using a \htmladdnormallink{Modelica generic block}{MBLOCK.htm}
(available in the \htmladdnormallink{Others}{Others_pal.htm} palette).
Using this block, you do not need writing the  interfacing 
function for the block, just define the input/output variable names and 
variable types and then write the Modelica program.

Second method: Beside your Modelica program, you need to define an
interfacing function for your block. In the interfacing function, the
name of the joint Modelica model, input/output variable names,
input/output types (explicit or implicit), as well as the dialog box
for modifying the the block parameters in Scicos can be defined.
Several examples of Modelica blocks are available in
\htmladdnormallink{Electrical}{Electrical_pal.htm} and
\htmladdnormallink{Thermo-Hydraulics}{ThermoHydraulics_pal.htm} palettes.

Remind that, once the interfacng function built, it should be loaded in Scilab, by
executing this command in Scilab:

{\tt getf("myblock.sci");}

You can load your block using "add new block" item in the
"Edit" menu of Scicos.

\subsection{Modelica Libraries in Scicos}
The Modelica model corresponding to the Scicos block is defined inside a 
Modelica package. The directory where Modelica packages are located 
should be declared with the {\bf "modelica\_libs"} variable. e.g., if
you have defined your Modelica fiels in the MyModelicalibs, you should
execute this command in Scilab to inform the Modelica compiler about
the location of Modelica libraries:

{\tt modelica\_libs=[modelica\_libs,'MyModelicalibs']}

The Modelica compiler looks for all Modelica files in the directories 
given by {\bf "modelica\_libs"} and use them for compile the main Modelica 
model generated by Scicos.

\subsection{External Functions}
You can define and use external functions in your Modelica
model. External functions can be written in C or Fortran languages.
In order to use an external function in a Modeli model, the Modelica function prototype defining
inputs and output of the external function, the header file (*.h) of
the external function, and a *.DLL (Windows) or *.SO (Unix) library
are required.

\subsubsection{Example of a Modelica function prototype:}
\begin{verbatim}
function Optimal
   input Real x;
   input Real y;
   output Real Optimal_out;
external;
end Optimal;
\end{verbatim}

\subsubsection{Example of a header file (Optimal.h):}
\begin{verbatim}
#include "Maths.h"
double Optimal(double x,double y);
\end{verbatim}

The modelica compiler looks for required external libraries in the
directories gievn by {\bf "modelica\_libs"}. The user can place the
Modelica model, the header file, and the libraries in a directory e.g.,
Mylibs and then in Scilab execute the command:

{\tt modelica\_libs=[modelica\_libs,'Mylibs']}
</FILE>

<FILE name='Modelica_pal' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
    <DESCRIPTION_ITEM>
    <P>
    Ajoutez ici un paragraphe pour la description de la fonction
    </P>
    </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='Modulo_Count' type='LATEX'>
Ce bloc est un bloc discret.
Il délivre un signal scalaire périodique qui a une forme déterminée
par les choix de l'utilisateur.
</FILE>

<FILE name='Multiwindow' type='LATEX'>
\subsection{Introduction}
A serious limitation of the Scicos editor has been its inability to
handle more than one diagram at a time. This limitation has been
lifted; it is now possible to open and edit multiple diagrams as
long as they are sub-diagrams of the same Scicos model. In most cases,
the multi-window editing is needed in this situation. The extension
that would allow the simultaneous editing of multiple Scicos models is
forthcoming.  

There are a number of new functionalities available in the new editor
for taking advantage of its muti-windows capabilites. This document
gives a brief description of these functionalities.

\subsection{Active diagram}
In the new editor multiple diagrams can be simultaneously
open. Standard object editing capabilities are available in all of the
diagrams as usual (but not palettes which are read only). But editing
across diagrams is also allowed. For example a block can be ``copied''
in one diagram and ``pasted'' to another one. 

Any action on a diagram window, such as clicking or selecting a menu,
activates the diagram. In most cases the user does not care which
diagram is active because most operations activate the diagram in
which the action has taken place immediately in a completely
transparent manner. 

When a diagram is activated, all the necessary steps are taken by
Scicos to make sure that the environment of the diagram is up to
date. In particular, the symbolic parameters defined in the context of
the diagram and all other diagrams above it are available. This
implies that the user can start editing the diagram without any risk
of inconsistency with the rest of the model.

In most cases, inactive diagrams are also up to date. There is however
an exception. If the number of input/output ports of a Super Block is
modified, the parent diagram is affected. If the parent diagram is
open, it should be updated. This modification however is not
materialized until either the first diagram is closed or the parent
diagram is activated. Once again there is no risk in creating any
inconsistency because the parent diagram, which may not be up to date
at a given time, cannot be edited without being activated.


\subsection{Scicos Browser}
It is very easy to lose track of the topology of a model when many
diagrams are open at the same time. To obtain a hierachical view of
the structure of the model, a Browser functionality has been made
available. The Browser gives a global view of the full model as a tree
like structure. It also indicates the node corresponding to the active
diagram (diagram in which the Browser operation has been launched). 

The Browser is more than just a viewing facility. By double clicking
on a node in the Browser, the corresponding diagram is activated
(opened first if not already open). The main diagram, which
is the root of the tree like structure in the Browser, is not a
node. To activate the main diagram use the
``Diagram/Up\_to\_Main\_diagram'' menu. 

Note that the Browser display is not updated dynamically as the diagram is
edited. So if a Super Block is removed or a new one is created, the
tree structure would no longer be correct. In that case the Browser must
be launched again.

\subsection{Limited Undo operations}
Scicos has always had a single step undo facility. This has not
been really improved in the new editor, however, now each diagram has
its own single step undo facility. In most cases the undo operations
are independent from one window to another, but there is an
exception. If a low-level diagram of a diagram is edited, the undo
operation in this latter diagram can undo all the editing done in the
low-level diagram since it has been opened. To avoid loss of work by an
inadvertent undo operation, a warning message is displayed in such situations.

\subsection{Scilab window activation}
One of the most important features of the new editor is that it allows the user
to activate the Scilab shell without really leaving Scicos. Such a
functionality did exist previously through the Calc command. But Calc activated
the Scilab shell under the pause environment. Even though user could have used this
environment to perform calculations, the result was lost upon leaving the shell
back to Scicos. This was particularly annoying for loaded functions which were
not usable in Scicos.

The Activate Scilab Window operation in Tools menu activates the Scilab prompt
at normal level. This operation is particularly useful for From/To workspace
blocks. For most usages, except perhaps very advanced debugging, this operation
replaces the Calc operation.


</FILE>

<FILE name='NEGTOPOS_f' type='LATEX'>
Un événement est généré lorsque l'unique entrée de ce bloc traverse
la valeur zéro lors d'un front montant.
</FILE>

<FILE name='NMOS' type='LATEX'>

The NMos model is a simple model of a n-channel metal-oxide
semiconductor FET. It differs slightly from the device used in the
SPICE simulator. For more details please care for H. Spiro.

The model does not consider capacitances. A small fixed drain-source
resistance is included (to avoid numerical difficulties).

\begin{tabular}{|p{2cm}|p{2cm}|p{2cm}|p{2cm}|p{2cm}|p{2cm}|p{2cm}|p{2cm}|p{3.5cm}|}
\hline
W [m] & L [m] &  Beta [1/V²]& Vt [V] &  K2 & K5 & DW [m]& DL[m] & \\
\hline
12.e-6&  4.e-6&  .062    &   -4.5   &   .24 &     .61  &   -1.2e-6 &    -.9e-6 & depletion\\
60.e-6&  3.e-6&  .048    &     .1   &  .08  &    .68   &  -1.2e-6  &   -.9e-6  & enhancement\\
12.e-6&  4.e-6&  .0625   &    -.8   &   .21 &     .78  &   -1.2e-6 &    -.9e-6 & zero\\
50.e-6&  8.e-6&  .0299   &     .24  &  1.144&     .7311&   -5.4e-6 &   -4.e-6  &     \\
20.e-6&  6.e-6&  .041    &     .8   &  1.144&     .7311&   -2.5e-6 &   -1.5e-6 &     \\
30.e-6&  9.e-6&  .025    &   -4.    &   .861&     .878 &   -3.4e-6 &   -1.74e-6&     \\
30.e-6&  5.e-6&  .031    &     .6   &  1.5  &     .72  &    0      &   -3.9e-6 &     \\
50.e-6&  6.e-6&  .0414   &   -3.8   &   .34 &     .8  &    -1.6e-6 &   -2.e-6  & depletion\\
50.e-6&  5.e-6&  .03     &     .37  &   .23 &     .86 &    -1.6e-6 &   -2.e-6  & enhancement\\
50.e-6&  6.e-6&  .038    &    -.9   &   .23 &     .707&    -1.6e-6 &   -2.e-6  & zero\\
20.e-6&  4.e-6&  .06776\;&     .5409&   .065&     .71 &     -.8e-6 &    -.2e-6 &     \\
20.e-6&  4.e-6&  .06505  &     .6209&   .065&     .71 &     -.8e-6 &    -.2e-6 &     \\
20.e-6&  4.e-6&  .05365  &     .6909&   .03 &     .8  &     -.3e-6 &    -.2e-6 &     \\
20.e-6&  4.e-6&  .05365  &     .4909&   .03 &     .8  &     -.3e-6 &    -.2e-6 &     \\
12.e-6&  4.e-6&  .023    &   -4.5   &   .29 &     .6  &     0      &    0      & depletion\\
60.e-6&  3.e-6&  .022    &     .1   &   .11 &     .65 &     0      &    0      & enhancement\\
12.e-6&  4.e-6&  .038    &    -.8   &   .33 &     .6  &     0      &    0     &  zero\\
20.e-6&  6.e-6&  .022    &     .8   &  1    &     .66 &     0      &    0     &      \\
\hline
\end{tabular}

</FILE>

<FILE name='NPN' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ce bloc est un modèle simple pour le transistor bipolaire NPN basé sur
le modèle  Ebers-Moll.
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='NRMSOM_f' type='LATEX'>
The Merge block combines its inputs into a single output line whose
value at any time is equal to the most recently computed output of its
driving blocks. You can specify any number of inputs by setting the
block's Number of inputs parameter.  
</FILE>

<FILE name='Non_linear_pal' type='LATEX'>
Cette palette contient des fonctions non-linéaires.
</FILE>

<FILE name='OUTIMPL_f' type='LATEX'>
Les ports de sortie OUTIMPL\_f sont des liens qui permettent de connecter
l'extérieur d'un système vers l'intérieur.
</FILE>

<FILE name='OUT_f' type='LATEX'>
Ce bloc doit être utilisé dans un superbloc pour représenter un port
de sortie régulier. La taille de ce port est ajustée automatiquement.
Dans un superbloc, les ports de sortie réguliers doivent être numérotés
de 1 jusqu'au nombre de ports de sortie réguliers composant le superbloc.
</FILE>

<FILE name='OldBlocks_pal' type='LATEX'>
Cette palette contient des anciens blocs Scicos.
Elle est fournie pour pouvoir assurer la compatibilité
avec des anciens diagrammes contenant ces anciens blocs.
</FILE>

<FILE name='OpAmp' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
    <DESCRIPTION_ITEM>
    <P>
The ideal OpAmp is a two-port. The left port is fixed to v1=0 and i1=0
(nullator). At the right port both any voltage v2 and any current i2
are possible (norator).
    </P>
    </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='Others_pal' type='XML'>
<DESCRIPTION>

</DESCRIPTION>
</FILE>

<FILE name='PAL_f' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
    <DESCRIPTION_ITEM>
    <P>
    Ce bloc correspond à une palette, c'est à dire que c'est un conteneur de blocs et de
    palettes. Ce bloc n'a aucun impact sur la simulation et ne possède aucune entrée/sortie.
    </P>
    </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='PDE' type='LATEX'>
This block is an implementation of several numerical schemes (Finite Elements (1st and 2nd order),
Finite Differences (1st and 2nd order), Finite Volumes (1st order)) to solve mono dimensional 
PDE (Partial Differential Equation) within SCICOS.
The mathematical framwork was restricts in PDEs linear scalars with maximum order 2 in time and space.
The goal is to provide engineers and physicists with an easy to use toolbox in SCICOS that will let them
graphically describe the PDE to be solved. A decision system selects the most efficient numerical scheme
depending on the type of the PDE and runs the solvers.
</FILE>

<FILE name='PENDULUM_ANIM' type='XML'>
  <DESCRIPTION>

  </DESCRIPTION>
</FILE>

<FILE name='PID' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
    <DESCRIPTION_ITEM>
    <P>
    Ce bloc implémente un régulateur PID. Un régulateur Proportionnel Intégral
Dérivé (PID) est un organe de contrôle permettant d'effectuer une régulation en
boucle fermée d'un système industriel. C'est le régulateur le plus utilisé dans l'industrie et permet de contrôler la grande majorité des
procédés.
    </P>
    </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='PMOS' type='LATEX'>

The PMOS model is a simple model of a p-channel metal-oxide
semiconductor FET. It differs slightly from the device used in the
SPICE simulator. For more details please care for H. Spiro.

The model does not consider capacitances. A small fixed drain-source
resistance is included (to avoid numerical difficulties).

Some typical parameter sets are:

\begin{tabular}{ |c|c|c|c|c|c|c|c|}
\hline
W [m]&L[m]&Beta [1/V²]& Vt [V]& K2 & K5&  DW [m]& DL [m] \\
\hline
50.e-6 &8.e-6 &.0085    &-.15 &   .41  &   .839  & -3.8e-6  & -4.0e-6  \\
20.e-6 &6.e-6 &.0105    &-1.0 &    .41 &    .839 &  -2.5e-6 &  -2.1e-6 \\
30.e-6 &5.e-6 &.0059    &-.3  &   .98  &  1.01   &  0       & -3.9e-6  \\
30.e-6 &5.e-6 &.0152\;  &-.69 &   .104 &  1.1    &  -.8e-6  &  -.4e-6  \\
30.e-6 &5.e-6 &.0163    &-.69 &   .104 &  1.1    &  -.8e-6  &  -.4e-6  \\
30.e-6 &5.e-6 &.0182    &-.69 &   .086 &  1.06   &  -.1e-6  &  -.6e-6  \\
20.e-6 &6.e-6 &.0074    &-1.  &    .4  &    .59  &   0      &   0 \\
\hline
\end{tabular}

</FILE>

<FILE name='PNP' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ce bloc est un modèle simple pour le transistor bipolaire PNP basé sur
le modèle  Ebers-Moll.
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='POSTONEG_f' type='LATEX'>
Un événement est généré lorsque l'unique entrée de ce bloc traverse
la valeur zéro lors d'un front descendant.
</FILE>

<FILE name='POWBLK_f' type='LATEX'>
Ce bloc réalise $y(i)=u(i)^a$.
Les tailles des ports d'entrée/sortie sont déterminées par le
compilateur.
</FILE>

<FILE name='PRODUCT' type='LATEX'>
Le bloc 'PRODUCT' réalise la multiplication ou la division de ses
entrées. Suivant la valeur du paramètre, ce bloc calcule la sortie
en utilisant le produit scalaire ou le produit matriciel.
</FILE>

<FILE name='PROD_f' type='LATEX'>
La sortie de ce bloc est le produit élément par élément des entrées.
</FILE>

<FILE name='PULSE_SC' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
    <DESCRIPTION_ITEM>
    <P>
    This block is a Pulse Generator. It generates a pulse at a rate of 1/P where P is the period of the signal (third parameter of the block). The Phase delay gives the value (in time) of the first event. The Phase delay known also as Offset must be less than the Frequency*(1-(Pulse_Width/100)). The second parameter of the block gives the Pulse width.The amplitude of the pulse is given by the fourth parameter.
    </P>
    </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='PerteDP' type='LATEX'>
Un bloc de PertDP représente un tuyau hydraulique avec des pertes de
charge. Ce composant représente une perte de charge hydraulique où la
perte de pression est directement proportionnelle au débit, état
laminaire.  Ce bloc a une direction; c.-à-d. la direction positive est
quand le fluide entre par le port d'entrée (le noir). Ceci signifie
que ce bloc suppose que le débit est positif si le fluide découle du
port noir vers le port blanc.  Les paramètres importants de ce composant
sont la longueur, le diamètre du tuyau, les altitudes des ports
d'entrée et de sortie, et quelques autres coefficients
thermo-hydrauliques.
</FILE>

<FILE name='PotentialSensor' type='LATEX'>
Ce bloc est employé pour mesurer la tension d'un noeud par rapport à
celle de terre (zero) dans un circuit électrique. La tension est
donnée à la partie explicite du modèle par un port explicite.
</FILE>

<FILE name='PuitsP' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  Ce composant représente un puit thermo-hydraulique de
	  pression constante. Ce bloc est défini avec sa pression
          et sa température. La direction positive est quand le
          fluide coule dans le bloc.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='QUANT_f' type='LATEX'>
Ce bloc quantifie le signal d'entrée suivant les méthodes choisies :
\begin{enumerate}
\item méthode 'Round' :
\begin{eqnarray}
 y(i)&={\rm Step}*({\rm int}(u(i)/{\rm Step}+0.5)-0.5) &\texttt{si} \; u(i)<0 .\\
 y(i)&={\rm Step}*({\rm int}(u(i)/{\rm Step}-0.5)+0.5) &\texttt{si} \; u(i)>=0 .
\end{eqnarray}
\item méthode 'Truncation' :
\begin{eqnarray}
 y(i)&={\rm Step}*({\rm int}(u(i)/{\rm Step}+0.5)) &\texttt{si} \; u(i)<0 .  \\
 y(i)&={\rm Step}*({\rm int}(u(i)/{\rm Step}-0.5)) &\texttt{si} \; u(i)>=0 .
\end{eqnarray}
\item méthode 'Floor' :
\begin{eqnarray}
 y(i)&={\rm Step}*({\rm int}(u(i)/{\rm Step}+0.5))  .
\end{eqnarray}
\item  méthode 'Ceil' :
\begin{eqnarray}
 y(i)&={\rm Step}*({\rm int}(u(i)/{\rm Step}-0.5))
\end{eqnarray}
\end{enumerate}
</FILE>

<FILE name='RAMP' type='LATEX'>
Le bloc RAMP génére un signal qui commence à une date et à une valeur
spécifiées et évolue suivant une pente donnée.
Les paramètres {\bf Slope , Start time} et {\bf Initial output} déterminent
les caractéristiques du signal de sortie.
Ces paramètres doivent avoir des dimensions identiques.
</FILE>

<FILE name='RAND_f' type='LATEX'>
Ce bloc est un générateur de nombres aléatoires : chaque composante de sortie
prend des valeurs constantes aléatoires par morceaux. Pour chaque événement les
sorties prennent des nouvelles valeurs indépendantes.\\
La taille du port de sortie est déterminée par la taille des vecteurs {\bf A} et {\bf B}.
</FILE>

<FILE name='RAND_m' type='LATEX'>
Ce bloc est un générateur de nombres aléatoires : chaque composante de sortie
prend des valeurs constantes aléatoires par morceaux. Pour chaque événement les
sorties prennent des nouvelles valeurs indépendantes.\\
La taille du port de sortie est déterminée par la taille des matrices {\bf A} et {\bf B}.
</FILE>

<FILE name='RATELIMITER' type='LATEX'>
Le bloc 'Rate Limiter' limite la première dérivée (la pente) du
signal entrant. La sortie ne peut donc pas changer plus vite que
la limite spécifiée.
</FILE>

<FILE name='READAU_f' type='LATEX'>
Charge un son enregistré dans un fichier 'au'.
Les données échantillonnées seront écrites sur la sortie y du bloc.
Si l'extension du fichier n'est pas spécifiée alors l'extension '.au' est
automatiquement ajoutée.
Les valeurs d'amplitude sont comprises entre [-1,+1].
La lecture 'au' supporte les données multi-canaux sous les formats suivants :
\begin{itemize}
   \item 8-bit mu-law 
   \item 8-, 16-, and 32-bit linear
   \item Floating-point
\end{itemize}
</FILE>

<FILE name='READC_f' type='LATEX'>
Ce bloc permet de lire des données dans un fichier C.
Les paramètres {\bf Output record selection} et {\bf Time record Selection}
permettent de sélectionner des données dans les enregistrements du fichier.
Chaque appel au bloc, fait avancer d'un enregistrement dans le fichier.
</FILE>

<FILE name='REGISTER' type='LATEX'>
Ce bloc réalise un registre à décalage.
Pour chaque événement d'entrée, le registre est décalé d'un élément.
</FILE>

<FILE name='REGISTER_f' type='LATEX'>
Ce bloc réalise un registre à décalage.
Pour chaque événement d'entrée, le registre est décalé d'un élément.
</FILE>

<FILE name='RELATIONALOP' type='LATEX'>
Ce bloc réalise la comparaison logique de ses deux entrées.
</FILE>

<FILE name='RELAY_f' type='LATEX'>
Ce bloc redirige une de ses entrées régulières sur son unique port régulier
de sortie. L'entrée qui est redirigée est initiallement choisie par le paramètre
"initial connected input". Lors de la simulation, lorsque qu'un évènement arrive
sur le port évènementiel numéro i, alors l'entrée régulière i est redirigée sur
la sortie.
</FILE>

<FILE name='RFILE' type='LATEX'>
Ce bloc permet à l'utilisateur de lire des données dans un fichier.
Ces données peuvent être formatées ou binaires.
Les paramètres {\bf  Output record selection} et {\bf Time record selection}
permettent de selectionner des données parmi les enregistrements du fichier.
Chaque appel au bloc avance d'un enregistrement.\\
Ce bloc fonctionne de paire avec le bloc \htmladdnormallink{WFILE}{WFILE.htm}.
</FILE>

<FILE name='RFILE_f' type='LATEX'>
Ce bloc permet à l'utilisateur de lire des données dans un fichier.
Ces données peuvent être formatées ou binaires.
Les paramètres {\bf  Output record selection} et {\bf Time record selection}
permettent de selectionner des données parmi les enregistrements du fichier.
Chaque appel au bloc avance d'un enregistrement.\\
Ce bloc fonctionne de paire avec le bloc \htmladdnormallink{WFILE\_f}{WFILE_f.htm}
</FILE>

<FILE name='RICC' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	This block computes the solution of riccati equation using
        different method and for both case continuous and discrete.
        </P>
	<P> The riccati equation in continuous time is:</P>
	<P>     A*X+X*A+C-X*D*X=0 </P>
	<P> The riccati equation in discrete time is:</P>
	<P>     A*X*(inv(In-D))*A-X+C=0</P>
	<P>
         where A is an NxN matrix, it is the first input of the block,
         C and D are two NxN symetrics matrices and are respectivly the
         second and third input of the RICC block. X represent the
         output of the block, it is also a NxN matrix.
        </P>
	<P>
         The user can choose between two methods of computation. For the
         continuous time he can use even the Schur method or the matrix
         sign function approach method, by setting the Model parameter
         to 1 or 2. For the discrete time, the models are the Schur
         method and the inverse free spectral decomposition method.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='ROOTCOEF' type='LATEX'>
Ce bloc calcule les coefficients d'un polynôme grâce aux valeurs
des racines.
</FILE>

<FILE name='Resistor' type='LATEX'>
Une résistance est un composant électrique à deux ports qui résiste à
un courant électrique en produisant une chute de tension ($V$) : la loi
d'Ohm.

 \[ R = \frac {V}{I}\] 

  La résistance électrique ($R$) est égale à la chute de tension entre
les ports de la résistance divisée par le courant qui passe au travers
($I$).
</FILE>

<FILE name='SAMPHOLD' type='LATEX'>
A chaque fois qu'un événement est reçu, ce bloc copie la valeur de son
entrée sur sa sortie et maintient cette valeur jusqu'au prochain
événement.
Pour réaliser un échantillonneur bloqueur périodique, l'entrée
événementielle doit être connectée à une horloge {\bf Clock}.
</FILE>

<FILE name='SAMPHOLD_m' type='LATEX'>
A chaque fois qu'un événement est reçu, ce bloc copie la valeur de son
entrée sur sa sortie et maintient cette valeur jusqu'au prochain
événement.
Pour réaliser un échantillonneur bloqueur périodique, l'entrée
événementielle doit être connectée à une horloge {\bf Clock}.
</FILE>

<FILE name='SAMPLEHOLD_f' type='LATEX'>
A chaque fois qu'un événement est reçu, ce bloc copie la valeur de son
entrée sur sa sortie et maintient cette valeur jusqu'au prochain
événement.
Pour réaliser un échantillonneur bloqueur périodique, l'entrée
événementielle doit être connectée à une horloge {\bf Clock}.
</FILE>

<FILE name='SATURATION' type='LATEX'>
Le bloc saturation impose des limites maximale et minimale sur un signal.
Lorsque le signal est compris dans l'échelle définie par les paramètres
{\bf Upper limit} et {\bf Lower limit}, celui ci est reporté à la sortie
sans modifications.
Lorsque le signal sort de ces limites, alors le signal sature à la sortie
du bloc.
</FILE>

<FILE name='SAT_f' type='LATEX'>
Le bloc saturation impose des limites maximale et minimale sur un signal.
Lorsque le signal est compris dans l'échelle définie par les paramètres
{\bf Upper limit} et {\bf Lower limit}, celui ci est reporté à la sortie
sans modifications.
Lorsque le signal sort de ces limites, alors le signal sature à la sortie
du bloc.
</FILE>

<FILE name='SAWTOOTH_f' type='LATEX'>
Ce bloc est un générateur de dents de scie : 
la sortie de ce bloc est calculée par $(t-t_i)$ de $t_i$ jusqu'à $t_{i+1}$
où $t_i$ et $t_{i+1}$ sont les instants de deux événements d'entrée successifs.
</FILE>

<FILE name='SCALAR2VECTOR' type='LATEX'>
Ce bloc convertit une valeur scalaire en un vecteur.
Lorsque des blocs avec plus d'un port régulier son utilisés (comme Somme
ou le bloc Relational Operator), vous pouvez mixer des entrées scalaires
et vectorielles.
Lorsque vous faites cela, les entrées scalaires sont étendues à des vecteurs
dont les tailles sont égales aux tailles des vecteurs d'entrée.
Si plus d'un port d'entrée est vectoriel, alors ils doivent avoir la même taille.
</FILE>

<FILE name='SELECT_f' type='LATEX'>
Ce bloc redirige l'une de ses entrées régulières sur l'unique
sortie régulière.
Le choix qui est fait pour savoir quel est le port d'entrée redirigé
est initalement fait par le paramètre {\bf initial connected input}.
Pendant la simulation, à chaque fois que ce bloc est activé par son
entrée événementielle $i$, alors la valeur présente sur le
 $i^{\rm \grave{e}me}$ port régulier est recopiée sur la sortie. 
</FILE>

<FILE name='SELECT_m' type='LATEX'>
Un bloc selecteur accepte sur son entrée aussi bien un vecteur qu'une matrice.
Vous pouvez définir le paramètre {\bf Input Type} au type de signal que vous
utilisez dans votre modèle (matrice ou vecteur).
Les paramètres de la boîte de dialogue et l'aspect du bloc changent en accord
avec le type de l'entrée, ainsi que la manière dont il détermine les éléments 
à sélectionner.
%Ce bloc redirige l'une de ses entrées régulières sur l'unique
%sortie régulière.
%Le choix qui est fait pour savoir quel est le port d'entrée redirigé
%est initalement fait par le paramètre {\bf initial connected input}.
%Pendant la simulation, à chaque fois que ce bloc est activé par son
%entrée événementielle $i$, alors la valeur présente sur le
% $i^{\rm \grave{e}me}$ port régulier est recopiée sur la sortie.
</FILE>

<FILE name='SHIFT' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  This block shifts the bits of the input signal. In this
          operation the digits are moved to the right or to the left.
	  The user can choose the rule to shifts the bits. It can be
          normal or cycle by setting the "Shifttype" parameter to "0"
          or "1".
        </P>
	<P>
          When the Shifttype is 0, an arithmetic shift is applied to the
          input signal. In this case, the bits that are shifted out of
          either end are discarded. Zeros are shifted in on the right,
          in the case of left shift; in the case of right shifts, copies
          of the sign bit is shifted in on the left.
        </P>
	<P>
          When the "Shifttype" is 1,a circular shift is applied to the
          input signal. In this case, the bits are rotated as if the left
          and right ends of the register are joined. The value that is
          shifted in on the right during a left-shift is whatever values
          was shifted out on the left, and vice versa.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='SIGNUM' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
    <DESCRIPTION_ITEM>
    <P>
    Ajoutez ici un paragraphe pour la description de la fonction
    </P>
    </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='SINBLK_f' type='LATEX'>
$$y={\rm sin}(u)$$
</FILE>

<FILE name='SLIDER_f' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='SPLIT_f' type='XML'>
<DESCRIPTION>

</DESCRIPTION>
</FILE>

<FILE name='SQRT' type='LATEX'>
Ce bloc calcule les racines carré de cahque élément de la matrice d'entrée.
Il supporte les types de donnée réels et complexes.
</FILE>

<FILE name='SRFLIPFLOP' type='LATEX'>
This block describe the simplest and the most fundamental latch
the SR flip flop. Where S and R are the input and Q and !Q are the
outputs.If S (Set) is pulsed high while R is held low, then the Q
output is forced high, and stays high when S returns low; similarly,
if R (Reset) is pulsed high while S is held low, then the Q output
is forced low, and stays low when R returns low. When both are low,
Q(t) takes the same state as Q(t-1). When they are both high, both Q
and !Q take the low values we are in an unstable state. Practicaly we
have to avoid this case.This block is almostly used with digital
number, the input data type is int8.\\

The truth table of this block is

\begin{tabular}{|c|c||c|c|}
\hline
S&
R&
Q(t)&
!Q(t)\\
\hline
0&
0&
Q(t-1)&
!Q(t-1)\\
\hline
0&
1&
0&
1\\
\hline
1&
0&
1&
0\\
\hline
1&
1&
0&
0\\
\hline --> This case is to avoid
\end{tabular}
</FILE>

<FILE name='STEP' type='XML'>
<DESCRIPTION>

</DESCRIPTION>
</FILE>

<FILE name='STEP_FUNCTION' type='LATEX'>
Le bloc 'Step' réalise un saut entre deux niveaux définis à un temps
spécifié.
Si le temps de simulation est inférieur au paramètre {\bf Step time}, la 
sortie est égale à la valeur du paramètre {\bf Initial value}.
Pour les temps de simulation supérieurs, la sortie est égale à la valeur
du paramètre {\bf Final value}.
</FILE>

<FILE name='SUBMAT' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  This block outputs a sub matrix of the input matrix.
          The output matrix will be defining by using the parameters
          of this block.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='SUMMATION' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P> Ce bloc fait l'addition ou la soustraction de ses entrées. Ce bloc
	peut additioner et soustraire des grandeurs scalaires, vectorielles et
	matricielles. Il peut aussi faire la somme cumulative d'une seule entrée
	vectorielle.</P>
	<P>
        Le nombre d'entrée est donné par le second paramètre de la boite de dialogue.
        Ce paramètre peut être un vecteur de nombre +1 et -1 ou bien
	il peut être une seule valeur positive. Dans le premier cas le vecteur donne le
        nombre d'entrée et le signe indique si c'est une addition ou une soustraction.
        Pour le second choix, ce bloc est un additionneur dont le nombre d'entrée est
        déterminée par la valeur de ce paramètre.
        </P>
	<P>
        Lorsqu'un dépassement intervient, le résulat peut prendre des valeurs
        différentes suivant le troisième paramètre "DO ON OVERFLOW":
       </P>
	<P>1- Un résulat non saturé.</P>
	<P>2- Un résultat saturé.</P>
	<P>3- Un message d'erreur est signalé lorsqu'un dépassement intervient.</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='SUM_f' type='LATEX'>
Le bloc somme réalise l'addition de ses entrées.
Ce bloc peut additionner des scalaires ou des vecteurs d'entrée.
</FILE>

<FILE name='SUPER_f' type='LATEX'>
This block opens up a new Scicos window for editing a new block
diagram. This diagram describes the internal functions of the super
block.  

Super block inputs and outputs (regular or event) are
designated by special (input or output) blocks.  

Regular input blocks
must be numbered from 1 to the number of regular input ports. Regular
input ports of the super block are numbered from the top of the block
shape to the bottom.  Regular output portss must be numbered from 1 to
the number of regular output ports. Regular output ports of the super
block are numbered from the top of the block shape to the bottom.
Event input blocks must be numbered from 1 to the number of event
input ports. Event input ports of the super block are numbered from
the left of the block shape to the right.  Event output ports must be
numbered from 1 to the number of event output ports. Event output
ports of the super block are numbered from the left of the block shape
to the right.
</FILE>

<FILE name='SWITCH2' type='LATEX'>
The Switch block passes through the first (top) input or the third
(bottom) input based on the value of the second (middle) input. The
first and third inputs are called data inputs. The second input is
called the control input. You select the conditions under which the
first input is passed with the Criteria for passing first input
parameter. You can make the block check whether the control input is
greater than or equal to the threshold value, purely greater than the
threshold value, or nonzero. If the control input meets the condition
set in the Criteria for passing first input parameter, then the first
input is passed. Otherwise, the third input is passed. 
</FILE>

<FILE name='SWITCH2_m' type='LATEX'>
The Switch block passes through the first (top) input or the third
(bottom) input based on the value of the second (middle) input. The
first and third inputs are called data inputs. The second input is
called the control input. You select the conditions under which the
first input is passed with the Criteria for passing first input
parameter. You can make the block check whether the control input is
greater than or equal to the threshold value, purely greater than the
threshold value, or nonzero. If the control input meets the condition
set in the Criteria for passing first input parameter, then the first
input is passed. Otherwise, the third input is passed. 
</FILE>

<FILE name='SWITCH_f' type='LATEX'>
Ce bloc est un 'interrupteur' manuel.
Il sélectionne une de ses entrées pour la rédigirer vers sa sortie.
Les entrées non sélectionnées ne sont donc pas propagées.
</FILE>

<FILE name='SampleCLK' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	The difference between the SampleCLK and the CLOCK_c is that
        all the SampleCLK blocks in our diagram are synchronous. The
        synchronism is done due to two differents methods of computation
        in the compilation phase.
        </P>
	<P>
        The first method consists of computing a clock that is faster
        than all the SampleCLK connected to a counter which activate
        the event select block.
        </P>
	<P>The clock is calculated due to the following rule.</P>
	<P>
        If all the blocks have the same offset then the frequency of
        the clock is the gcd of the sample time, and the offset of the
        clock is equal to the offset.
        </P>
	<P>
        If the offsets are differents, then the frequency of the clock
        is the gcd of the sample time and the offset, and the offset of
        the clock is equal to 0.
        </P>
	<P>
        The Counter counts from one to the least commun multiple of the
        sample time (lcm).
        </P>
	<P>
        The number of outputs of the ESELECT_f block is equal to the lcm.
        </P>
	<P>
        The second method uses the Multifrequency block it generates
        events only for specific time. Events in this method are not
        periodicly generated as in the first one.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='Sigbuilder' type='LATEX'>
The Signal Builder block is a superblock containing a
\htmladdnormallink{CURVE\_c}{CURVE_c.htm} block whose output event
port is connected to its input event port. This event feedback gives
the possibility to generate events at discontinuous point of the
signal. The generated events automatically restart the numerical
solver and avoids numerical problems. The generated event is also made
available to the user for possible use. Remind that if higher
interpolation methods are used, the events are generated only at the
beginning and at the end of the signal.
</FILE>

<FILE name='SineVoltage' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ce bloc est un bloc Modelica pour une source de tension sinusoïdale.
La résistance ohmique interne de ce bloc est zéro.
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='Sinks_pal' type='LATEX'>
Dans la palette Sinks, vous pouvez trouver une variété de
blocs utilisés pour afficher (Scope) et écrire les données
dans des fichiers pendant la simulation ainsi que des ports
de sortie utilisés dans les superblocs.\\
Les blocs de cette palette ne possèdent pas de ports réguliers
de sortie.
</FILE>

<FILE name='SourceP' type='LATEX'>
Ce composant représente une source thermohydraulique de pression
constante. Ce bloc est défini avec sa pression et sa température.  La
direction positive conventionnelle est quand le fluide sort du bloc.
</FILE>

<FILE name='Sources_pal' type='LATEX'>
La plupart des blocs de la palette source peuvent être compris comme
des générateurs de données.
Cette palette contient aussi des blocs pour lire des données dans des
fichers, ainsi que des ports d'entrée utilisés dans les superblocs.\\
Les blocs de cette palette ne possèdent pas de ports réguliers d'entrée.
</FILE>

<FILE name='Switch' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
    <DESCRIPTION_ITEM>
    <P>
This is a non-ideal two-pole switch. If the explicit input become
positive, two pins are connected via a resistor of resistance
RON). Otherwise, two pins are connected via ROFF resistance.  Note
that using this block may result in a stiff model, so try to choose
proper error tolerances.

    </P>
    </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='TANBLK_f' type='LATEX'>
$$y={\rm tan}(u)$$
</FILE>

<FILE name='TCLSS' type='LATEX'>
Ce bloc réalise un système d'équations d'etat en temporel continu avec
la possibilités de réaliser des sauts dans l'état.
Le nombre d'entrées de ce bloc est deux.
La première entrée est l'entrée régulière du système linéaire.
La seconde fournie la valeur du nouvel état qui est copié dans l'état du système lorsque le bloc est activé par un événement sur son unique port d'entrée événementiel.
Cela signifique que l'état du système saute à la valeur présente sur le deuxième port d'entrée (de taille égale à l'état du système).
Le système est défini par les matrices $(A,B,C,D)$
et par l'état initial $x_0$.
Les dimensions des matrices et de l'état initial doivent être appropriées.
Les tailles des entrées et des sorties sont ajustées automatiquement.
</FILE>

<FILE name='TCLSS_f' type='LATEX'>
Ce bloc réalise un système d'équations d'etat en temporel continu avec
la possibilités de réaliser des sauts dans l'état.
Le nombre d'entrées de ce bloc est deux.
La première entrée est l'entrée régulière du système linéaire.
La seconde fournie la valeur du nouvel état qui est copié dans l'état du système lorsque le bloc est activé par un événement sur son unique port d'entrée événementiel.
Cela signifique que l'état du système saute à la valeur présente sur le deuxième port d'entrée (de taille égale à l'état du système).
Le système est défini par les matrices $(A,B,C,D)$
et par l'état initial $x_0$.
Les dimensions des matrices et de l'état initial doivent être appropriées.
Les tailles des entrées et des sorties sont ajustées automatiquement.
</FILE>

<FILE name='TEXT_f' type='LATEX'>
Ce bloc spécial est utilisé pour ajouter du texte dans un diagramme scicos.
Il n'affecte pas la simulation.
</FILE>

<FILE name='TIME_DELAY' type='LATEX'>
Ce bloc retarde l'entrée par un laps de temps spécifié.
Il peut être utilisé pour la simulation d'un retad temporel.
Au début de la simulation, le bloc délivre la valeur du paramètre
{\bf Initial input} jusqu'à ce que le temps de la simulation dépasse
le paramètre {\bf Time delay}, auquel cas, le bloc commence à réaliser
le retard.\\
La valeur du paramètre {\bf Time delay} doit être non-négative.
</FILE>

<FILE name='TIME_f' type='LATEX'>
Ce bloc est un générateur de temps.\\
La seule sortie régulière de ce bloc donne le temps courant de la
simulation.
</FILE>

<FILE name='TKSCALE' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
    <DESCRIPTION_ITEM>
    <P>
    Ce bloc génère une sortie constante par morceaux dont la valeur est
définie interactivement par un widget TK au cours de la simulation. La
valeur de sortie est égale à la valeure entière affichée sur le
widget divisée par le paramètre de normalisation. On peut augmenter la
précisition de la sortie en augmentant proportionnellement tous les
parmètres du bloc.
    </P>
    </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='TOWS_c' type='LATEX'>
Ce bloc est utilisé pour transférer des données simulées dans
l'environnement Scilab.\\
A chaque instants d'échantillonnage, aussi bien les dates que les valeurs
de l'entrée sont enregistrées.
</FILE>

<FILE name='TRASH_f' type='XML'>
<DESCRIPTION>
 <DESCRIPTION_INDENT>
  <DESCRIPTION_ITEM>
  <P>
  Ce bloc est un bloc de terminaison.
  Il ne fait rien.
  </P>
  </DESCRIPTION_ITEM>
 </DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='ThermoHydraulics_pal' type='LATEX'>
La boîte à outils de thermohydraulique contient certains composants
thermohydrauliques tels que la source de pression, le tuyau, les vannes
réglantes, etc.
</FILE>

<FILE name='Threshold_pal' type='LATEX'>
Les blocs de cette palette sont utilisés pour détecter des passages à
certaines valeurs des variables d'état pendant la simulation.
Ces blocs utilisent les solveurs (EDO ou EAD) pour réaliser cette
opération.
</FILE>

<FILE name='TrigFun' type='LATEX'>
The Trigonometric Function block performs numerous common
trigonometric functions. You can select one of these functions from
the Function list: sin, cos, tan, asin, acos, atan, atan2, sinh, cosh,
and tanh. The block output is the result of the operation of the
function on the input or inputs. 
</FILE>

<FILE name='VARIABLE_DELAY' type='LATEX'>
The Variable Transport Delay block can be used to simulate a variable
time delay. The block might be used to model a system with a pipe
where the speed of a motor pumping fluid in the pipe is variable. The
block accepts two inputs: the first input is the signal that passes
through the block; the second input is the time delay. 
</FILE>

<FILE name='VVsourceAC' type='LATEX'>
Ce bloc est un modèle pour une source de tension CA contrôlable. Ce
composant fournit une tension sinusoidale entre ses
ports. L'amplitude de la tension de sortie est définie par une entrée
explicite et la fréquence est définie par l'utilisateur. La résistance
ohmique de ce bloc est zéro.
</FILE>

<FILE name='VanneReglante' type='LATEX'>
Le bloc de VanneReglante représente une Vanne Reglante ou une vanne à
orifice variable. Le débit du fluide passe par la vanne et est
proportionnel à l'ouverture de vanne, {\it c.-à-d.},

\[
  \Delta P \times h\times\left| h \right| = k\times Q\times \left|Q\right|
\]

là où $h$ est l'ouverture de vanne, $\delta P$ est la différence de
pression, et $Q$ est le débit. Ce modèle est seulement employé pour
les régimes laminaires d'écoulement. $k$ est une constante qui dépend
de la géométrie de la vanne et de la masse volumique de fluide.
</FILE>

<FILE name='VariableResistor' type='LATEX'>
Ce composant représente une résistance ohmique variable. La résistance
est commandée par le port d'entrée explicite.  \[ R_x = \frac {V}{I}
\]
</FILE>

<FILE name='VirtualCLK0' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
    <DESCRIPTION_ITEM>
    <P>
    This block is considered a virtual block by the compilor. It is used in a SuperBlock (subsystem) to trigger the always active blocks (ex: the sinus generator) in the SuperBlock and in the level below. The blocks will be virtually connected to the input of the VirtualCLK0.
    </P>
    </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='VoltageSensor' type='LATEX'>
Ce composant est employé pour mesurer la différence de tension entre
deux noeuds dans un circuit électrique. Le signal de sortie est la
différence entre la tension du port noir et celle du port blanc.
La conductance ohmique de ce bloc est zéro.
</FILE>

<FILE name='VsourceAC' type='LATEX'>
Ce composant est une source de tension CA avec une tension de sortie
sinusoidale. L'amplitude et la fréquence de la tension de sortie
sont définies par l'utilisateur. La résistance ohmique de ce bloc est
zéro.
</FILE>

<FILE name='WFILE' type='LATEX'>
Ce bloc permet à l'utilisateur de sauvegarder des données dans un fichier.
Ces données peuvent être formatées ou binaires.
Chaque appel au bloc correspond à un enregistrement.
Chaque enregistrement à la forme suivante :  $[t,V1,...,Vn]$ où $t$ est la valeur du temps lorsque le bloc est appelé et $V_i$ est la $i^{\rm\grave{e}me}$ valeur d'entrée.
Ce bloc fonctionne de paire avec le bloc \htmladdnormallink{RFILE}{RFILE.htm}.
</FILE>

<FILE name='WFILE_f' type='LATEX'>
Ce bloc permet à l'utilisateur de sauvegarder des données dans un fichier.
Ces données peuvent être formatées ou binaires.
Chaque appel au bloc correspond à un enregistrement.
Chaque enregistrement à la forme suivante :  $[t,V1,...,Vn]$ où $t$ est la valeur du temps lorsque le bloc est appelé et $V_i$ est la $i^{\rm\grave{e}me}$ valeur d'entrée.\\
Ce bloc fonctionne de paire avec le bloc \htmladdnormallink{RFILE\_f}{RFILE_f.htm}.
</FILE>

<FILE name='WRITEAU_f' type='LATEX'>
Ce bloc écrit un fichier son de type 'au'.
Les données doivent être rangées avec un canal par colonne.
Les valeurs en dehors de l'échelle [-1 +1] seront coupées à l'écriture.
L'écriture 'au' supporte les données multi-canaux pour les formats
'8-bit mu-law' et '8-,16-bit linear'.
</FILE>

<FILE name='WRITEC_f' type='LATEX'>
Ce bloc permet d'écrire des données dans un fichier C au format binaire.
</FILE>

<FILE name='ZCROSS_f' type='LATEX'>
Un événement est généré lorsque toutes les entrées traverse la valeur
zéro simultanément.
</FILE>

<FILE name='block_type' type='LATEX'>
Scicos has the possibility to handle and to call many different sorts of blocks.
Some blocks in Scicos palettes are special and are only used
internally by Scicos, such as synchro blocks and the Debug block, but
most blocks are regular blocks which the user can get inspired by to
construct new blocks.
The following table gives the known Scicos
block types, and is followed by the report of the type of the computational function
with its associated calling sequence by block type.

\begin{table}[!ht]
\begin{tabular}{|p{2cm}||p{11cm}||p{3cm}||p{3cm}|}
\hline
{\bf Type}&
{\bf Description}&
{\bf Function type}&
{\bf Simulator call}\\
\hline
\hline
-2&
Event select block (synchro block).&
-&
Never called.\\
\hline
-1&
If Then Else block (synchro block).&
-&
Never called.\\
\hline
0&
C, Fortran or Scilab block. Calling sequence fixed. Obsolete.&
Type 0.&
Type 0.\\
\hline
1&
C or Fortran block. Varying calling sequence. Obsolete.&
Type 1.&
Type 1.\\
\hline
2&
C block. Calling sequence fixed. Obsolete.&
Type 2.&
Type 2.\\
\hline
3&
Scilab block. Calling sequence fixed. Used but obsolete.&
Type 3.&
Type 2.\\
\hline
4&
C block. Calling sequence fixed. In use.&
Type 4.&
Type 4.\\
\hline
5&
Scilab block. Calling sequence fixed. In use.&
Type 5.&
Type 4.\\
\hline
1001&
Fortran block. Dynamically linked. Obsolete.&
Type 1.&
Type 1.\\
\hline
2001&
C block. Dynamically linked. Obsolete.&
Type 1.&
Type 1.\\
\hline
2004&
C block. Dynamically linked. In use.&
Type 4.&
Type 4.\\
\hline
10001&
Implicit C or Fortran block. Obsolete.&
Type 10001.&
Type 10001.\\
\hline
10002&
Implicit C block. Obsolete.&
Type 10002.&
Type 10002.\\
\hline
10004&
Implicit C block. In use.&
Type 10004.&
Type 4.\\
\hline
10005&
Implicit Scilab block. In use.&
Type 10005.&
Type 4.\\
\hline
30004&
Generic Modelica block. Dynamically linked. In use.&
Type 10004.&
Type 4.\\
\hline
99&
Debug block.&
Type 5.&
Type 4.\\
\hline
\end{tabular}
%\caption{Scicos block type}
\end{table}

\noindent
Note that even if type 0, 1 and 2  are obsolete, they are still supported
in Scicos; some blocks in the standard palettes of Scicos are still of
these types. Block type 3 is still used by scifunc block (Scilab
block) but users should prefer the type 5 when constructing a
computational function in Scilab because it takes full advantage of new data
structures. In fact it has all the the functionalities implemented for
block type 4. 

\begin{itemize}
\item{\textbf{Calling sequence of computational function type 0}}\\
void myfun(flag,nevrt,t,xd,x,nx,z,nz,tvec,ntvec,rpar,nrpar,ipar,nipar,u,nu,y,ny)
\item{\textbf{Calling sequence of computational function type 1}}\\
void myfun(flag,nevrt,t,xd,x,nx,z,nz,tvec,ntvec,rpar,nrpar,ipar,nipar,u1,nu1,u2,nu2,...,y1,ny1,y2,ny2,...)
\item{\textbf{Calling sequence of computational function type 10001 (type 1 implicit)}}\\
void myfun(flag,nevrt,t,res,xd,x,nx,z,nz,tvec,ntvec,rpar,nrpar,ipar,nipar,u1,nu1,u2,nu2,...,y1,ny1,y2,ny2,...)
\item{\textbf{Calling sequence of computational function type 2}}\\
void myfun(flag,nevrt,t,xd,x,nx,z,nz,tvec,ntvec,rpar,nrpar,ipar,nipar,inptr,insz,nin,outptr,outsz,nout)
\item{\textbf{Calling sequence of computational function type 2 (zero crossing)}}\\
void myfun(flag,nevrt,t,xd,x,nx,z,nz,tvec,ntvec,rpar,nrpar,ipar,nipar,inptr,insz,nin,outptr,outsz,nout,g,ng)
\item{\textbf{Calling sequence of computational function type 10002 (type 2 implicit)}}\\
void myfun(flag,nevrt,t,res,xd,x,nx,z,nz,tvec,ntvec,rpar,nrpar,ipar,nipar,inptr,insz,nin,outptr,outsz,nout)
\item{\textbf{Calling sequence of computational function type 10002 (type 2 implicit with zero crossing)}}\\
void myfun(flag,nevrt,t,res,xd,x,nx,z,nz,tvec,ntvec,rpar,nrpar,ipar,nipar,inptr,insz,nin,outptr,outsz,nout,g,ng)
\item{\textbf{Calling sequence of computational function type 3}}\\
\null [x,y,z,tvec,xd]=myfun(flag,nevprt,t,x,z,rpar,ipar,u)
\item{\textbf{Calling sequence of computational function type 4}}\\
void myfun(scicos\_block *block,int flag)
\item{\textbf{Calling sequence of computational function type 5}}\\
\null [block]=myfun(block,flag)
\end{itemize}
</FILE>

<FILE name='buildouttb' type='LATEX'>
Construit une liste "outtb" initialisée.
</FILE>

<FILE name='c_block' type='LATEX'>
Ce bloc crée une fonction de calcul squelette en C.
Il crée aussi une librairie et un fichier objet à la compilation.
</FILE>

<FILE name='callblk' type='LATEX'>
Cette fonction permet d'appeller une fonction de simulation d'un bloc Scicos à partir
d'une structure \htmladdnormallink{block}{sci_struct.htm}. Les champs de cette
structure doivent impérativement être renseignés avec des valeurs cohérentes.\\
Un principe de fonctionnement simplifié de {\bf callblk} peut-être expliqué par l'organigramme suivant:
\begin{figure}[!h]
  \begin{center}
    \scalebox{0.65}{\input{orgcallblk.pstex_t}}
  \end{center}
\end{figure}

A partir de la structure d'entrée {\bf blk\_in}, la fonction alloue et remplit une structure C scicos\_blocks,
le pointeur sur la fonction de calcul est recherchée, et la fonction de calcul
avec la structure scicos\_blocks et le paramètre flag est appellée. Puis une structure de sortie scilab {\bf blk\_out} est recrée à partir des valeurs modifiées de la structure C.\\
{\bf callblk} peut-être utilisée pour réaliser entre autres, des protoypes de simulateurs et de générateurs de code en langage Scilab.
</FILE>

<FILE name='coserror' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
    <DESCRIPTION_ITEM>
    <P>
    Cette fonction permet de définir un message d'erreur spécifique en cours de simulation pour le
    bloc courant. Si cette fonction est utilisée, alors à l'issue de l'éxecution de la fonction
    de calcul du bloc, le simulateur s'arrêtera et retournera le message d'erreur spécifié en argument.
    </P>
    </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='create_gif' type='XML'>
  <DESCRIPTION>
     <DESCRIPTION_INDENT>
     <DESCRIPTION_ITEM>
     <P>
     Crée des icones au format gif de blocs Scicos. La liste des noms des
     blocs peut être donnée via TXT. Le paramètre path contient le chemin
     cible où les fichiers sont crées. La couleur de fond est transparente
     par l'utilisation de la commande "convert" (si disponible). Si la fonction
     est appelée sans arguments alors les icones des blocs des librairies standards de
     Scicos sont créees et placées dans le répertoire
     SCI+'/macros/scicos/scicos_doc/man/gif_icons'.
     </P>
     </DESCRIPTION_ITEM>
     </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='create_palette' type='XML'>
  <DESCRIPTION>
     <DESCRIPTION_INDENT>
     <DESCRIPTION_ITEM>
     <P>
      Cette fonction génére une palette si Path est une chaîne de caractères
      indiquant un répertoire où se trouvent des fonctions d'interfaçages de
      blocs scicos.
      Si Path est absent ou bien si celui est égal à %t, les palettes
      standards de Scicos sont construites.
      Si Path est égal à %f, alors seul le paramètre IntFunc est retourné
      (le paramètre routines est vide dans ce cas).
     </P>
     </DESCRIPTION_ITEM>
     </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='curblock' type='XML'>
  <DESCRIPTION>

  </DESCRIPTION>
</FILE>

<FILE name='data2sig' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
    <DESCRIPTION_ITEM>
    <P>
    Met des données dans une structure signal scicos.
    Si A est un vecteur, alors elle sera comprise comme
    un scalaire qui évolue dans le temps.
    Si A est une matrice, alors elle sera comprise comme
    un scalaire qui évolue dans le temps.
    Si A est une hypermatrice, alors elle sera comprise comme
    une matrice qui évolue dans le temps.
    </P>
    </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='data_type' type='LATEX'>
  \begin{table}[!ht]
  \begin{center}
  \begin{tabular}{|p{5cm}|p{5cm}||p{5cm}|p{5cm}|}
    \hline
    {\bf Type dans l'éditeur}&
    {\bf Numéro dans l'éditeur}&
    {\bf Type C}&
    {\bf Numéro C}\\
    \hline
    \hline
    real&
    1&
    double&
    10\\
    \hline
    complex&
    2&
    double&
    11\\
    \hline
    int32&
    3&
    long&
    84\\
    \hline
    int16&
    4&
    short&
    82\\
    \hline
    int8&
    5&
    char&
    81\\
    \hline
    uint32&
    6&
    unsigned long&
    814\\
    \hline
    uint16&
    7&
    unsigned short&
    812\\
    \hline
    uint8&
    8&
    unsigned char&
    811\\
    \hline
   \end{tabular}
   %\caption{Editor/C data type number correspondence table}\label{tab1}
  \end{center}
  \end{table}
</FILE>

<FILE name='fortran_block' type='LATEX'>
Ce bloc crée une fonction de calcul squelette en fortran.
Il crée aussi une librairie et un fichier objet à la compilation.
</FILE>

<FILE name='freq_div' type='LATEX'>
Ce bloc est un superbloc.
L'entrée événementielle est redirigée une fois parmi n à la sortie.
</FILE>

<FILE name='func_block' type='XML'>
<DESCRIPTION>
<DESCRIPTION_INDENT>
<DESCRIPTION_ITEM>
<P>
Ajoutez ici un paragraphe pour la description de la fonction
</P>
</DESCRIPTION_ITEM>
</DESCRIPTION_INDENT>
</DESCRIPTION>
</FILE>

<FILE name='generic_block' type='LATEX'>

</FILE>

<FILE name='generic_block2' type='LATEX'>
The block provides a generic interfacing function but the
computational function needs to be defined separately, either as a
Scilab function or  a Fortran or a C function. Besides the name of the
function, user should specify information such as the type, whether or
not the block contains a direct feed-through term. The function
realising computational functions of generic blocks of a scicos
diagram must be saved along with the diagram and loaded or dynamically
linked before simulation. 
</FILE>

<FILE name='generic_block3' type='LATEX'>
The block provides a generic interfacing function but the
computational function needs to be defined separately, either as a
Scilab function or  a Fortran or a C function. Besides the name of the
function, user should specify information such as the type, whether or
not the block contains a direct feed-through term. The function
realising computational functions of generic blocks of a scicos
diagram must be saved along with the diagram and loaded or dynamically
linked before simulation. 
</FILE>

<FILE name='get_scicos_version' type='XML'>
  <DESCRIPTION>
     <DESCRIPTION_INDENT>
     <DESCRIPTION_ITEM>
     <P>
     Cette fonction retourne le numéro de version courant de Scicos.
     </P>
     </DESCRIPTION_ITEM>
     </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='getblocklabel' type='XML'>
  <DESCRIPTION>

  </DESCRIPTION>
</FILE>

<FILE name='getscicosvars' type='XML'>
  <DESCRIPTION>
    <P>
    Cette fonction utilitaire est utilisée pour retrouver les tableaux de travail du
    compilateur et du simulateur scicos pendant la simulation.
    </P>
    <P>
      Elle peut-être utilisée dans un bloc scilab pour retourner des informations de
      tous types de blocs. Cette fonction est très utile pour débugger les diagrammes
      et pour prototyper des simulations.
    </P>
  </DESCRIPTION>
</FILE>

<FILE name='lincos' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  Construit un système d'espace d'état linéaire en linéarisant
	  un modèle donné sous la forme d'un diagramme Scicos.
	</P>
      </DESCRIPTION_ITEM>
      <DESCRIPTION_ITEM>
	<P>
	  La sortie de cette fonction est structure de donnée Scilab de type
	  système linéaire d'espace d'état à temps continu (continuous-time state-space
	  linear system).
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='model2blk' type='LATEX'>
    Cette fonction est utilisée par obtenir une structure de simulation
    \htmladdnormallink{scicos block}{sci_struct.htm} à partir d'une structure
    de donnée \htmladdnormallink{scicos\_model}{scicos_model.htm} d'un bloc Scicos.
    Le modèle du bloc doit-être correctement renseigné avant d'appeller model2blk.\\
    Cette fonction peut être utilisée avant l'appel à la fonction de calcul via
    \htmladdnormallink{callblk}{callblk.htm}.
</FILE>

<FILE name='phase_simulation' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  Cette fonction permet de savoir si le simulateur scicos est dans sa phase
          d'intégration temporelle.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='pointer_xproperty' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
    <DESCRIPTION_ITEM>
    <P>
    Cette fonction retourne un vecteur indiquant le type (algébrique ou différentiel)
    des variables d'états continues utilisées dans un bloc.
    </P>
    </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='sci_struct' type='LATEX'>

A Scicos computational function of type 5 can be realized by the use of a Scilab function.
That function doesn't really differs from all other scilab function : one can use all functions and
instructions of the scilab language inside that function to do the computation.

Such a function must be written in a file with extension .sci, must be loaded inside scilab by the
common loading scilab function ({\tt exec}, {\tt getd}, {\tt genlib},...) and must have
two right hand side arguments and one left hand side argument, as the following calling sequence :

{\tt
function block=myblock(block,flag)\\
...\\
//your computational instructions \\
...\\
endfunction\\
}

When the simulator is calling such a computational function, it build a scilab structure (in the previous exemple this is the named {\tt block} rhs/lhs arguments) from his own internal C reprensation of a block structure (see \htmladdnormallink{C\_struct} {C_struct.htm} for more details about the C structure of scicos
blocks).

That scilab structure is a scilab typed list variable that have the following fields :

{\tt
!scicos\_block  nevprt  funpt  type  scsptr  nz  z  noz  ozsz  oztyp  !\\
!oz  nx  x  xd  res  nin  insz  inptr  nout  outsz  outptr  nevout  !\\
!evout  nrpar  rpar  nipar  ipar  nopar  oparsz  opartyp  opar  ng  g  !\\
!ztyp  jroot  label  work  nmode  mode  !
}

Each fields are then accessible inside the scilab computational function by the use of :

{\tt
 block.field
}

\subsection{Inputs/outputs}

\begin{itemize}
 \item {\bf block.nin :} a scalar that gives the number of regular input ports.
                         This is a read only data.

 \item {\bf block.insz :} a vector of size {\tt 3*nin}, that gives the dimensions and types of the regular input ports.
                          \begin{itemize}
                              \item{\bf {\tt block.insz(1:nin)} :} are the first dimensions.
                              \item{\bf {\tt block.insz(nin+1:2*nin)} :} are the second dimensions.
                              \item{\bf {\tt block.insz(2*nin+1:3*nin)} :} are the type of data (C coding).
                          \end{itemize}
                          This is a read only data.

 \item {\bf block.inptr :} a list of size {\tt nin} that enclosed typed matrices for regular input ports.
                           Each element correspond to only one regular input port. Then {i-th} matrix
                           of the block.inptr list will have the dimensions [{\tt block.insz(i)}, {\tt block.insz(nin+i)}] and
                           the type {\tt block.insz(2*nin+i)}.\\
                           The data type that can be provided by regular input ports are :
                           \begin{itemize}
                             \item {\bf 1 :} matrix of real numbers,
                             \item {\bf 2 :} matrix of complex numbers,
                             \item {\bf 3 :} matrix of int32 numbers,
                             \item {\bf 4 :} matrix of int16 numbers,
                             \item {\bf 5 :} matrix of int8 numbers,
                             \item {\bf 6 :} matrix of uint32 numbers,
                             \item {\bf 7 :} matrix of uint16 numbers,
                             \item {\bf 8 :} matrix of uint8 numbers.
                           \end{itemize}
                          This is a read only data.

 \item {\bf block.nout :} a scalar that gives the number of regular output ports.
                          This is a read only data.

 \item {\bf block.outsz :} a vector of size {\tt 3*nout}, that gives the dimensions and types of the regular output ports.
                          \begin{itemize}
                              \item{\bf {\tt block.outsz(1:nout)} :} are the first dimensions.
                              \item{\bf {\tt block.outsz(nout+1:2*nout)} :} are the second dimensions.
                              \item{\bf {\tt block.outsz(2*nout+1:3*nout)} :} are the type of data (C coding).
                          \end{itemize}
                          This is a read only data.

 \item {\bf block.outptr :} a list of size {\tt nout} that enclosed typed matrices for regular output ports.
                            Each element correspond to only one regular output port. Then {i-th} matrix
                            of the block.outptr list will have the dimensions [{\tt block.outsz(i)}, {\tt block.outsz(nin+i)}] and
                            the type {\tt block.outsz(2*nin+i)}.\\
                            The data type that can be provided by regular output ports are :
                            \begin{itemize}
                              \item {\bf 1 :} matrix of real numbers,
                              \item {\bf 2 :} matrix of complex numbers,
                              \item {\bf 3 :} matrix of int32 numbers,
                              \item {\bf 4 :} matrix of int16 numbers,
                              \item {\bf 5 :} matrix of int8 numbers,
                              \item {\bf 6 :} matrix of uint32 numbers,
                              \item {\bf 7 :} matrix of uint16 numbers,
                              \item {\bf 8 :} matrix of uint8 numbers.
                            \end{itemize}
                            Values of regular output ports will be saved in the \htmladdnormallink{C structure}{C_struct.htm} of
                            the block only for {\tt flag}=6 and {\tt flag}=1.
\end{itemize}

\subsection{Events}

\begin{itemize}
 \item {\bf block.nevprt :} a scalar given the event input port number (binary coding)
                            which have activated the block. This is a read only data.

 \item {\bf block.nevout :} a scalar given the number of output event port of the block.
                            This is a read only data.

 \item {\bf block.evout :} a vector of size {\tt nevout} corresponding to the register
                           of output event.
                           Values of  output event register will be saved in the \htmladdnormallink{C structure}{C_struct.htm} of
                           the block only for {\tt flag}=3.
\end{itemize}

\subsection{Parameters}

\begin{itemize}
 \item {\bf block.nrpar :} a scalar given the number of real parameters.
                           This is a read only data.

 \item {\bf block.rpar :} a vector of size {\tt nrpar} corresponding to the real parameter register.
                          This is a read only data.

 \item {\bf block.nipar :} a scalar given the number of integer parameters.
                           This is a read only data.

 \item {\bf block.ipar :} a vector of size {\tt nipar} correspondig to the integer parameter register.
                          This is a read only data.

 \item {\bf block.nopar :} a scalar given the number of object parameters.
                           This is a read only data.

 \item {\bf block.oparsz :} a matrix of size {\tt nopar,2}, that respectively gives the first and the second
                            dimension of object parameters. This is a read only data.

 \item {\bf block.opartyp :} a vector of size {\tt nopar} given the C coding type of data.
                            This is a read only data.

 \item {\bf block.opar :} a list of size {\tt nopar} given the values of object parameters.
                          Each element of {\tt opar} can be either a typed matrix or a list.
                          Only matrix that encloses numbers of type real, complex, int32, int16, int8,
                          uint32, uint16 and uint8 are allowed, all other types of scilab data will
                          be enclosed in a sub-list. This is a read only data.
\end{itemize}

\subsection{States}

\begin{itemize}
 \item {\bf block.nz :} a scalar given the number of discrete state for the block.
                        This is a read only data.

 \item {\bf block.z :} a vector of size {\tt nz} corresponding to the discrete state register.
                       Values of discrete state register will be saved in the \htmladdnormallink{C structure}{C_struct.htm} of
                       the block only for {\tt flag}=4, {\tt flag}=6, {\tt flag}=2 and {\tt flag}=5.

 \item {\bf block.noz :} a scalar that gives the number of discrete object state.
                         This is a read only data.

 \item {\bf block.ozsz :} a matrix of size {\tt noz,2}, that respectively gives the first and the second
                          dimension of discrete object state. This is a read only data.

 \item {\bf block.oztyp :} a vector of size {\tt noz} given the C coding type of data.

 \item {\bf block.oz :} a list of size {\tt noz} given the values of discrete object states.
                          Each element of {\tt oz} can be either a typed matrix or a list.
                          Only matrix that encloses numbers of type real, complex, int32, int16, int8,
                          uint32, uint16 and uint8 are allowed, all other types of scilab data will
                          be enclosed in a sub-list.
                          Values of discrete object state will be saved in the \htmladdnormallink{C structure}{C_struct.htm} of
                          the block only for {\tt flag}=4, {\tt flag}=6, {\tt flag}=2 and {\tt flag}=5.

 \item {\bf block.nx :} a scalar given the number of continuous state for the block.
                        This is a read only data.

 \item {\bf block.x :} a vector of size {\tt nx} given the value of the continuous state register.
                       Values of the continuous state register will be saved in the \htmladdnormallink{C structure}{C_struct.htm} of
                       the block only for {\tt flag}=4, {\tt flag}=6 and {\tt flag}=2.

 \item {\bf block.xd :} a vector of size {\tt nx} given the value of the derivative continuous state register.
                       Values of the derivative continuous state register will be saved in the \htmladdnormallink{C structure}{C_struct.htm} of
                       the block only for {\tt flag}=4, {\tt flag}=6, {\tt flag}=0 and {\tt flag}=2.

 \item {\bf block.res :} a vector of size {\tt nx} corresponding to the Differential Algebraic Equation (DAE) residual.
                       Values of that register will be saved in the \htmladdnormallink{C structure}{C_struct.htm} of
                       the block only for {\tt flag}=0, and {\tt flag}=10.
 %\item {\bf block.work:}
\end{itemize}

\subsection{Zero crossing surfaces and modes}

\begin{itemize}
 \item {\bf block.ng :} a scalar given the number of zero crossing surfaces for the block.
                        This is a read only data.

 \item {\bf block.g :} a vector of size {\tt ng} corresponding to the zero crossing register.
                       Values of that register will be saved in the \htmladdnormallink{C structure}{C_struct.htm} of
                       the block only for {\tt flag}=9.

% \item {\bf block.jroot :}
 \item {\bf block.nmode :} a scalar given the number of mode for the block.
                           This is a read only data.

 \item {\bf block.mode :} a vector of size {\tt mode} that corresponds to the mode register.
                       Values of that register will be saved in the \htmladdnormallink{C structure}{C_struct.htm} of
                       the block only for {\tt flag}=9, with {\tt \htmladdnormallink{phase\_simulation}{phase_simulation.htm}}=1.

\end{itemize}

\subsection{Miscallaneous}

\begin{itemize}
% \item {\bf : funpt}
 \item {\bf block.type :} a scalar given the type of the block.
                          This is a read only data.
% \item {\bf block.ztyp :}
 \item {\bf block.label :} a string given the label of the block.
                          This is a read only data.
 %\item {\bf scsptr :}
\end{itemize}

</FILE>

<FILE name='scicos' type='LATEX'>
Scicos est un éditeur graphique pour construire des modèles
de systèmes dynamiques hybrides.\\
L'appel à Scicos sans argument ouvre une fenêtre vierge de l'éditeur.
Les modèles peuvent alors être assemblés, chargés, sauvegardés,
compilés, simulés en utilisant les différentes interfaces utilisateur
graphiques (GUI) de l'éditeur.
Scicos est en fait une interface pour la compilation et le
simulateur 'scicosim'.
Des arguments en entrée et en sortie de la commande scicos peuvent
aussi être utilisées pour réaliser des opérations de débogage.
</FILE>

<FILE name='scicos_block' type='XML'>
  <DESCRIPTION>

  </DESCRIPTION>
</FILE>

<FILE name='scicos_block4_rout' type='XML'>
  <DESCRIPTION>

  </DESCRIPTION>
</FILE>

<FILE name='scicos_cpr' type='XML'>
  <DESCRIPTION>

  </DESCRIPTION>
</FILE>

<FILE name='scicos_debug' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  Cette fonction sert à paramétrer le niveau de débogage de la simulation
          scicos.
	</P>
	<P>
	  Elle peut être utilisée soit en mode "Calc" dans l'éditeur Scicos ou en tant
          qu'instruction dans un bloc scilab et encore dans une fonction d'interfaçage.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='scicos_diagram' type='XML'>
  <DESCRIPTION>

  </DESCRIPTION>
</FILE>

<FILE name='scicos_graphics' type='XML'>
  <DESCRIPTION>

  </DESCRIPTION>
</FILE>

<FILE name='scicos_link' type='XML'>
  <DESCRIPTION>

  </DESCRIPTION>
</FILE>

<FILE name='scicos_model' type='XML'>
  <DESCRIPTION>

  </DESCRIPTION>
</FILE>

<FILE name='scicos_params' type='XML'>
  <DESCRIPTION>

  </DESCRIPTION>
</FILE>

<FILE name='scicos_sim' type='XML'>
  <DESCRIPTION>

  </DESCRIPTION>
</FILE>

<FILE name='scicos_simulate' type='XML'>
  <DESCRIPTION>
    <P>
      Cette fonction est utilisée pour simuler des diagrammes Scicos
      en mode batch. Elle requiert la structure scs_m qui peut-être
      obtenue en chargeant un diagramme Scicos dans Scilab (par exemple
      -->load mydiagram.cos).
    </P>
    <P>
      Contrairement à la fonction <LINK>scicosim</LINK>, le diagramme
      ne nécessite pas d'être compilé avant d'être sauvegardé.
    </P>
  </DESCRIPTION>
</FILE>

<FILE name='scicos_state' type='XML'>
  <DESCRIPTION>

  </DESCRIPTION>
</FILE>

<FILE name='scicos_time' type='XML'>
<DESCRIPTION>

</DESCRIPTION>
</FILE>

<FILE name='scicosim' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  Simulator for Scicos compiled diagram.
	</P>
	<P>
	  Usually scicosim is called by scicos to perform simulation of
	  a diagram.
	</P>
	<P>
	  But scicosim may also be called outside Scicos. Typical usage
	  in such a case may be :
	</P>
      </DESCRIPTION_ITEM>
      <DESCRIPTION_ITEM>
	<DESCRIPTION_ITEM>
	  <P>
	    1- Use Scicos to define a block diagram, compile it.
	  </P>
	  <P>
	    2- Save the compiled diagram using Save,SaveAs Scicos menus.
	  </P>
	  <P>
	    3- In Scilab, load saved file using load function. You get
	       variables scicos_ver, scs_m, %cpr scs_m is the diagram Scicos
               main data structure.
	  </P>
	  <P>
	    %cpr is the data structure containing (state,sim,cor,corinv)
	    if the diagram had been compiled before saved, else %cpr=list().
	  </P>
	  <P>
	    4- Extract state, sim out of cpr.
	  </P>
	  <P>
	    5- Execute [state,t]=scicosim(state,0,tf,sim,'start',tol) for
               initialisation.
	  </P>
	  <P>
	    6- Execute [state,t]=scicosim(state,0,tf,sim,'run',tol) for
	       simulation from 0 to tf.
	  </P>
	  <P>
	    Many successives such calls may be
	    performed changing initial and final time.
	  </P>
	  <P>
	    7- Execute [state,t]=scicosim(state,0,tf,sim,'finish',tol) at
	       the very end of the simulation to close files,...
	  </P>
	</DESCRIPTION_ITEM>
      </DESCRIPTION_ITEM>
      <DESCRIPTION_ITEM>
	<P>
	  For advanced user it is possible to "manually"
	  change some parameters or state values.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='scifunc_block' type='LATEX'>
Ce bloc peut réaliser tous types de bloc Scicos. La fonction de calcul
de ce bloc est une fonction Scilab définie interactivement par la boîte
de dialogue. Pendant la simulation, les instructions sont interprétées
par Scilab et donc la simulation d'un diagramme comportant un tel bloc
peut devenir plus lente.
</FILE>

<FILE name='scifunc_block_m' type='LATEX'>
Ce bloc peut réaliser tous types de bloc Scicos. La fonction de calcul
de ce bloc est une fonction Scilab définie interactivement par la boîte
de dialogue. Pendant la simulation, les instructions sont interprétées
par Scilab et donc la simulation d'un diagramme comportant un tel bloc
peut devenir plus lente.
</FILE>

<FILE name='set_blockerror' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
    <DESCRIPTION_ITEM>
    <P>
    Cette fonction permet de définir une erreur spécifique en cours de simulation pour le
    bloc courant. Si cette fonction est utilisée, alors à l'issue de l'éxecution de la fonction
    de calcul du bloc, le simulateur s'arrêtera et retournera un message d'erreur associé au
    numéro donné en argument.
    </P>
    </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='set_xproperty' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
    <DESCRIPTION_ITEM>
    <P>
    Cette fonction permet de définir un vecteur indiquant le type (algébrique ou différentiel)
    des variables d'états continues utilisées dans un bloc.
    </P>
    </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='sig2data' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
    <DESCRIPTION_ITEM>
    <P>
    Extrait les données d'une structure signal scicos.
    x sera le champ B.values.
    t sera le champ B.time.
    x will be the field B.values
    t will be the field B.time
    </P>
    </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='steadycos' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	Cette fonction trouve le régime établi d'un système décrit par un
	diagramme Scicos. Le diagramme sera en général supposé être comme
	un superbloc avec des ports d'entrées/sorties réguliers. Le
	régime établi concerne seulement les dynamiques à temps continu.
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='use_flag' type='LATEX'>
During the simulation, the computational functions will be called with a given flag
that corresponds to the task to be realized and with the event number by which it has been activated.

\begin{itemize}
\item{\bf Flag 4: Initialization}
This is done only once in the initialization phase for all blocks.
Input event numbers are not used in that case.
Outputs and states can be initialized.
Some blocks use also this flag to open files, to do allocation and initialization of the field {\tt block->work} or initialize
graphic windows.

\item{\bf Flag 6: Initialization, fixed-point computation}
Flag 6 is used to set constraints that must be satisfied at the initial
time. Scicos uses a fixed point computation scheme to force the
constraints so the blocks are called more than once with flag 6 at
time 0. 
This is a special initialization technique for example to find the steady state of a system before running the simulation.
Input event numbers are not used in this case.

\item{\bf Flag 1: Output computation}
The output computation can be performed many times in one time step of
the simulation in particular when the diagram contains blocks
that use both discrete and continuous states and zero crossing surfaces.
In the current version of Scicos all blocks are called with flag = 1 at least once in every simulation time step,
even if they don't have any outputs.

\item{\bf Flag 2: Discrete state computation}
If blocks use states, this flag is when the state registers 
{\tt block->x}, {\tt block->z}, {\tt block->oz}, {\tt block->work}
must be set during discrete activation (with {\tt block->nevptr}$\geq$0)
but also to compute {\tt block->x} in the case of activation due to an
internal zero crossing, in which case the input event number {\tt block->nevptr} will be -1.

\item{\bf Flag 0: Continuous state derivative computation}
This flag is used when the derivative {\tt block->xd} or residual {\tt
block->res} of the continuous state needs to be set.
Only blocks that use continuous state are called with flag=0.

\item{\bf Flag 3: Output event computation}
Output event computation is done for blocks with output event register
during discrete activation but also zero crossing activation.
Note that in this latter case, the input event number {\tt block->nevptr} will be -1.

\item{\bf Flag 9: Modes and zero crossing computation}
Flag 9 is used to evaluate the function of zero crossings {\tt
block->g} and to set the modes, {\tt block->mode}.

\item{\bf Flag 5: Ending}
All blocks are called with flag = 5 before the end of the simulation or when the simulator aborts the simulation in case
an error occurs during the simulation. Input event numbers are not used in that case.

\item{\bf Flag 7: Properties of the continuous state variables}
Set the properties of the continuous state variables. Used for the description of DAE system (also internally used and generated by Scicos/Modelica implementation).

\item{\bf Flag 10: Jacobian computation}
Computation of Jacobian matrix of the system (internally used and generated by Scicos/Modelica implementation).
\end{itemize}
</FILE>

<FILE name='var2vec' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  Les fonctions var2vec / vec2var sont utilisées dans les fonctions
          d'interfaçages des blocs scilab pour donner la possibilité à l'utilisateur de
          manipuler des objets scilab avec le registre des paramètres réels (rpar) et
          avec le registre des états discrets (z).
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>

<FILE name='vec2var' type='XML'>
  <DESCRIPTION>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM>
	<P>
	  Les fonctions var2vec / vec2var sont utilisées dans les fonctions
          d'interfaçages des blocs scilab pour donner la possibilité à l'utilisateur de
          manipuler des objets scilab avec le registre des paramètres réels (rpar) et
          avec le registre des états discrets (z).
	</P>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
</FILE>


</DATA>
