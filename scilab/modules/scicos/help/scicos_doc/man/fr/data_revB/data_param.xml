<!--  Scicos

   Copyright (C) INRIA - METALAU Project <scicos@inria.fr>

  This program is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 2 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

  See the file ../license.txt
-->

<?xml version="1.0" encoding="ISO-8859-1" standalone="no"?>
<DATA flag="param">

<FILE name='ABCD_Blocks' type='XML'>
  <PARAM>

  </PARAM>
</FILE>

<FILE name='ABSBLK_f' type='XML'>
<PARAM>
<PARAM_INDENT>

</PARAM_INDENT>
</PARAM>
</FILE>

<FILE name='ABS_VALUE' type='LATEX'>
\begin{itemize}

  \item {\bf use zero\_crossing} \\
        Choix Oui/Non (1/0) pour activer la détection de passage à zéro.\\
        Propriétés : Type 'vec' de taille 1.
\end{itemize}
</FILE>

<FILE name='AFFICH_f' type='LATEX'>
%automatically generated, please edit
\begin{itemize}

  %Font number   1
  \item {\bf Font number}\\
        Entier, la taille de la fonte sélectionnée (voir xset). \\
	Propriétés : Type 'vec' de taille 1

  %Font size   1
  \item {\bf Font size}\\ 
	Entier, la taille de la police utilisée. \\
	Propriétés : Type 'vec' de taille 1

  %Color   1
  \item {\bf Color}\\
        Entier, la couleur sélectionnée pour le texte. (voir xset)\\
	Propriétés : Type 'vec' de taille 1

  %Total number of digits   9
  \item {\bf Total number of digits}\\
        Un entier plus grand que 3. 
        C'est le nombre de chiffres utilisés pour représenter le nombre affiché.
        (incluant le signe, la partie enière et les chiffres après la virgule)\\
	Propriétés : Type 'vec' de taille 1

  %Number of rational part digits   2
  \item {\bf Number of rational part digits}\\
        Un entier plus grand ou égal à 0.
        C'est le nombre de chiffres affichés après la virgule. \\
	Propriétés : Type 'vec' de taille 1

  %Block inherits (1) or not (0)   0
  \item {\bf Block inherits }\\
        Option pour choisir l'activation par héritage d'événement
        via le port d'entrée régulier ou explicitement par le port d'entrée
	événementiel. \\
	Propriétés : Type 'vec' de taille 1
\end{itemize}
</FILE>

<FILE name='AFFICH_m' type='LATEX'>
%automatically generated, please edit
\begin{itemize}

  \item {\bf Input Size}\\
        Définit explicitement la taille du port d'entrée. \\
	Propriétés : Type 'mat' de taille [1,2].

  %Font number   1
  \item {\bf Font number}\\
        Entier, la taille de la fonte sélectionnée (voir xset). \\
	Propriétés : Type 'vec' de taille 1

  %Font size   1
  \item {\bf Font size}\\ 
	Entier, la taille de la police utilisée. \\
	Propriétés : Type 'vec' de taille 1

  %Color   1
  \item {\bf Color}\\
        Entier, la couleur sélectionnée pour le texte. (voir xset)\\
	Propriétés : Type 'vec' de taille 1

  %Total number of digits   9
  \item {\bf Total number of digits}\\
        Un entier plus grand que 3. 
        C'est le nombre de chiffres utilisés pour représenter le nombre affiché.
        (incluant le signe, la partie enière et les chiffres après la virgule)\\
	Propriétés : Type 'vec' de taille 1

  %Number of rational part digits   2
  \item {\bf Number of rational part digits}\\
        Un entier plus grand ou égal à 0.
        C'est le nombre de chiffres affichés après la virgule. \\
	Propriétés : Type 'vec' de taille 1

  %Block inherits (1) or not (0)   0
  \item {\bf Block inherits }\\
        Option pour choisir l'activation par héritage d'événement
        via le port d'entrée régulier ou explicitement par le port d'entrée
	événementiel. \\
	Propriétés : Type 'vec' de taille 1
\end{itemize}
</FILE>

<FILE name='ANDBLK' type='XML'>
<PARAM>
<PARAM_INDENT>

</PARAM_INDENT>
</PARAM>
</FILE>

<FILE name='ANDLOG_f' type='XML'>
<PARAM>
<PARAM_INDENT>

</PARAM_INDENT>
</PARAM>
</FILE>

<FILE name='AUTOMAT' type='LATEX'>
\begin{itemize}
    \item {\bf Number of (finite-state) Modes}\\
           Number of modes in the automation. \\
           Properties : Type 'vec' of size [1,1].

    \item {\bf Initial Mode}\\
          Initial active mode at the beginning of the simulation. \\
          Properties : Type 'vec' of size [1,1].

    \item {\bf Number of continuous-time states}
          Number of continuous-time states at modes. Note that the number of
          continuous-time states is the same in all modes. \\
          Properties : Type 'vec' of size [-1,1].

    \item {\bf Continuous-time states initial values}\\
          Initial value of continuous-time states at the beginning of the
          simulation.\\
          Properties : Type 'vec' of size [-1,1].

    \item {\bf Xproperties of continuous-time states in each Mode}\\
          In this field the state types in mode are given.  A state in an index 1
          DAE can be either differential state or algebraic state. {\it
          Xproperties} vector is coded in an M*N matrix, where M is the
          number of modes and N is the number of states. This matrices
          indicates whether a continuous-time state is algebraic or
          differential in each control mode. If in the $i^{th}$ mode, $j^{th}$ state
          is differential, the (i,j)-th element of the Xproperty matrix
          should set to "+1", otherwise it should set to "-1". Xproperty can
          be given as a 1*N vector if type of states remain the
          same in  all modes.\\
          Properties : Type 'mat' of size [-1,-1].

    \item {\bf Jump from Mode 1:[..;M\_final(Guard=In(1).i);..]}\\
          The {\it Jump} fields express the mode transition information. Suppose
          that all control modes are labeled from 1 to M. Then, in the field
          corresponding to control mode {\bf i}, destination modes of mode {\bf i}
          are defined in a vector. {\bf j-th} element of this vector gives the
          destination mode when {\bf j-th} jump function :
          \begin{eqnarray}
           {\rm Jump}_{ij}(\dot x,x,u)
          \end{eqnarray}
          becomes positive. For example, if in the field of the mode {\bf 2}, the
          user defines [1;3;4], it means that in mode {\bf 2}, there are three
          active jump functions. When, for example, the third jump function
          becomes positive, a mode transition to mode {\bf 4} will be activated.\\
          Properties : Type 'vec' of size [-1,1].
\end{itemize}
</FILE>

<FILE name='About_scicos' type='XML'>
  <PARAM>

  </PARAM>
</FILE>

<FILE name='BACKLASH' type='XML'>
  <PARAM>
    <PARAM_INDENT>
      <PARAM_ITEM>
	<PARAM_NAME>initial output</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    La valeur initale en sortie du bloc.
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>

      <PARAM_ITEM>
	<PARAM_NAME>gap</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    La largeur de la zone morte.
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>

      <PARAM_ITEM>
	<PARAM_NAME>use zero-crossing (0:no, 1:yes)</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    A sélectionner pour permettre l'utilisation de la
	    traversée de zéro pour détecter les fronts montant et descendant.
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>

    </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='BIGSOM_f' type='XML'>
  <PARAM>
    <PARAM_INDENT>
      <PARAM_ITEM>
	<PARAM_NAME>Inputs ports signs/gain</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    Définit le signe de l'addition ainsi qu'un gain pour chaque entrée.
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille -1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
    </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='BITCLEAR' type='XML'>
  <PARAM>
    <PARAM_INDENT>
      <PARAM_ITEM>
	<PARAM_NAME>Datatype(3=int32 4=int16 5=int8 ...)</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    It indicates the type of the input/output data.
	    It support all the integer datatype, number must
	    be between 3 and 8.
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille  1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
	<PARAM_NAME>index of bit (0 is leat significant)</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    It indicate the index of the bit to clear.
	    When the type is int32 or uint32 the number must be positif
	    and less than 32. When the type is int16 or uint16 the number
	    must be positif and less than 16. When the type is int8 or
	    uint8 the number must be positif and less than 8.
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille  1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
    </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='BITSET' type='XML'>
  <PARAM>
    <PARAM_INDENT>
      <PARAM_ITEM>
	<PARAM_NAME>Datatype(3=int32 4=int16 5=int8 ...)</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    It indicates the type of the input/output data.
	    It support all the integer datatype, number must
	    be between 3 and 8.
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille  1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
	<PARAM_NAME>index of bit (0 is leat significant)</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    It indicate the index of the bit to clear. When the type
	    is int32 or uint32 the number must be positif and less
	    than 32. When the type is int16 or uint16 the number must
	    be positif and less than 16. When the type is int8 or uint8
	    the number must be positif and less than 8.
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille  1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
    </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='BOUNCE' type='XML'>
  <PARAM>
    <PARAM_INDENT>
      <PARAM_ITEM>
	<PARAM_NAME>Mass</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    La description du paramètre 1.
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille -1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
	<PARAM_NAME>Radius</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    La description du paramètre 2.
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille -1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
	<PARAM_NAME>[xmin,xmax,ymin,ymax]</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    La description du paramètre 3.
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille -1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
	<PARAM_NAME>xpos</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    La description du paramètre 4.
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille -1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
	<PARAM_NAME>xdpos</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    La description du paramètre 5.
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille -1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>

      <PARAM_ITEM>
	<PARAM_NAME>ypos</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    La description du paramètre 6.
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille -1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
	<PARAM_NAME>ydpos</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    La description du paramètre 7.
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille -1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
	<PARAM_NAME>g (gravity)</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    La description du paramètre 8.
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
	<PARAM_NAME>C (aerodynamic coeff</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    La description du paramètre 9.
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
    </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='BOUNCEXY' type='XML'>
  <PARAM>
    <PARAM_INDENT>
      <PARAM_ITEM>
	<PARAM_NAME>colors</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    La description du paramètre 1.
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille -1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
	<PARAM_NAME>radii</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    La description du paramètre 2.
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille -1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
	<PARAM_NAME>window number (-1 for automatic)</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    La description du paramètre 3.
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
	<PARAM_NAME>animation mode (0,1)</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    La description du paramètre 4.
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
	<PARAM_NAME>Xmin</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    La description du paramètre 5.
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
	<PARAM_NAME>Xmax</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    La description du paramètre 6.
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
	<PARAM_NAME>Ymin</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    La description du paramètre 7.
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
	<PARAM_NAME>Ymax</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    La description du paramètre 8.
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
    </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='BPLATFORM' type='XML'>
  <PARAM>

  </PARAM>
</FILE>

<FILE name='Bache' type='XML'>
  <PARAM>
    <PARAM_INDENT>
      <PARAM_ITEM>
	<PARAM_NAME>Pression dans le ciel de la bache : Patm (Pa)</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    Pression dans le ciel de la bache
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille -1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
	<PARAM_NAME>Section de la bache : A (m2)</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    Surface de la bache
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille -1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
	<PARAM_NAME>Altitude du piquage d entrée 1: ze1 (m)</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    Altitude du piquage d'entrée (ze1)
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille -1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
	<PARAM_NAME>Altitude du piquage d entrée 2: ze2 (m)</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    Altitude du piquage d'entrée (ze2)
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille -1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
	<PARAM_NAME>Altitude du piquage de sortie 1: zs1 (m)</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    Altitude du piquage de sortie (zs1)
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille -1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
	<PARAM_NAME>Altitude du piquage de sortie 2: zs2 (m)</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    Altitude du piquage de sortie (zs2)
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille -1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
	<PARAM_NAME>Altitude initiale du fluide : z0 (m)</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    Altitude initiale du fluide
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille -1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
	<PARAM_NAME>Température initiale du fluide : T0 (K)</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    Température initiale du fluide
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille -1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
	<PARAM_NAME>Si &gt;0, masse volumique imposée du fluide : p_rho (kg/m3)</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    masse volumique imposée du fluide
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille -1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
    </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='CANIMXY' type='LATEX'>
\begin{itemize}

  \item {\bf Number of Curves}\\
        Set the number of curves.\\
	Propriétés : Type 'vec' de taille  1

  %color ($<$0) or mark ($>$0)   -4
  \item {\bf color }\\
        an integer. It is the color number ($>=0$) or marker
	type ($<0$) used to draw the evolution of the input port signal.
	See {\bf  xset()}  for color (dash type) definitions.   \\
	Propriétés : Type 'vec' de taille  1

  %line or mark size   1
  \item {\bf line or mark size}\\
        an integer. \\
	Propriétés : Type 'vec' de taille  1

  %Output window number   1
  \item {\bf Output window number}\\
        The number of graphic window used for
	the display. It is often good to use high values to avoid conflict
	with palettes and Super Block windows. If you have more than one
	scope, make sure they don't have the same window numbers (unless
	superposition of the curves is desired).  \\
	Propriétés : Type 'vec' de taille  1

  %Output window position   []
  \item {\bf Output window position}\\
        a 2 vector specifying the coordinates
        of the upper left corner of the graphic window. Answer [] for
        default window position.  \\
	Propriétés : Type 'vec' de taille  -1

  %Output window sizes   []
  \item {\bf Output window sizes}\\
       a 2 vector specifying the width and height
       of the graphic window. Answer [] for default window dimensions.  \\
       Propriétés : Type 'vec' de taille  -1

  %Xmin   -15
  \item {\bf Xmin}\\
        Minimum values of the first input; used to set up the
	X-axis of the plot in the graphics window.  \\
	Propriétés : Type 'vec' de taille  1

  %Xmax   15
  \item {\bf Xmax}\\
        Maximum values of the first input; used to set up the
	X-axis of the plot in the graphics window.  \\
	Propriétés : Type 'vec' de taille  1

  %Ymin   -15
  \item {\bf Ymin}\\
        Minimum and maximum values of the second input; used to
	set up the Y-axis of the plot in the graphics window.  \\
	Propriétés : Type 'vec' de taille  1

  %Ymax   15
  \item {\bf Ymax}\\
        Maximum values of the second input; used to set up the
	Y-axis of the plot in the graphics window.  \\
	Propriétés : Type 'vec' de taille  1

  %Buffer size   2
  \item {\bf Buffer size}\\
        An integer value. In order to minimize the number
         of graphics outputs, data may buffered.   \\
	Propriétés : Type 'vec' de taille  1
\end{itemize}
</FILE>

<FILE name='CANIMXY3D' type='LATEX'>
\begin{itemize}

  \item {\bf Number of Curves}\\
        Set the number of curves.\\
	Propriétés : Type 'vec' de taille  -1

  %color ($<$0) or mark ($>$0)   -4
  \item {\bf color }\\
        an integer. It is the color number ($>=0$) or marker
	type ($<0$) used to draw the evolution of the input port signal.
        See {\bf  xset()}  for color (dash type) definitions.   \\
	Propriétés : Type 'vec' de taille  -1

  %line or mark size   1
  \item {\bf line or mark size}\\
        an integer. \\
	Propriétés : Type 'vec' de taille  -1

  %Output window number   1
  \item {\bf Output window number}\\
        The number of graphic window used for
	the display. It is often good to use high values to avoid conflict
	with palettes and Super Block windows. If you have more than one
	scope, make sure they don't have the same window numbers (unless
	superposition of the curves is desired).  \\
	Propriétés : Type 'vec' de taille  -1

  %Output window position   []
  \item {\bf Output window position}\\
        a 2 vector specifying the coordinates
        of the upper left corner of the graphic window. Answer [] for
        default window position.  \\
	Propriétés : Type 'vec' de taille  -1

  %Output window sizes   []
  \item {\bf Output window sizes}\\
       a 2 vector specifying the width and height
       of the graphic window. Answer [] for default window dimensions.  \\
       Propriétés : Type 'vec' de taille  -1

  \item {\bf Xmin and Xmax}\\
        Minimum and Maximum values of the first input; used to set up the
	X-axis of the plot in the graphics window.  \\
	Propriétés : Type 'vec' de taille  -1

  \item {\bf Ymin and Ymax}\\
        Minimum and Maximum values of the second input; used to set up the
	Y-axis of the plot in the graphics window.  \\
	Propriétés : Type 'vec' de taille  -1

  \item {\bf Zmin and Zmax}\\
        Minimum and Maximum values of the third input; used to set up the
	Z-axis of the plot in the graphics window.  \\
	Propriétés : Type 'vec' de taille  -1

  \item {\bf Alpha and Theta}\\
        Set Alpha and Theta for the 3D view.\\
	Propriétés : Type 'vec' de taille  -1

  %Buffer size   2
  \item {\bf Buffer size}\\
        An integer value. In order to minimize the number
         of graphics outputs, data may buffered.   \\
	Propriétés : Type 'vec' de taille  1
\end{itemize}
</FILE>

<FILE name='CBLOCK' type='LATEX'>
%automatically generated, please edit
\begin{itemize}

  %simulation function   toto
  \item {\bf simulation function}\\
         Nom de la fonction de simulation à générer.\\
	 Propriétés : Type 'str' de taille 1

  %is block implicit? (y,n)   n
  \item {\bf is block implicit? }\\
        Si oui (y), le bloc appelera le solveur implicite
	sinon (n), il appelera le solveur explicite.\\
	Propriétés : Type 'str' de taille 1

  %input ports sizes   1
  \item {\bf input ports sizes}\\
        Nombre de ports réguliers d'entrée.\\
	Propriétés : Type 'vec' de taille -1

  %output ports sizes   1
  \item {\bf output ports sizes}\\
        Nombre de ports réguliers de sortie.\\
	Propriétés : Type 'vec' de taille -1

  %input event ports sizes   []
  \item {\bf input event ports sizes}\\
        Nombre de ports événementiels d'entrée.\\
	Propriétés : Type 'vec' de taille -1

  %output events ports sizes   []
  \item {\bf output events ports sizes}\\
        Nombre de ports événementiels de sortie.\\
	Propriétés : Type 'vec' de taille -1

  %initial continuous state   []
  \item {\bf initial continuous state}\\
        Conditions initiales des états continus.\\
	Propriétés : Type 'vec' de taille -1

  %number of zero crossing surfaces   0
  \item {\bf number of zero crossing surfaces}\\
        Permet l'utilisation de la détection
	'zero-crossing'.\\
	Propriétés : Type 'vec' de taille 1

  %initial discrete state   [] 
  \item {\bf initial discrete state}\\
        Conditions initiales des états discrets.\\
	Propriétés : Type 'vec' de taille -1

  %Real parameters vector   []
  \item {\bf Real parameters vector}\\
        Vecteur des paramètres réels.\\
	Propriétés : Type 'vec' de taille -1

  %Integer parameters vector   []
  \item {\bf Integer parameters vector}\\
        Vecteur des paramètres entiers.\\
        Propriétés : Type 'vec' de taille -1

  %initial firing vector ($<$0 for no firing)   []
  \item {\bf initial firing vector }\\
        Un vecteur. La taille de ce vecteur correspond
	au nombre de sorties événementielles.
	La valeur de la $i^{\rm \grave{e}me}$ entrée
	spécifie la date initiale préprogrammée du 
	$i^{\rm \grave{e}me}$ port événementiel de sortie.
	Si la valeur est inférieure à zéro, alors aucun
	événement n'est préprogrammé.\\
	Propriétés : Type 'vec' de taille 'sum(\%6)'

  %direct feedthrough (y or n)   \%t
  \item {\bf direct feedthrough }\\
        L'entrée du bloc à un instant donné, détermine
	la sortie du bloc à ce même instant.
	Cela force le bloc à répondre instantanément, comme
	si le système était en régime établi.\\
	Propriétés : Type 'str' de taille 1

  %time dependence (y or n)   \%f
  \item {\bf time dependence }\\
        Permet de déterminer si le bloc doit être
	marqué comme temps dépendant.\\
	Propriétés : Type 'str' de taille 1
\end{itemize}
</FILE>

<FILE name='CBLOCK4' type='LATEX'>
%automatically generated, please edit
\begin{itemize}

  %simulation function   toto
  \item {\bf Simulation function}\\
        Nom de la fonction de simulation à générer et à charger.\\
	Propriétés : Type 'vec' de taille 1

  %input ports sizes   1
  \item {\bf Input ports sizes}\\
        Une matrice de taille [n,2] contenant des valeurs positives, nulles ou négatives.
        Cette matrice donne le
        nombre (n) et les tailles des ports réguliers d'entrée.\\
	Propriétés : Type 'vec' de taille -1

  %input ports type   1
  \item {\bf Intput ports type}\\
        Un vecteur qui définit les types de donnée
	des ports réguliers d'entrée.\\
	Propriétés : Type 'vec' de taille  -1

  %output port sizes   1
  \item {\bf Output port sizes}\\
        Une matrice de taille [n,2] contenant des valeurs positives, nulles ou négatives.
        Cette matrice donne le
        nombre et les tailles des ports réguliers de sortie.\\
	Propriétés : Type 'vec' de taille -1

  %output ports type   1
  \item {\bf Output ports type}\\
        Un vecteur qui définit les types de donnée
	des ports réguliers de sortie.\\
	Propriétés : Type 'vec' de taille  -1

  %input event ports sizes   []
  \item {\bf Input event ports sizes}\\
        Un vecteur contenant des valeurs 1.
        La taille de ce vecteur donne le
        nombre de ports événementiels d'entrée.\\
	Propriétés : Type 'vec' de taille -1

  %output events ports sizes   []
  \item {\bf Output events ports sizes}\\
        Un vecteur contenant des valeurs 1.
        La taille de ce vecteur donne le
        nombre de ports événementiels de sortie.\\
	Propriétés : Type 'vec' de taille -1

  %initial continuous state   []
  \item {\bf Initial continuous state}\\
        Un vecteur colonne.
	Conditions initiales des états continus.\\
	Propriétés : Type 'vec' de taille -1

  %initial discrete state   []
  \item {\bf Initial discrete state}\\
        Un vecteur colonne.
        Conditions initiales des états discrets.\\
	Propriétés : Type 'vec' de taille -1

  %initial object state list()
  \item {\bf Initial object state}\\
        Une liste scilab qui définit les états
	objets (oz).\\
	Propriétés : Type 'lis' de taille  -1

  %Real parameters vector   []
  \item {\bf Real parameters vector}\\
        Vecteur des paramètres réels.\\
	Propriétés : Type 'vec' de taille -1

  %Integer parameters vector   []
  \item {\bf Integer parameters vector}\\
        Vecteur des paramètres entiers.\\
	Propriétés : Type 'vec' de taille -1

  %object parameters list  list()
  \item {\bf Object parameters list  }\\
        Une liste scilab qui définit les paramètres
	objets (opar).\\
	Propriétés : Type 'lis' de taille  -1

  %number of modes   0
  \item {\bf Number of modes}\\
        Nombre de modes des fonctions du
	système.\\
	Propriétés : Type 'vec' de taille 1

  %number of zero\_corssings   0
  \item {\bf Number of zero\_corssings}\\
        Nombre de passage à zéro.
        Permet l'utilisation de la détection
	'zero-crossing'.\\
	Propriétés : Type 'vec' de taille 1

  %initial firing vector ($<$0 for no firing)   []
  \item {\bf Initial firing vector }\\
        Un vecteur. La taille de ce vecteur correspond
	au nombre de sorties événementielles.
	La valeur de la $i^{\rm \grave{e}me}$ entrée
	spécifie la date initiale préprogrammée du 
	$i^{\rm \grave{e}me}$ port événementiel de sortie.
	Si la valeur est inférieure à zéro, alors aucun
	événement n'est préprogrammé.\\
	Propriétés : Type 'vec' de taille sum(\%7)

  %direct feedthrough (y or n)   y
  \item {\bf Direct feedthrough }\\
        L'entrée du bloc à un instant donné, détermine
	la sortie du bloc à ce même instant.
	Cela force le bloc à répondre instantanément, comme
	si le système était en régime établi.\\
	Propriétés : Type 'vec' de taille 1

  %time dependence (y or n)   n
  \item {\bf Time dependence }\\
        Permet de déterminer si le bloc doit être
	marqué comme temps dépendant.\\
	Propriétés : Type 'vec' de taille 1
\end{itemize}
</FILE>

<FILE name='CCS' type='XML'>
  <PARAM>
    <PARAM_INDENT>

  </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='CEVENTSCOPE' type='LATEX'>
%automatically generated, please edit
\begin{itemize}

  %Number of event inputs   1
  \item {\bf Number of event inputs}\\
        an integer giving the number of event
        input ports colors : a vector of integers. The i-th element is the
        color number ($>=0$) or dash type ($<0$) used to draw the evolution of
        the i-th input port signal. See  {\bf xset}  for color (dash type)
        definitions.  \\
	Propriétés : Type 'vec' de taille  1
 
  %colors c ($>$0) or mark ($<$0)   1
  \item {\bf colors c }\\
        an integer. It is the color number ($>0$) or dash
	type ($<0$) used to draw the evolution of the input port signal. See
	{\bf plot2d}  for color (dash type) definitions.\\
	Propriétés : Type 'vec' de taille  -1

  %Output window number   1
  \item {\bf Output window number}\\
        The number of graphic window used for the
	display. It is often good to use high values to avoid conflict with
	palettes and Super Block windows. If you have more than one scope,
	make sure they don't have the same window numbers (unless
	superposition of the curves is desired). Output window position : a
	2 vector specifying the coordinates of the upper left corner of the
	graphic window. Answer [] for default window position.  \\
	Propriétés : Type 'vec' de taille  1
 
  %Output window position   []
  \item {\bf Output window position}\\
	Propriétés : Type 'vec' de taille  -1

  %Output window sizes   [600;400]
  \item {\bf Output window sizes}\\
        a 2 vector specifying the width and height
	of the graphic window. Answer [] for default window dimensions.\\
	Propriétés : Type 'vec' de taille  -1

  %Refresh period   30
  \item {\bf Refresh period}\\
        Maximum value on the X-axis (time). The plot is
	redrawn when time reaches a multiple of this value.   \\
	Propriétés : Type 'vec' de taille  1
\end{itemize}
</FILE>

<FILE name='CFSCOPE' type='LATEX'>
%automatically generated, please edit
\begin{itemize}

  %Color ($>$0) or mark ($<$0) vector (8 entries)   1 3 5 7 9 11 13 15
  \item {\bf Color }\\
        a vector of integers. The i-th element is the color
	number ($>0$) or dash type ($<0$) used to draw the evolution
        of the i-th input port signal. See  {\bf plot2d}  for color
       (dash type) definitions. \\
	Propriétés : Type 'vec' de taille  8

  %Output window number (-1 for automatic)   -1
  \item {\bf Output window number }\\
        The number of graphic window used for 
	the display. It is often good to use high values to avoid
        conflict with palettes and Super Block windows. If default
        value is used {\bf (1)}, Scicos define the output window
        number. \\
	Propriétés : Type 'vec' de taille  1

  %Output window position   [] 
  \item {\bf Output window position}\\
        a 2 vector specifying the coordinates
	of the upper left corner of the graphic window. Answer [] for 
	default window position. \\
	Propriétés : Type 'vec' de taille  -1

  %Output window sizes   [600;400] 
  \item {\bf Output window sizes}\\
        a 2 vector specifying the coordinates of
	the upper left corner of the graphic window. Answer []
        for default window position.   \\
	Propriétés : Type 'vec' de taille  -1

  %Ymin   -15
  \item {\bf Ymin}\\
        Minimum  values of the input; used to set up the Y-axis
	of the plot in the graphics window.   \\
	Propriétés : Type 'vec' de taille  -1

  %Ymax   15
  \item {\bf Ymax}\\
        Maximum values of the input; used to set up the Y-axis
	of the plot in the graphics window.   \\
	Propriétés : Type 'vec' de taille  1

  %Refresh period   30 
  \item {\bf Refresh period}\\
        Maximum value on the X-axis (time). The plot
	is redrawn when time reaches a multiple of this value. \\
	Propriétés : Type 'vec' de taille 

  %Buffer size   2
  \item {\bf Buffer size}\\
        To improve efficiency it is possible to buffer the
	input data. The drawing is only done after each
        {\bf Buffer size} call to the block. \\
	Propriétés : Type 'vec' de taille  1

  %Links to view   1
  \item {\bf Links to view}\\
        This parameter allows you to display the output
	of specified link. \\
	Propriétés : Type 'vec' de taille  1
\end{itemize}
</FILE>

<FILE name='CLINDUMMY_f' type='XML'>
<PARAM>
<PARAM_INDENT>

</PARAM_INDENT>
</PARAM>
</FILE>

<FILE name='CLKFROM' type='XML'>
  <PARAM>
    <PARAM_INDENT>
      <PARAM_ITEM>
	<PARAM_NAME>Tag</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    The tag of the CLKGOTO block passing the signal
            to this CLKFROM block.
	  </SP>
	  <SP>
	    Propriétés : Type 'str' de taille -1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
    </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='CLKGOTO' type='XML'>
  <PARAM>
    <PARAM_INDENT>
      <PARAM_ITEM>
	<PARAM_NAME>Tag</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    This parameter identifies the Goto block whose
            scope is defined in this block.
	  </SP>
	  <SP>
	    Propriétés : Type 'str' de taille -1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
	<PARAM_NAME>Tag Visibility (1=Local 2=Scoped 3=Global)</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    This parameter idetifies the visibility of the block.
            It can be local(1), scoped(2) or global(3).
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
    </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='CLKGotoTagVisibility' type='XML'>
  <PARAM>
    <PARAM_INDENT>
      <PARAM_ITEM>
	<PARAM_NAME>GotoTag</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    The Goto block tag whose visibility is defined by the
	    location of this block.
	  </SP>
	  <SP>
	    Propriétés : Type 'str' de taille -1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
    </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='CLKINV_f' type='XML'>
  <PARAM>
    <PARAM_INDENT>
      <PARAM_ITEM>
	<PARAM_NAME>Port number</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    un entier qui définit le numéro de port.
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
    </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='CLKIN_f' type='XML'>
  <PARAM>
    <PARAM_INDENT>
      <PARAM_ITEM>
	<PARAM_NAME>Port number</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    un entier qui définit le numéro de port.
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
    </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='CLKOUTV_f' type='XML'>
  <PARAM>
    <PARAM_INDENT>
      <PARAM_ITEM>
	<PARAM_NAME>Port number</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    un entier qui définit le numéro de port.
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
    </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='CLKOUT_f' type='XML'>
  <PARAM>
    <PARAM_INDENT>
      <PARAM_ITEM>
	<PARAM_NAME>Port number</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    un entier qui définit le numéro de port.
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
    </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='CLKSOMV_f' type='XML'>
<PARAM>
<PARAM_INDENT>

</PARAM_INDENT>
</PARAM>
</FILE>

<FILE name='CLKSOM_f' type='XML'>
<PARAM>
<PARAM_INDENT>

</PARAM_INDENT>
</PARAM>
</FILE>

<FILE name='CLKSPLIT_f' type='XML'>
<PARAM>
<PARAM_INDENT>

</PARAM_INDENT>
</PARAM>
</FILE>

<FILE name='CLOCK_c' type='LATEX'>
  %@lan
  \begin{itemize}
     
     \item {\bf Period} \\
           scalaire. \\
           La periode de l'horloge.\\
           Une période est le temps qui sépare deux événements de sortie.\\
	   Propriétés : Type 'vec' de taille 1.

     \item {\bf Init time} \\
           scalaire. \\
	   La date de départ.\\
           Si celle-ci est négative alors l'horloge ne démarre jamais.\\
	   Propriétés : Type 'vec' de taille 1.

  \end{itemize}
</FILE>

<FILE name='CLOCK_f' type='LATEX'>
  \begin{itemize}
     
     \item {\bf Period} \\
           scalaire. \\
           La periode de l'horloge.\\
           Une période est le temps qui sépare deux événements de sortie.\\
	   Propriétés : Type 'vec' de taille 1.

     \item {\bf Init time} \\
           scalaire. \\
	   La date de départ.\\
           Si celle-ci est négative alors l'horloge ne démarre jamais.\\
	   Propriétés : Type 'vec' de taille 1.

  \end{itemize}
</FILE>

<FILE name='CLR' type='LATEX'>
\begin{itemize}
  %Numerator (s)   1
  \item {\bf Numerator} \\
        Ce paramètre définit le numérateur de la fonction de transfert.\\
        Celà doit être un polynôme définit dans l'espace de LaPlace. \\
        Propriétés : Type 'pol' de taille 1.

  %Denominator (s)   1+s
  \item {\bf Denominator} \\
        Ce paramètre définit le dénominateur de la fonction de transfert.
        Celà doit être un polynôme définit dans l'espace de LaPlace. \\
        Propriétés : Type 'pol' de taille 1.
\end{itemize}
</FILE>

<FILE name='CLR_f' type='LATEX'>
\begin{itemize}
  %Numerator (s)   1
  \item {\bf Numerator} \\
        Ce paramètre définit le numérateur de la fonction de transfert.\\
        Celà doit être un polynôme définit dans l'espace de LaPlace. \\
        Propriétés : Type 'pol' de taille 1.

  %Denominator (s)   1+s
  \item {\bf Denominator} \\
        Ce paramètre définit le dénominateur de la fonction de transfert.
        Celà doit être un polynôme définit dans l'espace de LaPlace. \\
        Propriétés : Type 'pol' de taille 1.
\end{itemize}
</FILE>

<FILE name='CLSS' type='LATEX'>
\begin{itemize}

 \item {\bf $A$ matrix} \\
       Une matrice carré. \\
       Propriétés : Type 'mat' de taille [-1,-1].

 \item {\bf B matrix} \\
       La matrice $B$, [] si le système n'a pas d'entrées.\\
       Propriétés : Type 'mat' de taille ["size(\%1,2)","-1"].

 \item {\bf C matrix} \\
       La matrice $C$, [] si le système n'a pas de sorties.\\
       Propriétés : Type 'mat' de taille ["-1","size(\%1,2)"].

 \item {\bf D matrix} \\
       La matrice $D$, [] si le système n'a pas de terme D.\\
       Propriétés : Type 'mat' de taille [-1,-1].

 \item {\bf Initial state} \\
       Un état initial du système ( vectoriel ou scalaire).\\
       Propriétés : Type 'vec' de taille "size(\%1,2)".

\end{itemize}
</FILE>

<FILE name='CLSS_f' type='LATEX'>
\begin{itemize}

 \item {\bf $A$ matrix} \\
       Une matrice carré. \\
       Propriétés : Type 'mat' de taille [-1,-1].

 \item {\bf B matrix} \\
       La matrice $B$, [] si le système n'a pas d'entrées.\\
       Propriétés : Type 'mat' de taille ["size(\%1,2)","-1"].

 \item {\bf C matrix} \\
       La matrice $C$, [] si le système n'a pas de sorties.\\
       Propriétés : Type 'mat' de taille ["-1","size(\%1,2)"].

 \item {\bf D matrix} \\
       La matrice $D$, [] si le système n'a pas de terme D.\\
       Propriétés : Type 'mat' de taille [-1,-1].

 \item {\bf Initial state} \\
       Un état initial du système ( vectoriel ou scalaire).\\
       Propriétés : Type 'vec' de taille "size(\%1,2)".

\end{itemize}
</FILE>

<FILE name='CMAT3D' type='XML'>
  <PARAM>
    <PARAM_INDENT>
      <PARAM_ITEM>
	<PARAM_NAME>Bounds Vector X (-1 for standard)</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    If you let -1 the x ticks would be between 0 and 1
	    else you can put your own vector.
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille -1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
	<PARAM_NAME>Bounds Vector Y (-1 for standard)</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    If you let -1 the x ticks would be between 0 and 1
	    else you can put your own vector.
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille -1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
	<PARAM_NAME>ColorMap</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    The colormap is a range color linked to the window output
	    of the scope. You can put a jetcolormap or hotcolormap or
	    graycolormap or your own (see colormap help).
	  </SP>
	  <SP>
	    Propriétés : Must be a mx3 matrix and m >= 3
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
	<PARAM_NAME>Zmin</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    Minimum value in Z values
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
	<PARAM_NAME>Zmax</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    Maximum values in Z values
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
    </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='CMATVIEW' type='XML'>
  <PARAM>
    <PARAM_INDENT>
      <PARAM_ITEM>
	<PARAM_NAME>ColorMap</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    The colormap is a range color linked to the window output of
	    the scope. You can put a jetcolormap or hotcolormap or
	    graycolormap or your own (see colormap help).
	  </SP>
	  <SP>
	    Propriétés : Must be a mx3 matrix and m >= 3
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
	<PARAM_NAME>Minimum level range</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    The minimum level range is the minimum value who comes in
	    the regular input port. It would be linked to the 'cold value'
	    of the colormap.
	  </SP>
	  <SP>
	    Propriétés : A scalar
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
	<PARAM_NAME>Maximum level range</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    The maximum level range is the maximum value who comes
	    in the regular input port. It would be linked to the 'hot value'
	    of the colormap.
	  </SP>
	  <SP>
	    Propriétés : A scalar
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
    </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='CMSCOPE' type='LATEX'>
%automatically generated, please edit
\begin{itemize}

  %Input ports sizes   1 1
  \item {\bf Input ports sizes}\\
        It allows multiple  input ports. \\
	Propriétés : Type 'vec' de taille -1

  %Drawing colors ($>$0) or mark ($<$0)   1 3 5 7 9 11 13 15
  \item {\bf Drawing colors }\\
        a vector of integers. The i-th element is the color
	number ($>0$) or dash type ($<0$) used to draw the evolution
	of the i-th input port signal. See {\bf plot2d} for color
	(dash type) definitions. \\
	Propriétés : Type 'vec' de taille -1

  %Output window number   1
  \item {\bf Output window number}\\
        The number of graphic window used for the display.
	It is often good to use high values to avoid conflict 
	with palettes and Super Block windows. If default value
	is used {\bf 	(1)}, Scicos define the output window number. \\
	Propriétés : Type 'vec' de taille 1

  %Output window position   []
  \item {\bf Output window position}\\
        a 2 vector specifying the coordinates
	of the upper left corner of the graphic window. Answer [] for 
	default window position.    \\
	Propriétés : Type 'vec' de taille -1

  %Output window sizes   []
  \item {\bf Output window sizes}\\
        a 2 vector specifying the coordinates of
	the upper left corner of the graphic window. Answer []
	for default window position.   \\
	Propriétés : Type 'vec' de taille -1

  %Ymin vector   -1 -5
  \item {\bf Ymin vector}\\
        Minimum  values of the input; used to set up the Y-axis
	of the plot in the graphics window. \\
	Propriétés : Type 'vec' de taille size(\%1,'*')

  %Ymax vector   1 5
  \item {\bf Ymax vector}\\
        Maximum values of the input; used to set up the Y-axis
	of the plot in the graphics window.  \\
	Propriétés : Type 'vec' de taille size(\%1,'*')

  %Refresh period   30
  \item {\bf Refresh period}\\
        Maximum value on the X-axis (time). The plot
        is redrawn when time reaches a multiple of this value.\\
	Propriétés : Type 'vec' de taille size(\%1,'*')

  %Buffer size   2
  \item {\bf Buffer size}\\
        To improve efficiency it is possible to buffer the
	input data. The drawing is only done after each
	{\bf Buffer size} call to the block. \\
	Propriétés : Type 'vec' de taille 1

  %Accept herited events 0/1   0
  \item {\bf Accept herited events 0/1}\\
        if 0  {\bf CSCOPE\_f}  draws a new point
	only when an event occurs on its event input port. if 1
	{\bf CSCOPE\_f}	draws a new point when an event occurs
	on its event input port and when it's regular input changes
	due to an event on an other upstrem block (herited events). \\
	Propriétés : Type 'vec' de taille 1

  %Name of Scope (label\&Id)   
  \item {\bf Name of Scope }\\
        Name/label of the block. \\
	Propriétés : Type 'str' de taille 1
\end{itemize}
</FILE>

<FILE name='CONST' type='XML'>
  <PARAM>
    <PARAM_INDENT>
      <PARAM_ITEM>
	<PARAM_NAME>Constant</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    La valeur constante.
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille -1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
    </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='CONSTRAINT2_c' type='XML'>
  <PARAM>
    <PARAM_INDENT>

    <PARAM_ITEM>
    <PARAM_NAME>Initial guess values of states x</PARAM_NAME>
    <PARAM_DESCRIPTION>
      <SP>
       Initial value of the states  used as initial guess to help the
    solver to converge toward the desired solution.
      </SP>
      <SP>
      Propriétés : Type 'vec' de taille -1.
      </SP>
    </PARAM_DESCRIPTION>
    </PARAM_ITEM>

    <PARAM_ITEM>
    <PARAM_NAME>Initial guess values of derivative x'</PARAM_NAME>
    <PARAM_DESCRIPTION>
      <SP>
       Initial guess value of the derivatives of states used as initial guess to help the
    solver to converge toward the desired solution specially at the
    beginning of the simulation.
      </SP>
      <SP>
      Propriétés : Type 'vec' de taille -1.
      </SP>
    </PARAM_DESCRIPTION>
    </PARAM_ITEM>

    <PARAM_ITEM>
    <PARAM_NAME>Id(i)=1: if x'(i) is present in the feedback, else Id(i)=0</PARAM_NAME>
    <PARAM_DESCRIPTION>
      <SP>
       The elemenets of this vector indicate if the derivative of the
    corresponding state has been used in the feedback path, i.e., if
    it exists in the function f(x',x)=0.
      </SP>
      <SP>
      Propriétés : Type 'vec' de taille -1.
      </SP>
    </PARAM_DESCRIPTION>
    </PARAM_ITEM>

  </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='CONSTRAINT_c' type='XML'>
  <PARAM>
    <PARAM_INDENT>

    <PARAM_ITEM>
    <PARAM_NAME>Initial guess values</PARAM_NAME>
    <PARAM_DESCRIPTION>
      <SP>
             Initial value of the state  used as initial guess to help the
    solver to converge toward the desired solution.
      </SP>
      <SP>
      Propriétés : Type 'vec' de taille -1.
      </SP>
    </PARAM_DESCRIPTION>
    </PARAM_ITEM>

  </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='CONST_f' type='XML'>
  <PARAM>
    <PARAM_INDENT>
      <PARAM_ITEM>
	<PARAM_NAME>Constant</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	   Un vecteur de réel.
           La taille du vecteur donne la taille du port régulier de sortie.
           La valeur de la constante(i) est la valeur de la composante
           i du port de sortie.
	  </SP>
	  <SP>
            Propriétés : Type 'vec' de taille -1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
    </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='CONST_m' type='XML'>
  <PARAM>
    <PARAM_INDENT>
      <PARAM_ITEM>
	<PARAM_NAME>Constant</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    Une matrice de tous types.
	  </SP>
	  <SP>
            Les dimensions de la matrice donnent les dimensions du port
            régulier de sortie.
	  </SP>
	  <SP>
           La valeur de la constante(i,j) est la valeur de la composante(i,j)
           du port de sortie.
	  </SP>
	  <SP>
           Le type de donnée de la sortie du bloc est hérité de cette valeur.
	  </SP>
	  <SP>
	    Propriétés : Type 'mat' de taille [-1,-2].
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
    </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='CONVERT' type='XML'>
  <PARAM>
    <PARAM_INDENT>
      <PARAM_ITEM>
	<PARAM_NAME>input type (1= double 3=int32  4=int16 5=int8 ...)</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    It indicates the input data type, it can be a double or an integer.
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
	<PARAM_NAME>output type (1= double 3=int32  4=int16 5=int8 ...)</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    It indicates the output data type, it can be a double or an integer.
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
	<PARAM_NAME>Do on Overflow(0=Nothing 1=Saturate 2=Error)</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    When this parameter is set to zero the result is similar to a normal
	    multiplication of two integer matrix. When it is set
	    to 1, on overflow the block saturate the result. When it is
	    set to 2, on overflow an error message box appears.
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
    </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='COSBLK_f' type='XML'>
<PARAM>
<PARAM_INDENT>

</PARAM_INDENT>
</PARAM>
</FILE>

<FILE name='CSCOPE' type='LATEX'>
%automatically generated, please edit
\begin{itemize}

  %Color ($>$0) or mark ($<$0) vector (8 entries)   1 3 5 7 9 11 13 15
  \item {\bf Color }\\
        a vector of integers. The i-th element is the color
	number ($>0$) or dash type ($<0$) used to draw the evolution
	of the i-th input port signal. See {\bf plot2d} for color
	(dash type) definitions. \\
	Propriétés : Type 'vec' de taille 8

  %Output window number (-1 for automatic)   -1
  \item {\bf Output window number }\\
        The number of graphic window used for 
	the display. It is often good to use high values to avoid
	conflict with palettes and Super Block windows. If default
	value is used {\bf (1)}, Scicos define the output window
	number. \\
	Propriétés : Type 'vec' de taille 1

  %Output window position   [] 
  \item {\bf Output window position}\\
        a 2 vector specifying the coordinates
	of the upper left corner of the graphic window.
	Answer [] for default window position.\\
	Propriétés : Type 'vec' de taille -1

  %Output window sizes   [600;400] 
  \item {\bf Output window sizes}\\
        a 2 vector specifying the coordinates of
        the upper left corner of the graphic window.
	Answer [] for default window position.\\
	Propriétés : Type 'vec' de taille -1

  %Ymin   -15
  \item {\bf Ymin}\\
        Minimum  values of the input; used to set up the Y-axis
	of the plot in the graphics window.\\
	Propriétés : Type 'vec' de taille

  %Ymax   15
  \item {\bf Ymax}\\
        Maximum values of the input; used to set up the Y-axis
	of the plot in the graphics window.\\
	Propriétés : Type 'vec' de taille 1

  %Refresh period   30 
  \item {\bf Refresh period}\\
        Maximum value on the X-axis (time). The plot
	is redrawn when time reaches a multiple of this value.\\
	Propriétés : Type 'vec' de taille 1

  %Buffer size   2
  \item {\bf Buffer size}\\
        To improve efficiency it is possible to buffer the
	input data. The drawing is only done after each  {\bf Buffer size}
	call to the block.\\
	Propriétés : Type 'vec' de taille 1

  %Accept herited events 0/1   0
  \item {\bf Accept herited events 0/1}\\
        if 0  {\bf CSCOPE\_f}  draws a new point
	only when an event occurs on its event input port.
	If 1  {\bf CSCOPE\_f} draws a new point when an event occurs
	on its event input port and when it's regular input changes
	due to an event on an other upstream block (herited events).  \\
	Propriétés : Type 'vec' de taille 1

  %Name of Scope (label\&Id)
  \item {\bf Name of Scope }\\
        Name/label of the block. \\
	Propriétés : Type 'str' de taille 1
\end{itemize}
</FILE>

<FILE name='CSCOPXY' type='LATEX'>
\begin{itemize}
  \item {\bf Number of Curves }\\
        Set the number of curves.
	Propriétés : Type 'vec' de taille  1

  %color ($>$0) or mark ($<$0)   4
  \item {\bf color }\\
        an integer. It is the color number ($>0$) or dash type
	($<0$) used to draw the evolution of the input port signal. See
	{\bf plot2d}  for color (dash type) definitions.  \\
	Propriétés : Type 'vec' de taille  1

  %line or mark size   1
  \item {\bf line or mark size}\\
        an integer. \\
	Propriétés : Type 'vec' de taille  1

  %Output window number   1
  \item {\bf Output window number}\\
        The number of graphic window used for the
	display. It is often good to use high values to avoid conflict with
	palettes and Super Block windows. If you have more than one scope,
	make sure they don't have the same window numbers (unless
	superposition of the curves is desired).  \\
	Propriétés : Type 'vec' de taille  1

  %Output window position   []
  \item {\bf Output window position}\\
        a 2 vector specifying the coordinates
	of the upper left corner of the graphic window. Answer [] for
	default window position.  \\
	Propriétés : Type 'vec' de taille  -1

  %Output window sizes   [600;400]
  \item {\bf Output window sizes}\\
        a 2 vector specifying the width and
        height of the graphic window. Answer [] for default window
	dimensions.  \\
	Propriétés : Type 'vec' de taille  -1

  %Xmin   -15
  \item {\bf Xmin}\\
        Minimum  values of the first input; used to
        set up the X-axis of the plot in the graphics window.  \\
	Propriétés : Type '' de taille 

  %Xmax   15
  \item {\bf Xmax}\\
        Maximum values of the first input; used to
        set up the X-axis of the plot in the graphics window. \\
	Propriétés : Type 'vec' de taille  1

  %Ymin   -15
  \item {\bf Ymin}\\
        Minimum values of the second input; used to set up the
	Y-axis of the plot in the graphics window.  \\
	Propriétés : Type 'vec' de taille  1

  %Ymax   15
  \item {\bf Ymax}\\
        Maximum values of the second input; used to set up the
	Y-axis of the plot in the graphics window. \\
	Propriétés : Type 'vec' de taille  1

  %Buffer size   2
  \item {\bf Buffer size}\\
        To improve efficiency it is possible to buffer
	the input data. The drawing is only done after each  Buffer size
	call to the block.  \\
	Propriétés : Type 'vec' de taille  1
\end{itemize}
</FILE>

<FILE name='CSCOPXY3D' type='LATEX'>
\begin{itemize}

  \item {\bf Number of Curves}\\
        Set the number of curves.\\
	Propriétés : Type 'vec' de taille  -1

  %color ($<$0) or mark ($>$0)   -4
  \item {\bf color }\\
        an integer. It is the color number ($>=0$) or marker
	type ($<0$) used to draw the evolution of the input port signal.
        See {\bf  xset()}  for color (dash type) definitions.   \\
	Propriétés : Type 'vec' de taille  -1

  %line or mark size   1
  \item {\bf line or mark size}\\
        an integer. \\
	Propriétés : Type 'vec' de taille  -1

  %Output window number   1
  \item {\bf Output window number}\\
        The number of graphic window used for
	the display. It is often good to use high values to avoid conflict
	with palettes and Super Block windows. If you have more than one
	scope, make sure they don't have the same window numbers (unless
	superposition of the curves is desired).  \\
	Propriétés : Type 'vec' de taille  -1

  %Output window position   []
  \item {\bf Output window position}\\
        a 2 vector specifying the coordinates
        of the upper left corner of the graphic window. Answer [] for
        default window position.  \\
	Propriétés : Type 'vec' de taille  -1

  %Output window sizes   []
  \item {\bf Output window sizes}\\
       a 2 vector specifying the width and height
       of the graphic window. Answer [] for default window dimensions.  \\
       Propriétés : Type 'vec' de taille  -1

  \item {\bf Xmin and Xmax}\\
        Minimum and Maximum values of the first input; used to set up the
	X-axis of the plot in the graphics window.  \\
	Propriétés : Type 'vec' de taille  -1

  \item {\bf Ymin and Ymax}\\
        Minimum and Maximum values of the second input; used to set up the
	Y-axis of the plot in the graphics window.  \\
	Propriétés : Type 'vec' de taille  -1

  \item {\bf Zmin and Zmax}\\
        Minimum and Maximum values of the third input; used to set up the
	Z-axis of the plot in the graphics window.  \\
	Propriétés : Type 'vec' de taille  -1

  \item {\bf Alpha and Theta}\\
        Set Alpha and Theta for the 3D view.\\
	Propriétés : Type 'vec' de taille  -1

  %Buffer size   2
  \item {\bf Buffer size}\\
        An integer value. In order to minimize the number
         of graphics outputs, data may buffered.   \\
	Propriétés : Type 'vec' de taille  1
\end{itemize}
</FILE>

<FILE name='CUMSUM' type='XML'>
  <PARAM>
    <PARAM_INDENT>
      <PARAM_ITEM>
	<PARAM_NAME>Datatype(1=real double  2=Complex)</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    It indicates the type of the output. It support only the two
            types double (1) and complex (2). If we input another entry
	    in this label scicos will print the message "Datatype is not
	    supported".
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
	<PARAM_NAME>Sum along (0=the first non singleton dimension  1=Rows  2=Columns)</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    Indicate whether to sum across the rows, the columns or the
	    first non singleton dimension.
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
    </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='CURVE_c' type='LATEX'>
\begin{itemize}

\item {\bf Spline Method (0..7):} accepted values $0, 1, 2, 3, 4, 5, 6, 7$.
    This parameter defines the spline method for interpolating the
    points. The Signal builder block computes a linear or a cubic
    spline or sub-spline $S$ which interpolates the $(x_i,y_i)$
    points, i.e., we have $S(x_i)=y_i$ for all $i=1,..,n$.  Several
    kind of splines may be computed by selecting the appropriate
    spline method:

\begin{itemize}

\item {\bf 0: "Zero order method"}. This method generates a piecewise
    constant signal. i.e., for $t_{i} \leq t < t_{i+1}$, $y(t)=y_{i}$

\item {\bf 1: "Linear method"}. This method generates a piecewise
    linear signal. i.e., for $t_i \leq t < t_{i+1}$,
    $y(t)=y_i+(t-t_i)(y_{i+1}-y_i)/(t_{i+1}-t_i).$

\item {\bf 2: "Order 2 method"}. The interpolation is done by passing
    2-order polynomials between $(x_i,y_i)$ and
    $(x_{i+1},y_{i+1})$. The Derivative at $(x_i,y_i)$ is identical
    for two adjacent polynomials. The derivative at $(x_1,y_1)$
    can be selected arbitrary, so it is selected such that the sum of
    derivatives at all points be minimum. This condition provides a
    less fluctuated signal.

\item {\bf 3:"not\_a\_knot"}. The cubic spline is computed by using the
    following conditions (considering $n$ points $x_1,...,x_n$):
    $$S^{(3)}(x_2^-) = S^{(3)}(x_2^+)$$ $$S^{(3)}(x_{n-1}^-) =
    S^{(3)}(x_{n-1}^+)$$

\item {\bf 4:"periodic"}. A periodic cubic spline is computed ($y$
    must verify $y_1=y_n$) by using the conditions:  \\$$S^{'}(x_1) =
    S^{'}(x_n)$$ \\$$S^{''}(x_1) = S^{''}(x_n)$$.\\ In this case the value
    of $y_n$ is ignored and $y_1$ is used instead. Note that in order
    to generate a periodic signal, {\it Periodic} flag should be
    activated.

\item {\bf 5:"monotone"}. In this case a sub-spline ($S$ is only one
    continuously differentiable) is computed such that $S$ is monotone
    on each interval: \\ if $y_i \le y_{i+1}$, $S$ is increasing on
    $[x_i, x_{i+1}]$. \\ if $y_i \> y_{i+1}$, $S$ is decreasing on
    $[x_i, x_{i+1}]$.

\item {\bf 6:"clamped"}. In this case the cubic spline is computed by
    using the end points derivatives which are set to zero, i.e.,
    $$S^{'}(x_1) = S^{'}(x_n)=0$$

\item {\bf 7:"fast"}. In this case a sub-spline is computed by using a
    simple local scheme for the derivative at $x_i$ of the
    interpolation polynomial of $(x_{i-1},y_{i-1})$, $(x_{i},y_{i})$,
    $(x_{i+1},y_{i+1})$, except for the end points (derivative at
    these points are computed from the 3 left most points and the 3
    right most points).
\end{itemize}

\item {\bf x:} Abscissa data vector (X-axis). This vector can be
   either a row or a column vector of double data.  This vector can
   be also defined in the Scicos context. The data vector can be
   specified by mathematical formula.

\item {\bf y:} Ordinate data vector (Y-axis). This vector can be
   either a row or a column vector of double data. Not that the size
   of X and Y vector should be the same. This vector can be also
   defined in the Scicos context. The data vector can also be
   specified by formula.

\item {\bf Periodic signal(y/n)}. If {\bf y} is selected, the created
   signal will be periodic with the period of $t_n$. Note that if the
   {\it Periodic} spline method is selected, the output signal will be
   a continuous signal, otherwise the signal will be discontinuous at
   endpoints.

\item {\bf Launch graphical window (y/n)}. If {\bf y} is selected, by
   clicking on {\bf OK} button, a graphical window is launched. In
   this 2D graphical window, the user can edit data points: 

\begin{itemize}
    \item: Mouse left click on the window: adding a new data point

    \item: Mouse right click on the window: remove a data point

    \item: Mouse left double-click on a data point: edit a point's
         coordinates

    \item: Mouse left button press/drag/release: move a data point

    \item  {\it Autoscale menu}: Rescaling the window to show all data
         points properly.
   
    \item  {\it Spline/Method menu}: Selecting the spline interpolation method.

    \item {\it Data/Clear menu} removing all data points

    \item {\it Data/Data\_Bounds menu} Change the window size

    \item {\it Data/Load\_from\_text\_file menu} reading data points
          from a text data file (using C data format)

    \item {\it Data/save\_to\_text\_file menu} saving the data points
          to a text data file (using C data format)

    \item {\it Data/Load\_from\_excel menu}: Reading data from an
         excel file.
  
    \item {\it Data/Periodic\_signal menu}: Specifying weather the created
        signal is periodic or not. If the signal is not periodic, the
        signal stays constant beyond $t_n$, otherwise it is clamped
        to $y_1$ at $t_n$.
 
    \item {\it Standards/Functions menu}: Specifying Sine, Sawtooth,
         Pulse, and random signals.

    \item {\it Exit/Help menu}: a short help on the graphic window commands

    \item {\it Exit/Exit\_without\_save menu}: closing the graphical
          window, discarding all modifications in data. 

    \item {\it Exit/Exit\_with\_save menu}: closing the graphical window
    and saving data points.

\end{itemize}

\end{itemize}
</FILE>

<FILE name='CURV_f' type='XML'>
<PARAM>
<PARAM_INDENT>

</PARAM_INDENT>
</PARAM>
</FILE>

<FILE name='CVS' type='XML'>
  <PARAM>
    <PARAM_INDENT>

  </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='C_macros' type='XML'>
  <PARAM>

  </PARAM>
</FILE>

<FILE name='C_struct' type='XML'>
  <PARAM>

  </PARAM>
</FILE>

<FILE name='C_utils' type='XML'>
  <PARAM>

  </PARAM>
</FILE>

<FILE name='Capacitor' type='XML'>
  <PARAM>
    <PARAM_INDENT>
      <PARAM_ITEM>
	<PARAM_NAME>C (F)</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    Capacitance
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
	<PARAM_NAME>Initial Voltage</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    Voltage Initial
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
    </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='ConstantVoltage' type='XML'>
  <PARAM>
    <PARAM_INDENT>
      <PARAM_ITEM>
	<PARAM_NAME>V (volt)</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    Tension de source
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
    </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='Context' type='XML'>
  <PARAM>

  </PARAM>
</FILE>

<FILE name='Counter' type='XML'>
  <PARAM>
    <PARAM_INDENT>
      <PARAM_ITEM>
	<PARAM_NAME>Minimum</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    La valeur minimale du compteur.
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
	<PARAM_NAME>Maximum</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    La valeur maximale du compteur.
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
	<PARAM_NAME>Rule (1=Increment 2=Decrement)</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    La loi de comptage. Si ce paramètre est égal à 1, le compteur
	    s'incrémente de la valeur minimale vers la valeur maximale.
	    Sinon, si ce paramètre est égal à 2, alors le compteur diminue
	    sa valeur du maximum vers le minimum.
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
    </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='CurrentSensor' type='XML'>
<PARAM>
<PARAM_INDENT>

</PARAM_INDENT>
</PARAM>
</FILE>

<FILE name='DEADBAND' type='XML'>
  <PARAM>
    <PARAM_INDENT>
      <PARAM_ITEM>
	<PARAM_NAME>End of dead band</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    La limite supérieure de la zone morte.
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>

      <PARAM_ITEM>
	<PARAM_NAME>Start of dead band</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    La limite inférieure de la zone morte.
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
	<PARAM_NAME>zero crossing (0:no, 1:yes)</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    A sélectionner pour permettre la détection de passage à zéro.
	    Permet de savoir si les limites sont dépassées.
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
    </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='DEBUG_SCICOS' type='XML'>
<PARAM>
<PARAM_INDENT>

</PARAM_INDENT>
</PARAM>
</FILE>

<FILE name='DELAYV_f' type='XML'>
  <PARAM>
    <PARAM_INDENT>
      <PARAM_ITEM>
	<PARAM_NAME>Number of inputs</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    Définit la taille du vecteur de la première entrée régulière
	    et de la seule sortie régulière
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
	<PARAM_NAME>Register initial condition</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    Définit la longueur et les conditions initiales du registre à
	    décalage.
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille -1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
	<PARAM_NAME>Max delay</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    Ce paramètre définit la plus grande valeur du retard.
	    Cette valeur ne peut pas être négative.
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
    </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='DELAY_f' type='XML'>
  <PARAM>
    <PARAM_INDENT>
      <PARAM_ITEM>
	<PARAM_NAME>Discretisation time step</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    Définit la période temporelle de l'horloge intégrée.
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
	<PARAM_NAME>Register initial state</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    Définit la longueur et les conditions initiales du
	    registre à décalage.
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille -1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
    </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='DEMUX' type='XML'>
  <PARAM>
    <PARAM_INDENT>
      <PARAM_ITEM>
	<PARAM_NAME>number of output ports or vector de tailles</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    un entier positif supérieur ou égale à 8.
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille -1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
    </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='DEMUX_f' type='XML'>
  <PARAM>
    <PARAM_INDENT>
      <PARAM_ITEM>
	<PARAM_NAME>number of output ports or vector de tailles</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    un entier positif supérieur ou égale à 8.
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille -1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
    </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='DERIV' type='XML'>
<PARAM>
<PARAM_INDENT>

</PARAM_INDENT>
</PARAM>
</FILE>

<FILE name='DFLIPFLOP' type='XML'>
<PARAM>

</PARAM>
</FILE>

<FILE name='DIFF_c' type='XML'>
  <PARAM>
    <PARAM_INDENT>

    <PARAM_ITEM>
    <PARAM_NAME>Initial state</PARAM_NAME>
    <PARAM_DESCRIPTION>
      <SP>
      Initial value of the state used as initial guess to help the
      solver to converge toward the solution. This is specially useful
      at the beginning of the simulation.
      </SP>
      <SP>
      Propriétés : Type 'vec' de taille -1.
      </SP>
    </PARAM_DESCRIPTION>
    </PARAM_ITEM>

    <PARAM_ITEM>
    <PARAM_NAME>Initial Derivative</PARAM_NAME>
    <PARAM_DESCRIPTION>
      <SP>
      Initial value of the state derivatives used as initial guess to help the
      solver. The very first output of the block is the initial
      derivative vector.
      </SP>
      <SP>
      Propriétés : Type 'vec' de taille -1.
      </SP>
    </PARAM_DESCRIPTION>
    </PARAM_ITEM>

  </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='DIFF_f' type='XML'>
  <PARAM>
    <PARAM_INDENT>

    <PARAM_ITEM>
    <PARAM_NAME>Initial state</PARAM_NAME>
    <PARAM_DESCRIPTION>
      <SP>
      Initial value of the state used as initial guess to help the
      solver to converge toward the solution. This is specially useful
      at the beginning of the simulation.
      </SP>
      <SP>
      Propriétés : Type 'vec' de taille 1.
      </SP>
    </PARAM_DESCRIPTION>
    </PARAM_ITEM>

    <PARAM_ITEM>
    <PARAM_NAME>Initial Derivative</PARAM_NAME>
    <PARAM_DESCRIPTION>
      <SP>
      Initial value of the state derivatives used as initial guess to help the
      solver. The very first output of the block is the initial
      derivative vector.
      </SP>
      <SP>
      Propriétés : Type 'vec' de taille 1.
      </SP>
    </PARAM_DESCRIPTION>
    </PARAM_ITEM>

  </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='DLATCH' type='XML'>
<PARAM>

</PARAM>
</FILE>

<FILE name='DLR' type='LATEX'>
\begin{itemize}
  \item {\bf Numerator (z)} \\
        Ce paramètre définit le numérateur de la fonction de transfert.\\
        Celà doit être un polynôme définit dans l'espace de la transformée en z.\\
        Propriétés : Type 'pol' de taille 1.

  \item {\bf Denominator (z)} \\
        Ce paramètre définit le dénominateur de la fonction de transfert.
        Celà doit être un polynôme définit dans l'espace de la transformée en z.\\
        Propriétés : Type 'pol' de taille 1.
\end{itemize}
</FILE>

<FILE name='DLRADAPT_f' type='XML'>
  <PARAM>
    <PARAM_INDENT>
      <PARAM_ITEM>
	<PARAM_NAME>Vector of p mesh points</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    La description du paramètre 1.
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille -1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
	<PARAM_NAME>Numerator roots (one line for each mesh)</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    La description du paramètre 2.
	  </SP>
	  <SP>
	    Propriétés : Type 'mat' de taille [-1,-1].
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>

      <PARAM_ITEM>
	<PARAM_NAME>Denominator roots (one line for each mesh)</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    La description du paramètre 3.
	  </SP>
	  <SP>
	    Propriétés : Type 'mat' de taille [&quot;size(%1,''*'')&quot;,&quot;-1&quot;].
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
	<PARAM_NAME>Vector of gain at mesh points</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    La description du paramètre 4.
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille &quot;size(%1,''*'')&quot;.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
	<PARAM_NAME>past inputs (Num degree values)</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    La description du paramètre 5.
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille &quot;size(%2,2)&quot;.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
	<PARAM_NAME>past outputs (Den degree values)</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    La description du paramètre 6.
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille &quot;size(%3,2)&quot;.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
    </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='DLR_f' type='XML'>
  <PARAM>
    <PARAM_INDENT>

    <PARAM_ITEM>
    <PARAM_NAME>Numerator (z)</PARAM_NAME>
    <PARAM_DESCRIPTION>
      <SP>
      La description du paramètre 1.
      </SP>
      <SP>
      Propriétés : Type 'pol' de taille 1.
      </SP>
    </PARAM_DESCRIPTION>
    </PARAM_ITEM>

    <PARAM_ITEM>
    <PARAM_NAME>Denominator (z)</PARAM_NAME>
    <PARAM_DESCRIPTION>
      <SP>
      La description du paramètre 2.
      </SP>
      <SP>
      Propriétés : Type 'pol' de taille 1.
      </SP>
    </PARAM_DESCRIPTION>
    </PARAM_ITEM>

  </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='DLSS' type='LATEX'>
\begin{itemize}

 \item {\bf $A$ matrix} \\
       Une matrice carré. \\
       Propriétés : Type 'mat' de taille [-1,-1].

 \item {\bf B matrix} \\
       La matrice $B$, [] si le système n'a pas d'entrées.\\
       Propriétés : Type 'mat' de taille ["size(\%1,2)","-1"].

 \item {\bf C matrix} \\
       La matrice $C$, [] si le système n'a pas de sorties.\\
       Propriétés : Type 'mat' de taille ["-1","size(\%1,2)"].

 \item {\bf D matrix} \\
       La matrice $D$, [] si le système n'a pas de terme D.\\
       Propriétés : Type 'mat' de taille [-1,-1].

 \item {\bf Initial state} \\
       Un état initial du système ( vectoriel ou scalaire).\\
       Propriétés : Type 'vec' de taille "size(\%1,2)".

\end{itemize}
</FILE>

<FILE name='DLSS_f' type='LATEX'>
\begin{itemize}

 \item {\bf $A$ matrix} \\
       Une matrice carré. \\
       Propriétés : Type 'mat' de taille [-1,-1].

 \item {\bf B matrix} \\
       La matrice $B$, [] si le système n'a pas d'entrées.\\
       Propriétés : Type 'mat' de taille ["size(\%1,2)","-1"].

 \item {\bf C matrix} \\
       La matrice $C$, [] si le système n'a pas de sorties.\\
       Propriétés : Type 'mat' de taille ["-1","size(\%1,2)"].

 \item {\bf D matrix} \\
       La matrice $D$, [] si le système n'a pas de terme D.\\
       Propriétés : Type 'mat' de taille [-1,-1].

 \item {\bf Initial state} \\
       Un état initial du système ( vectoriel ou scalaire).\\
       Propriétés : Type 'vec' de taille "size(\%1,2)".

\end{itemize}
</FILE>

<FILE name='DOLLAR' type='XML'>
  <PARAM>
    <PARAM_INDENT>
      <PARAM_ITEM>
	<PARAM_NAME>initial condition</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
            Définit la valeur de la sortie au début de la simulation.
	  </SP>
	  <SP>
	    Propriétés : Type 'mat' de taille [-1,-2].
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
	<PARAM_NAME>Inherit (no:0, yes:1)</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
            Lorsque "Inherit" est égal à 1 alors le bloc hérite des événements
	    provenant des ports d'entrée réguliers.
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille -1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
    </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='DOLLAR_f' type='XML'>
  <PARAM>
    <PARAM_INDENT>
      <PARAM_ITEM>
	<PARAM_NAME>initial condition</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
            Définit la valeur de la sortie au début de la simulation.
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille -1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
	<PARAM_NAME>Inherit (no:0, yes:1)</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
            Lorsque "Inherit" est égal à 1 alors le bloc hérite
	    des événements provenant des ports d'entrée réguliers.
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille -1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
    </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='DOLLAR_m' type='XML'>
  <PARAM>
    <PARAM_INDENT>
      <PARAM_ITEM>
	<PARAM_NAME>initial condition</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
            Définit la valeur de la sortie au début de la simulation.
	  </SP>
	  <SP>
	    Propriétés : Type 'mat' de taille [-1,-2].
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
	<PARAM_NAME>Inherit (no:0, yes:1)</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
            Lorsque "Inherit" est égal à 1 alors le bloc hérite
	    des événements provenant des ports d'entrée réguliers.
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille -1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
    </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='Diode' type='XML'>
  <PARAM>
    <PARAM_INDENT>
      <PARAM_ITEM>
	<PARAM_NAME>Saturation cuurent (A)</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    Courant de saturation
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
	<PARAM_NAME>Voltage equivalent to temperature (Volt)</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    Tension équivalente de la température
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
	<PARAM_NAME>Max exponent for linear continuation</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    Exposant maximum
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
	<PARAM_NAME>R (ohm)</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    La resistance parallele
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
    </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='EDGETRIGGER' type='XML'>
  <PARAM>
    <PARAM_INDENT>
      <PARAM_ITEM>
	<PARAM_NAME>rising (1), falling (-1), both (0)</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    Propriétés : Type 'vec' de taille 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
    </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='EDGE_TRIGGER' type='XML'>
  <PARAM>
    <PARAM_INDENT>
      <PARAM_ITEM>
	<PARAM_NAME>rising (1), falling (-1), both (0)</PARAM_NAME>
	<PARAM_DESCRIPTION>
          <SP>
	    Indique le type du front auquel le bloc doit réagir.
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
    </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='ENDBLK' type='XML'>
  <PARAM>
    <PARAM_INDENT>

    <PARAM_ITEM>
    <PARAM_NAME>Final simulation time</PARAM_NAME>
    <PARAM_DESCRIPTION>
      <SP>
      Définit le temps final de la simulation.
      </SP>
      <SP>
      Lorsque le simulateur passera par cette date, alors le temps
      courant sera avancé au temps final d'intégration.
      </SP>
      <SP>
      Propriétés : Type 'vec' de taille 1.
      </SP>
    </PARAM_DESCRIPTION>
    </PARAM_ITEM>

  </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='END_c' type='XML'>
  <PARAM>
    <PARAM_INDENT>

    <PARAM_ITEM>
    <PARAM_NAME>Final simulation time</PARAM_NAME>
    <PARAM_DESCRIPTION>
      <SP>
      Ce paramètre est une date pour un événement inital de sortie. En rebouclant
      la sortie événementielle sur l'entrée événementielle, alors ce bloc terminera
      de lui même la simulation à la date définit par ce paramètre.
      </SP>
      <SP>
      Propriétés : Type 'vec' de taille 1.
      </SP>
    </PARAM_DESCRIPTION>
    </PARAM_ITEM>

  </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='ESELECT_f' type='XML'>
  <PARAM>
    <PARAM_INDENT>
      <PARAM_ITEM>
	<PARAM_NAME>number of output event ports</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    Un scalaire à valeur entière.
	    Nombre de ports de sortie événementiel.
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
	<PARAM_NAME>Inherit (1: no, 0: yes)</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    Si 'no' est sélectionné, alors le bloc est activé par
	    son entrée événementiel. Si 'yes' est sélectionnée,
	    alors le bloc est activé par les événements du signal reçu
	    sur son port d'entrée régulier.
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
	<PARAM_NAME>zero-crossing (0: no, 1: yes)</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    A sélectionner pour activer la détection de passage à zéro.
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
    </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='EVTDLY_c' type='XML'>
  <PARAM>
    <PARAM_INDENT>
      <PARAM_ITEM>
	<PARAM_NAME>Delay</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    Un scalaire à valeur réelle donnant le retard temporel entre les
	    événements d'entrée et de sortie.
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille 1
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
	<PARAM_NAME>Date of initial output event</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    Un scalaire à valeur réelle donnant la première date de l'événement
	    de sortie. Si aucune date initiale est nécéssaire alors ce champ doit
	    être renseigné par une valeur négative.
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille 1
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
    </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='EVTDLY_f' type='XML'>
  <PARAM>
    <PARAM_INDENT>
      <PARAM_ITEM>
	<PARAM_NAME>Delay</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    Un scalaire à valeur réelle donnant le retard temporel entre les
	    événements d'entrée et de sortie.
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille 1
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
	<PARAM_NAME>Date of initial output event</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    Un scalaire à valeur réelle donnant la première date
            de l'événement de sortie.
            Si aucune date initiale est nécéssaire alors ce champ
            doit être renseigné par une valeur négative.
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille 1
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
    </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='EVTGEN_f' type='XML'>
  <PARAM>
    <PARAM_INDENT>
      <PARAM_ITEM>
	<PARAM_NAME>Event Time</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    Un scalaire donnant la date de l'événement à produire.
	  </SP>
	  <SP>
	    Type 'vec' de taille 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
    </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='EVTVARDLY' type='XML'>
  <PARAM>
    <PARAM_INDENT>
      <PARAM_ITEM>
	<PARAM_NAME>Initial event firing time (&lt;0 if absent)</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    Un scalaire donnant la date de l'événement initial.
            Un événement est généré sur l'unique port de sortie
            événementiel de ce bloc si la valeur de champ est supérieur
            ou égal à zéro, sinon aucun événement inital n'est généré.
	  </SP>
	  <SP>
	    Type 'vec' de taille 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
    </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='EXPBLK_f' type='XML'>
  <PARAM>
    <PARAM_INDENT>
      <PARAM_ITEM>
	<PARAM_NAME>a (&gt;0)</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	   Un scalaire à valeur réelle positive donnant
	   le nombre élévé à la puissance u.
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
    </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='EXPBLK_m' type='XML'>
  <PARAM>
    <PARAM_INDENT>
      <PARAM_ITEM>
	<PARAM_NAME>a (&gt;0)</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	   Un scalaire à valeur réelle positive donnant
	   le nombre élévé à la puissance u.
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
    </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='EXPRESSION' type='XML'>
  <PARAM>
    <PARAM_INDENT>
      <PARAM_ITEM>
	<PARAM_NAME>number of inputs</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    Un scalaire à valeur entière donnant le nombre de port
            d'entrée régulier.
            Ces entrées peuvent-être scalaires ou vectorielles.
	  </SP>
	  <SP>
	    Type 'vec' de taille 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
	<PARAM_NAME>scilab expression</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    Chaine de caractères définissant la relation mathématique
	    à appliquer aux entrées. C'est une expression scilab.
	  </SP>
	  <SP>
	    Type 'str' de taille 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
	<PARAM_NAME>use zero-crossing (0: no, 1 yes)</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    A sélectionner pour permettre la détection de passages à zéro.
	  </SP>
	  <SP>
	    Type 'vec' de taille 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
    </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='EXTRACT' type='XML'>
  <PARAM>
    <PARAM_INDENT>
      <PARAM_ITEM>
	<PARAM_NAME>Datatype (1=real double  2=Complex)</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    It indicates the type of the output. It support only the two types
	    double (1) and complex (2). If we input another entry in this label
	    scicos will print the message "Datatype is not supported".
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
	<PARAM_NAME>Lines to extract</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    It indicates the numbers of the lines to extract.
	  </SP>
	  <SP>
	    Propriétés : Type 'mat' de taille [1,-1].
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
	<PARAM_NAME>Columns to extract</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    It indicates the numbers of the columns to extract.
	  </SP>
	  <SP>
	    Propriétés : Type 'mat' de taille [1,-1].
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
    </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='EXTRACTBITS' type='XML'>
  <PARAM>
    <PARAM_INDENT>
      <PARAM_ITEM>
	<PARAM_NAME>Datatype(3=int32 4=int16 5=int8 ...)</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    It indicates the type of the input/output data.
	    It support all the integer datatype, number must be between 3 and 8.
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
	<PARAM_NAME>Bits to extract(1=Upper Half 2=Lower Half 3=Range starting with most significant bit 4=Range ending with least significant bit 5=Range of bits)</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    It indicates the mode used to extract bits from the input data.
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
	<PARAM_NAME>number of bits or index of bit (case range of bits:[start,end],0 is leat significant bit)</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    When the "Bits to extract" field is set to 3 or 4, this parameter is
	    used to determine the number of bits to extract and it must be a
	    number. When the "Bits to extract" field is set to 5 ,this parameter
	    is used to determine range of bits to extract and it must have the
	    [start,end] form vector. When the "Bits to extract" field is set to 1
	    or 2, this parameter is ignored.
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille -1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
	<PARAM_NAME>Treat bit field as an integer(0=no 1=yes)</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    It indicates the scaling mode to use on the output bits selection.
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
    </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='EXTRACTOR' type='XML'>
  <PARAM>
    <PARAM_INDENT>
      <PARAM_ITEM>
	<PARAM_NAME>indices to extract</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    Un vecteur d'indices entier.
	    Donne les éléments à extraire du vecteur du port régulier d'entrée.
	  </SP>
	  <SP>
	    Type 'vec' de taille -1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
    </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='EXTTRI' type='XML'>
  <PARAM>
    <PARAM_INDENT>
      <PARAM_ITEM>
	<PARAM_NAME>Datatype(1=real double  2=Complex)</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    It indicates the type of the output. It support only the two types
	    double (1) and complex (2). If we input another entry in this label
	    scicos will print the message "Datatype is not supported".
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
	<PARAM_NAME>extraction type (1=lower  2=upper  3=diagonal)</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    It indicates the form of the output matrix. It can be an upper
	    triangle, a lower triangle or a diagonal matrix.
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
    </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='Extract_Activation' type='XML'>
<PARAM>
<PARAM_INDENT>

</PARAM_INDENT>
</PARAM>
</FILE>

<FILE name='FROM' type='XML'>
  <PARAM>
    <PARAM_INDENT>
      <PARAM_ITEM>
	<PARAM_NAME>Tag</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
            Le label du bloc GOTO qui amène le signal à ce bloc.
	  </SP>
	  <SP>
	    Propriétés : Type 'str' de taille -1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
    </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='FROMMO' type='XML'>
  <PARAM>
    <PARAM_INDENT>
      <PARAM_ITEM>
	<PARAM_NAME>Tag</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    The tag of the GOTOMO block passing the signal to this
	    FROMMO block.
	  </SP>
	  <SP>
	    Propriétés : Type 'str' de taille -1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
    </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='FROMWSB' type='LATEX'>
\begin{itemize}

\item {\bf Variable name:} This variable is defined in Scilab and
should be a structure with two fields, i.e., a "time" field of size
(Nx1) and a "values" filed of size (NxM). "time" is a column vector of
size Nx1 and "values" is a matrix of size "N*M". "time" filed can only
be of Real type, whereas the "values" field can be {\it Real},{\it
Complex}, {\it int8},{\it int16},{\it int32},{\it uint8},{\it uint16},
and {\it uint32}.

\item {\bf Interpolation method:} Variables read by Scicos are data
values read at discrete instants given by the time field.  This option
causes the block to interpolate at time steps for which no
corresponding workspace data exists. There are four interpolation
methods available.
 
\begin{itemize}

\item {\bf 0: "Zero order method"}. This method generates a piecewise
    constant signal. i.e., for $t_{i} \leq t < t_{i+1}$, $y(t)=y_{i}$.
    This method is available for all data types.

\item {\bf 1: "Linear method"}. This method generates a piecewise
    linear signal, i.e., for $t_i \leq t < t_{i+1}$,
    $y(t)=y_i+(t-t_i)\frac{y_{i+1}-y_i}{t_{i+1}-t_i}$.  For data types
    other than double and complex, the linear interpolation can be
    used, but the final output will be computed by casting
    interpolation result into the original data type.

\item {\bf 2:"NATURAL method"}. This cubic spline is computed by using
    the following conditions (considering $n$ points $x_1,...,x_n$):
    $$S^{(2)}(x_1) = 0$$ $$S^{(2)}(x_{n}) =0$$.  This method is only
    available for Real and complex data types.

\item {\bf 3:"NOT\_A\_KNOT method"}. The cubic spline is computed by
    using the following conditions (considering $n$ points
    $x_1,...,x_n$): $$S^{(3)}(x_2^-) = S^{(3)}(x_2^+)$$
    $$S^{(3)}(x_{n-1}^-) = S^{(3)}(x_{n-1}^+)$$.  This method is only
    available for Real and complex data types.

\end{itemize}

\item {\bf Enable zero crossing(0:No, 1:Yes)?:} Enables zero crossing
 detection. When {\it linear} and {\it Zero order} interpolation
 methods are chosen, the output signal will be discontinuous at data
 time instants. These possible discontinuities may cause problem for
 the numerical solver. In order to perform a reliable numerical
 integration, the zero crossing option is used. If output of the {\it
 FROMWSB} block affects data used by the numerical solver, at
 discontinuous points, a discrete event is generated and the numerical
 solver is cold restarted.  The discrete event is also generated at
 the $t_1$ and $t_n$ for other interpolating methods.

\item {\bf Output at end(0:Zero, 1:Hold, 2:Repeat):} This option is
for selecting method for generating output after the last time point
for which data is available from the workspace.

\begin{itemize}

\item {\bf 0 ("Zero"):} The output is set to zero.

\item {\bf 1 ("Hold"):} The output is hold.

\item {\bf 2 ("Repeat"):} The output is repeated from workspace.
\end{itemize}

\end{itemize}
</FILE>

<FILE name='FROMWS_c' type='LATEX'>
The same as \htmladdnormallink{FROMWSB}{FROMWSB.htm} block.
</FILE>

<FILE name='FSV_f' type='XML'>
<PARAM>
<PARAM_INDENT>

</PARAM_INDENT>
</PARAM>
</FILE>

<FILE name='Flowmeter' type='XML'>
  <PARAM>
    <PARAM_INDENT>

  </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='GAINBLK' type='XML'>
  <PARAM>
    <PARAM_INDENT>
      <PARAM_ITEM>
	<PARAM_NAME>Gain</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    Ce paramètre définit la matrice carré A.
	    Ce paramètre supporte tous les types de données.
	  </SP>
	  <SP>
	    Propriétés : Type 'mat' de taille [-1,-1].
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>

      <PARAM_ITEM>
	<PARAM_NAME>Do on Overflow(0=Nothing 1=Saturate 2=Error)</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    Lorsque que ce paramètre est mis à la valeur 0, le résultat est
	    similaire à une addition de deux matrices. Lorque la valeur est à 1,
	    lorqu'un dépassement intervient, le bloc sature la valeur de sortie.
	    Lorsque la valeur est égale à 2, alors, lors d'un dépassement de
	    capacité, un message d'erreur est envoyé à l'utilisateur. Lorsque le
	    type de donnée est un nombre réel ou un nombre complexe, ce paramètre
	    n'est pas pris en compte.
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taile 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
    </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='GAINBLK_f' type='XML'>
  <PARAM>
    <PARAM_INDENT>
      <PARAM_ITEM>
	<PARAM_NAME>Gain</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    Ce paramètre définit la matrice carré A.
	  </SP>
	  <SP>
	    Propriétés : Type 'mat' de taille [-1,-1].
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
    </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='GAIN_f' type='XML'>
  <PARAM>
    <PARAM_INDENT>
      <PARAM_ITEM>
	<PARAM_NAME>Gain</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    Ce paramètre définit la matrice carré A.
	  </SP>
	  <SP>
	    Propriétés : Type 'mat' de taille [-1,-1].
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
    </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='GENERAL_f' type='XML'>
  <PARAM>
    <PARAM_INDENT>
      <PARAM_ITEM>
	<PARAM_NAME>Input size</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    La description du paramètre 1.
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
	<PARAM_NAME>Number of event output</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    La description du paramètre 2.
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
    </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='GENSIN_f' type='LATEX'>
\begin{itemize}
  \item {\bf Magnitude} \\
         un scalaire à valeur réelle.\\
         L'amplitude $M$ de la sinusoide.\\
         Propriétes : Type 'vec' de taille 1.

  \item {\bf Frequency} \\
        un scalaire à valeur réelle.\\
        La pulsation $F$ (rad/s) de la sinusoide.\\
	Propriétes : Type 'vec' de taille 1.

  \item {\bf phase} \\
        un scalaire à valeur réelle. \\
        La phase à l'origine $P$ (en radian) de la sinusoide.\\
	Propriétes : Type 'vec' de taille 1.

\end{itemize}
</FILE>

<FILE name='GENSQR_f' type='XML'>
  <PARAM>
    <PARAM_INDENT>
      <PARAM_ITEM>
	<PARAM_NAME>Amplitude</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	   Un scalaire à valeur réelle donnant l'amplide M
           de la forme d'onde carrée.
	  </SP>
	   Propriétes : Type 'vec' de taille 1.
	  <SP>
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
    </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='GEN_SQR' type='XML'>
  <PARAM>
    <PARAM_INDENT>

    <PARAM_ITEM>
    <PARAM_NAME>Minimum Value</PARAM_NAME>
    <PARAM_DESCRIPTION>
      <SP>
      The Lower bound of the generator.
      </SP>
      <SP>
      Properties : Type 'mat' of size [-1,-1].
      </SP>
    </PARAM_DESCRIPTION>
    </PARAM_ITEM>

    <PARAM_ITEM>
    <PARAM_NAME>Maximum Value</PARAM_NAME>
    <PARAM_DESCRIPTION>
      <SP>
      The upper bound of the generator.
      </SP>
      <SP>
      Properties : Type 'mat' of size [-1,-1].
      </SP>
    </PARAM_DESCRIPTION>
    </PARAM_ITEM>

    <PARAM_ITEM>
    <PARAM_NAME>Initial Value( 1= Minimum Value 2= Maximum Value)</PARAM_NAME>
    <PARAM_DESCRIPTION>
      <SP>
      When this parameter is set to 1, the initial value of the signal will be the lower bound. When it is set to 2, the initial value will be the upper bound. In else case, it generates an error.
      </SP>
      <SP>
      Properties : Type 'pol' of size -1.
      </SP>
    </PARAM_DESCRIPTION>
    </PARAM_ITEM>

    <PARAM_ITEM>
    <PARAM_NAME>Period (sec)</PARAM_NAME>
    <PARAM_DESCRIPTION>
      <SP>
      The period of the square wave.
      </SP>
      <SP>
      Properties : Type 'pol' of size -1.
      </SP>
    </PARAM_DESCRIPTION>
    </PARAM_ITEM>

  </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='GOTO' type='XML'>
  <PARAM>
    <PARAM_INDENT>
      <PARAM_ITEM>
	<PARAM_NAME>Tag</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    Ce paramètre définit le label de ce bloc.
	  </SP>
	  <SP>
	    Propriétés : Type 'str' de taille -1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
	<PARAM_NAME>Tag Visibility(1=Local 2=scoped 3= global)</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
            Ce paramètre définit la porté du label de ce bloc.
            Elle peut être locale(1), scoped(2) ou globale(3).
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
    </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='GOTOMO' type='XML'>
  <PARAM>
    <PARAM_INDENT>
      <PARAM_ITEM>
	<PARAM_NAME>Tag</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    This parameter identifies the Goto block whose
	    scope is defined in this block.
	  </SP>
	  <SP>
	    Propriétés : Type 'str' de taille -1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
	<PARAM_NAME>Tag Visibility(1=Local 2=scoped 3= global)</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    This parameter idetifies the visibility of the block.
	    It can be local(1), scoped(2) or global(3).
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
    </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='GotoTagVisibility' type='XML'>
  <PARAM>
    <PARAM_INDENT>
      <PARAM_ITEM>
	<PARAM_NAME>GotoTag</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    The Goto block tag whose visibility is defined by the
	    location of this block.
	  </SP>
	  <SP>
	    Propriétés : Type 'str' de taille -1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
    </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='GotoTagVisibilityMO' type='XML'>
  <PARAM>
    <PARAM_INDENT>
      <PARAM_ITEM>
	<PARAM_NAME>GotoTag</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    The Goto block tag whose visibility is defined by the
	    location of this block.
	  </SP>
	  <SP>
	    Propriétés : Type 'str' de taille -1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
    </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='Ground' type='XML'>
<PARAM>
<PARAM_INDENT>

</PARAM_INDENT>
</PARAM>
</FILE>

<FILE name='Ground_g' type='XML'>
  <PARAM>
    <PARAM_INDENT>

  </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='Gyrator' type='XML'>
  <PARAM>
    <PARAM_INDENT>

    <PARAM_ITEM>
    <PARAM_NAME>G1</PARAM_NAME>
    <PARAM_DESCRIPTION>
      <SP>
      Gyration conductance (-i2/v1) .
      </SP>
      <SP>
      Propriétés : Type 'vec' de taille 1.
      </SP>
    </PARAM_DESCRIPTION>
    </PARAM_ITEM>

    <PARAM_ITEM>
    <PARAM_NAME>G2</PARAM_NAME>
    <PARAM_DESCRIPTION>
      <SP>
      Gyration conductance (i1/v2).
      </SP>
      <SP>
      Propriétés : Type 'vec' de taille 1.
      </SP>
    </PARAM_DESCRIPTION>
    </PARAM_ITEM>

  </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='HALT_f' type='XML'>
  <PARAM>
    <PARAM_INDENT>
      <PARAM_ITEM>
	<PARAM_NAME>State on halt</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    Un scalaire à valeur réelle donnant l'état du bloc lors de l'arret.
	    Cela permet de distinguer différents bloc 'STOP' entre eux
	    (lors de la correction des 'bugs').
	  </SP>
	  <SP>
	    Propriétes : Type 'vec' de taille 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
    </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='HYSTHERESIS' type='XML'>
  <PARAM>
    <PARAM_INDENT>
      <PARAM_ITEM>
	<PARAM_NAME>switch on at</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    Un scalaire à valeur réelle donnant la valeur du point
	    de commutation ouvert. La donnée en entrée est convertie
	    en utilisant une approximation de type 'arrondie au plus proche'.
	  </SP>
	  <SP>
	    Propriétes : Type 'vec' de taille 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
	<PARAM_NAME>switch off at</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    Un scalaire à valeur réelle donnant la valeur du point
	    de commutation fermé. La donnée en entrée est convertie
	    en utilisant une approximation de type 'arrondie au plus proche'.
	  </SP>
	  <SP>
	    Propriétes : Type 'vec' de taille 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
	<PARAM_NAME>output when on</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    Un scalaire à valeur réelle donnant la valeur en
	    sortie du bloc lorsque le cycle est à l'état ouvert.
	  </SP>
	  <SP>
	    Propriétes : Type 'vec' de taille 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
	<PARAM_NAME>output when off</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    Un scalaire à valeur réelle donnant la valeur en sortie
	    du bloc lorsque le cycle est à l'état fermé.
	  </SP>
	  <SP>
	    Propriétes : Type 'vec' de taille 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
	<PARAM_NAME>use zero crossing: yes (1), no (0)</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    A sélectionner pour permettre la détection de zéro.
	  </SP>
	  <SP>
	    Propriétes : Type 'vec' de taille 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
    </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='IFTHEL_f' type='XML'>
  <PARAM>
    <PARAM_INDENT>
      <PARAM_ITEM>
	<PARAM_NAME>Inherit (1: no, 0: yes)</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    Si 'no' est sélectionné, alors le bloc est activé
	    par son port événementiel d'entrée, sinon il est activé
	    par les événements hérités via son port régulier d'entrée.
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
	<PARAM_NAME>zero-crossing (0: no, 1: yes)</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    A sélectionner pour permettre la détection de zéro.
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
    </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='IMPSPLIT_f' type='XML'>
<PARAM>
<PARAM_INDENT>

</PARAM_INDENT>
</PARAM>
</FILE>

<FILE name='INIMPL_f' type='XML'>
  <PARAM>
    <PARAM_INDENT>
      <PARAM_ITEM>
	<PARAM_NAME>Port number</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    Spécifie le numéro du port d'entrée.
	  </SP>
	  <SP>
            Propriétés : Type 'vec' de taille 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
    </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='INTEGRAL' type='LATEX'>
\begin{itemize}
  %Initial Condition   0
  \item {\bf Initial Condition} \\
         Un vecteur ou un scalaire définissant les conditions initiales.\\
         Propriétés : Type 'vec' de taille -1.

  %With re-intialization (1:yes, 0:no)   0
  \item {\bf With re-intialization} \\
        Si ce paramètre est mis à {\bf 1}, celui-ci permet la 
        réinitialisation de l'état à une condition
        initiale définie par la valeur présente sur le deuxième port
        d'entrée régulier.\\
        Propriétés : Type 'vec' de taille 1.

  %With saturation (1:yes, 0:no)   0
  \item {\bf With saturation} \\
        Si ce paramètre est placé à 1, alors les états sont limités
        à des valeurs qui seront comprises entre la limite basse de
        saturation (Lower limit) et la limite haute de saturation
        (Upper limit).\\
        Propriétés : Type 'vec' de taille 1.

  %Upper limit   1
  \item {\bf Upper limit} \\
        La limite haute de saturation de l'intégration.\\
        Propriétés : Type 'vec' de taille -1.

  %Lower limit   -1
  \item {\bf Lower limit} \\
        La limite basse de saturation de l'intégration.\\
        Propriétés : Type 'vec' de taille -1.
\end{itemize}
</FILE>

<FILE name='INTEGRAL_f' type='LATEX'>
\begin{itemize}
  %Initial Condition   0
  \item {\bf Initial Condition} \\
         Un scalaire définissant la condition initiale.\\
         Propriétés : Type 'vec' de taille 1.
\end{itemize}
</FILE>

<FILE name='INTEGRAL_m' type='LATEX'>
\begin{itemize}
  %Initial Condition   0
  \item {\bf Initial Condition} \\
         Un vecteur ou un scalaire définissant les conditions initiales.\\
	 La définition du type de donnée en entrée/sortie est définit
         grâce à ce paramètre. Le type peut être réel ou complexe.\\
         Propriétés : Type 'mat' de taille [-1,-1].

  %With re-intialization (1:yes, 0:no)   0
  \item {\bf With re-intialization} \\
        Si ce paramètre est mis à {\bf 1}, celui-ci permet la 
        réinitialisation de l'état à une condition
        initiale définie par la valeur présente sur le deuxième port
        d'entrée régulier.\\
        Propriétés : Type 'vec' de taille 1.

  %With saturation (1:yes, 0:no)   0
  \item {\bf With saturation} \\
        Si ce paramètre est placé à 1, alors les états sont limités
        à des valeurs qui seront comprises entre la limite basse de
        saturation (Lower limit) et la limite haute de saturation
        (Upper limit).\\
        Propriétés : Type 'vec' de taille 1.

  %Upper limit   1
  \item {\bf Upper limit} \\
        La limite haute de saturation de l'intégration.\\
         Propriétés : Type 'mat' de taille [-1,-1].

  %Lower limit   -1
  \item {\bf Lower limit} \\
        La limite basse de saturation de l'intégration.\\
         Propriétés : Type 'mat' de taille [-1,-1].
\end{itemize}
</FILE>

<FILE name='INTMUL' type='XML'>
  <PARAM>
    <PARAM_INDENT>
      <PARAM_ITEM>
	<PARAM_NAME>Datatype (3=int32  4=int16 5=int8 ...)</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    It indicates the type of the input/output data.
	    It support all the integer datatype, number must be
	    between 3 and 8.
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
	<PARAM_NAME>Do on Overflow(0=Nothing 1=Saturate 2=Error)</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    When this parameter is set to zero the result is similar
	    to a normal multiplication of two integer matrix. When it
	    is set to 1, on overflow the block saturate the result.
	    When it is set to 2, on overflow an error message box appears.
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
    </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='INTRP2BLK_f' type='LATEX'>
%automatically generated, please edit
\begin{itemize}

  %X coord.   [0;1]
  \item {\bf X coord.} \\
        un vecteur de taille n (strictement croissant).\\
        Propriétés : Type 'vec' de taille -1

  %Y coord.   [0;1]
  \item {\bf Y coord.} \\
        un vecteur de taille m (strictement croissant).\\
        Propriétés : Type 'vec' de taille -1

  %Z values   [0,1;1,2]
  \item {\bf Z values} \\
        une matrice de taille m,n.\\
        Propriétés : Type 'mat' de taille [-1,-1]

\end{itemize}
</FILE>

<FILE name='INTRPLBLK_f' type='LATEX'>
%automatically generated, please edit
\begin{itemize}

  %X coord.   [0;1]
  \item {\bf X coord.}\\
        un vecteur (strictement croissant).\\
        Propriétés : Type 'vec' de taille -1

  %Y coord.   [0;1]
  \item {\bf Y coord.}\\
        un vecteur (de même taille que $X$).\\
        Propriétés : Type 'vec' de taille -1

\end{itemize}
</FILE>

<FILE name='INVBLK' type='XML'>
  <PARAM>
    <PARAM_INDENT>

  </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='INVBLK_f' type='XML'>
<PARAM>
<PARAM_INDENT>

</PARAM_INDENT>
</PARAM>
</FILE>

<FILE name='IN_f' type='XML'>
  <PARAM>
    <PARAM_INDENT>
      <PARAM_ITEM>
	<PARAM_NAME>Port number</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    un entier qui définit le numéro de port.
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
    </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='ISELECT_f' type='LATEX'>
%automatically generated, please edit
\begin{itemize}

  %number of outputs   2
  \item {\bf number of outputs}\\
        un scalaire. Nombre de sorties régulières et événementielles.\\
	Propriétés : Type 'vec' de taille 1

  %initial connected output   1
  \item {\bf initial connected output}\\
        un entier. Celui ci doit être compris
        entre 1 et le nombre d'entrée.\\
	Propriétés : Type 'vec' de taille 1
\end{itemize}
</FILE>

<FILE name='ISELECT_m' type='LATEX'>
\begin{itemize}

  \item {\bf Datatype(1= real double  2=Complex)}\\
        Ce paramètre indique le type de donnée de la sortie. Ce
	bloc fonctionne uniquement avec des types de donnée
	réels(1) et complexes(2). Si un autre type que 1 et 2 est
	indiqué, alors Scicos retourne le message d'erreur
	"Datatype is not supported". \\
	Propriétés : Type 'vec' de taille 1
	
  %number of outputs   2
  \item {\bf number of outputs}\\
        un scalaire. Nombre de sorties régulières et événementielles.\\
	Propriétés : Type 'vec' de taille 1

  %initial connected output   1
  \item {\bf initial connected output}\\
        un entier. Celui ci doit être compris
        entre 1 et le nombre d'entrée.\\
	Propriétés : Type 'vec' de taille 1
\end{itemize}
</FILE>

<FILE name='IdealTransformer' type='XML'>
  <PARAM>
    <PARAM_INDENT>

    <PARAM_ITEM>
    <PARAM_NAME>N</PARAM_NAME>
    <PARAM_DESCRIPTION>
      <SP>
        Turns ratio (N1/N2)
      </SP>
      <SP>
      Propriétés : Type 'vec' de taille 1.
      </SP>
    </PARAM_DESCRIPTION>
    </PARAM_ITEM>

  </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='Inductor' type='XML'>
  <PARAM>
    <PARAM_INDENT>
      <PARAM_ITEM>
	<PARAM_NAME>L (H)</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    Inductance
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
    </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='JKFLIPFLOP' type='XML'>
  <PARAM>
    <PARAM_INDENT>
      <PARAM_ITEM>
	<PARAM_NAME>Initial Value</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    La valeur initial de l'état Q.
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
    </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='Keyboard_shortcuts' type='XML'>
<PARAM>
<PARAM_INDENT>

</PARAM_INDENT>
</PARAM>
</FILE>

<FILE name='LOGBLK_f' type='LATEX'>
%automatically generated, please edit
\begin{itemize}

  %Basis ($>$1)   \%e
  \item {\bf Basis} \\
        Un scalaire plus grand que 1.\\
        Propriétés : Type 'vec' de taille 1.

\end{itemize}
</FILE>

<FILE name='LOGIC' type='XML'>
  <PARAM>
    <PARAM_INDENT>
      <PARAM_ITEM>
	<PARAM_NAME>Truth table</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    The matrix of outputs. For more information see
	    the description part.
	  </SP>
	  <SP>
	    Propriétés : Type 'mat' de taille [-1,-2].
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>

      <PARAM_ITEM>
	<PARAM_NAME>Inherit(0=no 1=yes)</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    Specifies if the clock is inherit or not.
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
    </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='LOGICAL_OP' type='LATEX'>
%automatically generated, please edit
\begin{itemize}

  %number of inputs   2
  \item {\bf number of inputs}\\
        Le nombre d'entrées du bloc. La valeur doit
        être appropriée pour l'opérateur sélectionné.\\
	Propriétés : Type 'vec' de taille 1

  %Operator: AND (0), OR (1), NAND (2), NOR (3), XOR (4), NOT (5)   0
  \item {\bf Operator: AND }\\
        L'opérateur logique à appliquer  aux entrées du bloc.
        Les choix valides sont ceux proposés dans la liste.\\
	Propriétés : Type 'vec' de taille 1
\end{itemize}
</FILE>

<FILE name='LOOKUP2D' type='XML'>
  <PARAM>
    <PARAM_INDENT>

    <PARAM_ITEM>
    <PARAM_NAME>Row index input values</PARAM_NAME>
    <PARAM_DESCRIPTION>
      <SP>
      The row values for the table, entered as a row or column vector.
       The vector values must be strictly monotonic increasing.
      </SP>
      <SP>
      Propriétés : Type 'vec' de taille -1.
      </SP>
    </PARAM_DESCRIPTION>
    </PARAM_ITEM>

    <PARAM_ITEM>
    <PARAM_NAME>Column index input values</PARAM_NAME>
    <PARAM_DESCRIPTION>
      <SP>
            The column values for the table, entered as a row or column vector.
       The vector values must be strictly monotonic increasing.
      </SP>
      <SP>
      Propriétés : Type 'vec' de taille -1.
      </SP>
    </PARAM_DESCRIPTION>
    </PARAM_ITEM>

    <PARAM_ITEM>
    <PARAM_NAME>Table data</PARAM_NAME>
    <PARAM_DESCRIPTION>
      <SP>
     Output value table. The matrix size must match the dimensions
    used in the row index vector and the column index vector.
      </SP>
      <SP>
      Propriétés : Type 'matrix' de taille [-1,-1].
      </SP>
    </PARAM_DESCRIPTION>
    </PARAM_ITEM>

    <PARAM_ITEM>
    <PARAM_NAME>Lookup method(1..5)</PARAM_NAME>
    <PARAM_DESCRIPTION>
      <SP>
      Specify the lookup method:
      </SP>
      <SP>
      1)Interpolation-extrapolation (Bilinear) method: Performs a bilinear interpolation when inputs are inside the
    table range and  uses a bilinear extrapolation using two
    endpoints of the table if inputs are outside the table input ranges.
      </SP>
      <SP>
      2)Interpolation-endvalues (Bilinear) method: Performs a bilinear interpolation when inputs are inside the
    table range and  uses table endvalues if if inputs are outside the table input ranges.
      </SP>
      <SP>
      3)InputNearest: This method does not interpolate or
    extrapolate. Instead, the elements in row and column vectors nearest the current
    inputs are found. The corresponding element in the table is then used as
    the output.

      </SP>
      <SP>
      4)InputBelow: This method does not interpolate or
    extrapolate. Instead, the elements in row and column vectors below the current
    inputs are found. The corresponding element in the table is then used as
    the output.
      </SP>
      <SP>
      5)InputAbove: This method does not interpolate or
    extrapolate. Instead, the elements in row and column vectors above the current
    inputs are found. The corresponding element in the table is then used as
    the output.
      </SP>

      <SP>
      Propriétés : Type 'vec' de taille 1.
      </SP>
    </PARAM_DESCRIPTION>
    </PARAM_ITEM>

    <PARAM_ITEM>
    <PARAM_NAME>Launch graphic window(y/n)?</PARAM_NAME>
    <PARAM_DESCRIPTION>
      <SP>
      If set to 'y', clicking on OK, the 3D plot of the table will be
    shown.
This parameter is automatically reset to 'n'.
      </SP>
      <SP>
      Propriétés : Type 'str' de taille 1.
      </SP>
    </PARAM_DESCRIPTION>
    </PARAM_ITEM>

  </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='LOOKUP_c' type='LATEX'>
\begin{itemize}

\item  {\bf Spline Interpolation method (0..9):} accepted values $0,
    1, 2, 3, 4, 5, 6, 7, 8, 9$.

  This parameter defines the spline method for interpolating the
    points. The Signal builder block computes a linear or a cubic
    spline or sub-spline $S$ which interpolates the $(x_i,y_i)$
    points, i.e., we have $S(x_i)=y_i$ for all $i=1,..,n$.  Several
    kind of splines may be computed by selecting the appropriate
    spline method:

\begin{itemize}

\item {\bf 0: "Zero order method (Use Input Below)"}.  This method
    does not interpolate or extrapolate. Instead, the element in x
    nearest and below the current input is found, i.e., for $t_{i}
    \leq t < t_{i+1}$, $y(t)=y_{i}$. The corresponding element in y is
    then used as the output. If there is no element in x below the
    current input, then the nearest element is found.

\item {\bf 1: "Linear interpolation method"}.  This is the default
method; it performs linear interpolation of the inputs. If a value
matches the block's input, the output is the corresponding element in
the output vector. If no value matches the block's input, then the
block performs linear interpolation between the two appropriate
elements of the table to determine an output value, i.e., for $t_i
\leq t < t_{i+1}$, $y(t)=y_i+(t-t_i)(y_{i+1}-y_i)/(t_{i+1}-t_i)$.  If
the block input is less than the first or greater than the last input
vector element, then the block extrapolates using the first two or
last two points.

\item {\bf 2: "Order 2 method"}. The interpolation is done by passing
    2-order polynomials between $(x_i,y_i)$ and
    $(x_{i+1},y_{i+1})$. The Derivative at $(x_i,y_i)$ is identical
    for two adjacent polynomials. The derivative at $(x_1,y_1)$
    can be selected arbitrary, so it is selected such that the sum of
    derivatives at all points be minimum. This condition provides a
    less fluctuated signal.

\item {\bf 3:"not\_a\_knot"}. The cubic spline is computed by using the
    following conditions (considering $n$ points $x_1,...,x_n$):
    $$S^{(3)}(x_2^-) = S^{(3)}(x_2^+)$$ $$S^{(3)}(x_{n-1}^-) =
    S^{(3)}(x_{n-1}^+)$$

\item {\bf 4:"periodic"}. A periodic cubic spline is computed ($y$
    must verify $y_1=y_n$) by using the conditions:  \\$$S^{'}(x_1) =
    S^{'}(x_n)$$ \\$$S^{''}(x_1) = S^{''}(x_n)$$.\\ In this case the value
    of $y_n$ is ignored and $y_1$ is used instead. Note that in order
    to generate a periodic signal, {\it Periodic} flag should be
    activated.

\item {\bf 5:"monotone"}. In this case a sub-spline ($S$ is only one
    continuously differentiable) is computed such that $S$ is monotone
    on each interval: \\ if $y_i \le y_{i+1}$, $S$ is increasing on
    $[x_i, x_{i+1}]$. \\ if $y_i \> y_{i+1}$, $S$ is decreasing on
    $[x_i, x_{i+1}]$.

\item {\bf 6:"clamped"}. In this case the cubic spline is computed by
    using the end points derivatives which are set to zero, i.e.,
    $$S^{'}(x_1) = S^{'}(x_n)=0$$

\item {\bf 7:"fast"}. In this case a sub-spline is computed by using a
    simple local scheme for the derivative at $x_i$ of the
    interpolation polynomial of $(x_{i-1},y_{i-1})$, $(x_{i},y_{i})$,
    $(x_{i+1},y_{i+1})$, except for the end points (derivative at
    these points are computed from the 3 left most points and the 3
    right most points).

\item {\bf 8: "Zero order method (Use Input-above)"}. 
This method does not interpolate or extrapolate. Instead, the element
in x nearest and above the current input is found, i.e., for $t_{i}
    \leq t < t_{i+1}$, $y(t)=y_{i+1}$.. The corresponding
element in y is then used as the output. If there is no element in x
above the current input, then the nearest element is found.

\item {\bf 9: "Zero order method (Use Input-nearest)"}. This method
 does not interpolate or extrapolate. Instead, the element in x
 nearest the current input is found. The corresponding element in y is
 then used as the output.

\end{itemize}

\item {\bf x:} Abscissa data vector (X-axis). This vector can be
   either a row or a column vector of double data.   Further mor it
   should be monotonic increasing. This vector can
   be also defined in the Scicos context. The data vector can be
   specified by mathematical formula.

\item {\bf y:} Ordinate data vector (Y-axis). This vector can be
   either a row or a column vector of double data. Not that the size
   of X and Y vector should be the same. This vector can be also
   defined in the Scicos context. The data vector can also be
   specified by formula.


\item {\bf Extrapolate method (0,1):} 
If the block input is less
than the first or greater than the last input vector element, then 

\begin{itemize}
\item: {\bf 0}  the block uses the first  or last  point as output.
\item: {\bf 1}  the block extrapolates using the first two or last two
points.
\end{itemize}

\item {\bf Launch graphic window(y/n)?:} If {\bf y} is selected, by
   clicking on {\bf OK} button, a graphical window is launched. In
   this 2D graphical window, the user can edit data points: 
\end{itemize}

</FILE>

<FILE name='LOOKUP_f' type='XML'>
<PARAM>
<PARAM_INDENT>

</PARAM_INDENT>
</PARAM>
</FILE>

<FILE name='MATBKSL' type='XML'>
  <PARAM>
    <PARAM_INDENT>
      <PARAM_ITEM>
	<PARAM_NAME>Datatype (1=real double  2=Complex)</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
           Ce paramètre indique le type de donnée de la sortie. Ce
	   bloc fonctionne uniquement avec des types de donnée
	   réels(1) et complexes(2). Si un autre type que 1 et 2 est
	   indiqué, alors Scicos retourne le message d'erreur
	   "Datatype is not supported".
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
    </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='MATCATH' type='XML'>
  <PARAM>
    <PARAM_INDENT>
      <PARAM_ITEM>
	<PARAM_NAME>Datatype(1=real double  2=Complex)</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
           Ce paramètre indique le type de donnée de la sortie. Ce
	   bloc fonctionne uniquement avec des types de donnée
	   réels(1) et complexes(2). Si un autre type que 1 et 2 est
	   indiqué, alors Scicos retourne le message d'erreur
	   "Datatype is not supported".
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
	<PARAM_NAME>number of columns of each matrix</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    It indicates the number of columns of the inputs matrices.
	  </SP>
	  <SP>
	    Propriétés : Type 'mat' de taille [-1,1].
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
    </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='MATCATV' type='XML'>
  <PARAM>
    <PARAM_INDENT>
      <PARAM_ITEM>
	<PARAM_NAME>Datatype(1=real double  2=Complex)</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
           Ce paramètre indique le type de donnée de la sortie. Ce
	   bloc fonctionne uniquement avec des types de donnée
	   réels(1) et complexes(2). Si un autre type que 1 et 2 est
	   indiqué, alors Scicos retourne le message d'erreur
	   "Datatype is not supported".
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
	<PARAM_NAME>number of line of each matrix</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    It indicates the number of rows of the inputs matrices.
	  </SP>
	  <SP>
	    Propriétés : Type 'mat' de taille [-1,1].
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
    </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='MATDET' type='XML'>
  <PARAM>
    <PARAM_INDENT>
      <PARAM_ITEM>
	<PARAM_NAME>Datatype(1=real double  2=Complex)</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
           Ce paramètre indique le type de donnée de la sortie. Ce
	   bloc fonctionne uniquement avec des types de donnée
	   réels(1) et complexes(2). Si un autre type que 1 et 2 est
	   indiqué, alors Scicos retourne le message d'erreur
	   "Datatype is not supported".
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
    </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='MATDIAG' type='XML'>
  <PARAM>
    <PARAM_INDENT>
      <PARAM_ITEM>
	<PARAM_NAME>Datatype (1=real double  2=Complex)</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
           Ce paramètre indique le type de donnée de la sortie. Ce
	   bloc fonctionne uniquement avec des types de donnée
	   réels(1) et complexes(2). Si un autre type que 1 et 2 est
	   indiqué, alors Scicos retourne le message d'erreur
	   "Datatype is not supported".
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
    </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='MATDIV' type='XML'>
  <PARAM>
    <PARAM_INDENT>
      <PARAM_ITEM>
	<PARAM_NAME>Datatype(1=real double  2=Complex)</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
           Ce paramètre indique le type de donnée de la sortie. Ce
	   bloc fonctionne uniquement avec des types de donnée
	   réels(1) et complexes(2). Si un autre type que 1 et 2 est
	   indiqué, alors Scicos retourne le message d'erreur
	   "Datatype is not supported".
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
    </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='MATEIG' type='XML'>
  <PARAM>
    <PARAM_INDENT>
      <PARAM_ITEM>
	<PARAM_NAME>Datatype(1=real double  2=Complex)</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
           Ce paramètre indique le type de donnée de la sortie. Ce
	   bloc fonctionne uniquement avec des types de donnée
	   réels(1) et complexes(2). Si un autre type que 1 et 2 est
	   indiqué, alors Scicos retourne le message d'erreur
	   "Datatype is not supported".
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
	<PARAM_NAME>decomposition type (1=eig values  2=eig values+eig vectors</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    To select the form of the output.
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
    </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='MATEXPM' type='XML'>
  <PARAM>
    <PARAM_INDENT>
      <PARAM_ITEM>
	<PARAM_NAME>Datatype(1=real double  2=Complex)</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
           Ce paramètre indique le type de donnée de la sortie. Ce
	   bloc fonctionne uniquement avec des types de donnée
	   réels(1) et complexes(2). Si un autre type que 1 et 2 est
	   indiqué, alors Scicos retourne le message d'erreur
	   "Datatype is not supported".
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
    </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='MATINV' type='XML'>
  <PARAM>
    <PARAM_INDENT>
      <PARAM_ITEM>
	<PARAM_NAME>Datatype(1=real double  2=Complex)</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
           Ce paramètre indique le type de donnée de la sortie. Ce
	   bloc fonctionne uniquement avec des types de donnée
	   réels(1) et complexes(2). Si un autre type que 1 et 2 est
	   indiqué, alors Scicos retourne le message d'erreur
	   "Datatype is not supported".
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
    </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='MATLU' type='XML'>
  <PARAM>
    <PARAM_INDENT>
      <PARAM_ITEM>
	<PARAM_NAME>Datatype(1=real double  2=Complex)</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
           Ce paramètre indique le type de donnée de la sortie. Ce
	   bloc fonctionne uniquement avec des types de donnée
	   réels(1) et complexes(2). Si un autre type que 1 et 2 est
	   indiqué, alors Scicos retourne le message d'erreur
	   "Datatype is not supported".
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
    </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='MATMAGPHI' type='XML'>
  <PARAM>
    <PARAM_INDENT>
      <PARAM_ITEM>
	<PARAM_NAME>decomposition type (1=Complex2MAG&amp;PHI 2=MAG&amp;PHI2Complex)</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    It indicates the rule of the conversion.
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
    </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='MATMUL' type='XML'>
  <PARAM>
    <PARAM_INDENT>
      <PARAM_ITEM>
	<PARAM_NAME>Datatype(1=real double 2=Complex)</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
           Ce paramètre indique le type de donnée de la sortie. Ce
	   bloc fonctionne uniquement avec des types de donnée
	   réels(1) et complexes(2). Si un autre type que 1 et 2 est
	   indiqué, alors Scicos retourne le message d'erreur
	   "Datatype is not supported".
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
	<PARAM_NAME>Multiplication rule (1= * 2= .* )</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    ?
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
    </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='MATPINV' type='XML'>
  <PARAM>
    <PARAM_INDENT>
      <PARAM_ITEM>
	<PARAM_NAME>Datatype(1=real double  2=Complex)</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
           Ce paramètre indique le type de donnée de la sortie. Ce
	   bloc fonctionne uniquement avec des types de donnée
	   réels(1) et complexes(2). Si un autre type que 1 et 2 est
	   indiqué, alors Scicos retourne le message d'erreur
	   "Datatype is not supported".
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
    </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='MATRESH' type='XML'>
  <PARAM>
    <PARAM_INDENT>
      <PARAM_ITEM>
	<PARAM_NAME>Datatype(1=real double  2=Complex)</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
           Ce paramètre indique le type de donnée de la sortie. Ce
	   bloc fonctionne uniquement avec des types de donnée
	   réels(1) et complexes(2). Si un autre type que 1 et 2 est
	   indiqué, alors Scicos retourne le message d'erreur
	   "Datatype is not supported".
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille -1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
	<PARAM_NAME>input size</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    It indicates the size of the input matrix.
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille -1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
	<PARAM_NAME>output size desired</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    It indicates the desired output's size.
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille -1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
    </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='MATSING' type='XML'>
  <PARAM>
    <PARAM_INDENT>
      <PARAM_ITEM>
	<PARAM_NAME>Datatype(1=real double  2=Complex)</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
           Ce paramètre indique le type de donnée de la sortie. Ce
	   bloc fonctionne uniquement avec des types de donnée
	   réels(1) et complexes(2). Si un autre type que 1 et 2 est
	   indiqué, alors Scicos retourne le message d'erreur
	   "Datatype is not supported".
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
	<PARAM_NAME>decomposition type (1=singular values  2=sing values+matrix U &amp; V)</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    It indicates the form of the output. When it is set to one,
            we have a unique vector output (singular values). When it
            is set to two we have three same sizes matrices(U,S,V).
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
    </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='MATSUM' type='XML'>
  <PARAM>
    <PARAM_INDENT>
      <PARAM_ITEM>
	<PARAM_NAME>Datatype(1=real double  2=Complex)</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
           Ce paramètre indique le type de donnée de la sortie. Ce
	   bloc fonctionne uniquement avec des types de donnée
	   réels(1) et complexes(2). Si un autre type que 1 et 2 est
	   indiqué, alors Scicos retourne le message d'erreur
	   "Datatype is not supported".
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
	<PARAM_NAME>Sum along (0=all 1=lines  2=Columns)</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    Indicates the used rule to sum. For more information see the
            description part.
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
    </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='MATTRAN' type='XML'>
  <PARAM>
    <PARAM_INDENT>
      <PARAM_ITEM>
	<PARAM_NAME>Datatype(1=real double  2=Complex)</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
           Ce paramètre indique le type de donnée de la sortie. Ce
	   bloc fonctionne uniquement avec des types de donnée
	   réels(1) et complexes(2). Si un autre type que 1 et 2 est
	   indiqué, alors Scicos retourne le message d'erreur
	   "Datatype is not supported".
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
    </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='MATZCONJ' type='XML'>
<PARAM>
<PARAM_INDENT>

</PARAM_INDENT>
</PARAM>
</FILE>

<FILE name='MATZREIM' type='XML'>
  <PARAM>
    <PARAM_INDENT>
      <PARAM_ITEM>
	<PARAM_NAME>decomposition type (1=Complex2Real&amp;Imag 2=Real&amp;Imag2Complex)</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    Indicates the type to use for the decomposition.
            See the description part for more information.
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
    </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='MAXMIN' type='LATEX'>
%automatically generated, please edit
\begin{itemize}

  %Min (1) or Max (2)    2
  \item {\bf Min or Max} \\
        La fonction (min ou max) à appliquer à l'entrée.\\
        Propriétés : Type 'vec' de taille 1.

  %Number of input vectors (1 or 2)   1
  \item {\bf Number of input vectors} \\
        Le nombre d'entrées du bloc. \\
        Propriétés : Type 'vec' de taille 1.

  %zero-crossing (1: yes, 0;no)   1
  \item {\bf zero-crossing} \\
        Sélectionnez ce paramètre pour permettre
        l'utilisation de la détection 'zero crossing'
        pour déterminer les valeurs minimales et maximales.\\
        Propriétés : Type 'vec' de taille 1.

\end{itemize}
</FILE>

<FILE name='MAX_f' type='XML'>
<PARAM>
<PARAM_INDENT>

</PARAM_INDENT>
</PARAM>
</FILE>

<FILE name='MBLOCK' type='LATEX'>
\begin{itemize}
  \item {\bf Input variables}\\
        In this filed, the ports connected to the left hand side of the block are
        defined. If the port is an explicit port, it will be an input port. In
        this case, the variable should be declared in the Modelica program as
        Real. If the port is an implicit port, the variable desinating this
        port should be a "connector". Remind that for implicit port, the
        notion of input and output does not exist and specifying an implicit
        variable in this filed is just placing the port at the left hend side
        of the block.

  \item {\bf Input variables types}\\
        In this filed, the type of ports are specified, i.e., 'I' for implicit
        ports and 'E' for explicit ports. The size of the vector of "input
        variables" and the vector of "input\_vector\_type" should be equal.

  \item {\bf Output variables}\\
        Similar to the input variables vector, the explicit
        output variables and implicit variables which are displayed at the right
        hand side of the block are specified in this filed.

   \item {\bf Output variables types}\\
         The type of variables given in the Output
         variable vector are specified, i.e., 'I' for implicit ports and 'E'
         for explicit ports.

   \item {\bf Parameters in Modelica}\\
         The values of parameters declared in the Modelica program can be
         overloaded. To overload a parameter value, the name of parameters are given in
         this field and their corresponding values are given in the "parameter
         values" fields that are displayed in the second dialog box.

   \item {\bf Parameters properties}\\
         The type of the Modelica parameters. For that time being, one can parametrize
         three types of Modelica variable :
         \begin{itemize}
             \item {\bf 0 :} the parameter is set to be a {\bf Modelica parameter} variable (scalar or vector).

             \item {\bf 1 :} the parameter is set to be an {\bf initial condition of Modelica state} variable
                             (scalar or vector).

             \item {\bf 2 :} the parameter is set to be an {\bf initial condition of Modelica state} variable
                             with the property {\bf fixed=true} (scalar or vector).
         \end{itemize}

    \item {\bf Function name}\\
          The Modelica class name is specified in this filed.  If the Modelica
          class name is specified without any path or extension, an interactive
          window is opened and the user can write or edit the Modelica
          program. This window is opened each time the user clicks on the
          block. If the Modelica class name is specified with path and '.mo'
          extension, the compiler looks for the file and if it is found, the
          file will be compiled, otherwise a window is opened and the user can
          write the Modelica program. This Modelica file will be saved with the
          given filename in the specified path. The next time, only input/output
          characteristics of the block can be changed, and the Modelica file
          should be edited with another text editor.

    \item {\bf Parameter values}\\
          The value of Modelica parameters are given in the "Set parameters values"
          dialog box.

          \begin{figure}
            \begin{center}
              \epsfig{file=MBLOCK_1_1_gui.eps,width=200pt}
            \end{center}
          \end{figure}

          These values that can be scalar or vector, can also be defined in the
          Scicos context. In order to access the Scicos context, click on the
          "Diagram" menu then click on the "Context" submenu.
          For instance, here is an example of overloading of parameters in a Modelica program.

          \begin{verbatim}
Class Example
parameter Real Speed=12.0;
          Real Position[3](start={0.0,0.1,0.5},fixed={true,true,true});
          Real Length[2](start={13.0,12.1});
 ...
equation
  ...
end Example;
          \end{verbatim}

          Parameters vector  = ['Speed';'Position';"Length"]\\
          Parameters properties vector  = [0;2;1]

          Speed value        =  [12.0]\\
          Position value     =  [0.0 ; 0.1 ; POS]\\
          Length value       =  [13.0 ; 12.1]\\

\end{itemize}
</FILE>

<FILE name='MCLOCK_f' type='XML'>
  <PARAM>
    <PARAM_INDENT>
      <PARAM_ITEM>
	<PARAM_NAME>basic period (1/f)</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    La description du paramètre 1.
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
	<PARAM_NAME>multiply by (n)</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    La description du paramètre 2.
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
    </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='MEMORY_f' type='XML'>
  <PARAM>
    <PARAM_INDENT>
      <PARAM_ITEM>
	<PARAM_NAME>initial condition</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    La description du paramètre 1.
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille -1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
	<PARAM_NAME>Inherit (1: no, 0: yes)</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    La description du paramètre 2.
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
    </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='MFCLCK_f' type='XML'>
  <PARAM>
    <PARAM_INDENT>
      <PARAM_ITEM>
	<PARAM_NAME>basic period (1/f)</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    La description du paramètre 1.
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
	<PARAM_NAME>multiply by (n)</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    La description du paramètre 2.
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
    </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='MIN_f' type='XML'>
<PARAM>
<PARAM_INDENT>

</PARAM_INDENT>
</PARAM>
</FILE>

<FILE name='MOTOR' type='XML'>
<PARAM>
<PARAM_INDENT>

</PARAM_INDENT>
</PARAM>
</FILE>

<FILE name='MPBLOCK' type='XML'>
  <PARAM>
    <PARAM_INDENT>

    <PARAM_ITEM>
    <PARAM_NAME>Input variables:       </PARAM_NAME>
    <PARAM_DESCRIPTION>
      <SP>
      La description du paramètre 1.
      </SP>
      <SP>
      Propriétés : Type 'str' de taille -1.
      </SP>
    </PARAM_DESCRIPTION>
    </PARAM_ITEM>

    <PARAM_ITEM>
    <PARAM_NAME>Input variables types: </PARAM_NAME>
    <PARAM_DESCRIPTION>
      <SP>
      La description du paramètre 2.
      </SP>
      <SP>
      Propriétés : Type 'str' de taille -1.
      </SP>
    </PARAM_DESCRIPTION>
    </PARAM_ITEM>

    <PARAM_ITEM>
    <PARAM_NAME>Output variables:      </PARAM_NAME>
    <PARAM_DESCRIPTION>
      <SP>
      La description du paramètre 3.
      </SP>
      <SP>
      Propriétés : Type 'str' de taille -1.
      </SP>
    </PARAM_DESCRIPTION>
    </PARAM_ITEM>

    <PARAM_ITEM>
    <PARAM_NAME>Output variables types:</PARAM_NAME>
    <PARAM_DESCRIPTION>
      <SP>
      La description du paramètre 4.
      </SP>
      <SP>
      Propriétés : Type 'str' de taille -1.
      </SP>
    </PARAM_DESCRIPTION>
    </PARAM_ITEM>

    <PARAM_ITEM>
    <PARAM_NAME>Parameters in Modelica:</PARAM_NAME>
    <PARAM_DESCRIPTION>
      <SP>
      La description du paramètre 5.
      </SP>
      <SP>
      Propriétés : Type 'str' de taille -1.
      </SP>
    </PARAM_DESCRIPTION>
    </PARAM_ITEM>

    <PARAM_ITEM>
    <PARAM_NAME>Parameters properties: </PARAM_NAME>
    <PARAM_DESCRIPTION>
      <SP>
      La description du paramètre 6.
      </SP>
      <SP>
      Propriétés : Type 'vec' de taille -1.
      </SP>
    </PARAM_DESCRIPTION>
    </PARAM_ITEM>

    <PARAM_ITEM>
    <PARAM_NAME>Model name in packages:</PARAM_NAME>
    <PARAM_DESCRIPTION>
      <SP>
      La description du paramètre 7.
      </SP>
      <SP>
      Propriétés : Type 'str' de taille -1.
      </SP>
    </PARAM_DESCRIPTION>
    </PARAM_ITEM>

  </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='MUX' type='LATEX'>
%automatically generated, please edit
\begin{itemize}

  %number of input ports or vector de tailles   2
  \item {\bf number of input ports or vector de tailles}\\
        un entier supérieur ou égal à 1 et plus petit que 8.\\
        Propriétés : Type 'vec' de taille -1.
\end{itemize}
</FILE>

<FILE name='MUX_f' type='LATEX'>
%automatically generated, please edit
\begin{itemize}

  %number of input ports or vector de tailles   2
  \item {\bf number of input ports or vector de tailles}\\
        un entier supérieur ou égal à 1 et plus petit que 8.\\
        Propriétés : Type 'vec' de taille -1.
\end{itemize}
</FILE>

<FILE name='M_SWITCH' type='LATEX'>
%automatically generated, please edit
\begin{itemize}

  %number of inputs   2
  \item {\bf number of inputs}\\
        Spécifie le nombre d'entrées de donnée du bloc.\\
	Propriétés : Type 'vec' de taille 1

  %zero base indexing (0), otherwise 1   1
  \item {\bf zero base indexing }\\
        Si ce paramètre est sélectionnée, le bloc
        utilise des indices commencant par 0, sinon
        commencant par 1.\\
	Propriétés : Type 'vec' de taille 1

  %rounding rule: int (0), round (1), ceil (2), floor (3)   3
  \item {\bf rounding rule: int }\\
        Sélectionne le mode d'arrondi pour la sortie.\\
	Propriétés : Type 'vec' de taille 1
\end{itemize}
</FILE>

<FILE name='M_freq' type='XML'>
  <PARAM>
    <PARAM_INDENT>
      <PARAM_ITEM>
	<PARAM_NAME>Sample time</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
           Vecteur des instants d'échantilonnage.
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille -1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
	<PARAM_NAME>Offset</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
            Vecteur des valeurs de décalage.
            Doit avoir la même taille que le vecteur des instants
	    d'échantillonnage. Chaque valeur doit être inférieure
	    à la valeur correspondant de l'instant d'échantillonnage.
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille -1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
    </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='Menu_entries' type='XML'>
<PARAM>
<PARAM_INDENT>

</PARAM_INDENT>
</PARAM>
</FILE>

<FILE name='ModelicaBlocks' type='XML'>
  <PARAM>
  <PARAM_INDENT>

  </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='Modulo_Count' type='LATEX'>
%automatically generated, please edit
\begin{itemize}

  %initial state ($>$=0)   0
  \item {\bf initial state} \\
         Un état initial discret scalaire.\\
         Propriétés : Type 'vec' de taille 1

  %Modulo what number ($>$0)   3
  \item {\bf Modulo what number} \\
         Nombre de signaux discrets requis.\\
         Propriétés : Type 'vec' de taille 1

\end{itemize}
</FILE>

<FILE name='Multiwindow' type='XML'>
  <PARAM>

  </PARAM>
</FILE>

<FILE name='NEGTOPOS_f' type='XML'>
<PARAM>
<PARAM_INDENT>

</PARAM_INDENT>
</PARAM>
</FILE>

<FILE name='NMOS' type='XML'>
  <PARAM>
    <PARAM_INDENT>

    <PARAM_ITEM>
    <PARAM_NAME>Width [m]</PARAM_NAME>
    <PARAM_DESCRIPTION>
      <SP>
      W
      </SP>
      <SP>
      Propriétés : Type 'vec' de taille 1.
      </SP>
    </PARAM_DESCRIPTION>
    </PARAM_ITEM>

    <PARAM_ITEM>
    <PARAM_NAME>Length [m]</PARAM_NAME>
    <PARAM_DESCRIPTION>
      <SP>
      L
      </SP>
      <SP>
      Propriétés : Type 'vec' de taille 1.
      </SP>
    </PARAM_DESCRIPTION>
    </PARAM_ITEM>

    <PARAM_ITEM>
    <PARAM_NAME>Transconductance parameter [A/(V*V)]</PARAM_NAME>
    <PARAM_DESCRIPTION>
      <SP>
     Beta
      </SP>
      <SP>
      Propriétés : Type 'vec' de taille 1.
      </SP>
    </PARAM_DESCRIPTION>
    </PARAM_ITEM>

    <PARAM_ITEM>
    <PARAM_NAME>Zero bias threshold voltage [V]</PARAM_NAME>
    <PARAM_DESCRIPTION>
      <SP>
      Vt
      </SP>
      <SP>
      Propriétés : Type 'vec' de taille 1.
      </SP>
    </PARAM_DESCRIPTION>
    </PARAM_ITEM>

    <PARAM_ITEM>
    <PARAM_NAME>Bulk threshold parameter</PARAM_NAME>
    <PARAM_DESCRIPTION>
      <SP>
      K2
      </SP>
      <SP>
      Propriétés : Type 'vec' de taille 1.
      </SP>
    </PARAM_DESCRIPTION>
    </PARAM_ITEM>

    <PARAM_ITEM>
    <PARAM_NAME>Reduction of pinch-off region</PARAM_NAME>
    <PARAM_DESCRIPTION>
      <SP>
      K5
      </SP>
      <SP>
      Propriétés : Type 'vec' de taille 1.
      </SP>
    </PARAM_DESCRIPTION>
    </PARAM_ITEM>

    <PARAM_ITEM>
    <PARAM_NAME>Narrowing of channel [m]</PARAM_NAME>
    <PARAM_DESCRIPTION>
      <SP>
      dW
      </SP>
      <SP>
      Propriétés : Type 'vec' de taille 1.
      </SP>
    </PARAM_DESCRIPTION>
    </PARAM_ITEM>

    <PARAM_ITEM>
    <PARAM_NAME>Shortening of channel [m]</PARAM_NAME>
    <PARAM_DESCRIPTION>
      <SP>
      dL
      </SP>
      <SP>
      Propriétés : Type 'vec' de taille 1.
      </SP>
    </PARAM_DESCRIPTION>
    </PARAM_ITEM>

    <PARAM_ITEM>
    <PARAM_NAME>Drain-Source-Resistance [Ohm]</PARAM_NAME>
    <PARAM_DESCRIPTION>
      <SP>
      RDS
      </SP>
      <SP>
      Propriétés : Type 'vec' de taille 1.
      </SP>
    </PARAM_DESCRIPTION>
    </PARAM_ITEM>

  </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='NPN' type='LATEX'>
\begin{table}[h!b!p!]
\begin{tabular}{lll}
\hline
Paramètre & Valeur par d\'efaut & Description \\
\hline
Bf	& 50	  & Forward beta \\
Br	& 0.1	  & Reverse beta\\
Is	& 1.e-16  & Transport saturation current [A]\\
Vak	& 0.02    & Early voltage (inverse), 1/Volt [1/V]\\
Tauf	& 0.12e-9 & Ideal forward transit time [s]\\
Taur	& 5e-9	  & Ideal reverse transit time [s]\\
Ccs	& 1e-12	  & Collector-substrat(ground) cap. [F]\\
Cje	& 0.4e-12 & Base-emitter zero bias depletion cap. [F]\\
Cjc	& 0.5e-12 & Base-coll. zero bias depletion cap. [F]\\
Phie	& 0.8	  & Base-emitter diffusion voltage [V]\\
Me	& 0.4	  & Base-emitter gradation exponent\\
Phic	& 0.8	  & Base-collector diffusion voltage [V]\\
Mc	& 0.333	  & Base-collector gradation exponent\\
Gbc	& 1e-15	  & Base-collector conductance [S]\\
Gbe	& 1e-15	  & Base-emitter conductance [S]\\
Vt	& 0.02585 & Voltage equivalent of temperature [V]\\
EMin	& -100	  & if x < EMin, the exp(x) function is linearized\\
EMax	& 40	  & if x > EMax, the exp(x) function is linearized\\
\hline
\end{tabular}
\end{table}
</FILE>

<FILE name='NRMSOM_f' type='LATEX'>
%automatically generated, please edit
\begin{itemize}

  %number of inputs   2
  \item {\bf number of inputs}\\
        Le nombre de port d'entrée à regrouper.\\
	Propriétés : Type 'vec' de taille 1
\end{itemize}
</FILE>

<FILE name='OUTIMPL_f' type='XML'>
  <PARAM>
    <PARAM_INDENT>
      <PARAM_ITEM>
	<PARAM_NAME>Port number</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    Spécifie le numéro du port de sortie.
	  </SP>
	  <SP>
            Propriétés : Type 'vec' de taille 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
    </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='OUT_f' type='XML'>
  <PARAM>
    <PARAM_INDENT>
      <PARAM_ITEM>
	<PARAM_NAME>Port number</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    un entier qui définit le numéro de port.
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
    </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='OpAmp' type='XML'>
  <PARAM>
    <PARAM_INDENT>

  </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='PAL_f' type='XML'>
  <PARAM>
    <PARAM_INDENT>

  </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='PDE' type='LATEX'>
\begin{itemize}

  \item {\bf a et b} \\
        (double) The two edges of the discretization field.

  \item {\bf specification de l'EDP} \\
        check box to select the PDE operators.

        ai(x), bi(t) (i=1:7) are the operator coefficients.

        type of PDE discriminant (constant or variable, in the
        later case, the sign should be given).

  \item {\bf Discretization methode} \\
        choix (check box) : is the choice for the manual or the
        automatic mode.

        type : in the manual mode we can give the method type
        (Finite differences, finite elements or finite volumes).

        degré : method degre (1 or 2 for the FD and FE methods,
        1 for the FV method).

        Nombre de noeuds : to give the number of the nodal points.

  \item {\bf Conditions initiales} \\
        u(x,t0)=, du/dt at t0= : to give the initial conditions.

  \item {\bf Conditions aux limites} \\
        type : two type of the boundray conditions are possible :
        Dirichlet or Neumann.

        expressions : to give then boundray conditions expressions.

  \item {\bf Points de mesures} \\
        To give the list of mesurment points.

  \item {\bf Name} \\
        A getvalue box to give the block name's.

\end{itemize}
</FILE>

<FILE name='PENDULUM_ANIM' type='XML'>
  <PARAM>

  </PARAM>
</FILE>

<FILE name='PID' type='XML'>
  <PARAM>
    <PARAM_INDENT>
      <PARAM_ITEM>
	<PARAM_NAME>Proportional</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    La valeur du gain qui multiplie l'erreur.
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille -1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
	<PARAM_NAME>Integral</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    La valeur de l'intervalle de temps sur lequel l'erreur est intégrée.(1/Integral)
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille -1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
	<PARAM_NAME>Derivation</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    La valeur de temps suivant laquelle l'erreur est dérivée.
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille -1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
    </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='PMOS' type='XML'>
  <PARAM>
    <PARAM_INDENT>

    <PARAM_ITEM>
    <PARAM_NAME>Width [m]</PARAM_NAME>
    <PARAM_DESCRIPTION>
      <SP>
      W
      </SP>
      <SP>
      Propriétés : Type 'vec' de taille 1.
      </SP>
    </PARAM_DESCRIPTION>
    </PARAM_ITEM>

    <PARAM_ITEM>
    <PARAM_NAME>Length [m]</PARAM_NAME>
    <PARAM_DESCRIPTION>
      <SP>
      L
      </SP>
      <SP>
      Propriétés : Type 'vec' de taille 1.
      </SP>
    </PARAM_DESCRIPTION>
    </PARAM_ITEM>

    <PARAM_ITEM>
    <PARAM_NAME>Transconductance parameter [A/(V*V)]</PARAM_NAME>
    <PARAM_DESCRIPTION>
      <SP>
      Beta
      </SP>
      <SP>
      Propriétés : Type 'vec' de taille 1.
      </SP>
    </PARAM_DESCRIPTION>
    </PARAM_ITEM>

    <PARAM_ITEM>
    <PARAM_NAME>Zero bias threshold voltage [V]</PARAM_NAME>
    <PARAM_DESCRIPTION>
      <SP>
      Vt
      </SP>
      <SP>
      Propriétés : Type 'vec' de taille 1.
      </SP>
    </PARAM_DESCRIPTION>
    </PARAM_ITEM>

    <PARAM_ITEM>
    <PARAM_NAME>Bulk threshold parameter</PARAM_NAME>
    <PARAM_DESCRIPTION>
      <SP>
      K2
      </SP>
      <SP>
      Propriétés : Type 'vec' de taille 1.
      </SP>
    </PARAM_DESCRIPTION>
    </PARAM_ITEM>

    <PARAM_ITEM>
    <PARAM_NAME>Reduction of pinch-off region</PARAM_NAME>
    <PARAM_DESCRIPTION>
      <SP>
      K5
      </SP>
      <SP>
      Propriétés : Type 'vec' de taille 1.
      </SP>
    </PARAM_DESCRIPTION>
    </PARAM_ITEM>

    <PARAM_ITEM>
    <PARAM_NAME>Narrowing of channel [m]</PARAM_NAME>
    <PARAM_DESCRIPTION>
      <SP>
      dW
      </SP>
      <SP>
      Propriétés : Type 'vec' de taille 1.
      </SP>
    </PARAM_DESCRIPTION>
    </PARAM_ITEM>

    <PARAM_ITEM>
    <PARAM_NAME>Shortening of channel [m]</PARAM_NAME>
    <PARAM_DESCRIPTION>
      <SP>
      dL
      </SP>
      <SP>
      Propriétés : Type 'vec' de taille 1.
      </SP>
    </PARAM_DESCRIPTION>
    </PARAM_ITEM>

    <PARAM_ITEM>
    <PARAM_NAME>Drain-Source-Resistance [Ohm]</PARAM_NAME>
    <PARAM_DESCRIPTION>
      <SP>
      RDS
      </SP>
      <SP>
      Propriétés : Type 'vec' de taille 1.
      </SP>
    </PARAM_DESCRIPTION>
    </PARAM_ITEM>

  </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='PNP' type='LATEX'>
\begin{table}[h!b!p!]
\begin{tabular}{lll}
\hline
Paramètre & Valeur pas d\'efaut & Description \\
\hline
Bf      & 50      & Forward beta\\
Br      & 0.1     & Reverse beta\\
Is	& 1.e-16  & Transport saturation current [A]\\
Vak     & 0.02    & Early voltage (inverse), 1/Volt [1/V]\\
Tauf	& 0.12e-9 & Ideal forward transit time [s]\\
Taur	& 5e-9    & Ideal reverse transit time [s]\\
Ccs	& 1e-12	  & Collector-substrat(ground) cap. [F]\\
Cje	& 0.4e-12 & Base-emitter zero bias depletion cap. [F]\\
Cjc	& 0.5e-12 & Base-coll. zero bias depletion cap. [F]\\
Phie	& 0.8     & Base-emitter diffusion voltage [V]\\
Me	& 0.4     & Base-emitter gradation exponent\\
Phic	& 0.8	  & Base-collector diffusion voltage [V]\\
Mc	& 0.333	  & Base-collector gradation exponent\\
Gbc	& 1e-15	  & Base-collector conductance [S]\\
Gbe	& 1e-15   & Base-emitter conductance [S]\\
Vt	& 0.02585 & Voltage equivalent of temperature [V]\\
EMin    &-100	  & if x < EMin, the exp(x) function is linearized\\
EMax	& 40	  & if x > EMax, the exp(x) function is linearized\\
\hline
\end{tabular}
\end{table}
</FILE>

<FILE name='POSTONEG_f' type='XML'>
<PARAM>
<PARAM_INDENT>

</PARAM_INDENT>
</PARAM>
</FILE>

<FILE name='POWBLK_f' type='LATEX'>
%automatically generated, please edit
\begin{itemize}

  %to the power of   1.5
  \item {\bf to the power of} \\
        scalaire.\\
        Propriétés : Type 'vec' de taille 1.

\end{itemize}
</FILE>

<FILE name='PRODUCT' type='XML'>
  <PARAM>
    <PARAM_INDENT>
      <PARAM_ITEM>
	<PARAM_NAME>Number of inputs or sign vector (multiplication: + 1, division: -1)</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    Le nombre d'entrées.
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille -1
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
    </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='PROD_f' type='XML'>
<PARAM>
<PARAM_INDENT>

</PARAM_INDENT>
</PARAM>
</FILE>

<FILE name='PULSE_SC' type='XML'>
  <PARAM>
    <PARAM_INDENT>

    <PARAM_ITEM>
    <PARAM_NAME>Phase delay (secs):</PARAM_NAME>
    <PARAM_DESCRIPTION>
      <SP>
      The offset of the block. It must be less than Frequency*(1-(Pulse_width/100)).
      </SP>
      <SP>
      Properties : Type 'pol' of size -1.
      </SP>
    </PARAM_DESCRIPTION>
    </PARAM_ITEM>

    <PARAM_ITEM>
    <PARAM_NAME>Pulse Width (% of period):</PARAM_NAME>
    <PARAM_DESCRIPTION>
      <SP>
      The pulse width. It can take values from 1 to 100.
      </SP>
      <SP>
      Properties : Type 'pol' of size -1.
      </SP>
    </PARAM_DESCRIPTION>
    </PARAM_ITEM>

    <PARAM_ITEM>
    <PARAM_NAME>Period (secs):</PARAM_NAME>
    <PARAM_DESCRIPTION>
      <SP>
      The Period of the signal.
      </SP>
      <SP>
      Properties : Type 'pol' of size -1.
      </SP>
    </PARAM_DESCRIPTION>
    </PARAM_ITEM>

    <PARAM_ITEM>
    <PARAM_NAME>Amplitude:</PARAM_NAME>
    <PARAM_DESCRIPTION>
      <SP>
      The amplitude of the pulse. It can support all scicos types.
      </SP>
      <SP>
      Properties : Type 'mat' of size [-1,-1].
      </SP>
    </PARAM_DESCRIPTION>
    </PARAM_ITEM>

  </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='PerteDP' type='XML'>
  <PARAM>
    <PARAM_INDENT>
      <PARAM_ITEM>
	<PARAM_NAME>Longueur du tube : L (m)</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    Longeur du tube
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille -1
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
	<PARAM_NAME>Diamètre interne du tube : D (m)</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    Diamètre interne du tube
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille -1
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
	<PARAM_NAME>Coefficient de perte de charge-frottement(S.U) : lambda</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    Coefficient de perte de charge-frottement(S.U)
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille -1
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
	<PARAM_NAME>Altitude entrée tuyauterie : z1 (m)</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    Altitude entrée tuyauterie (z1)
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille -1
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
	<PARAM_NAME>Altitude sortie tuyauterie : z2 (m)</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    Altitude entrée tuyauterie (z2)
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille -1
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
	<PARAM_NAME>Si &gt;0, masse volumique imposée fu fluide : p_rho (kg/m3)</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    masse volumique imposée fu fluide
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille -1
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
    </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='PotentialSensor' type='XML'>
<PARAM>
<PARAM_INDENT>

</PARAM_INDENT>
</PARAM>
</FILE>

<FILE name='PuitsP' type='XML'>
  <PARAM>
    <PARAM_INDENT>
      <PARAM_ITEM>
	<PARAM_NAME>Pression de la source : P0 (Pa)</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    Pression de la source
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille -1
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
	<PARAM_NAME>Temperature de la source : T0 (K)</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    Température de la source
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille -1
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
	<PARAM_NAME>Enthalpie spécifique de la source : H0 (J/kg)</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    Enthalpie spécifique de la source
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille -1
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
	<PARAM_NAME>1:température fixée - 2:enthalpie fixée : option_temperature</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    Option de temperature. 1:température fixée, 2:enthalpie fixée
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille -1
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
    </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='QUANT_f' type='LATEX'>
%automatically generated, please edit
\begin{itemize}

  %Step   0.1
  \item {\bf Step}\\
        scalaire, le pas de quantification\\
        Propriétés : Type 'vec' de taille 1.

  %Quantization Type (1-4)   1
  \item {\bf Quantization Type}\\
        scalire avec des valeurs possibles 1,2,3 ou 4
        \begin{description}
           \item[1] méthode 'Round'
           \item[2] méthode 'Truncation'
           \item[3] méthode 'Floor'
           \item[4] méthode 'Ceil' 
        \end{description}
        Propriétés : Type 'vec' de taille 1.

\end{itemize}
</FILE>

<FILE name='RAMP' type='LATEX'>
%automatically generated, please edit
\begin{itemize}

  %Slope   0
  \item {\bf Slope} \\
        La pente du signal généré.\\
        The rate of change of the generated signal.\\
        Propriétés : Type 'vec' de taille 1.

  %Start time   0
  \item {\bf Start time} \\
        La date d'origine à laquelle le signal est généré.
        Propriétés : Type 'vec' de taille 1.

  %Initial output   0
  \item {\bf Initial output} \\
        La valeur initiale du signal.\\
        Propriétés : Type 'vec' de taille 1.

\end{itemize}

</FILE>

<FILE name='RAND_f' type='LATEX'>
\begin{itemize}
  \item {\bf flag} \\
        0 ou 1.\\
        0 pour une distribution uniforme sur [A,A+B]. \\
        1 pour une distribution normale.\\
        Propriétés : Type 'vec' de taille 1.

  \item {\bf A} \\
        vecteur\\
        Propriétés : Type 'vec' de taille -1.

  \item {\bf B} \\
        vecteur\\
        Propriétés : Type 'vec' de taille -1.

  \item {\bf seed} \\
        scalaire\\
        Valeur de "graine" pour une séquence de nombre aléatoire.\\
        Propriétés : Type 'vec' de taille 1.
\end{itemize}
</FILE>

<FILE name='RAND_m' type='LATEX'>
\begin{itemize}
  \item {\bf Datatype(1=real double  2=complex)} \\
        Ce paramètre indique le type de donnée de la sortie. Ce
        bloc fonctionne uniquement avec des types de donnée
        réels(1) et complexes(2). Si un autre type que 1 et 2 est
        indiqué, alors Scicos retourne le message d'erreur
        "Datatype is not supported".\\
        Propriétiés : Type 'vec' de taille 1.

  \item {\bf flag} \\
        0 ou 1.\\
        0 pour une distribution uniforme sur [A,A+B]. \\
        1 pour une distribution normale.\\
        Propriétés : Type 'vec' de taille 1.

  \item {\bf A} \\
        matrice\\
        Propriétés : Type 'mat' de taille [-1,-2].

  \item {\bf B} \\
        matrice\\
        Propriétés : Type 'mat' de taille [-1,-2].

  \item {\bf seed} \\
        matrice\\
        Valeur de "graine" pour une séquence de nombre aléatoire.\\
	Le premier nombre est pour la partie réelle et le deuxième
	pour la partie imaginaire.\\
        Propriétés : Type 'mat' de taille [1,2].
\end{itemize}
</FILE>

<FILE name='RATELIMITER' type='LATEX'>
%automatically generated, please edit
\begin{itemize}

  %max slope   1
  \item {\bf max slope}\\
        La limite de la pente d'un signal d'entrée croissant.\\
	Propriétés : Type 'vec' de taille 1

  %min slope   -1
  \item {\bf min slope}\\
        La limite de la pente d'un signal d'entrée décroissant.\\
	Propriétés : Type 'vec' de taille 1
\end{itemize}
</FILE>

<FILE name='READAU_f' type='LATEX'>
%automatically generated, please edit
\begin{itemize}

  %Input file name   test.au
  \item {\bf Input file name} \\
        une chaîne de caractères définissant le chemin du fichier.\\
        Propriétés : Type 'str' de taille 1

  %Buffer size   20
  \item {\bf Buffer size} \\
        Pour améliorer l'efficacité du bloc, il est possible de
        mettre les données dans un buffer.
        La lecture dans le fichier est alors fait après 
        appel au bloc lorsque le buffer est rempli.\\
        Propriétés : Type 'vec' de taille 1

  %Swap mode 0/1   0
  \item {\bf Swap mode 0/1} \\
        Avec le paramètre {\bf Swap mode=1} le fichier est supposé être
        au format IEEE "little endian" et les données sont 
        entrelacées si nécessaire pour répondre au format IEEE du processeur.
        Si {\bf Swap mode=0} alors l'entrelacement est désactivé. \\
        Propriétés : Type 'vec' de taille 1

\end{itemize}
</FILE>

<FILE name='READC_f' type='LATEX'>
%automatically generated, please edit
\begin{itemize}

  %Time record selection []
  \item {\bf Time record selection} \\
        une matrice vide ou un entier positif.\\
        Si un entier i est donné, le $i^{\rm\grave{e}me}$ élément
        de l'enregistrement lu est supposé être la date de la sortie
        d'événement.\\
        Si ce paramètre est vide alors le bloc n'a pas de 
        sortie événementielle. \\
        Propriétés : Type 'vec' de taille -1

  %Outputs record selection   1
  \item {\bf Outputs record selection} \\
        un vecteur ou un entier positif.\\
        $[k_1,\cdots,k_n]$ ,le  $k_i^{\rm\grave{e}me}$ élément
        de l'enregistrement lu donne la valeur de la $i^{\rm\grave{e}me}$
        sortie.\\
        Propriétés : Type 'vec' de taille -1

  %Input file name   foo
  \item {\bf Input file name} \\
        une chaîne de caractères définissant le chemin du fichier.\\
        Propriétés : Type 'str' de taille 1

  %Input Format   d  
  \item {\bf Input Format} \\
        une chaîne de caractères définissant le format
        à utiliser.\\
        Propriétés : Type 'str' de taille 1

  %Record size   1
  \item {\bf Record size} \\
        Le fichier est supposé être formé par des séquence de données
        au même format.\\
        Ces données sont organisées en séquence d'enregistrement dont
        la taille est déterminée par ce paramètre.\\
        Propriétés : Type 'vec' de taille 1

  %Buffer size (in records)   20
  \item {\bf Buffer size} \\
        Pour améliorer l'efficacité du bloc, il est possible de
        mettre les données dans un buffer.
        La lecture dans le fichier est alors fait après chaque
        appel au bloc lorsque le buffer est rempli.\\
        Propriétés : Type 'vec' de taille 1

  %Initial record index   1
  \item {\bf Initial record index} \\
        Un scalaire. Cela définit le premier enregistrement à lire dans le
        fichier.\\
        Propriétés : Type 'vec' de taille 1

  %Swap mode 0/1   0
  \item {\bf Swap mode 0/1} \\
        Avec le paramètre {\bf Swap mode=1} le fichier est supposé être
        au format IEEE "little endian" et les données sont 
        entrelacées si nécessaire pour répondre au format IEEE du processeur.
        Si {\bf Swap mode=0} alors l'entrelacement est désactivé. \\
        Propriétés : Type 'vec' de taille 1
\end{itemize}
</FILE>

<FILE name='REGISTER' type='LATEX'>
\begin{itemize}

  %Register initial condition   0;0;0;0;0;0;0;0;0;0
  \item {\bf Register initial condition} \\
        Un vecteur colonne.\\
        Ce paramètre contient l'état initial du registre.\\
        Propriétés : Type 'vec' de taille -1

  \item {\bf Datatype} \\
        Ce bloc supporte tous les types de données sauf les
        complexes.\\
        Propriétés : Type 'vec' de taille -1
\end{itemize}
</FILE>

<FILE name='REGISTER_f' type='LATEX'>
\begin{itemize}

  %Register initial condition   0;0;0;0;0;0;0;0;0;0
  \item {\bf Register initial condition} \\
        Un vecteur colonne.\\
        Ce paramètre contient l'état initial du registre.\\
        Propriétés : Type 'vec' de taille -1
\end{itemize}
</FILE>

<FILE name='RELATIONALOP' type='LATEX'>
%automatically generated, please edit
\begin{itemize}

  %Operator: == (0), ~= (1), $<$ (2), $<$= (3), $>$= (4), $>$ (5)   2
  \item {\bf Operator:}\\
        Désigne l'opérateur de relation à utiliser
        pour la comparaison des deux entrées. \\
	Propriétés : Type 'vec' de taille 1

  %Use zero crossing (no: 0), (yes: 1)   0
  \item {\bf Use zero crossing }\\
        A sélectionner pour permettre la détection 'zero-crossing'.\\
	Propriétés : Type 'vec' de taille 1
\end{itemize}
</FILE>

<FILE name='RELAY_f' type='LATEX'>
%automatically generated, please edit
\begin{itemize}

  %number of inputs   2
  \item {\bf number of inputs}\\
        un scalaire. Nombre d'entrées régulières et événementielles.\\
	Propriétés : Type 'vec' de taille 1

  %initial connected input   1
  \item {\bf initial connected input}\\
        un entier qui doit être compris entre 1 et
        le nombre d'entrées.\\
	Propriétés : Type 'vec' de taille 1
\end{itemize}
</FILE>

<FILE name='RFILE' type='LATEX'>
\begin{itemize}
  %Time record selection   []
  \item {\bf Time record selection} \\
        une matrice vide ou un entier positif.\\
        Si un entier $i$ est donnée, le $i^{\rm \grave{e}me}$ élément de 
	l'enregistrement lu est supposé être la date de
	l'événement de sortie.
	Si ce paramètre est vide, alors le bloc ne fournit pas d'événements
	de sortie.
	Propriétés : Type 'vec' de taille -1.

  %Outputs record selection   1
  \item {\bf Outputs record selection} \\
        un vecteur d'entiers positifs. \\
        $[k_1,\cdots,k_n]$. Le $k_i^{\rm i\grave{e}me}$ élément de
	l'enregistrement lu donne la valeur de la $i^{\rm i\grave{e}me}$ sortie.\\
	Propriétés : Type 'vec' de taille -1.

  %Input file name   foo
  \item {\bf Input file name} \\
        une chaîne de caractères définissant le chemin du fichier.\\
	Propriétés : Type 'str' de taille 1.

  %Input Format   (7(e10.3,1x))
  \item {\bf Input Format} \\
        une chaîne de caractères définissant le format d'enregistrement 
        (de type fortran ou bien vide pour aucun format).
        Si ce paramètre est renseigné alors il doit être encadrer 
        par des paranthèses. Par exemple : $(e10.3)$.\\
	Propriétés : Type 'str' de taille 1.

  %Buffer size   2
  \item {\bf Buffer size} \\
        Pour améliorer l'efficacité de la lecture, il est possible d'enregistrer
	les données d'entrée dans un buffer. Les données sont alors délivrées à
	chaque appel du bloc lorsque le buffer est rempli.\\
	Propriétés : Type 'vec' de taille 1.
\end{itemize}
</FILE>

<FILE name='RFILE_f' type='LATEX'>
\begin{itemize}
  %Time record selection   []
  \item {\bf Time record selection} \\
        une matrice vide ou un entier positif.\\
        Si un entier $i$ est donnée, le $i^{\rm \grave{e}me}$ élément de 
	l'enregistrement lu est supposé être la date de
	l'événement de sortie.
	Si ce paramètre est vide, alors le bloc ne fournit pas d'événements
	de sortie.
	Propriétés : Type 'vec' de taille -1.

  %Outputs record selection   1
  \item {\bf Outputs record selection} \\
        un vecteur d'entiers positifs. \\
        $[k_1,\cdots,k_n]$. Le $k_i^{\rm i\grave{e}me}$ élément de
	l'enregistrement lu
	donne la valeur de la $i^{\rm i\grave{e}me}$ sortie.\\
	Propriétés : Type 'vec' de taille -1.

  %Input file name   foo
  \item {\bf Input file name} \\
        une chaîne de caractères définissant le chemin du fichier.\\
	Propriétés : Type 'str' de taille 1.

  %Input Format   (7(e10.3,1x))
  \item {\bf Input Format} \\
        une chaîne de caractères définissant le format d'enregistrement 
        (de type fortran ou bien vide pour aucun format).
        Si ce paramètre est renseigné alors il doit être encadrer 
        par des paranthèses. Par exemple : $(e10.3)$.\\
	Propriétés : Type 'str' de taille 1.

  %Buffer size   2
  \item {\bf Buffer size} \\
        Pour améliorer l'efficacité de la lecture, il est possible
	d'enregistrer les données d'entrée dans un buffer. Les
	données sont alors délivrées à chaque appel du bloc lorsque
	le buffer est rempli.\\
	Propriétés : Type 'vec' de taille 1.
\end{itemize}
</FILE>

<FILE name='RICC' type='XML'>
  <PARAM>
    <PARAM_INDENT>
      <PARAM_ITEM>
	<PARAM_NAME>Type (1=Cont  2=Disc)</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    For continuous time signal set this parameter to 1.
	    For discrete input time set it to 2.
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
	<PARAM_NAME>Model(1=Schr  2=sign(cont) inv(disc))</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    To use the Shur method in computation set this parameter to 1.
	    To use matrix sign function approach in continuous case or
	    the inverse free spectral decomposition method in discrete
	    case set this parameter to 2.
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
    </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='ROOTCOEF' type='XML'>
  <PARAM>
    <PARAM_INDENT>
      <PARAM_ITEM>
	<PARAM_NAME>Datatype(1=real double  2=Complex)</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    This block can only support double inputs values.
	    These values can be real or complex.
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
	<PARAM_NAME>input row size</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    The input row size.
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
    </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='Resistor' type='XML'>
  <PARAM>
    <PARAM_INDENT>
      <PARAM_ITEM>
	<PARAM_NAME>R (ohm)</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    Resistance
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
    </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='SAMPHOLD' type='XML'>
<PARAM>
<PARAM_INDENT>

</PARAM_INDENT>
</PARAM>
</FILE>

<FILE name='SAMPHOLD_m' type='XML'>
  <PARAM>
    <PARAM_INDENT>
      <PARAM_ITEM>
	<PARAM_NAME>Datatype(1=real double 2=Complex 3=int32 ...)</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    Le type de donnée de la sortie.
	    Ce bloc supporte tous les types de données.
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
    </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='SAMPLEHOLD_f' type='XML'>
<PARAM>
<PARAM_INDENT>

</PARAM_INDENT>
</PARAM>
</FILE>

<FILE name='SATURATION' type='LATEX'>
%automatically generated, please edit
\begin{itemize}

  %Upper limit   1
  \item {\bf Upper limit}\\
        Spécifie la limite supérieure du signal d'entrée. Lorsque
        le signal d'entrée est au dessus de cette valeur alors la
        sortie est maintenue à cette valeur.\\
	Propriétés : Type 'vec' de taille 1

  %Lower limit   -1
  \item {\bf Lower limit}\\
        Spécifie la limite inférieure du signal d'entrée. Lorsque
        le signal d'entrée est en dessous de cette valeur alors la
        sortie est maintenue à cette valeur.\\
	Propriétés : Type 'vec' de taille 1

  %zero crossing (0:no, 1:yes)   1
  \item {\bf zero crossing }\\
        A sélectionner pour permettre la détection 'zero-crossing'.\\
	Propriétés : Type 'vec' de taille 1
\end{itemize}
</FILE>

<FILE name='SAT_f' type='XML'>
  <PARAM>
    <PARAM_INDENT>
      <PARAM_ITEM>
	<PARAM_NAME>Min</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    La description du paramètre 1.
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
	<PARAM_NAME>Max</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    La description du paramètre 2.
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
	<PARAM_NAME>Slope</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    La description du paramètre 3.
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
    </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='SAWTOOTH_f' type='XML'>
<PARAM>
<PARAM_INDENT>

</PARAM_INDENT>
</PARAM>
</FILE>

<FILE name='SCALAR2VECTOR' type='LATEX'>
%automatically generated, please edit
\begin{itemize}
  %size of output (-1: if don't know)   -1
  \item {\bf size of output} \\
        Le nombre d'éléments du vecteur de sortie.\\
        Propriétés : Type 'vec' de taille 1.
\end{itemize}
</FILE>

<FILE name='SELECT_f' type='LATEX'>
%automatically generated, please edit
\begin{itemize}

  %number of inputs   2
  \item {\bf number of inputs}\\
        un scalaire. Nombre d'entrées régulières et événementielles.\\
	Propriétés : Type 'vec' de taille 1

  %initial connected input   1
  \item {\bf initial connected input}\\
        un entier qui doit être compris entre 1 et le nombre
        d'entrée.\\
	Propriétés : Type 'vec' de taille 1
\end{itemize}
</FILE>

<FILE name='SELECT_m' type='LATEX'>
%automatically generated, please edit
\begin{itemize}
  \item {\bf Datatype(1= real double  2=Complex)}\\
        une scalaire. Ce paramètre indique le type de donnée de
	la sortie. Ce bloc fonctionne uniquement avec des types
	de donnée réels(1) et complexes(2). Si un autre type que
	1 et 2 est indiqué, alors Scicos retourne le message d'erreur
        "Datatype is not supported". \\
	Propriétés : Type 'vec' de taille 1

  %number of inputs   2
  \item {\bf number of inputs}\\
        un scalaire. Nombre d'entrées régulières et événementielles.\\
	Propriétés : Type 'vec' de taille 1

  %initial connected input   1
  \item {\bf initial connected input}\\
        un entier qui doit être compris entre 1 et le nombre
        d'entrée.\\
	Propriétés : Type 'vec' de taille 1
\end{itemize}
</FILE>

<FILE name='SHIFT' type='XML'>
  <PARAM>
    <PARAM_INDENT>
      <PARAM_ITEM>
	<PARAM_NAME>Datatype (3=int32  4=int16 5=int8 ...)</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    It indicates the type of the input/output data.
	    It support all the integer datatype, number must be between 3 and 8.
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
	<PARAM_NAME>Number of bits to shift left (use negatif number to shift right)</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    It indicates the number of bits the input signal is shifted.
	    A positif value indicates a shift left, negatif values
	    indicates shift right.
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
	<PARAM_NAME>Shifttype(0=Arithmetic 1=Circular)</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    It indicate the rule used to shift the bits. It can be
	    arithmetic or circular. When the Shifttype is normal, an
	    arithmetic shift is applied to the input signal. In this
	    case, the bits that are shifted.
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
    </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='SIGNUM' type='LATEX'>
%automatically generated, please edit
\begin{itemize}

  %use zero\_crossing (1: yes) (0:no)   1
  \item {\bf use zero\_crossing }\\
        A sélectionner pour permettre la détection 'zero-crossing'.\\
	Propriétés : Type 'vec' de taille 1
\end{itemize}
</FILE>

<FILE name='SINBLK_f' type='XML'>
<PARAM>
<PARAM_INDENT>

</PARAM_INDENT>
</PARAM>
</FILE>

<FILE name='SLIDER_f' type='XML'>
  <PARAM>
    <PARAM_INDENT>

      <PARAM_ITEM>
	<PARAM_NAME>Min range</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    La description du paramètre 1.
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>

      <PARAM_ITEM>
	<PARAM_NAME>Max range</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    La description du paramètre 2.
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>

      <PARAM_ITEM>
	<PARAM_NAME>Type</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    La description du paramètre 3.
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>

      <PARAM_ITEM>
	<PARAM_NAME>Color</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    La description du paramètre 4.
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>

      <PARAM_ITEM>
	<PARAM_NAME>Block inherits (1) or not (0)</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    La description du paramètre 5.
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>

    </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='SPLIT_f' type='XML'>
<PARAM>
<PARAM_INDENT>

</PARAM_INDENT>
</PARAM>
</FILE>

<FILE name='SQRT' type='XML'>
  <PARAM>
    <PARAM_INDENT>
      <PARAM_ITEM>
	<PARAM_NAME>Datatype(1=real double  2=Complex)</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
           Ce paramètre indique le type de donnée de la sortie. Ce
	   bloc fonctionne uniquement avec des types de donnée
	   réels(1) et complexes(2). Si un autre type que 1 et 2 est
	   indiqué, alors Scicos retourne le message d'erreur
	   "Datatype is not supported".
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
    </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='SRFLIPFLOP' type='XML'>
  <PARAM>
    <PARAM_INDENT>
      <PARAM_ITEM>
	<PARAM_NAME>Initial Value</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    La valeur initial de l'état Q.
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
    </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='STEP' type='LATEX'>
%automatically generated, please edit
\begin{itemize}

  %Step time   1
  \item {\bf Step time} \\
        Le temps en seconde à partir duquel la sortie saute de
        la valeur du paramètre {\bf Initial value} à la valeur
        du paramètre {\bf Final value}.\\
        Propriétés : Type 'vec' de taille 1.

  %Initial value   0
  \item {\bf Initial value}\\
        La valeur de la sortie du bloc jusqu'à ce que
        le temps de la simulation arrive à la valeur du
        paramètre {\bf Step time}.\\
        Propriétés : Type 'vec' de taille -1.

  %Final value   1
  \item {\bf Final value} \\
        La valeur de la sortie du bloc lorsque le temps de
        simulation est supérieur à la valeur du paramètre
        {\bf Step time}.\\
        Propriétés : Type 'vec' de taille -1.

\end{itemize}
</FILE>

<FILE name='STEP_FUNCTION' type='LATEX'>
%automatically generated, please edit
\begin{itemize}

  %Step time   1
  \item {\bf Step time} \\
        Le temps en seconde à partir duquel la sortie saute de
        la valeur du paramètre {\bf Initial value} à la valeur
        du paramètre {\bf Final value}.\\
        Propriétés : Type 'vec' de taille 1.

  %Initial value   0
  \item {\bf Initial value}\\
        La valeur de la sortie du bloc jusqu'à ce que
        le temps de la simulation arrive à la valeur du
        paramètre {\bf Step time}.\\
        Propriétés : Type 'vec' de taille -1.

  %Final value   1
  \item {\bf Final value} \\
        La valeur de la sortie du bloc lorsque le temps de
        simulation est supérieur à la valeur du paramètre
        {\bf Step time}.\\
        Propriétés : Type 'vec' de taille -1.

\end{itemize}
</FILE>

<FILE name='SUBMAT' type='XML'>
  <PARAM>
    <PARAM_INDENT>
      <PARAM_ITEM>
	<PARAM_NAME>Datatype (1=real double  2=Complex)</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    Type of the output matrix. It can be double or complex.
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
	<PARAM_NAME>Starting Row Index</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    The first row of the submatrix.
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
	<PARAM_NAME>Ending Row Index</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    The last row of the Submatrix.
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
	<PARAM_NAME>Starting Column Index</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    The first column of the submatrix.
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
	<PARAM_NAME>Ending Column Index</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    The last row of the submatrix.
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
	<PARAM_NAME>Input Dimension</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    The Matrix input dimensions.
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille 2.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
    </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='SUMMATION' type='XML'>
  <PARAM>
    <PARAM_INDENT>
      <PARAM_ITEM>
	<PARAM_NAME>Datatype (1=real double  2=complex 3=int32 ...)</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    Indique le type de donnée des entrées/sortie.
	    Tous les types de données, numérotés de 1 à 8,
	    sont supportés.
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
	<PARAM_NAME>Number of inputs or sign vector (of +1, -1)</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    Indique le nombre d'entrées et le type d'opération (addition ou
	    soustraction). Voir la description pour plus de détails.
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille -1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
	<PARAM_NAME>Do on Overflow(0=Nothing 1=Saturate 2=Error)</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    Lorsque que ce paramètre est mis à la valeur 0, le résultat est
	    similaire à une addition de deux matrices. Lorque la valeur est
	    à 1, lorqu'un dépassement intervient, le bloc sature la valeur
	    de sortie. Lorsque la valeur est égale à 2, alors, lors d'un
	    dépassement de capacité, un message d'erreur est envoyé à
	    l'utilisateur. Lorsque le type de donnée est un nombre réel
	    ou un nombre complexe, ce paramètre n'est pas pris en compte.
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taile 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
    </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='SUM_f' type='XML'>
<PARAM>
<PARAM_INDENT>

</PARAM_INDENT>
</PARAM>
</FILE>

<FILE name='SUPER_f' type='XML'>
<PARAM>
<PARAM_INDENT>

</PARAM_INDENT>
</PARAM>
</FILE>

<FILE name='SWITCH2' type='LATEX'>
%automatically generated, please edit
\begin{itemize}

  %pass first input if: u2$>$=a (0), u2$>$a (1), u2~=a (2)   0
  \item {\bf pass first input if: u2$>$=a }\\
	Détermine la condition pour laquelle la première
	entrée est redirigée.
	Cette condition peut être une entrée de contôle supérieure ou égale, 
	strictement supérieure ou différente de la valeur donnée dans
	le paramètre {\bf threshold a}.
	Si l'entrée de contrôle satisfie la condition alors c'est la première
	entrée régulière qui est redirigée à la sortie, sinon c'est la troisième
	entrée régulière. \\
	Propriétés : Type 'vec' de taille 1.

  %threshold a   0
  \item {\bf threshold a}\\
        Définit la valeur de détection qui détermine qu'elle est
	l'entrée redigirée vers la sortie. \\
	Propriétés : Type 'vec' de taille 1.

  %use zero crossing: yes (1), no (0)   1
  \item {\bf use zero crossing: yes }\\
        A sélectionner pour permettre la détection 'zero-crossing'.\\
	Propriétés : Type 'vec' de taille 1.
\end{itemize}
</FILE>

<FILE name='SWITCH2_m' type='LATEX'>
%automatically generated, please edit
\begin{itemize}

  \item {\bf Datatype(1= real double  2=Complex)}\\
        un scalaire. Donne le type de donnée en entrée/sortie.\\
	Propriétés : Type 'vec' de taille 1

  %pass first input if: u2$>$=a (0), u2$>$a (1), u2~=a (2)   0
  \item {\bf pass first input if: u2$>$=a }\\
        Détermine la condition pour laquelle la première
        entrée est redirigée.
        Cette condition peut être une entrée de contôle supérieure ou égale, 
        strictement supérieure ou différente de la valeur donnée dans
        le paramètre {\bf threshold a}.
        Si l'entrée de contrôle satisfie la condition alors c'est la première
        entrée régulière qui est redirigée à la sortie, sinon c'est la troisième
        entrée régulière. \\
	Propriétés : Type 'vec' de taille 1.

  %threshold a   0
  \item {\bf threshold a}\\
        Définit la valeur de détection qui détermine qu'elle est
        l'entrée redigirée vers la sortie. \\
	Propriétés : Type 'vec' de taille 1.

  %use zero crossing: yes (1), no (0)   1
  \item {\bf use zero crossing: yes }\\
        A sélectionner pour permettre la détection 'zero-crossing'.\\
	Propriétés : Type 'vec' de taille 1.
\end{itemize}
</FILE>

<FILE name='SWITCH_f' type='LATEX'>
%automatically generated, please edit
\begin{itemize}

  %number of inputs   2
  \item {\bf number of inputs}\\
        Spécifie le nombre d'entrées de donnée du bloc.\\
	Propriétés : Type 'vec' de taille 1

  %connected input   1
  \item {\bf connected input}\\
        un entier qui doit être compris entre 1 et
        le nombre d'entrées.\\
	Propriétés : Type 'vec' de taille 1
\end{itemize}
</FILE>

<FILE name='SampleCLK' type='XML'>
  <PARAM>
    <PARAM_INDENT>
      <PARAM_ITEM>
	<PARAM_NAME>Sample time</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
            L'instant d'échantillonnage.
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
	<PARAM_NAME>Offset</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
            La valeur du décalage.
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
    </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='Sigbuilder' type='LATEX'>
Les paramètres du bloc Sigbuilder sont identiques à ceux du bloc \htmladdnormallink{CURVE\_c}{CURVE_c.htm}.
</FILE>

<FILE name='SineVoltage' type='XML'>
  <PARAM>
    <PARAM_INDENT>

      <PARAM_ITEM>
	<PARAM_NAME>Amplitude (Volt)</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    Amplitude de la sinusoïde.
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>

      <PARAM_ITEM>
	<PARAM_NAME>phase (rad)</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    Phase de la sinusoïde.
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>

      <PARAM_ITEM>
	<PARAM_NAME>Frequency (Hz)</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    Fréquence de la sinusoïde.
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>

      <PARAM_ITEM>
	<PARAM_NAME>Voltageoffset (V)</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    Tension de décalage de la sinusoïde.
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>

      <PARAM_ITEM>
	<PARAM_NAME>Timeoffset (s)</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    Décalage temporel. Durant ce temps, le signal de sortie
	    reste constant et égal à la tension de décalage.
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille 1.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>

    </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='SourceP' type='XML'>
  <PARAM>
    <PARAM_INDENT>
      <PARAM_ITEM>
	<PARAM_NAME>Pression de la source : P0 (Pa)</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    Pression de la source
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille -1
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
	<PARAM_NAME>Temperature de la source : T0 (K)</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    Température de la source
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille -1
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
	<PARAM_NAME>Enthalpie spécifique de la source : H0 (J/kg)</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    Enthalpie spécifique de la source
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille -1
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
	<PARAM_NAME>1:température fixée - 2:enthalpie fixée : option_temperature</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    option_temperature. 1:température fixée, 2:enthalpie fixée :
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille -1
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
    </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='Switch' type='XML'>
  <PARAM>
    <PARAM_INDENT>

    <PARAM_ITEM>
    <PARAM_NAME>Resistance in On state (Ohm)</PARAM_NAME>
    <PARAM_DESCRIPTION>
      <SP>
           Switch resistance when the Switch is closed
      </SP>
      <SP>
      Propriétés : Type 'vec' de taille 1.
      </SP>
    </PARAM_DESCRIPTION>
    </PARAM_ITEM>

    <PARAM_ITEM>
    <PARAM_NAME>Resistance in Off state (Ohm)</PARAM_NAME>
    <PARAM_DESCRIPTION>
      <SP>
          Switch resistance when the switch is open
      </SP>
      <SP>
      Propriétés : Type 'vec' de taille 1.
      </SP>
    </PARAM_DESCRIPTION>
    </PARAM_ITEM>

  </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='TANBLK_f' type='XML'>
<PARAM>
<PARAM_INDENT>

</PARAM_INDENT>
</PARAM>
</FILE>

<FILE name='TCLSS' type='LATEX'>
\begin{itemize}

 \item {\bf $A$ matrix} \\
       Une matrice carré. \\
       Propriétés : Type 'mat' de taille [-1,-1].

 \item {\bf B matrix} \\
       La matrice $B$, [] si le système n'a pas d'entrées.\\
       Propriétés : Type 'mat' de taille ["size(\%1,2)","-1"].

 \item {\bf C matrix} \\
       La matrice $C$, [] si le système n'a pas de sorties.\\
       Propriétés : Type 'mat' de taille ["-1","size(\%1,2)"].

 \item {\bf D matrix} \\
       La matrice $D$, [] si le système n'a pas de terme D.\\
       Propriétés : Type 'mat' de taille [-1,-1].

 \item {\bf Initial state} \\
       Un état initial du système ( vectoriel ou scalaire).\\
       Propriétés : Type 'vec' de taille "size(\%1,2)".

\end{itemize}
</FILE>

<FILE name='TCLSS_f' type='LATEX'>
\begin{itemize}

 \item {\bf $A$ matrix} \\
       Une matrice carré. \\
       Propriétés : Type 'mat' de taille [-1,-1].

 \item {\bf B matrix} \\
       La matrice $B$, [] si le système n'a pas d'entrées.\\
       Propriétés : Type 'mat' de taille ["size(\%1,2)","-1"].

 \item {\bf C matrix} \\
       La matrice $C$, [] si le système n'a pas de sorties.\\
       Propriétés : Type 'mat' de taille ["-1","size(\%1,2)"].

 \item {\bf D matrix} \\
       La matrice $D$, [] si le système n'a pas de terme D.\\
       Propriétés : Type 'mat' de taille [-1,-1].

 \item {\bf Initial state} \\
       Un état initial du système ( vectoriel ou scalaire).\\
       Propriétés : Type 'vec' de taille "size(\%1,2)".

\end{itemize}
</FILE>

<FILE name='TEXT_f' type='LATEX'>
%automatically generated, please edit
\begin{itemize}

  %Text   Text
  \item {\bf Text}\\
        la chaîne de caractères à afficher.\\
	Propriétés : Type 'str' de taille -1

  %Font number   2
  \item {\bf Font number}\\
        un entier positif (plus petit que 6) donnant
        le type de la police.\\
	Propriétés : Type 'vec' de taille 1

  %Font size   1
  \item {\bf Font size}\\
        un entier positif donnant la taille
        de la police (voir {\bf xset}).\\
	Propriétés : Type 'vec' de taille 1
\end{itemize}
</FILE>

<FILE name='TIME_DELAY' type='LATEX'>
%automatically generated, please edit
\begin{itemize}

  %Delay   1
  \item {\bf Delay}\\
        Le temps définissant le retard entre l'entrée et
	la sortie pendant la simulation. Cette valeur doit
	être supérieure ou égale à zéro.\\
	Propriétés : Type 'vec' de taille 1

  %initial input   0
  \item {\bf initial input}\\
        La valeur initiale de la sortie du bloc avant
	que l'entrée ne soit reportée à la sortie. \\
	Propriétés : Type 'vec' de taille 1

  %Buffer size   1024
  \item {\bf Buffer size}\\
        L'allocation de mémoire initiale définissant le
	le nombre de points à enregistrer.\\
	Propriétés : Type 'vec' de taille 1
\end{itemize}
</FILE>

<FILE name='TIME_f' type='XML'>
<PARAM>
<PARAM_INDENT>

</PARAM_INDENT>
</PARAM>
</FILE>

<FILE name='TKSCALE' type='XML'>
  <PARAM>
    <PARAM_INDENT>

    <PARAM_ITEM>
    <PARAM_NAME>Min value</PARAM_NAME>
    <PARAM_DESCRIPTION>
      <SP>
      Un entier indiquant la borne inf de l'échelle.
      </SP>
      <SP>
      Propriétés : Type 'vec' de taille 1.
      </SP>
    </PARAM_DESCRIPTION>
    </PARAM_ITEM>

    <PARAM_ITEM>
    <PARAM_NAME>Max value</PARAM_NAME>
    <PARAM_DESCRIPTION>
      <SP>
      Un entier indiquant la borne sup de l'échelle.
      </SP>
      <SP>
      Propriétés : Type 'vec' de taille 1.
      </SP>
    </PARAM_DESCRIPTION>
    </PARAM_ITEM>

    <PARAM_ITEM>
    <PARAM_NAME>Normalization</PARAM_NAME>
    <PARAM_DESCRIPTION>
      <SP>
      La sortie du bloc est la valeur de l'échelle divisée par ce facteur
de normalisation.
      </SP>
      <SP>
      Propriétés : Type 'vec' de taille 1.
      </SP>
    </PARAM_DESCRIPTION>
    </PARAM_ITEM>

  </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='TOWS_c' type='XML'>
  <PARAM>
    <PARAM_INDENT>

    <PARAM_ITEM>
    <PARAM_NAME>Size of buffer</PARAM_NAME>
    <PARAM_DESCRIPTION>
      <SP>
      Définit la taille du buffer. Cela donne le nombre total
      d'échantillons qui seront enregistrés pendant la simulation.
      </SP>
      <SP>
      Ce buffer est circulaire.
      </SP>
      <SP>
      Propriétés : Type 'vec' de taille 1.
      </SP>
    </PARAM_DESCRIPTION>
    </PARAM_ITEM>

    <PARAM_ITEM>
    <PARAM_NAME>Scilab variable name</PARAM_NAME>
    <PARAM_DESCRIPTION>
      <SP>
      Définit le nom de la variable Scilab.
      Ce nom doit être un nom de variable valide.
      </SP>
      <SP>
      La simulation doit être achevée pour pouvoir
      récupérer la variable dans Scilab.
      </SP>
      <SP>
      Propriétés : Type 'str' de taille 1.
      </SP>
    </PARAM_DESCRIPTION>
    </PARAM_ITEM>

    <PARAM_ITEM>
    <PARAM_NAME>Inherit (no:0, yes:1)</PARAM_NAME>
    <PARAM_DESCRIPTION>
      <SP>
       Option pour choisir l'activation par héritage d'événement
       via le port d'entrée régulier ou explicitement par le port d'entrée
       événementiel. \\
      </SP>
      <SP>
      Propriétés : Type 'vec' de taille 1.
      </SP>
    </PARAM_DESCRIPTION>
    </PARAM_ITEM>

  </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='TRASH_f' type='XML'>
<PARAM>
<PARAM_INDENT>

</PARAM_INDENT>
</PARAM>
</FILE>

<FILE name='TrigFun' type='LATEX'>
%automatically generated, please edit
\begin{itemize}

  %Function   sin
  \item {\bf Function}\\
        La fonction trigonométrique à utiliser.\\
	Propriétés : Type 'str' de taille 1
\end{itemize}
</FILE>

<FILE name='VARIABLE_DELAY' type='LATEX'>
%automatically generated, please edit
\begin{itemize}

  %Max delay   1
  \item {\bf Max delay}\\
        Ce paramètre définit la plus grande valeur du retard.
	Cette valeur ne peut pas être négative.\\
	Propriétés : Type 'vec' de taille 1.

  %initial input   0
  \item {\bf initial input}\\
        La valeur de la sortie jusqu'à ce que le
	temps de la simulation dépasse la valeur du retard.\\
	Propriétés : Type 'vec' de taille 1.

  %Buffer size   1024
  \item {\bf Buffer size}\\
        Le nombre de points que le bloc peut enregistrer.\\
	Propriétés : Type 'vec' de taille 1.
\end{itemize}
</FILE>

<FILE name='VVsourceAC' type='XML'>
  <PARAM>
    <PARAM_INDENT>
      <PARAM_ITEM>
	<PARAM_NAME>Frequency (Hz)</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    Frequence (Hz)
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille -1
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
    </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='VanneReglante' type='XML'>
  <PARAM>
    <PARAM_INDENT>
      <PARAM_ITEM>
	<PARAM_NAME>Cvmax</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    Cvmax (l'ouverture maxi)
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille -1
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
	<PARAM_NAME>p_rho</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    Masse volumique du fluide
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille -1
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
    </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='VariableResistor' type='XML'>
<PARAM>
<PARAM_INDENT>

</PARAM_INDENT>
</PARAM>
</FILE>

<FILE name='VirtualCLK0' type='XML'>
  <PARAM>
    <PARAM_INDENT>

  </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='VoltageSensor' type='XML'>
<PARAM>
<PARAM_INDENT>

</PARAM_INDENT>
</PARAM>
</FILE>

<FILE name='VsourceAC' type='XML'>
  <PARAM>
    <PARAM_INDENT>
      <PARAM_ITEM>
	<PARAM_NAME>Amplitude (Volt)</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    Amplitude de la tension sinosoidale
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille -1
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
	<PARAM_NAME>Frequency (Hz)</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    Fréquence de la tension sinosoidale
	  </SP>
	  <SP>
	    Propriétés : Type 'vec' de taille -1
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
    </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='WFILE' type='LATEX'>
\begin{itemize}
  %Input size   1
  \item {\bf Input size} \\
        un scalaire. Cela fixe la taille de l'entrée.\\
        Propriétés : Type 'vec' de taille 1.

  %Output file name   foo
  \item {\bf Output file name} \\
        une chaîne de caractères définissant le chemin du fichier.\\
	Propriétés : Type 'str' de taille 1.

  %Output Format   (7(e10.3,1x))
  \item {\bf Output Format} \\
        une chaîne de caractères définissant le format d'enregistrement
        (de type fortran ou bien vide pour aucun format).
        Si ce paramètre est renseigné alors il doit être encadrer
        par des paranthèses. Par exemple : $(e10.3)$.\\
        Propriétés : Type 'str' de taille 1.

  %Buffer size   2
  \item {\bf Buffer size} \\
        Pour améliorer l'efficacité de la lecture, il est possible
        d'enregistrer les données d'entrée dans un buffer. Les
        données sont alors délivrées à chaque appel du bloc
        lorsque le buffer est rempli.\\
        Propriétés : Type 'vec' de taille 1.
\end{itemize}
</FILE>

<FILE name='WFILE_f' type='LATEX'>
\begin{itemize}
  %Input size   1
  \item {\bf Input size} \\
        un scalaire. Cela fixe la taille de l'entrée.\\
        Propriétés : Type 'vec' de taille 1.

  %Output file name   foo
  \item {\bf Output file name} \\
        une chaîne de caractères définissant le chemin du fichier.\\
	Propriétés : Type 'str' de taille 1.

  %Output Format   (7(e10.3,1x))
  \item {\bf Output Format} \\
        une chaîne de caractères définissant le format d'enregistrement
        (de type fortran ou bien vide pour aucun format).
        Si ce paramètre est renseigné alors il doit être encadrer 
        par des paranthèses. Par exemple : $(e10.3)$.\\
	Propriétés : Type 'str' de taille 1.

  %Buffer size   2
  \item {\bf Buffer size} \\
        Pour améliorer l'efficacité de la lecture, il est possible
	d'enregistrer les données d'entrée dans un buffer. Les
	données sont alors délivrées à chaque appel du bloc lorsque
	le buffer est rempli.\\
	Propriétés : Type 'vec' de taille 1.
\end{itemize}
</FILE>

<FILE name='WRITEAU_f' type='LATEX'>
%automatically generated, please edit
\begin{itemize}

  %Buffer size   20
  \item {\bf Buffer size} \\
        Pour améliorer l'efficacité du bloc, il est possible de
        mettre les données dans un buffer.
        La lecture dans le fichier est alors fait après chaque
        appel au bloc lorsque le buffer est rempli.\\
        Propriétés : Type 'vec' de taille 1

  %Swap mode 0/1   0
  \item {\bf Swap mode 0/1} \\
        Avec le paramètre {\bf Swap mode=1} le fichier est supposé être
        au format IEEE "little endian" et les données sont 
        entrelacées si nécessaire pour répondre au format IEEE du processeur.
        Si {\bf Swap mode=0} alors l'entrelacement est désactivé. \\
        Propriétés : Type 'vec' de taille 1

\end{itemize}
</FILE>

<FILE name='WRITEC_f' type='LATEX'>
%automatically generated, please edit
\begin{itemize}

  %Input size   1
  \item {\bf Input size} \\
        un scalaire, la taille de l'entrée.\\
        Propriétés : Type 'vec' de taille 1

  %Output file name   foo
  \item {\bf Output file name} \\
        une chaîne de caractères définissant le chemin du fichier.\\
        Propriétés : Type 'str' de taille 1

  %Output Format   d  
  \item {\bf Output Format} \\
        une chaîne de caractères définissant le format
        à utiliser.\\
        Propriétés : Type 'str' de taille 1

  %Buffer size (in records)   20
  \item {\bf Buffer size} \\
        Pour améliorer l'efficacité du bloc, il est possible de
        mettre les données dans un buffer.
        L'écriture dans le fichier est alors fait après chaque
        appel au bloc lorsque le buffer est rempli.\\
        Propriétés : Type 'vec' de taille 1

  %Initial record index   1
  \item {\bf Initial record index} \\
        Un scalaire. Cela définit le premier enregistrement à lire dans le
        fichier.\\
        Propriétés : Type 'vec' de taille 1

  %Swap mode 0/1   0
  \item {\bf Swap mode 0/1} \\
        Avec le paramètre {\bf Swap mode=1} le fichier est supposé être
        au format IEEE "little endian" et les données sont 
        entrelacées si nécessaire pour répondre au format IEEE du processeur.
        Si {\bf Swap mode=0} alors l'entrelacement est désactivé. \\
        Propriétés : Type 'vec' de taille 1
\end{itemize}
</FILE>

<FILE name='ZCROSS_f' type='LATEX'>
%automatically generated, please edit
\begin{itemize}

  %Input size   1
  \item {\bf Input size}\\
        un entier positif.\\
        Propertie : Type 'vec' de taille 1.
\end{itemize}
</FILE>

<FILE name='block_type' type='XML'>
  <PARAM>

  </PARAM>
</FILE>

<FILE name='buildouttb' type='XML'>
  <PARAM>
    <PARAM_INDENT>
      <PARAM_ITEM>
	<PARAM_NAME>outtb</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    une liste de taille n.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
	<PARAM_NAME>lnksz</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    Ce paramètre donne la taille d'un objet scilab dans la liste outtb.
	  </SP>
	  <SP>
	    Cette matrice de nombres entiers ou de nombres réels
	    peut avoir une taille n,2 ou 2,n.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
	<PARAM_NAME>lnktyp</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    Ce paramètre donne le type d'objet scilab dans outtb :
	  </SP>
	  <SP>
	    1 : réel
	  </SP>
	  <SP>
	    2 : complexe
	  </SP>
	  <SP>
	    3 : int32
	  </SP>
	  <SP>
	    4 : int16
	  </SP>
	  <SP>
	    5 : int8
	  </SP>
	  <SP>
	    6 : uint32
	  </SP>
	  <SP>
	    7 : uint16
	  </SP>
	  <SP>
	    8 : uint8
	  </SP>
	  <SP>
	    sinon : réel
	  </SP>
	  <SP>
	    Cette matrice de nombres entiers ou de nombres réels
	    peut avoir une taille n,1 ou 1,n.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
    </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='c_block' type='LATEX'>
%automatically generated, please edit
\begin{itemize}

  %input ports sizes   1
  \item {\bf input ports sizes}\\
        Nombre de ports d'entrée réguliers.\\
        Propriétés : Type 'vec' de taille -1.

  %output port sizes   1
  \item {\bf output port sizes}\\
        Nombre de ports de sortie réguliers.\\
        Propriétés : Type 'vec' de taille -1.

  %System parameters vector   []
  \item {\bf System parameters vector}\\
        Le vector des paramètres.\\
        Propriétés : Type 'vec' de taille -1.

  %function name   toto
  \item {\bf function name}\\
        Le nom de la fonction de calcul qui doit
        être générée.\\
        Propriétés : Type 'str' de taille -1.
\end{itemize}
</FILE>

<FILE name='callblk' type='XML'>
  <PARAM>
  <PARAM_INDENT>

    <PARAM_ITEM>
    <PARAM_NAME>blk</PARAM_NAME>
    <PARAM_DESCRIPTION>
      <SP>
      structure scilab scicos_bloc
      </SP>
    </PARAM_DESCRIPTION>
    </PARAM_ITEM>

    <PARAM_ITEM>
    <PARAM_NAME>flag</PARAM_NAME>
    <PARAM_DESCRIPTION>
      <SP>
      flag d'appel de la fonction de calcul
      </SP>
    </PARAM_DESCRIPTION>
    </PARAM_ITEM>

    <PARAM_ITEM>
    <PARAM_NAME>time</PARAM_NAME>
    <PARAM_DESCRIPTION>
      <SP>
      temps du simulateur
      </SP>
    </PARAM_DESCRIPTION>
    </PARAM_ITEM>

  </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='coserror' type='XML'>
  <PARAM>
  <PARAM_INDENT>

    <PARAM_ITEM>
    <PARAM_NAME>errmsg</PARAM_NAME>
    <PARAM_DESCRIPTION>
      <SP>
      une chaîne de caractères à afficher pour signaler l'erreur à l'utilisateur
      </SP>
    </PARAM_DESCRIPTION>
    </PARAM_ITEM>

  </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='create_gif' type='XML'>
  <PARAM>
  <PARAM_INDENT>

    <PARAM_ITEM>
    <PARAM_NAME>TXT</PARAM_NAME>
    <PARAM_DESCRIPTION>
       <SP>
       un vecteur de chaînes de caractères donnant la liste des fichiers de fonctions d'interfacages de bloc Scicos.
       </SP>
    </PARAM_DESCRIPTION>
    </PARAM_ITEM>

    <PARAM_ITEM>
    <PARAM_NAME>path</PARAM_NAME>
    <PARAM_DESCRIPTION>
       <SP>
       le chemin cible où sont enregistrés les icones gif.
       </SP>
    </PARAM_DESCRIPTION>
    </PARAM_ITEM>
  </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='create_palette' type='XML'>
  <PARAM>
  <PARAM_INDENT>

    <PARAM_ITEM>
    <PARAM_NAME>Path</PARAM_NAME>
    <PARAM_DESCRIPTION>
       <SP>
        une chaîne de caractères qui donne le chemin du répertoire contenant des fonctions d'interfaçage de blocs Scicos.
       </SP>
    </PARAM_DESCRIPTION>
    </PARAM_ITEM>

    <PARAM_ITEM>
    <PARAM_NAME>routines</PARAM_NAME>
    <PARAM_DESCRIPTION>
       <SP>
        un vecteur de chaînes de caractères contenat les noms des fonctions de calcul utilisées dans les blocs Scicos.
       </SP>
    </PARAM_DESCRIPTION>
    </PARAM_ITEM>

    <PARAM_ITEM>
    <PARAM_NAME>IntFunc</PARAM_NAME>
    <PARAM_DESCRIPTION>
       <SP>
       un vecteur de chaînes de caractères contenant les noms des fonctions d'interfaçage des blocs Scicos.
       </SP>
    </PARAM_DESCRIPTION>
    </PARAM_ITEM>
  </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='curblock' type='XML'>
  <PARAM>
    <PARAM_INDENT>
      <PARAM_ITEM>
	<PARAM_NAME>blk</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    le numéro du bloc courant dans la structure compilée.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
    </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='data2sig' type='XML'>
  <PARAM>
  <PARAM_INDENT>

    <PARAM_ITEM>
    <PARAM_NAME>A</PARAM_NAME>
    <PARAM_DESCRIPTION>
      <SP>
        vecteur/matrice ou hypermatrice(à 3 dimensions)
        de nombres réels/complexes ou entiers.
      </SP>
    </PARAM_DESCRIPTION>
    </PARAM_ITEM>

    <PARAM_ITEM>
    <PARAM_NAME>step</PARAM_NAME>
    <PARAM_DESCRIPTION>
      <SP>
        un argument optionnel qui donne le pas temporel
        pour le champ de sortie "time".
        Si celui-ci n'est pas donné, alors le pas temporel
        est égal à 1.
      </SP>
    </PARAM_DESCRIPTION>
    </PARAM_ITEM>

    <PARAM_ITEM>
    <PARAM_NAME>B</PARAM_NAME>
    <PARAM_DESCRIPTION>
      <SP>
      une structure scilab qui définit un signal :
      </SP>
        <PARAM_INDENT>
          <PARAM_ITEM>
            <PARAM_NAME>B.values</PARAM_NAME>
            <PARAM_DESCRIPTION>
              <SP>
                L'entrée A.
              </SP>
            </PARAM_DESCRIPTION>
          </PARAM_ITEM>

          <PARAM_ITEM>
            <PARAM_NAME>B.time</PARAM_NAME>
            <PARAM_DESCRIPTION>
              <SP>
                Les instants d'échantillons sous la
                forme d'un vecteur colonne. La taille
                du vecteur est donnée par l'entrée A.
              </SP>
            </PARAM_DESCRIPTION>
          </PARAM_ITEM>

        </PARAM_INDENT>
    </PARAM_DESCRIPTION>
    </PARAM_ITEM>

  </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='data_type' type='XML'>
  <PARAM>

  </PARAM>
</FILE>

<FILE name='fortran_block' type='LATEX'>
%automatically generated, please edit
\begin{itemize}

  %input ports sizes   1
  \item {\bf input ports sizes}\\
        Nombre de ports d'entrée réguliers.\\
        Propriétés : Type 'vec' de taille -1.

  %output port sizes   1
  \item {\bf output port sizes}\\
        Nombre de ports de sortie réguliers.\\
        Propriétés : Type 'vec' de taille -1.

  %System parameters vector   []
  \item {\bf System parameters vector}\\
        Le vector des paramètres.\\
        Propriétés : Type 'vec' de taille -1.

  %function name   toto
  \item {\bf function name}\\
        Le nom de la fonction de calcul qui doit
        être générée.\\
        Propriétés : Type 'str' de taille -1.
\end{itemize}
</FILE>

<FILE name='freq_div' type='LATEX'>
%automatically generated, please edit
\begin{itemize}

  %Phase (0 to division factor -1)   0
  \item {\bf Phase }\\
        un scalaire positif.\\
	Propriétés : Type 'vec' de taille 1

  %Division factor   3
  \item {\bf Division factor}\\
        un entier plus grand que 1.\\
	Propriétés : Type 'vec' de taille 1
\end{itemize}
</FILE>

<FILE name='func_block' type='XML'>
<PARAM>
<PARAM_INDENT>

</PARAM_INDENT>
</PARAM>
</FILE>

<FILE name='generic_block' type='LATEX'>
%automatically generated, please edit
\begin{itemize}

  %simulation function   sinblk
  \item {\bf simulation function}\\
        Nom de la fonction de simulation à charger.\\
	Propriétés : Type 'vec' de taille 1

  %function type (0,1,2,..)   1
  \item {\bf function type }\\
        Définit le type de la fonction de calcul.\\
	Propriétés : Type 'vec' de taille 1

  %input ports sizes   1
  \item {\bf input ports sizes}\\
        Un vecteur contenant des valeurs positives, nulles ou négatives.
        La taille de ce vecteur donne le
        nombre de ports réguliers d'entrée.\\
	Propriétés : Type 'vec' de taille -1

  %output port sizes   1
  \item {\bf output port sizes}\\
        Un vecteur contenant des valeurs positives, nulles ou négatives.
        La taille de ce vecteur donne le
        nombre de ports réguliers de sortie.\\
	Propriétés : Type 'vec' de taille -1

  %input event ports sizes   []
  \item {\bf input event ports sizes}\\
        Un vecteur contenant des valeurs 1.
        La taille de ce vecteur donne le
        nombre de ports événementiels d'entrée.\\
	Propriétés : Type 'vec' de taille -1

  %output events ports sizes   []
  \item {\bf output events ports sizes}\\
        Un vecteur contenant des valeurs 1.
        La taille de ce vecteur donne le
        nombre de ports événementiels de sortie.\\
	Propriétés : Type 'vec' de taille -1

  %initial continuous state   []
  \item {\bf initial continuous state}\\
        Un vecteur colonne.
	Conditions initiales des états continus.\\
	Propriétés : Type 'vec' de taille -1

  %initial discrete state   []
  \item {\bf initial discrete state}\\
        Un vecteur colonne.
        Conditions initiales des états discrets.\\
	Propriétés : Type 'vec' de taille -1

  %Real parameters vector   []
  \item {\bf Real parameters vector}\\
        Vecteur des paramètres réels.\\
	Propriétés : Type 'vec' de taille -1

  %Integer parameters vector   []
  \item {\bf Integer parameters vector}\\
        Vecteur des paramètres entiers.\\
	Propriétés : Type 'vec' de taille -1

  %initial firing vector ($<$0 for no firing)   []
  \item {\bf initial firing vector }\\
        Un vecteur. La taille de ce vecteur correspond
	au nombre de sorties événementielles.
	La valeur de la $i^{\rm \grave{e}me}$ entrée
	spécifie la date initiale préprogrammée du 
	$i^{\rm \grave{e}me}$ port événementiel de sortie.
	Si la valeur est inférieure à zéro, alors aucun
	événement n'est préprogrammé.\\
	Propriétés : Type 'vec' de taille sum(\%6)

  %direct feedthrough (y or n)   y
  \item {\bf direct feedthrough }\\
        L'entrée du bloc à un instant donné, détermine
	la sortie du bloc à ce même instant.
	Cela force le bloc à répondre instantanément, comme
	si le système était en régime établi.\\
	Propriétés : Type 'vec' de taille 1

  %time dependence (y or n)   n
  \item {\bf time dependence }\\
        Permet de déterminer si le bloc doit être
	marqué comme temps dépendant.\\
	Propriétés : Type 'vec' de taille 1
\end{itemize}
</FILE>

<FILE name='generic_block2' type='LATEX'>
%automatically generated, please edit
\begin{itemize}

  %simulation function   sinblk
  \item {\bf simulation function}\\
        Nom de la fonction de simulation à charger.\\
	Propriétés : Type 'vec' de taille 1

  %function type (0,1,2,..)   1
  \item {\bf function type }\\
        Définit le type de la fonction de calcul.\\
	Propriétés : Type 'vec' de taille 1

  %input ports sizes   1
  \item {\bf input ports sizes}\\
        Un vecteur contenant des valeurs positives, nulles ou négatives.
        La taille de ce vecteur donne le
        nombre de ports réguliers d'entrée.\\
	Propriétés : Type 'vec' de taille -1

  %output port sizes   1
  \item {\bf output port sizes}\\
        Un vecteur contenant des valeurs positives, nulles ou négatives.
        La taille de ce vecteur donne le
        nombre de ports réguliers de sortie.\\
	Propriétés : Type 'vec' de taille -1

  %input event ports sizes   []
  \item {\bf input event ports sizes}\\
        Un vecteur contenant des valeurs 1.
        La taille de ce vecteur donne le
        nombre de ports événementiels d'entrée.\\
	Propriétés : Type 'vec' de taille -1

  %output events ports sizes   []
  \item {\bf output events ports sizes}\\
        Un vecteur contenant des valeurs 1.
        La taille de ce vecteur donne le
        nombre de ports événementiels de sortie.\\
	Propriétés : Type 'vec' de taille -1

  %initial continuous state   []
  \item {\bf initial continuous state}\\
        Un vecteur colonne.
	Conditions initiales des états continus.\\
	Propriétés : Type 'vec' de taille -1

  %initial discrete state   []
  \item {\bf initial discrete state}\\
        Un vecteur colonne.
        Conditions initiales des états discrets.\\
	Propriétés : Type 'vec' de taille -1

  %Real parameters vector   []
  \item {\bf Real parameters vector}\\
        Vecteur des paramètres réels.\\
	Propriétés : Type 'vec' de taille -1

  %Integer parameters vector   []
  \item {\bf Integer parameters vector}\\
        Vecteur des paramètres entiers.\\
	Propriétés : Type 'vec' de taille -1

  %number of modes   0
  \item {\bf number of modes}\\
        Nombre de modes des fonctions du
	système.\\
	Propriétés : Type 'vec' de taille 1

  %number of zero\_corssings   0
  \item {\bf number of zero\_corssings}\\
        Nombre de passage à zéro.
        Permet l'utilisation de la détection
	'zero-crossing'.\\
	Propriétés : Type 'vec' de taille 1

  %initial firing vector ($<$0 for no firing)   []
  \item {\bf initial firing vector }\\
        Un vecteur. La taille de ce vecteur correspond
	au nombre de sorties événementielles.
	La valeur de la $i^{\rm \grave{e}me}$ entrée
	spécifie la date initiale préprogrammée du 
	$i^{\rm \grave{e}me}$ port événementiel de sortie.
	Si la valeur est inférieure à zéro, alors aucun
	événement n'est préprogrammé.\\
	Propriétés : Type 'vec' de taille sum(\%6)

  %direct feedthrough (y or n)   y
  \item {\bf direct feedthrough }\\
        L'entrée du bloc à un instant donné, détermine
	la sortie du bloc à ce même instant.
	Cela force le bloc à répondre instantanément, comme
	si le système était en régime établi.\\
	Propriétés : Type 'vec' de taille 1

  %time dependence (y or n)   n
  \item {\bf time dependence }\\
        Permet de déterminer si le bloc doit être
	marqué comme temps dépendant.\\
	Propriétés : Type 'vec' de taille 1
\end{itemize}
</FILE>

<FILE name='generic_block3' type='LATEX'>
%automatically generated, please edit
\begin{itemize}

  %simulation function   sinblk
  \item {\bf Simulation function}\\
        Nom de la fonction de simulation à charger.\\
	Propriétés : Type 'vec' de taille 1

  %function type (0,1,2,..)   1
  \item {\bf Function type }\\
        Définit le type de la fonction de calcul.\\
	Propriétés : Type 'vec' de taille 1

  %input ports sizes   1
  \item {\bf Input ports sizes}\\
        Une matrice de taille [n,2] contenant des valeurs positives, nulles ou négatives.
        Cette matrice donne le
        nombre (n) et les tailles des ports réguliers d'entrée.\\
	Propriétés : Type 'vec' de taille -1

  %input ports type   1
  \item {\bf Intput ports type}\\
        Un vecteur qui définit les types de donnée
	des ports réguliers d'entrée.\\
	Propriétés : Type 'vec' de taille  -1

  %output port sizes   1
  \item {\bf Output port sizes}\\
        Une matrice de taille [n,2] contenant des valeurs positives, nulles ou négatives.
        Cette matrice donne le
        nombre (n) et les tailles des ports réguliers de sortie.\\
	Propriétés : Type 'vec' de taille -1

  %output ports type   1
  \item {\bf Output ports type}\\
        Un vecteur qui définit les types de donnée
	des ports réguliers de sortie.\\
	Propriétés : Type 'vec' de taille  -1

  %input event ports sizes   []
  \item {\bf Input event ports sizes}\\
        Un vecteur contenant des valeurs 1.
        La taille de ce vecteur donne le
        nombre de ports événementiels d'entrée.\\
	Propriétés : Type 'vec' de taille -1

  %output events ports sizes   []
  \item {\bf Output events ports sizes}\\
        Un vecteur contenant des valeurs 1.
        La taille de ce vecteur donne le
        nombre de ports événementiels de sortie.\\
	Propriétés : Type 'vec' de taille -1

  %initial continuous state   []
  \item {\bf Initial continuous state}\\
        Un vecteur colonne.
	Conditions initiales des états continus.\\
	Propriétés : Type 'vec' de taille -1

  %initial discrete state   []
  \item {\bf Initial discrete state}\\
        Un vecteur colonne.
        Conditions initiales des états discrets.\\
	Propriétés : Type 'vec' de taille -1

  %initial object state list()
  \item {\bf Initial object state}\\
        Une liste scilab qui définit les états
	objets (oz).\\
	Propriétés : Type 'lis' de taille  -1

  %Real parameters vector   []
  \item {\bf Real parameters vector}\\
        Vecteur des paramètres réels.\\
	Propriétés : Type 'vec' de taille -1

  %Integer parameters vector   []
  \item {\bf Integer parameters vector}\\
        Vecteur des paramètres entiers.\\
	Propriétés : Type 'vec' de taille -1

  %object parameters list  list()
  \item {\bf Object parameters list  }\\
        Une liste scilab qui définit les paramètres
	objets (opar).\\
	Propriétés : Type 'lis' de taille  -1

  %number of modes   0
  \item {\bf Number of modes}\\
        Nombre de modes des fonctions du
	système.\\
	Propriétés : Type 'vec' de taille 1

  %number of zero\_corssings   0
  \item {\bf Number of zero\_corssings}\\
        Nombre de passage à zéro.
        Permet l'utilisation de la détection
	'zero-crossing'.\\
	Propriétés : Type 'vec' de taille 1

  %initial firing vector ($<$0 for no firing)   []
  \item {\bf Initial firing vector }\\
        Un vecteur. La taille de ce vecteur correspond
	au nombre de sorties événementielles.
	La valeur de la $i^{\rm \grave{e}me}$ entrée
	spécifie la date initiale préprogrammée du 
	$i^{\rm \grave{e}me}$ port événementiel de sortie.
	Si la valeur est inférieure à zéro, alors aucun
	événement n'est préprogrammé.\\
	Propriétés : Type 'vec' de taille sum(\%6)

  %direct feedthrough (y or n)   y
  \item {\bf Direct feedthrough }\\
        L'entrée du bloc à un instant donné, détermine
	la sortie du bloc à ce même instant.
	Cela force le bloc à répondre instantanément, comme
	si le système était en régime établi.\\
	Propriétés : Type 'vec' de taille 1

  %time dependence (y or n)   n
  \item {\bf Time dependence }\\
        Permet de déterminer si le bloc doit être
	marqué comme temps dépendant.\\
	Propriétés : Type 'vec' de taille 1
\end{itemize}
</FILE>

<FILE name='get_scicos_version' type='XML'>
  <PARAM>
  <PARAM_INDENT>

    <PARAM_ITEM>
    <PARAM_NAME>scicos_ver</PARAM_NAME>
    <PARAM_DESCRIPTION>
       <SP>
       une chaîne de caractère indiquant le numéro de version.
       </SP>
    </PARAM_DESCRIPTION>
    </PARAM_ITEM>
  </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='getblocklabel' type='XML'>
  <PARAM>
    <PARAM_INDENT>
      <PARAM_ITEM>
	<PARAM_NAME>blk</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    Paramètre entier. Définit l'index d'un bloc dans la
	    structure compilée.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
	<PARAM_NAME>label</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    Chaînes de caractères. Retourne le label du bloc numéroté blk.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
    </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='getscicosvars' type='XML'>
  <PARAM>
    <PARAM_INDENT>
      <PARAM_ITEM>
	<PARAM_NAME>str,str1,str2,...</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    Ce paramètre est soit une chaîne de caractères ou une matrice de
	    chaine de caractère. Les entrées suivantes sont permises :
	  </SP>
	  <SP>
	    "x" : retourne le registre des états continus.
	  </SP>
	  <SP>
	    "nx" : retourne la longueur du registre des états continus.
	  </SP>
	  <SP>
	    "xptr" : retourne le registre des pointeurs du registre des états continus.
	  </SP>
	  <SP>
	    "zcptr" : retourne le registre des pointeurs du registre des détections de surfaces.
	  </SP>
	  <SP>
	    "z" : retourne le registre des états discrets.
	  </SP>
	  <SP>
	    "nz" : retourne la longueur des registres des états discrets.
	  </SP>
	  <SP>
	    "zptr" : retourne le registre des pointeurs du registre des états discrets.
	  </SP>
	  <SP>
	    "noz" : retourne le nombre d'éléments de la liste de l'état discret objet.
	  </SP>
	  <SP>
	    "oz" : retourne la liste de l'état discret objet.
	  </SP>
	  <SP>
	    "ozsz" : retourne les tailles des éléments de la liste l'état discret objet.
	  </SP>
	  <SP>
	    "oztyp" : retourne les types des éléments de la liste l'état discret objet.
	  </SP>
	  <SP>
	    "ozptr" : retourne le registre des pointeurs de la liste l'état discret objet.
	  </SP>
	  <SP>
	    "rpar" : retourne le registre des paramètres réels.
	  </SP>
	  <SP>
	    "rpptr" : retourne le registre des pointeurs du registre des paramètres réels.
	  </SP>
	  <SP>
	    "ipar" : retourne le registre des paramètres entiers.
	  </SP>
	  <SP>
	    "ipptr" : retourne le registre des pointeurs du registre des paramètres entiers.
	  </SP>
	  <SP>
	    "opar" : retourne la liste des paramètres objets.
	  </SP>
	  <SP>
	    "oparsz" : retourne les tailles des éléments de la liste des paramètres objets.
	  </SP>
	  <SP>
	    "opartyp" : retourne les types des éléments de la liste des paramètres objets.
	  </SP>
	  <SP>
	    "opptr" : retourne le registre des pointeurs de la liste des paramètres objets.
	  </SP>
	  <SP>
	    "outtb" : retourne le registre des sorties.
	  </SP>
	  <SP>
	    "inpptr" : retourne le registre des pointeurs des ports réguliers d'entrée.
	  </SP>
	  <SP>
	    "outptr" : retourne le registre des pointeurs des ports réguliers de sorties.
	  </SP>
	  <SP>
	    "inplnk" : retourne le registre des pointeurs des liens connectés aux ports réguliers d'entrée.
	  </SP>
	  <SP>
	    "outlnk" : retourne le registre des pointeurs des liens connectés aux ports réguliers de sortie.
	  </SP>
	  <SP>
	    "subs" : pas utilisé.
	  </SP>
	  <SP>
	    "tevts" : retourne le registre des dates courantes de l'agenda.
	  </SP>
	  <SP>
	    "evtspt" : retourne le registre des événements courants de l'agenda.
	  </SP>
	  <SP>
	    "pointi" : retourne le prochain événement à activer.
	  </SP>
	  <SP>
	    "iord" : retourne le vecteur des blocs activés au début de la simulation.
	  </SP>
	  <SP>
	    "oord" : retourne le vecteur des blocs dont les sorties affectent le calcul des états continus.
	  </SP>
	  <SP>
	    "zord" : retourne le vecteur des blocs dont les sorties affectent le calcul des détections de surfaces.
	  </SP>
	  <SP>
	    "funtyp" : retourne le vecteur des types des fonctions de calcul.
	  </SP>
	  <SP>
	    "ztyp" : retourne le vecteur de pointeurs pour les blocs utilisant les détections de surface.
	  </SP>
	  <SP>
	    "cord" : retourne le vecteur des blocs dont les sorties évoluent continuellement.
	  </SP>
	  <SP>
	    "ordclk" : retourne la matrice associée aux blocs activés par événements.
	  </SP>
	  <SP>
	    "clkptr" : retourne le vecteur de pointeurs pour les ports de sortie d'activation.
	  </SP>
	  <SP>
	    "ordptr" : retourne le vecteur de pointeurs (à partir de ordclk) qui désigne les parties de ordclk correspondant à une activation donnée.
	  </SP>
	  <SP>
	    "critev" : retourne le vecteur des événements critiques.
	  </SP>
	  <SP>
	    "mod" : retourne le vecteur de pointeurs des modes des blocs.
	  </SP>
	  <SP>
	    "nmod" : retourne la longueur du vecteur de pointeurs des modes des blocs.
	  </SP>
	  <SP>
	    "iz" : retourne le registre qui contient les pointeurs C sur block->work.
	  </SP>
	  <SP>
	    "izptr" : retourne le vecteur de pointeurs sur le registre qui contient les pointeurs C sur block->work.
	  </SP>
	  <SP>
	    "nblk" : retourne le nombre de blocs.
	  </SP>
	  <SP>
	    "outtbptr" : retourne le registre qui contient les pointeurs C de outtb.
	  </SP>
	  <SP>
	    "outtbpsz" : retourne le registre qui contient les tailles des éléments de outtb.
	  </SP>
	  <SP>
	    "outtbtyp" : retourne le registre qui contient les types des éléments de outtb.
	  </SP>
	  <SP>
	    "nlnk" : retourne le nombre de sortie.
	  </SP>
	  <SP>
	    "ncord" : retourne le nombre de blocs qui évoluent continuellement.
	  </SP>
	  <SP>
	    "nordptr" : retourne le nombre de blocs qui évoluent par activation.
	  </SP>
	  <SP>
	    "iwa" : n.d.
	  </SP>
	  <SP>
	    "blocks" : retourne une liste scilab qui contient toutes les structures des blocs contenus dans le diagramme.
	  </SP>
	  <SP>
	    "ng" : retourne la longueur du registre des détections de surface.
	  </SP>
	  <SP>
	    "g" : retourne le registre des détections de surfaces.
	  </SP>
	  <SP>
	    "t0" : retourne le temps courant de la simulation.
	  </SP>
	  <SP>
	    "tf" : retourne le temps final de la simulation.
	  </SP>
	  <SP>
	    "Atol" : retourne la tolérance absolue de l'intégrateur du solveur numérique.
	  </SP>
	  <SP>
	    "rtol" : retourne la tolérance relative de l'intégrateur du solveur numérique.
	  </SP>
	  <SP>
	    "ttol" : retourne la tolérance sur le temps du simulateur.
	  </SP>
	  <SP>
	    "deltat" : retourne le temps maximal d'intégration.
	  </SP>
	  <SP>
	    "hmax" : retourne le pas maximal d'intégration du solveur numérique.
	  </SP>
	  <SP>
	    "nelem" : retourne le nombre d'éléments dans outtb.
	  </SP>
	  <SP>
	    "outtb_elem" : retourne le vecteur contenant les numéro d'éléments dans outtb.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>

      <PARAM_ITEM>
	<PARAM_NAME>myvar</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    Ce paramètre de sortie peut-être soit une matrice de nombre int32,
	    une matrice de nombre réel (double) ou bien une Tlist, suivant le
	    paramètre donné en entrée.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>

    </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='lincos' type='XML'>
  <PARAM>
    <PARAM_INDENT>
      <PARAM_ITEM>
	<PARAM_NAME>scs_m</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    une structure de donnée scicos.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
	<PARAM_NAME>x0</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    un vecteur colonne.
	    La valeur de l'état continu autour de laquelle la linéarisation
	    est effectuée (par défaut 0).
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
	<PARAM_NAME>u0</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    un vecteur colonne.
	    La valeur de l'entrée autour de laquelle la linéarisation
	    est effectuée (par défaut 0).
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
	<PARAM_NAME>param</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    param: une liste avec deux éléments (par defaut list(1.d-6,0))
	    param(1): un scalaire. Définit un niveau de perturbation pour la
	    linéarisation;
	    la variation suivante est utilisée :
	    del([x;u])_i = param(1)+param(1)*1d-4*abs([x;u])_i.
	    param(2): un scalaire. Un temps t.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
	<PARAM_NAME>sys</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
            un système définit dans un espace d'état en temporel.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
    </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='model2blk' type='XML'>
  <PARAM>
  <PARAM_INDENT>

    <PARAM_ITEM>
    <PARAM_NAME>blk</PARAM_NAME>
    <PARAM_DESCRIPTION>
      <SP>
      une structure scicos_block
      </SP>
    </PARAM_DESCRIPTION>
    </PARAM_ITEM>

    <PARAM_ITEM>
    <PARAM_NAME>model</PARAM_NAME>
    <PARAM_DESCRIPTION>
      <SP>
      une structure scicos_model
      </SP>
    </PARAM_DESCRIPTION>
    </PARAM_ITEM>

  </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='phase_simulation' type='XML'>
  <PARAM>
  <PARAM_INDENT>
    <PARAM_ITEM>
      <PARAM_NAME>psim</PARAM_NAME>
      <PARAM_DESCRIPTION>
	<SP>
          retourne la  phase courante de la simulation.
	</SP>
	<PARAM_INDENT>
	  <PARAM_ITEM>
	    <PARAM_NAME>1</PARAM_NAME>
	    <PARAM_DESCRIPTION>
	      <SP>
		Le simulateur est sur un point temporel d'activation discrète.
	      </SP>
	    </PARAM_DESCRIPTION>
	  </PARAM_ITEM>
	</PARAM_INDENT>
	<PARAM_INDENT>
	  <PARAM_ITEM>
	    <PARAM_NAME>2</PARAM_NAME>
	    <PARAM_DESCRIPTION>
	      <SP>
		Le simulateur est entrain de réaliser une intégration
		temporelle à temps continu.
	      </SP>
	    </PARAM_DESCRIPTION>
	  </PARAM_ITEM>
	</PARAM_INDENT>
      </PARAM_DESCRIPTION>
    </PARAM_ITEM>
  </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='pointer_xproperty' type='LATEX'>
\begin{itemize}
  \item {\bf xprop} \\
    La valeur donne le type des états :
    \begin{itemize}
      \item -1 : un état algébrique.\\
      \item 1  : un état différentiel.
    \end{itemize}
\end{itemize}
</FILE>

<FILE name='sci_struct' type='XML'>
  <PARAM>

  </PARAM>
</FILE>

<FILE name='scicos' type='LATEX'>
\begin{itemize}
  \item {\bf input : } ce paramètre peut aussi bien être une structure de diagramme Scicos
    (scs\_m) qu'une chaîne de caractères indiquant le chemin du fichier
    du diagramme à charger dans l'éditeur (extension .cos ou .cosf). Si 
    aucun argument d'entrée est utilisé, un diagramme vide est ouvert 
    (avec un nom par défaut 'Untitled').

  \item {\bf scs\_m : } une structure de diagramme Scicos après édition.
\end{itemize}
</FILE>

<FILE name='scicos_block' type='XML'>
  <PARAM>

  </PARAM>
</FILE>

<FILE name='scicos_block4_rout' type='XML'>
  <PARAM>

  </PARAM>
</FILE>

<FILE name='scicos_cpr' type='XML'>
  <PARAM>

  </PARAM>
</FILE>

<FILE name='scicos_debug' type='XML'>
  <PARAM>
  <PARAM_INDENT>
    <PARAM_ITEM>
      <PARAM_NAME>level</PARAM_NAME>
      <PARAM_DESCRIPTION>
	<SP>
	  retourne/définit le niveau de débogage de la simulation scicos.
	</SP>
	<PARAM_INDENT>
	  <PARAM_ITEM>
	    <PARAM_NAME>0</PARAM_NAME>
	    <PARAM_DESCRIPTION>
	      <SP>
              pas de débogage.
	      </SP>
	    </PARAM_DESCRIPTION>
	  </PARAM_ITEM>
	</PARAM_INDENT>
	<PARAM_INDENT>
	  <PARAM_ITEM>
	    <PARAM_NAME>1</PARAM_NAME>
	    <PARAM_DESCRIPTION>
	      <SP>
              debogage léger et informations affichées dans la console Scilab.
	      </SP>
	    </PARAM_DESCRIPTION>
	  </PARAM_ITEM>
	</PARAM_INDENT>
	<PARAM_INDENT>
	  <PARAM_ITEM>
	    <PARAM_NAME>2</PARAM_NAME>
	    <PARAM_DESCRIPTION>
	      <SP>
              debogage fort : plus d'informations affichées dans la console Scilab
	      et éxécution du bloc "debug" si celui ci est présent dans le diagramme.
	      </SP>
	    </PARAM_DESCRIPTION>
	  </PARAM_ITEM>
	</PARAM_INDENT>
	<PARAM_INDENT>
	  <PARAM_ITEM>
	    <PARAM_NAME>3</PARAM_NAME>
	    <PARAM_DESCRIPTION>
	      <SP>
              debogage silencieux : pas d'informations affichées dans la console Scilab
	      et éxécution du bloc "debug" si celui ci est présent dans le diagramme.
	      </SP>
	    </PARAM_DESCRIPTION>
	  </PARAM_ITEM>
	</PARAM_INDENT>
      </PARAM_DESCRIPTION>
    </PARAM_ITEM>
  </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='scicos_diagram' type='XML'>
  <PARAM>

  </PARAM>
</FILE>

<FILE name='scicos_graphics' type='XML'>
  <PARAM>

  </PARAM>
</FILE>

<FILE name='scicos_link' type='XML'>
  <PARAM>

  </PARAM>
</FILE>

<FILE name='scicos_model' type='XML'>
  <PARAM>

  </PARAM>
</FILE>

<FILE name='scicos_params' type='XML'>
  <PARAM>

  </PARAM>
</FILE>

<FILE name='scicos_sim' type='XML'>
  <PARAM>

  </PARAM>
</FILE>

<FILE name='scicos_simulate' type='XML'>
  <PARAM>
    <PARAM_INDENT>
      <PARAM_ITEM>
	<PARAM_NAME>scs_m</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
          scicos diagram (obtained by "load file.cos"). Note that the
	  version of file.cos must be the current version. If not, load into
	  scicos and save.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
	<PARAM_NAME>Info</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
          a list. It must be list() at the first call, then use output
	  Info as input Info for the next calls. Info contains compilation
	  and simulation information and is used to avoid recompilation when
	  not needed.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
	<PARAM_NAME>%scicos_context</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
          a scilab struct containing values of symbolic variables used
	  in the context and Scicos blocks. This is often used to change a
	  parameter in the diagram context. In that case, make sure that in
	  the diagram context the variable is defined such that it can be
	  modified. Say a variable "a" is to be defined in the context
	  having value 1, and later in batch mode, we want to change the
	  value of "a". In that case, in the context of the diagram place:
	  if ~exists('a') then a=1,end If you want then to run the
	  simulation in batch mode using the value a=2, set:
	  %scicos_context.a=2
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
	<PARAM_NAME>flag</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    string. If it equals 'nw' (no window), then blocks using
	    graphical windows are not executed. Note that the list of such
	    blocks must be updated as new blocks are added.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
	<PARAM_NAME>Info</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    contains compilation and simulation information and is used
	    to avoid recompilation when not needed. Normally it should
	    not be modified.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
    </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='scicos_state' type='XML'>
  <PARAM>

  </PARAM>
</FILE>

<FILE name='scicos_time' type='XML'>
  <PARAM>
    <PARAM_INDENT>
      <PARAM_ITEM>
	<PARAM_NAME>t</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    c'est le temps courant de la simulation retourné par un nombre réel.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
    </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='scicosim' type='XML'>
  <PARAM>
    <PARAM_INDENT>

      <PARAM_ITEM>
	<PARAM_NAME>state</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    Scilab tlist containing initial state. Usually generated by
	    Scicos Compile. After loading a compiled .cos file, it can be
	    found in %cpr.state.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>

      <PARAM_ITEM>
	<PARAM_NAME>tcur</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    starting time of simulation. At the beginning it must be zero.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>

      <PARAM_ITEM>
	<PARAM_NAME>tf</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    final simulation time.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>

      <PARAM_ITEM>
	<PARAM_NAME>sim</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    Scilab tlist containing compilation results. Usually generated by
	    Scicos Compile. After loading a compiled .cos file, it can be
	    found in %cpr.sim.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>

      <PARAM_ITEM>
	<PARAM_NAME>str</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    'start' , 'run' or 'finish'. Function must be first called
	    with 'start', then with 'run' one or more times, and finally
	    with 'finish'.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>

      <PARAM_ITEM>
	<PARAM_NAME>tol</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    vector [atol,rtol,ttol,deltat,realtimescale,solver,hmax]
	    where atol, rtol are respectively the absolute and relative
	    tolerances for ode or dae solver, ttol is the precision on
	    event dates (must be very small). deltat is maximum integration
	    interval for each call to ode solver (sometimes needed to force
	    restaring the call to solver). raltimescale is the correspondance
	    between simulation time and real time (0 means no slowing down).
	    solver is the choice of solver (0: lsodar, 100: daskr). hmax: max
	    step size used by solver.
	    Default: [0.0001,1.000E-06,1.000E-10,100001,0,0]
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>

      <PARAM_ITEM>
	<PARAM_NAME>state</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    state after simulation
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>

      <PARAM_ITEM>
	<PARAM_NAME>t</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    final reached time. Usually tf but not always.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
    </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='scifunc_block' type='LATEX'>
%automatically generated, please edit
\begin{itemize}

  %input ports sizes   1
  \item {\bf input ports sizes}\\
        Un scalaire.
        Le nombre de ports réguliers d'entrée.\\
	Propriétés : Type 'vec' de taille -1

  %output port sizes   1
  \item {\bf output port sizes}\\
        Un scalaire.
        Le nombre de ports réguliers de sortie.\\
	Propriétés : Type 'vec' de taille -1

  %input event ports sizes   []
  \item {\bf input event ports sizes}\\
        Un scalaire.
        Le nombre de ports événementiel d'entrée.\\
	Propriétés : Type 'vec' de taille -1

  %output events ports sizes   []
  \item {\bf output events ports sizes}\\
        Un scalaire.
        Le nombre de ports événementiel de sortie.\\
	Propriétés : Type 'vec' de taille -1

  %initial continuous state   []
  \item {\bf initial continuous state}\\
        Un vecteur colonne.
        Conditions initiales des états continus.\\
	Propriétés : Type 'vec' de taille -1

  %initial discrete state   []
  \item {\bf initial discrete state}\\
        Un vecteur colonne.
        Conditions initiales des états discrets.\\
	Propriétés : Type 'vec' de taille -1

  %System parameters vector   []
  \item {\bf System parameters vector}\\
        une chaîne de caractères : c ou d
	({\bf CBB} ou {\bf DBB}), les autres
	types ne sont pas supportés.\\
	Propriétés : Type 'vec' de taille -1

  %initial firing vector ($<$0 for no firing)   []
  \item {\bf initial firing vector }\\
        Un vecteur. La taille de ce vecteur correspond
	au nombre de sorties événementielles.
	La valeur de la $i^{\rm \grave{e}me}$ entrée
	spécifie la date initiale préprogrammée du 
	$i^{\rm \grave{e}me}$ port événementiel de sortie.
	Si la valeur est inférieure à zéro, alors aucun
	événement n'est préprogrammé.\\
	Propriétés : Type 'vec' de taille sum(\%4)

  %is block always active (0:no, 1:yes)   0
  \item {\bf is block always active }\\
        other dialogues are opened
	consecutively where used may input Scilab code associated with the
	computations needed (block initialization, outputs, continuous and
	discrete state, output events date, block ending)\\
	Propriétés : Type 'vec' de taille 1
 \end{itemize}
</FILE>

<FILE name='scifunc_block_m' type='LATEX'>
%automatically generated, please edit
\begin{itemize}

  %input ports sizes   1
  \item {\bf input ports sizes}\\
        Un scalaire.
        Le nombre de ports réguliers d'entrée.\\
	Propriétés : Type 'vec' de taille -1

  %output port sizes   1
  \item {\bf output port sizes}\\
        Un scalaire.
        Le nombre de ports réguliers de sortie.\\
	Propriétés : Type 'vec' de taille -1

  %input event ports sizes   []
  \item {\bf input event ports sizes}\\
        Un scalaire.
        Le nombre de ports événementiel d'entrée.\\
	Propriétés : Type 'vec' de taille -1

  %output events ports sizes   []
  \item {\bf output events ports sizes}\\
        Un scalaire.
        Le nombre de ports événementiel de sortie.\\
	Propriétés : Type 'vec' de taille -1

  %initial continuous state   []
  \item {\bf initial continuous state}\\
        Un vecteur colonne.
        Conditions initiales des états continus.\\
	Propriétés : Type 'vec' de taille -1

  %initial discrete state   []
  \item {\bf initial discrete state}\\
        Un vecteur colonne.
        Conditions initiales des états discrets.\\
	Propriétés : Type 'vec' de taille -1

  %System parameters vector   []
  \item {\bf System parameters vector}\\
        une chaîne de caractères : c ou d
	({\bf CBB} ou {\bf DBB}), les autres
	types ne sont supportés.\\
	Propriétés : Type 'vec' de taille -1

  %initial firing vector ($<$0 for no firing)   []
  \item {\bf initial firing vector }\\
        Un vecteur. La taille de ce vecteur correspond
	au nombre de sorties événementielles.
	La valeur de la $i^{\rm \grave{e}me}$ entrée
	spécifie la date initiale préprogrammée du 
	$i^{\rm \grave{e}me}$ port événementiel de sortie.
	Si la valeur est inférieure à zéro, alors aucun
	événement n'est préprogrammé.\\
	Propriétés : Type 'vec' de taille sum(\%4)

  %is block always active (0:no, 1:yes)   0
  \item {\bf is block always active }\\
        other dialogues are opened
	consecutively where used may input Scilab code associated with the
	computations needed (block initialization, outputs, continuous and
	discrete state, output events date, block ending)\\
	Propriétés : Type 'vec' de taille 1
 \end{itemize}
</FILE>

<FILE name='set_blockerror' type='LATEX'>
 \begin{itemize}
   \item {\bf n} : un numéro d'erreur. Les appels suivant sont autorisés :
          \begin{itemize}
             \item {\bf set\_blockerror(-1)}\\ 
                   le bloc a été appelé avec une valeur d'entrée en dehors du domaine autorisé
             \item {\bf set\_blockerror(-2)}\\
                   une singularité a été rencontrée dans le bloc
             \item {\bf set\_blockerror(-3)}\\
                   le bloc a produit une erreur interne
             \item {\bf set\_blockerror(-16)} \\
                   le bloc ne peut pas allouer de mémoire
          \end{itemize}
 \end{itemize}
</FILE>

<FILE name='set_xproperty' type='LATEX'>
\begin{itemize}
  \item {\bf xprop} \\
    La valeur donne le type des états :
    \begin{itemize}
      \item -1 : un état algébrique.\\
      \item 1  : un état différentiel.
    \end{itemize}
\end{itemize}
</FILE>

<FILE name='sig2data' type='XML'>
  <PARAM>
  <PARAM_INDENT>
    <PARAM_ITEM>
    <PARAM_NAME>B</PARAM_NAME>
    <PARAM_DESCRIPTION>
      <SP>
      une structure scilab qui définit un signal :
      </SP>
        <PARAM_INDENT>
          <PARAM_ITEM>
            <PARAM_NAME>B.values</PARAM_NAME>
            <PARAM_DESCRIPTION>
              <SP>
                B data
              </SP>
            </PARAM_DESCRIPTION>
          </PARAM_ITEM>

          <PARAM_ITEM>
            <PARAM_NAME>B.time</PARAM_NAME>
            <PARAM_DESCRIPTION>
              <SP>
                les instants d'échantillonnage sous la
                forme d'un vecteur colonne.
              </SP>
            </PARAM_DESCRIPTION>
          </PARAM_ITEM>

        </PARAM_INDENT>
    </PARAM_DESCRIPTION>
    </PARAM_ITEM>

    <PARAM_ITEM>
    <PARAM_NAME>x</PARAM_NAME>
    <PARAM_DESCRIPTION>
      <SP>
        le champ B.values
      </SP>
    </PARAM_DESCRIPTION>
    </PARAM_ITEM>

    <PARAM_ITEM>
    <PARAM_NAME>t</PARAM_NAME>
    <PARAM_DESCRIPTION>
      <SP>
        le champ B.time
      </SP>
    </PARAM_DESCRIPTION>
    </PARAM_ITEM>
  </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='steadycos' type='XML'>
  <PARAM>
    <PARAM_INDENT>

      <PARAM_ITEM>
	<PARAM_NAME>scs_m</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    a Scicos data structure
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>

      <PARAM_ITEM>
	<PARAM_NAME>X</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    column vector. Continuous state. Can be set to [] if zero.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>

      <PARAM_ITEM>
	<PARAM_NAME>U</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    column vector. Input. Can be set to [] if zero.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>

      <PARAM_ITEM>
	<PARAM_NAME>Y</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    column vector. Output. Can be set to [] if zero.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>

      <PARAM_ITEM>
	<PARAM_NAME>Indx</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    index of entries of X that are not fixed. If all can vary,
	    set to 1:$
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>

      <PARAM_ITEM>
	<PARAM_NAME>Indu</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    index of entries of U that are not fixed. If all can vary,
	    set to 1:$
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>

      <PARAM_ITEM>
	<PARAM_NAME>Indy</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    index of entries of Y that are not fixed. If all can vary,
	    set to 1:$
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>

      <PARAM_ITEM>
	<PARAM_NAME>Indxp</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    index of entries of XP (derivative of x) that need not be
	    zero. If all can vary, set to 1:$. Default [].
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>

      <PARAM_ITEM>
	<PARAM_NAME>param</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    list with two elements (default list(1.d-6,0)). param(1):
	    scalar. Perturbation level for linearization; the following
	    variation is used del([x;u])_i =
	    param(1)+param(1)*1d-4*abs([x;u])_i.
	    param(2): scalar. Time t.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>

      <PARAM_ITEM>
	<PARAM_NAME>X</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    steady state X
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>

      <PARAM_ITEM>
	<PARAM_NAME>U</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    stationary input U
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>

      <PARAM_ITEM>
	<PARAM_NAME>Y</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    output corresponding to steady state found
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>

      <PARAM_ITEM>
	<PARAM_NAME>XP</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    derivative of the state corresponding to steady state found
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
    </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='use_flag' type='XML'>
  <PARAM>

  </PARAM>
</FILE>

<FILE name='var2vec' type='XML'>
  <PARAM>
    <PARAM_INDENT>
      <PARAM_ITEM>
	<PARAM_NAME>var</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    Paramètre d'entrée. Peut-être tous types d'objet scilab.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
	<PARAM_NAME>vec</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    Paramètre de sortie. Un vecteur de nombres réels.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
    </PARAM_INDENT>
  </PARAM>
</FILE>

<FILE name='vec2var' type='XML'>
  <PARAM>
    <PARAM_INDENT>
      <PARAM_ITEM>
	<PARAM_NAME>vec</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    Paramètre d'entrée. Un vecteur de nombres réels.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
	<PARAM_NAME>var</PARAM_NAME>
	<PARAM_DESCRIPTION>
	  <SP>
	    Paramètre de sortie. Peut-être tous types d'objet scilab.
	  </SP>
	</PARAM_DESCRIPTION>
      </PARAM_ITEM>
    </PARAM_INDENT>
  </PARAM>
</FILE>


</DATA>

