// Scilab ( http://www.scilab.org/ ) - This file is part of Scilab
// Copyright (C) - 2013 - INRIA -Serge Steer
// Copyright (C) INRIA - METALAU Project <scicos@inria.fr>
//
// This file must be used under the terms of the CeCILL.
// This source file is licensed as described in the file COPYING, which
// you should have received as part of this distribution.  The terms
// are also available at
// http://www.cecill.info/licences/Licence_CeCILL_V2-en.txt

function sys = lincos(scs_m,x0,u0,param)
    // lincos - Constructs by linearization a linear state-space
    // model from a general dynamical system described by a
    // scicos diagram
    // CALLING SEQUENCE
    // sys = lincos(scs_m [,x0,u0 [,param] ])
    // sys = lincos(cpr [,x0,u0 [,param] ])
    // PARAMETERS
    // scs_m     : a Scicos data structure with input and output ports
    // cpr       : a tlist generated by xcos_compile
    // x0        : column vector. Continuous state around which linearization to be done (default 0)
    // u0        : column vector. Input around which linearization to be done (default 0)
    // param     : list with two elements (default list(1.d-6,0))
    //   param(1): scalar. Perturbation level for linearization; the following variation is used
    //             del([x;u])_i = param(1)+param(1)*1d-4*abs([x;u])_i
    //   param(2): scalar. Time t.
    // sys       : state-space system
    // DESCRIPTION
    // Constructs by linearization a linear state-space
    // model from a general dynamical system described by a
    // scicos diagram scs_m. Input and output ports, normally
    // used inside superblocks, should be used to specify
    // inputs and outputs in the scicos diagram.

    fname="lincos"
    [lhs,rhs] = argn(0) ;
    if rhs < 1 then
        error(msprintf(_("%s: Wrong number of input argument(s): At least %d expected.\n"), fname, 1));
    end
    if ~exists("scicos_diagram") then
        loadXcosLibs();
    end

    if exists("scicos_scicoslib")==0 then
        load("SCI/modules/scicos/macros/scicos_scicos/lib") ;
    end

    if exists("scicos_autolib")==0 then
        load("SCI/modules/scicos/macros/scicos_auto/lib") ;
    end

    if exists("scicos_utilslib")==0 then
        load("SCI/modules/scicos/macros/scicos_utils/lib") ;
    end

    // Define Scicos data tables ===========================================
    if ~isdef("modelica_libs") |~isdef("scicos_pal_libs")  then
        [modelica_libs, scicos_pal_libs] = initial_scicos_tables();
    end
    // =====================================================================

    //overload message functions
    fprot=funcprot(0)
    message=console_message
    messagebox=console_message
    hilite_path=console_path
    funcprot(fprot)

    select typeof(scs_m)
    case "diagram" then
        //compile
        [%cpr,ok] = xcos_compile(scs_m,fname);

        if ~ok then return;end
    case "cpr" then
        %cpr=scs_m
    else
        error(msprintf(_("%s: Wrong type for input argument #%d: A diagram expected.\n"), fname, 1));
    end
    clear scs_m;

    select rhs
    case 1 then
        param=list(1.d-6,0)
        [x0,u0] = steadycos(%cpr,[],[],[],1:$,1:$,1:$,[],param);
    case 2 then
        param=x0;
        [x0,u0] = steadycos(%cpr,[],[],[],1:$,1:$,1:$,[],param);
    case 3 then
        param=list(1.d-6,0)
    case 4 then
        if type(param)<>15 then
            error(msprintf(_("Wrong type for argument %d: List expected.\n"), ...
            fname, 9))
        end
        if size(param)<>2 then
            error(msprintf(_("%s: Wrong size for input argument #%d: List of size %d expected.\n"),...
            fname, 9,2))
        end
        if param(1)==0 then param(1)=1.d-6;end
    else
        error(msprintf(_("%s: Wrong number of input argument(s): %d,%d or %d expected.\n"), fname, 1,3,4));
    end

    t = param(2);

    // compile and post-process the diagram
    cor=%cpr.cor;
    sim=%cpr.sim;
    ports=%cpr.ports
    //Get the adress of storage of input signals in outtb
    nin=size(ports.IN,1);
    outlnk=sim.outlnk;
    outptr=sim.outptr;
    pointi=zeros(1,nin)
    for i=1:nin;
        kcpr=cor(ports.IN(i,2));
        pointi(i)=outlnk(outptr(kcpr))
    end

    //Get the adress of storage of output signals in outtb
    nout=size(ports.OUT,1)
    inplnk=sim.inplnk;inpptr=sim.inpptr;
    pointo=zeros(1,nout)
    for i=1:nout;
        kcpr=cor(ports.OUT(i,2));
        pointo(i)=inplnk(inpptr(kcpr))
    end

    state=%cpr.state;
    is_impl=or(sim.funtyp==10004)
    //
    nx=size(state.x,"*");
    if is_impl then
        ns=nx/2;
        tol=[zeros(1,5) 100 0]; //unused but requested by scicosim
    else
        ns=nx;
        tol=[zeros(1,5) 0 0]; //unused but requested by scicosim
    end
    //total number of input values
    nu=0; for k=pointi, nu=nu+size(state.outtb(k),"*"), end
    //total number of output values
    ny=0; for k=pointo, ny=ny+size(state.outtb(k),"*"), end

    if x0==[] then x0=zeros(nx,1);end
    if u0==[] then u0=zeros(nu,1);end
    if size(x0,"*")<>nx then
        error(msprintf(gettext("%s: Wrong size for input argument #%d: %d-by-%d matrix expected.\n"),...
        "lincos", 2, nx, 1))
    end

    if size(u0,"*")<>nu then
        error(msprintf(gettext("%s: Wrong size for input argument #%d: %d-by-%d matrix expected.\n"),...
        "lincos", 3, nu, 1))
    end
    x0 = x0(:);
    u0 = u0(:);

    del = param(1)+param(1)*1d-4*abs([x0;u0])
    t   = param(2)


    [state,t] = scicosim(state,t,t,sim,"start",tol);

    state.x=x0;//x0 is assumed to contain [x0;xp0]  for implicit systems
    state.outtb=setInputs(state.outtb,pointi,u0);
    [state,t]=scicosim(state,t,t,sim,"linear",tol);
    //LHS and LHS0 contain state derivative or residual followed by outputs
    LHS0=[state.x(1:ns);getOutputs(state.outtb,pointo)];
    np=size(LHS0,"*")

    F=zeros(np,nx+nu);
    Args0=[x0;u0];

    for i=1:nx+nu
        Args=Args0;
        Args(i)=Args(i)+del(i);
        state.x=Args(1:nx);
        state.outtb=setInputs(state.outtb,pointi,Args(nx+1:$));
        [state,t]=scicosim(state,t,t,sim,"linear",tol);
        LHS=[state.x(1:ns);getOutputs(state.outtb,pointo)];
        F(:,i)=(LHS-LHS0)/del(i);
    end
    [state,t] = scicosim(state,t,t,sim,"finish",tol);
    if is_impl then
        sys=des2ss(F(1:ns,1:ns),F(1:ns,nx+1:$),F(ns+1:$,1:ns),F(ns+1:$,nx+1:$),F(1:ns,ns+1:nx))
        sys=syslin("c",sys)
    else
        sys = syslin("c",F(1:nx,1:nx),F(1:nx,nx+1:nx+nu),F(nx+1:nx+ny,1:nx),F(nx+1:nx+ny,nx+1:nx+nu));
    end
endfunction
