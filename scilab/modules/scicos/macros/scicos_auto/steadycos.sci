// Scilab ( http://www.scilab.org/ ) - This file is part of Scilab
// Copyright (C) - 2013 - INRIA -Serge Steer
// Copyright (C) INRIA - METALAU Project <scicos@inria.fr>
//
// This file must be used under the terms of the CeCILL.
// This source file is licensed as described in the file COPYING, which
// you should have received as part of this distribution.  The terms
// are also available at
// http://www.cecill.info/licences/Licence_CeCILL_V2-en.txt

function [X,U,Y,XP,cpr] = steadycos(scs_m,X,U,Y,Indx,Indu,Indy,Indxp,param)
    // steadycos - Finds an equilibrium state of a general
    // dynamical system described by a scicos diagram
    // CALLING SEQUENCE
    // [X,U,Y,XP [,cpr]] = steadycos(scs_m,X,U,Y,Indx,Indu,Indy [,Indxp [,param ] ])
    // [X,U,Y,XP] = steadycos(cpr,X,U,Y,Indx,Indu,Indy [,Indxp [,param ] ])
    //
    // scs_m     : a Scicos data structure with input and output ports
    // cpr       : a tlist generated by xcos_compile
    // X         : column vector. Continuous state. Can be set to [] if zero.
    // U         : column vector. Input. Can be set to [] if zero.
    // Y         : column vector. Output. Can be set to [] if zero.
    // Indx      : index of entries of X that are not fixed. If all can vary, set to 1:$
    // Indu      : index of entries of U that are not fixed. If all can vary, set to 1:$
    // Indy      : index of entries of Y that are not fixed. If all can vary, set to 1:$
    // Indxp     : index of entries of XP (derivative of x) that need not be zero.
    //             If all can vary, set to 1:$. Default [].
    // param:    list with two elements (default list(1.d-6,0))
    //   param(1): scalar. Perturbation level for linearization; the following variation is used
    //             del([x;u])_i = param(1)+param(1)*1d-4*abs([x;u])_i
    //   param(2): scalar. Time t.
    //
    XP=[];cpr=list();
    fname="steadycos"
    if ~exists("scicos_diagram") then
        loadXcosLibs();
    end

    if exists("scicos_scicoslib")==0 then
        load("SCI/modules/scicos/macros/scicos_scicos/lib") ;
    end

    if exists("scicos_autolib")==0 then
        load("SCI/modules/scicos/macros/scicos_auto/lib") ;
    end

    if exists("scicos_utilslib")==0 then
        load("SCI/modules/scicos/macros/scicos_utils/lib") ;
    end

    // Define Scicos data tables ===========================================
    if ~isdef("modelica_libs") |~isdef("scicos_pal_libs")  then
        [modelica_libs, scicos_pal_libs] = initial_scicos_tables();
    end
    // =====================================================================

    [lhs,rhs] = argn(0) ;
    if rhs < 1 then
        error(msprintf(_("%s: Wrong number of input argument(s): At least %d expected.\n"), fname, 1));
    end

    // Overload message functions to have messages redirected to the console
    fprot=funcprot(0)
    message=console_message
    messagebox=console_message
    hilite_path=console_path
    funcprot(fprot)

    select typeof(scs_m)
    case "diagram" then
        [cpr,ok] = xcos_compile(scs_m,fname);
        if ~ok then return;end

    case "cpr" then
        cpr=scs_m
    else
        error(msprintf(_("%s: Wrong type for input argument #%d: A diagram expected.\n"), fname, 1));
    end


    if rhs==7 then
        Indxp=[ ];param=list(1.d-6,0)
    elseif rhs==8 then
        param=list(1.d-6,0)
    elseif rhs==9 then
        if type(param)<>15 then
            error(msprintf(_("Wrong type for argument %d: List expected.\n"), ...
            fname, 9))
        end
        if size(param)<>2 then
            error(msprintf(_("%s: Wrong size for input argument #%d: List of size %d expected.\n"),...
            fname, 9,2))
        end
        if param(1)==0 then param(1)=1.d-6;end
    else
        error(msprintf(_("%s: Wrong number of input arguments: %d to %d expected.\n"), fname, 7, 9));
    end
    t = param(2);

    cor=cpr.cor;
    sim=cpr.sim;
    ports=cpr.ports;

    //Get the adress of storage of input signals in outtb
    nin=size(ports.IN,1);
    outlnk=sim.outlnk;outptr=sim.outptr;
    pointi=zeros(1,nin)
    for i=1:nin;
        kcpr=cor(ports.IN(i,2));
        pointi(i)=outlnk(outptr(kcpr))
    end

    //Get the adress of storage of output signals in outtb
    nout=size(ports.OUT,1)
    inplnk=sim.inplnk;inpptr=sim.inpptr;
    pointo=zeros(1,nout)
    for i=1:nout;
        kcpr=cor(ports.OUT(i,2));
        pointo(i)=inplnk(inpptr(kcpr))
    end

    state=cpr.state;
    is_impl=or(sim.funtyp==10004)
    //


    nx=size(state.x,"*");
    if is_impl ns=nx/2;else ns=nx;end
    //total number of input values
    nu=0; for k=pointi, nu=nu+size(state.outtb(k),"*"), end
    //total number of output values
    ny=0; for k=pointo, ny=ny+size(state.outtb(k),"*"), end

    Indu=index2index(Indu,nu);
    if max(Indu)>nu|min(Indu)<1 then
        error(msprintf(_("%s: Wrong value for input argument #%d: Must be in [%d %d].\n"),...
        fname,6,1,nu))
    end
    Indx=index2index(Indx,ns);
    if max(Indx)>nx|min(Indx)<1 then
        error(msprintf(_("%s: Wrong value for input argument #%d: Must be in [%d %d].\n"),...
        fname,5,1,ns))
    end

    Indy=index2index(Indy,ny);
    if max(Indy)>nx|min(Indy)<1 then
        error(msprintf(_("%s: Wrong value for input argument #%d: Must be in [%d %d].\n"),...
        fname,7,1,ny))
    end

    Indxp=index2index(Indxp,ns);
    if max(Indxp)>nx|min(Indxp)<1 then
        error(msprintf(_("%s: Wrong value for input argument #%d: Must be in [%d %d].\n"),...
        fname,8,1,ns))
    end

    sindu = size(Indu,"*");
    sindx = size(Indx,"*");


    if X==[] then X=zeros(ns,1);end
    if Y==[] then Y=zeros(ny,1);end
    if U==[] then U=zeros(nu,1);end
    if is_impl then
        tol=[zeros(1,5) 100 0];
    else
        tol=zeros(1,7);
    end

    //Initialize diagram blocks
    [state,t] = scicosim(state,t,t,sim,"start",tol);
    global state

    //Create mimization variable array
    neq=ns+ny-size(Indy,"*")
    unk = [U(Indu);X(Indx);zeros(X(Indxp))];
    nunk=size(unk,"*")
    if neq>nunk then
        //Over determined problem extend the unknown vector
        unk(neq)=0
    end
    if is_impl then
        [sol,e,info]=fsolve(unk,list(steadyEQ_impl,X,Indx,Indxp,U,Indu,Y,Indy),1e-12)
    else
        [sol,e,info]=fsolve(unk,list(steadyEQ_expl,X,Indx,Indxp,U,Indu,Y,Indy),1e-12)
    end
    if info>1 then
        Info=[_("number of calls to fcn reached.")
        _("tol is too small. No further improvement in the approximate solution x is possible.")
        _("iteration is not making good progress.")]
        warning([_("Solution found does not fullfill requested convergence criteria");
        Info(info-1)])
    end
    //Extract results out of the vector of unknowns
    U(Indu) = sol(1:sindu);
    X(Indx) = sol(sindu+1:sindu+sindx);
    if is_impl then
        XP=zeros(X);XP(Indxp)=sol(sindu+sindx+1:$)
        residual=state.x(1:ns)
    else
        XP=state.x
    end
    Y=getOutputs(state.outtb,pointo)
    //Terminates all the blocks of the diagram
    [state,t] = scicosim(state,t,t,sim,"finish",tol);
    clearglobal state
endfunction

function e=steadyEQ_expl(unk,X,Indx,Indxp,U,Indu,Y,Indy)
    //fsolve external function used by steadycos in case of explicit diagram
    //  unk    : column vector of the unknowns
    //  X      : initial state vector  X(Indx)  is the part to be computed
    //  Indx   : index of the components of the state that have to be computed
    //  Indxp  : index of the components of the state derivatives that do not
    //           need to be equal to zero
    //  U      : initial input vector, U(Indu)  is to be computed
    //  Indu   : index of the components of the inputs that have to be computed
    //  Y      : initial output vector, Y(Indy)  is free output values
    //  Indy   : index of the components of the outputs that are free
    //  e      : column vector, equation errors (constrained part of state
    //           derivative and  imposed outputs)
    //
    //  pointi : row vector, the adress of the beginning of inputs vector
    //           in outtb. Comes from calling environnment.
    //  pointo : row vector, the adress of the beginning of outputs vector
    //           in outtb. Comes from calling environnment.
    //Author : Serge Steer INRIA - 2013
    global state
    //Set diagram output registers of input blocs and states from unknowns
    sindu=size(Indu,"*");
    U(Indu)=unk(1:sindu);
    sindx=size(Indx,"*");
    X(Indx)=unk(sindu+1:sindx+sindu);
    sindxp=size(Indxp,"*");
    Xp=zeros(X);Xp(Indxp)=unk(sindx+sindu+1:sindx+sindu+sindxp);
    state.x=X
    state.outtb=setInputs(state.outtb,pointi,U)
    //evaluate state derivatives
    [state,t] = scicosim(state,t,t,sim,"linear",tol);
    //get input registers of output blocs and state derivatives
    xp=state.x;//the derivative of the state
    y=getOutputs(state.outtb,pointo)

    //evaluate error vector
    xp(Indxp)=0;
    ey=Y-y;ey(Indy)=[]
    e=[xp;ey;zeros(nunk-neq,1)];
endfunction

function e=steadyEQ_impl(unk,X,Indx,Indxp,U,Indu,Y,Indy)
    //fsolve external function used by steadycos in case of implicit diagram
    //  unk    : column vector of the unknowns
    //  X      : initial state vector  X(Indx)  is the part to be computed
    //  Indx   : index of the components of the state that have to be computed
    //  Indxp  : index of the components of the state derivatives that do not
    //           need to be equal to zero
    //  U      : initial input vector, U(Indu)  is to be computed
    //  Indu   : index of the components of the inputs that have to be computed
    //  Y      : initial output vector, Y(Indy)  is free output values
    //  Indy   : index of the components of the outputs that are free
    //  e      : column vector, equation errors (residual and imposed outputs)
    //
    //  pointi : row vector, the adress of the beginning of inputs vector
    //           in outtb. Comes from calling environnment.
    //  pointo : row vector, the adress of the beginning of outputs vector
    //           in outtb. Comes from calling environnment.
    //Author : Serge Steer INRIA - 2013
    global state
    //Set diagram output registers of input blocs, states and states
    //derivatives from unknowns
    sindu=size(Indu,"*");
    sindx=size(Indx,"*");
    sindxp=size(Indxp,"*");
    U(Indu)=unk(1:sindu);
    X(Indx)=unk(sindu+1:sindx+sindu);
    Xp=zeros(X); Xp(Indxp)=unk(sindx+sindu+1:sindx+sindu+sindxp);
    state.x=[X;Xp]
    state.outtb=setInputs(state.outtb,pointi,U)
    //evaluate state derivatives
    [state,t] = scicosim(state,t,t,sim,"linear",tol);
    //get input registers of output blocs and residual
    residual=state.x(1:$/2); //residual
    y=getOutputs(state.outtb,pointo);

    //evaluate error vector
    ey=Y-y;ey(Indy)=[]
    e=[residual;ey;zeros(nunk-neq,1)]
endfunction

function Ind=index2index(Ind,n)
    //Convert implicitly defined index (:, $, ...) by corresponding vectors
    //of index
    //Author : Serge Steer INRIA  - 2013
    select type(Ind)
    case 1 then
        if and(size(Ind)==[-1 -1]) then
            Ind=1:n
        end
    case 4 then
        Ind=find(Ind)
    case 2 then
        Ind=horner(Ind,n)
    case 129 then
        Ind=horner(Ind(1),n):horner(Ind(2),n):horner(Ind(3),n)
    else
        error("Invalid index")
    end
endfunction
