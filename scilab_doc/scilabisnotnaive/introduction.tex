\section{Introduction}

Scilab take cares with your numbers.
While most mathematic books deals with exact formulas, 
Scilab uses algorithms which are specifically designed for 
computers. 

As a practical example of the problem considered in this
document, consider the following experiments. The following is an example of 
a Scilab 5.1 session, where we compute 0.1 by two ways.

\begin{verbatim}
-->format(25)
-->0.1
 ans  =
    0.1000000000000000055511  
-->1.0-0.9
 ans  =
    0.0999999999999999777955  
\end{verbatim}

I guess that for a person who has never heard of these problems,
this experiment may be a shock. To get things clearer, let's 
check that the sinus function is approximated.

\begin{verbatim}
-->format(25)
-->sin(0.0)
 ans  =
    0.  
-->sin(%pi)
 ans  =
    0.0000000000000001224647  
\end{verbatim}

The difficulty is generated by the fact that, while 
the mathematics treat with \emph{real} numbers, the 
computer deals with their \emph{floating point representations}.
This is the difference between the 
\emph{naive}, mathematical, approach, and the \emph{numerical},
floating-point aware, implementation.
(The detailed explanations of the previous examples are presented  
in the appendix of this document.)

In this article, we will show examples of these problems by 
using the following theoric and experimental approach.
\begin{enumerate}
\item First, we will derive the basic theory at the core of a numerical
formula. 
\item Then we will implement it in Scilab and compare with the 
result given by the primitive provided by Scilab.
As we will see, some particular cases do not work well
with our formula, while the Scilab primitive computes a correct
result.
\item Then we will analyse the \emph{reasons} of the differences.
\end{enumerate}

When we compute errors, we use the relative error formula
\begin{eqnarray}
e_r=\frac{|x_c-x_e|}{|x_e|}, \qquad x_e\neq 0
\end{eqnarray}
where $x_c\in\RR$ is the computed value, and $x_e\in\RR$ is the 
expected value, i.e. the mathematically exact result.
The relative error is linked with the number of significant 
digits in the computed value $x_c$. For example, if the relative 
error $e_r=10^{-6}$, then the number of significant digits is 6.

When the expected value is zero, the relative error cannot 
be computed, and we then use the absolute error instead 
\begin{eqnarray}
e_a=|x_c-x_e|.
\end{eqnarray}

Before getting into the details, it is important to 
know that real variables in the Scilab language are stored in 
\emph{double precision} variables. Since Scilab is 
following the IEEE 754 standard, that means that real 
variables are stored with 64 bits precision.
As we shall see later, this has a strong influence on the 
results.



