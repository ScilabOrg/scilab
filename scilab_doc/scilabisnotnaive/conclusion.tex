% Copyright (C) 2008-2010 - Consortium Scilab - Digiteo - Michael Baudin
%
% This file must be used under the terms of the 
% Creative Commons Attribution-ShareAlike 3.0 Unported License :
% http://creativecommons.org/licenses/by-sa/3.0/

\section{Conclusion}

We have presented several cases where the mathematically perfect 
algorithm (i.e. without obvious bugs) does not produce accurate results 
with the computer in particular situations.
Many Scilab algorithms take floating point values as inputs,
and return floating point values as output. We have presented situations 
where the intermediate calculations involve terms which are 
not representable as floating point values. We have also presented 
examples where cancellation occurs so that the rounding errors dominate 
the result. We have analyzed specific algorithms which can be used to 
cure some of the problems. 

Most algorithms provided by Scilab are designed specifically to take into 
account for floating point numbers issues. The result is a collection of 
robust algorithms which, most of the time, exceed the user's needs.

Still, it may happen that the algorithm used by Scilab is not accurate enough,
so that floating point issues may occur in particular cases. We cannot 
pretend that Scilab always use the best algorithm. In fact, we have 
given in this document practical (but extreme) examples where the 
algorithm used by Scilab is not accurate. In this situation, an 
interesting point is that Scilab is open-source, so that anyone who want 
can inspect the source code, analyze the algorithm and point out the 
problems of this algorithm.

That article does not aim at discouraging from 
using floating point numbers or implementing our own algorithms.
Instead, the goal of this document is to give examples where 
some specific work is to do when we translate the 
mathematical material into a computational algorithm based on floating 
point numbers. Indeed, accuracy can be obtained with floating point numbers, 
provided that we are less \emph{naive}, use the appropriate theory and algorithms, and perform 
the computations with tested softwares.

