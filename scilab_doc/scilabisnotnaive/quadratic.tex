% Copyright (C) 2008-2010 - Consortium Scilab - Digiteo - Michael Baudin
%
% This file must be used under the terms of the 
% Creative Commons Attribution-ShareAlike 3.0 Unported License :
% http://creativecommons.org/licenses/by-sa/3.0/

\section{Quadratic equation}

In this section, we analyze the computation of the roots of a quadratic polynomial.
As we shall see, there is a whole \emph{world} from the mathematical formulas to the 
implementation of such computations. In the first part, we briefly report the formulas which allow to 
compute the real roots of a quadratic equation with real coefficients.
We then present the naive algorithm based on these mathematical formulas. 
In the second part, we make some experiments in Scilab and compare our
naive algorithm with the \scifun{roots} Scilab function.
In the third part, we analyze why and how floating point numbers must be 
taken into account when the roots of a quadratic are required.

\subsection{Theory}

In this section, we present the mathematical formulas which allow to compute the 
real roots of a quadratic polynomial with real coefficients.
We chose to begin by the example of a quadratic equation, because most of 
us exactly know (or \emph{think} we know) how to solve such an equation with a computer.

Assume that $a, b, c \in \RR$ are given coefficients and $a\neq 0$. 
Consider the following quadratic \cite{wikipediaquadratic,wikipedialossofsign,mathworldquadratic} equation:
\begin{eqnarray}
\label{eq-quadratic}
a x^2 + b x + c = 0,
\end{eqnarray}
where $x\in\RR$ is the unknown.

Let us define by $\Delta=b^2-4ac$ the discriminant of the quadratic equation.
We consider the mathematical solution of the quadratic equation, 
depending on the sign of the discriminant $\Delta=b^2 - 4ac$.
\begin{itemize}
\item If $\Delta> 0$, there are two real roots: 
% Keep two equations for the root selection explanation
\begin{eqnarray}
x_- &=& \frac{-b- \sqrt{\Delta}}{2a}, \label{real:x-} \\
x_+ &=& \frac{-b+ \sqrt{\Delta}}{2a}. \label{real:x+}
\end{eqnarray}
\item If $\Delta=0$, there is one double root:
\begin{eqnarray}
\label{realdouble:x-+}
x_\pm &=& -\frac{b}{2a}.
\end{eqnarray}
\item If $\Delta< 0$, there are two complex roots:
\begin{eqnarray}
\label{complex:x-+}
x_\pm &=&\frac{-b}{2a} \pm i \frac{\sqrt{-\Delta}}{2a}.
\end{eqnarray}
\end{itemize}

We now consider a simplified algorithm where we only compute the real roots of the 
quadratic, assuming that $\Delta>0$.
This naive algorithm is presented in figure \ref{naive-quadratic}.

\begin{algorithm}[htbp]
\SetKwInOut{Input}{input}\SetKwInOut{Output}{output}
\Input{$a,b,c$}
\Output{$x_-$, $x_+$}
$\Delta:= b^2-4ac$\;
$s:= \sqrt{\Delta}$\;
$x_-:= (-b-s)/(2a)$\;
$x_+:= (-b+s)/(2a)$\;
\caption{Naive algorithm to compute the real roots of a quadratic equation. - We assume that $\Delta> 0$.}
\label{naive-quadratic}
\end{algorithm}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Experiments}

In this section, we compare our naive algorithm with the \scifun{roots} function.
We begin by defining a function which naively implements the mathematical formulas.
Then we use our naive function on two particular examples. 
In the first example, we focus on massive cancellation and in the second example, we 
focus on overflow problems.

The following Scilab function \scifun{myroots} is a straightforward implementation
of the previous formulas. It takes as input the coefficients of the quadratic, stored in the 
vector variable \scivar{p}, and returns the two roots in the vector \scivar{r}.
\lstset{language=scilabscript}
\begin{lstlisting}
function r=myroots(p)
  c=coeff(p,0);
  b=coeff(p,1);
  a=coeff(p,2);
  r(1)=(-b+sqrt(b^2-4*a*c))/(2*a);
  r(2)=(-b-sqrt(b^2-4*a*c))/(2*a);
endfunction
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Massive cancellation}
\label{section-exp-quadraticrounding}

\index{cancellation}
\index{massive cancellation}
We analyze the rounding errors which are 
appearing when the discriminant of the quadratic equation 
is such that $b^2\gg 4ac$.
We consider the following quadratic equation 
\begin{eqnarray}
\label{sinn-eq-roundingerror}
\epsilon x^2 + (1/\epsilon)x - \epsilon = 0
\end{eqnarray}
with $\epsilon>0$. For example, consider the special case $\epsilon=0.0001=10^{-4}$. 
The discriminant of this equation is $\Delta = 1/\epsilon^2+4\epsilon^2$.

The two real solutions of the quadratic equation are
\begin{eqnarray}
\label{sinn-eq-roundingerror-roots}
x_- = \frac{-1/\epsilon- \sqrt{1/\epsilon^2+4\epsilon^2}}{2\epsilon}, \qquad
x_+ = \frac{-1/\epsilon+ \sqrt{1/\epsilon^2+4\epsilon^2}}{2\epsilon}.
\end{eqnarray}
These roots are approximated by 
\begin{eqnarray}
\label{sinn-eq-roundingerror-roots-approx}
x_- \approx  -1/\epsilon^2, \qquad
x_+ \approx  \epsilon^2,
\end{eqnarray}
when $\epsilon$ is close to zero.
We now consider the limit of the two roots when $\epsilon \rightarrow 0$. We have 
\begin{eqnarray}
\lim_{\epsilon\rightarrow 0} x_- = -\infty, \qquad
\lim_{\epsilon\rightarrow 0} x_+ = 0.
\end{eqnarray}

\index{\scifun{roots}}
In the following Scilab script, we compare the roots computed by the \scifun{roots}
function and the roots computed by our naive function. We begin by creating 
a polynomial with the \scifun{poly} function, which is given the coefficients of 
the polynomial. Only the positive root $x_+ \approx \epsilon^2$ is considered in this 
test. Indeed, the $x_-$ root is so that $x_- \rightarrow -\infty$ in both 
implementations.
\lstset{language=scilabscript}
\begin{lstlisting}
p=poly([-0.0001 10000.0 0.0001],"x","coeff");
e1 = 1e-8;
roots1 = myroots(p);
r1 = roots1(1);
roots2 = roots(p);
r2 = roots2(1);
error1 = abs(r1-e1)/e1;
error2 = abs(r2-e1)/e1;
printf("Expected : %e\n", e1);
printf("Naive method : %e (error=%e)\n", r1,error1);
printf("Scilab method : %e (error=%e)\n", r2, error2);
\end{lstlisting}

The previous script produces the following output.
\lstset{language=scilabscript}
\begin{lstlisting}
Expected : 1.000000e-008
Naive method : 9.094947e-009 (error=9.050530e-002)
Scilab method : 1.000000e-008 (error=1.654361e-016)
\end{lstlisting}

We see that the naive method produces a root which has no significant digit 
and a relative error which is 14 orders of magnitude greater than the relative 
error of the Scilab root.

This behavior is explained by the fact that the expression for the 
positive root $x_+$ given by the equality \ref{real:x+} is numerically evaluated 
as following. We first consider how the discriminant $\Delta = 1/\epsilon^2+4\epsilon^2$ 
is computed. The term $1/\epsilon^2$ is equal to 100000000 and the term $4\epsilon^2$ 
is equal to 0.00000004. Therefore, the sum of these two terms is equal to 100000000.000000045.
Hence, the square root of the discriminant is 
\begin{eqnarray}
\sqrt{1/\epsilon^2+4\epsilon^2} = 10000.000000000001818989.
\end{eqnarray}
As we see, the first digits are correct, but the last digits 
are subject to rounding errors. When the expression $-1/\epsilon+ \sqrt{1/\epsilon^2+4\epsilon^2}$
is evaluated, the following computations are performed~:
\begin{eqnarray}
-1/\epsilon+ \sqrt{1/\epsilon^2+4\epsilon^2} &=& -10000.0 + 10000.000000000001818989 \\
  &=& 0.0000000000018189894035
\end{eqnarray}
We see that the result is mainly driven by the cancellation of significant digits.

We may think that the result is extreme, but it 
is not. For example, consider the case where we reduce further the value of $\epsilon$ down to 
$\epsilon=10^{-11}$, we get the following output :
\begin{lstlisting}
Expected : 1.000000e-022
Naive method : 0.000000e+000 (error=1.000000e+000)
Scilab method : 1.000000e-022 (error=1.175494e-016)
\end{lstlisting}

The relative error is this time 16 orders of magnitude 
greater than the relative error of the Scilab root.
There is no significant decimal digit in the result. 
In fact, the naive implementation computes a false root $x_+$ even for 
a value of epsilon equal to $\epsilon=10^{-3}$, where the relative 
error is 7 orders of magnitude greater than the relative error produced by the 
\scifun{roots} function.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Overflow}
\label{section-exp-quadraticoverflow}

\index{overflow}
In this section, we analyse the overflow which appears  
when the discriminant of the quadratic equation 
is such that $b^2- 4ac$ is not representable as a double.
We consider the following quadratic equation 
\begin{eqnarray}
\label{sinn-eq-overflowerror}
x^2 + (1/\epsilon)x + 1 = 0
\end{eqnarray}
with $\epsilon>0$. We especially consider the case $\epsilon\rightarrow 0$. 
The discriminant of this equation is $\Delta=1/\epsilon^2 -4$. Assume that the discriminant is positive.
Therefore, the roots of the quadratic equation are 
\begin{eqnarray}
x_- = \frac{-1/\epsilon- \sqrt{1/\epsilon^2-4}}{2}, \qquad
x_+ = \frac{-1/\epsilon+ \sqrt{1/\epsilon^2-4}}{2}.
\end{eqnarray}
These roots are approximated by 
\begin{eqnarray}
\label{sinn-eq-rootsoverflowapprox}
x_- \approx  -1/\epsilon, \qquad
x_+ \approx  -\epsilon,
\end{eqnarray}
when $\epsilon$ is close to zero.
We now consider the limit of the two roots when $\epsilon \rightarrow 0$. We have 
\begin{eqnarray}
\lim_{\epsilon\rightarrow 0} x_- = -\infty, \qquad
\lim_{\epsilon\rightarrow 0} x_+ = 0^-.
\end{eqnarray}
To create a difficult case, we search $\epsilon$ so that 
$1/\epsilon^2 > 10^{308}$, because we know that $10^{308}$
is the maximum representable double precision floating 
point number. Therefore, we expect that something should go wrong 
in the computation of the expression $\sqrt{1/\epsilon^2-4}$. 
We choose $\epsilon=10^{-155}$.

In the following script, we compare the roots computed by the \scifun{roots}
function and our naive implementation.
\lstset{language=scilabscript}
\begin{lstlisting}
e=1.e-155
a = 1;
b = 1/e;
c = 1;
p=poly([c b a],"x","coeff");
expected = [-e;-1/e];
roots1 = myroots(p);
roots2 = roots(p);
error1 = abs(roots1-expected)/norm(expected);
error2 = abs(roots2-expected)/norm(expected);
printf("Expected : %e %e\n", expected(1),expected(2));
printf("Naive method : %e %e (error=%e %e)\n", ...
  roots1(1),roots1(2), error1(1),error1(2));
printf("Scilab method : %e %e (error=%e %e)\n", ...
  roots2(1),roots2(2), error2(1),error2(2));
\end{lstlisting}

The previous script produces the following output.
\begin{lstlisting}
Expected : -1.000000e-155 -1.000000e+155
Naive method : Inf Inf (error=Nan Nan)
Scilab method : -1.000000e-155 -1.000000e+155 
            (error=0.000000e+000 0.000000e+000)
\end{lstlisting}

In this case, the discriminant $\Delta = b^2-4ac$ has been evaluated as $1/\epsilon^2-4$,
which is approximately equal to $10^{310}$. This number cannot 
be represented in a double precision floating point number. It therefore produces the 
IEEE Infinite number, which is displayed by Scilab as \scivar{Inf}.
The Infinite number is associated with an algebra and functions can perfectly 
take this number as input. Therefore, when the square root function 
must compute $\sqrt{\Delta}$, it produces again \scivar{Inf}. This number is 
then propagated into the final roots.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Explanations}

In this section, we suggest robust methods to compute the roots of a 
quadratic equation. 

\index{Jenkins, M. A.}
\index{Traub, J. F.}
The methods presented in this section are extracted from the 
\emph{quad} routine of the \emph{RPOLY} algorithm by
Jenkins and Traub \cite{JenkinsTraub1970,Jenkins1975}. This algorithm is used by Scilab in the 
\scifun{roots} function, where a special case is used when the 
degree of the equation is equal to 2, i.e. a quadratic equation.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Properties of the roots}

In this section, we present elementary results, which will be 
used in the derivation of robust floating point formulas of the roots 
of the quadratic equation. 

Let us assume that the quadratic equation \ref{eq-quadratic}, with 
real coefficients $a,b,c\in\RR$ and $a>0$ has a positive 
discriminant $\Delta=b^2-4ac$. Therefore, the two real roots of 
the quadratic equation are given by the equations \ref{real:x-} and \ref{real:x+}.
We can prove that the sum and the product of the roots satisfy the equations 
\begin{eqnarray}
\label{eq-rootsprops}
x_- + x_+ =\frac{-b}{a},\qquad
x_- x_+ =\frac{c}{a}.
\end{eqnarray}
Therefore, the roots are the solution of the normalized 
quadratic equation 
\begin{eqnarray}
\label{eq-rootsprops2}
x^2 - (x_- + x_+) x  + x_- x_+ &=&0.
\end{eqnarray}

Another transformation leads to an alternative form of the roots. 
Indeed, the original quadratic equation can be written as a quadratic 
equation of the unknown $1/x$. Consider the quadratic equation \ref{eq-quadratic}
and divide it by $1/x^2$, assuming that $x\neq 0$. This leads to the equation 
\begin{eqnarray}
\label{eq-quadraticinverse}
c(1/x)^2 + b (1/x)  + a &=&0,
\end{eqnarray}
where we assume that $x\neq 0$.
The two real roots of the quadratic equation \ref{eq-quadraticinverse} are 
\begin{eqnarray}
% Keep two equations for the root selection explanation
x_- &=& \frac{2c}{-b+ \sqrt{b^2-4ac}}, \label{real:x-inverse}\\
x_+ &=& \frac{2c}{-b- \sqrt{b^2-4ac}} \label{real:x+inverse}.
\end{eqnarray}
The expressions \ref{real:x-inverse} and \ref{real:x+inverse} can 
also be derived directly from the equations \ref{real:x-} and \ref{real:x+}.
For that purpose, it suffices to multiply their numerator and denominator 
by $-b+ \sqrt{b^2-4ac}$.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Floating-Point implementation : overview}

The numerical experiments presented in sections \ref{section-exp-quadraticrounding} and
\ref{section-exp-quadraticoverflow} suggest that the floating point implementation
must deal with two different problems:
\begin{itemize}
\item massive cancellation when $b^2\gg 4ac$ because of the cancellation of the 
terms $-b$ and $\pm\sqrt{b^2-4ac}$ which may have opposite signs,
\item overflow in the computation of the square root of the 
discriminant $\sqrt{\pm(b^2-4ac)}$ when $b^2-4ac$ is not representable as 
a floating point number.
\end{itemize}

The cancellation problem occurs only when the discriminant is positive, i.e. only
when there are two real roots. Indeed, the cancellation will not appear when $\Delta<0$,
since the complex roots do not use the sum $-b\pm\sqrt{b^2-4ac}$.
When $\Delta=0$, the double real root does not cause any trouble.
Therefore, we must take into account for the cancellation problem only in the 
equations \ref{real:x-} and \ref{real:x+}.

On the other hand, the overflow problem occurs whatever the sign of the discriminant
but does not occur when $\Delta=0$. Therefore, we must take into account 
for this problem in the equations \ref{real:x-}, \ref{real:x+} and \ref{complex:x-+}.
In section \ref{section-quadratic-fixcancellation}, we focus on the cancellation error while 
the overflow problem is addressed in section \ref{section-quadratic-fixoverflow}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Floating-Point implementation : fixing massive cancellation}
\label{section-quadratic-fixcancellation}
In this section, we present the computation of the roots of a 
quadratic equation with protection against massive cancellation. 

When the discriminant $\Delta$ is positive, the massive cancellation problem can be split in two cases:
\begin{itemize}
\item if $b<0$, then $-b-\sqrt{b^2-4ac}$ may suffer of massive cancellation
because $-b$ is positive and $-\sqrt{b^2-4ac}$ is negative,
\item if $b>0$, then $-b+\sqrt{b^2-4ac}$ may suffer of massive cancellation because 
$-b$ is negative and $\sqrt{b^2-4ac}$ is positive.
\end{itemize}
Therefore, 
\begin{itemize}
\item if $b>0$, we should use the expression $-b-\sqrt{b^2-4ac}$,
\item if $b<0$, we should use the expression $-b+\sqrt{b^2-4ac}$.
\end{itemize}
The solution consists in a combination of the following expressions of the 
roots given by, on one hand the equations \ref{real:x-} and \ref{real:x+},
and, on the other hand the equations \ref{real:x-inverse} and \ref{real:x+inverse}.
We pick the formula so that the sign of $b$ is the 
same as the sign of the square root.
The following choice allow to solve the massive cancellation problem:
\begin{itemize}
\item if $b<0$, then compute $x_-$ from \ref{real:x-inverse}, else 
(if $b>0$), compute $x_-$ from \ref{real:x-},
\item if $b<0$, then compute $x_+$ from \ref{real:x+}, else 
(if $b>0$), compute $x_+$ from \ref{real:x+inverse}.
\end{itemize}

We can also consider the modified Fagnano formulas
\begin{eqnarray}
x_1 &=& -\frac{2c}{b+sgn(b)\sqrt{b^2-4ac}}, \\
x_2 &=& -\frac{b+sgn(b)\sqrt{b^2-4ac}}{2a}, 
\end{eqnarray}
where the sign function is defined by 
\begin{eqnarray}
sgn(b)=\left\{\begin{array}{l}
1, \textrm{ if } b\geq 0,\\
-1, \textrm{ if } b< 0.
\end{array}\right.
\end{eqnarray}
The roots $x_{1,2}$ correspond to the roots $x_{+,-}$. Indeed, on one hand, 
if $b<0$, $x_1=x_-$ and if $b>0$, $x_1=x_+$. On the other hand, if $b<0$, $x_2=x_+$ and
if $b>0$, $x_2=x_-$.

Moreover, we notice that the division by two (and the multiplication
by 2) is exact with floating point numbers so these operations
cannot be a source of problem. But it is 
interesting to use $b/2$, which involves only one division, instead
of the three multiplications $2*c$, $2*a$ and $4*a*c$.
This leads to the following expressions of the real roots 
\begin{eqnarray}
x_1 &=& -\frac{c}{(b/2)+sgn(b)\sqrt{(b/2)^2-ac}}, \\
x_2 &=& -\frac{(b/2)+sgn(b)\sqrt{(b/2)^2-ac}}{a}.
\end{eqnarray}
Therefore, the two real roots can be computed by the following sequence of 
computations:
\begin{eqnarray}
b'&:=&b/2, \qquad \Delta' := b'^2-ac,\\
h&:=& -\left(b'+sgn(b)\sqrt{\Delta'}\right)\\
x_1 &:=& \frac{c}{h}, \qquad x_2 := \frac{h}{a}. 
\end{eqnarray}

In the case where the discriminant $\Delta' := b'^2-ac$ is negative, the 
two complex roots are
\begin{eqnarray}
x_1 &=& -\frac{b'}{a} - i \frac{\sqrt{ac-b'^2}}{a}, \qquad 
x_2 = -\frac{b'}{a} + i \frac{\sqrt{ac-b'^2}}{a}. 
\end{eqnarray}

A more robust algorithm, based on the previous analysis is presented in figure \ref{robust-quadratic}.
By comparing \ref{naive-quadratic} and \ref{robust-quadratic}, we can see that 
the algorithms are different in many points.

\begin{algorithm}[htbp]
\SetKwInOut{Input}{input}\SetKwInOut{Output}{output}
\Input{$a,b,c$}
\Output{$x_-^R$, $x_-^I$, $x_+^R$, $x_+^I$}
\uIf {$a=0$} {
        \eIf {$b=0$} {
             $x_-^R:= 0$ , $x_-^I:= 0$ \;
             $x_+^R:= 0$ , $x_+^I:= 0$ \;
        } {
             $x_-^R:= -c/b$ , $x_-^I:= 0$ \;
             $x_+^R:= 0$ , $x_+^I:= 0$ \;
        }
}
\Else {
         $b':= b/2$ \;
         $\Delta:= b'^2 - ac$ \;
        \uIf {$\Delta<0$} {
                 $s:= \sqrt{-\Delta}$ \;
                 $x_-^R:= -b'/a$ , $x_-^I:= -s/a$ \;
                 $x_+^R:= x_-^R$ , $x_+^I:= -x_1^I$ \;
        }
        \uElseIf {$\Delta=0$} {
                 $x_-:= -b'/a$ , $x_-^I:= 0$ \;
                 $x_+:= x_2$ , $x_+^I:= 0$ \;
        }
        \Else {
                 $s:= \sqrt{\Delta}$ \;
                \uIf {$b>0$}{
                     $g:=1$ \;
                }
                \Else {
                     $g:=-1$ \;
                }
                 $h:=-(b'+g*s)$ \;
                 $x_-^R:= c/h$ , $x_-^I:= 0$ \;
                 $x_+^R:= h/a$ , $x_+^I:= 0$ \;
        }
}
\caption{A more robust algorithm to compute the roots of a quadratic equation. This algorithm 
takes as input arguments the real coefficients $a,b,c$ and returns the real and imaginary parts 
of the two roots, i.e. returns $x_-^R$, $x_-^I$, $x_+^R$, $x_+^I$.}
\label{robust-quadratic}
\end{algorithm}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Floating-Point implementation : fixing overflow problems}
\label{section-quadratic-fixoverflow}

The remaining problem is to compute the square root of the 
discriminant $\sqrt{\pm(b'^2-ac)}$ without creating 
unnecessary overflows. In order to simplify the discussion, we 
focus on the computation of $\sqrt{b'^2-ac}$.

Obviously, the problem occur for large values of $b'$. 
Notice that a (very) small improvement has already been done. Indeed, we have the 
inequality $|b'|=|b|/2<|b|$
so that overflows are twice less likely to occur. The current upper bound 
for $|b'|$ is $10^{154}$, which is associated with 
$b^{'2}\leq 10^{308}$, the maximum double value before overflow.
The goal is therefore to increase the possible range of values of $b'$ without 
generating unnecessary overflows.

Consider the situation when $b'$ is large in magnitude with respect to $a$ and $c$. 
In that case, notice that we first square $b'$ to get $b^{'2}$
and then compute the square root $\sqrt{b^{'2} - ac}$.
Hence, we can factor the expression by $b^{'2}$ and move this 
term outside the square root, which makes the term $|b'|$ appear.
This method allows to compute the expression $\sqrt{b^{'2} - ac}$,
without squaring $b'$ when it is not necessary.

In the general case, we use the fact that the term $b'^2-ac$ can be 
evaluated with the two following equivalent formulas:
\begin{eqnarray}
b'^2-ac &=& b'^2\left[1-(a/b')(c/b')\right], \label{eq-discroverflow1}\\
b'^2-ac &=& c\left[b'(b'/c) - a\right].\label{eq-discroverflow2}
\end{eqnarray}
The goal is then to compute the square root $s = \sqrt{b'^2-ac}$.
\begin{itemize}
\item If $|b'|>|c|>0$, then the equation \ref{eq-discroverflow1} involves the expression $1-(a/b')(c/b')$.
The term $1-(a/b')(c/b')$ is so that no overflow is possible since $|c/b'| < 1$ (the overflow problem occurs
only when $b$ is large in magnitude with respect to both $a$ and $c$).
In this case, we use the expression
\begin{eqnarray}
e &=& 1-(a/b')(c/b'),
\end{eqnarray}
and compute
\begin{eqnarray}
\label{quadratic-overflow-trick1}
s &=& \pm|b'|\sqrt{|e|}.
\end{eqnarray}
In the previous equation, we use the sign + when $e$ is positive
and the sign - when $e$ is negative.

\item If $|c|>|b'|>0$, then the equation \ref{eq-discroverflow2} involves the expression $b'(b'/c) - a$.
The term $b'(b'/c) - a$ should limit the possible overflows since $|b'/c| < 1$. This implies that 
$\left|b'(b'/c)\right|<|b'|$. (There is 
still a possibility of overflow, for example in the case where $b'(b'/c)$
is near, but under, the overflow limit and $a$ is large.)
Therefore, we use the expression
\begin{eqnarray}
e &=& b'(b'/c) - a,
\end{eqnarray}
and compute 
\begin{eqnarray}
\label{quadratic-overflow-trick2}
s &=& \pm\sqrt{|c|} \sqrt{|e|}.
\end{eqnarray}
In the previous equation, we use the sign + when $e$ is positive
and the sign - when $e$ is negative.
\end{itemize}
In both equations \ref{quadratic-overflow-trick1} and \ref{quadratic-overflow-trick2}, 
the parenthesis must be strictly used. This property is ensured by the IEEE standard 
and by the Scilab language. 
This normalization method are similar to the one used by Smith in the 
algorithm for the division of complex numbers \cite{Smith1962} and 
which will be reviewed in the next section.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{References}

\index{Forsythe, George}
The 1966 technical report by G. Forsythe \cite{Forsythe1966} 
presents the floating point system and the possible large error 
in using mathematical algorithms blindly. An accurate way of solving 
a quadratic is outlined. A few general remarks are made about 
computational mathematics. 

\index{Goldberg, David}
The 1991 paper by Goldberg \cite{WhatEveryComputerScientist} is a general presentation of the floating
point system and its consequences. It begins with background on floating point 
representation and rounding errors, continues with a discussion
of the IEEE floating point standard and concludes with examples of how
computer system builders can better support floating point. The section
1.4, "Cancellation" specifically consider the computation of the roots
of a quadratic equation.

We can also read the numerical experiments performed by Nievergelt in \cite{Nievergelt2003}.

The Numerical Recipes \cite{NumericalRecipes}, chapter 5, section 5.6,
"Quadratic and Cubic Equations" present the elementary theory 
for a floating point implementation of the quadratic and cubic equations.

\index{Kahan, William}
Other references include William Kahan \cite{Kahan2004}.


